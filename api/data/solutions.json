{
  "solutions": {
    "triangle": {
      "title": "Triangle",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcc9",
      "timeComplexity": "O(n^2)",
      "spaceComplexity": "O(n)",
      "oneliner": "Compute min path sum from bottom to top to avoid greedy traps!",
      "intuition": [
        "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
        "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
        "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
      ],
      "testCases": [
        {
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "output": "11"
        },
        {
          "input": "triangle = [[-10]]",
          "output": "-10"
        }
      ],
      "code": "def minimumTotal(triangle):\n    \"\"\"\n    Intuition:\n    - \ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min\n    - \ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom\n    - \ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n    \"\"\"\n    dp = triangle[-1][:]  # Initialize DP table to store results.\n    for i in range(len(triangle) - 2, -1, -1):  # Iterate through the range.\n        for j in range(i + 1):  # Iterate through the range.\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])  # Take the minimum value.\n    return dp[0]",
      "keyInsight": "Bottom-up DP simplifies boundary conditions and reuses space.",
      "description": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
      "examples": [
        {
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "output": "11",
          "explanation": "Path 2 -> 3 -> 5 -> 1 = 11."
        },
        {
          "input": "triangle = [[-10]]",
          "output": "-10",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= triangle.length <= 200",
        "triangle[0].length == 1",
        "triangle[i].length == triangle[i - 1].length + 1",
        "-10^4 <= triangle[i][j] <= 10^4"
      ],
      "hints": [
        "Use DP from bottom to top.",
        "dp[i] = triangle[row][i] + min(dp[i], dp[i+1]).",
        "Space optimization: reuse same array."
      ],
      "relatedProblems": [
        "minimum-path-sum",
        "dungeon-game"
      ],
      "videoId": "OM1MTokvxs4",
      "problemStatement": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "visualizationType": "matrix",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Triangle",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            [
              4,
              1,
              8,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 2",
          "arrayState": [
            [
              2
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              2
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 3,4",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 6,5,7",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 4,1,8,3",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            [
              4,
              1,
              8,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            [
              4,
              1,
              8,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            [
              4,
              1,
              8,
              3
            ]
          ],
          "pointers": [],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              2
            ],
            [
              3,
              4
            ],
            [
              6,
              5,
              7
            ],
            [
              4,
              1,
              8,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "initialState": [
        [
          2
        ],
        [
          3,
          4
        ],
        [
          6,
          5,
          7
        ],
        [
          4,
          1,
          8,
          3
        ]
      ],
      "approach": "Dynamic Programming: Compute min path sum from bottom to top to avoid greedy traps!",
      "suggestedNextQuestion": {
        "slug": "unique-paths",
        "title": "Unique Paths",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def minimumTotal(triangle):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def minimumTotal_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n^2)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
            "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
            "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
          ],
          "code": "def minimumTotal(triangle):\n    \"\"\"\n    Intuition:\n    - \ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min\n    - \ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom\n    - \ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n    \"\"\"\n    dp = triangle[-1][:]  # Initialize DP table to store results.\n    for i in range(len(triangle) - 2, -1, -1):  # Iterate through the range.\n        for j in range(i + 1):  # Iterate through the range.\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])  # Take the minimum value.\n    return dp[0]"
        }
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "best-time-to-buy-and-sell-stock": {
      "title": "Best Time to Buy and Sell Stock",
      "pattern": "Track Minimum",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track the minimum price seen so far, maximize profit at each step!",
      "intuition": [
        "\ud83c\udfaf Buy LOW, Sell HIGH",
        "\ud83e\udde0 Keep track of the cheapest day to buy",
        "\ud83d\udca1 At each day, calculate: what if I sold today?"
      ],
      "testCases": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "5"
        },
        {
          "input": "prices = [7,6,4,3,1]",
          "output": "0"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Initialize Trackers",
          "visual": "min_price = \u221e\nmax_profit = 0",
          "explanation": "Start with infinity as min (first price will always be lower)"
        },
        {
          "step": 2,
          "title": "Walk Through Prices",
          "visual": "prices: [7, 1, 5, 3, 6, 4]\n         \u2191\n       Day 1: price = 7",
          "explanation": "Visit each day's price"
        },
        {
          "step": 3,
          "title": "Update Minimum",
          "visual": "Day 1: min = min(\u221e, 7) = 7\nDay 2: min = min(7, 1) = 1 \u2b50 NEW LOW!",
          "explanation": "Always track the best buying opportunity"
        },
        {
          "step": 4,
          "title": "Calculate Profit",
          "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 \ud83d\udcb0\n        max_profit = 5",
          "explanation": "At each step: profit = today - min_so_far"
        }
      ],
      "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Buy LOW, Sell HIGH\n    - \ud83e\udde0 Keep track of the cheapest day to buy\n    - \ud83d\udca1 At each day, calculate: what if I sold today?\n\n    Algorithm:\n    1. Initialize Trackers - Start with infinity as min (first price will always be lower)\n    2. Walk Through Prices - Visit each day's price\n    3. Update Minimum - Always track the best buying opportunity\n    4. Calculate Profit - At each step: profit = today - min_so_far\n    \"\"\"\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:  # Iterate over elements.\n        min_price = min(min_price, price)  # Take the minimum value.\n        profit = price - min_price\n        max_profit = max(max_profit, profit)  # Take the maximum value.\n    \n    return max_profit",
      "keyInsight": "One pass solution - no need to compare every pair!",
      "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
      "examples": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "5",
          "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
        },
        {
          "input": "prices = [7,6,4,3,1]",
          "output": "0",
          "explanation": "No profitable transaction possible."
        }
      ],
      "constraints": [
        "1 <= prices.length <= 10^5",
        "0 <= prices[i] <= 10^4"
      ],
      "hints": [
        "Track the minimum price seen so far.",
        "At each day, calculate potential profit if you sold today.",
        "Keep track of the maximum profit seen."
      ],
      "relatedProblems": [
        "best-time-to-buy-and-sell-stock-ii",
        "best-time-to-buy-and-sell-stock-iii",
        "maximum-subarray"
      ],
      "videoId": "1pkOgXD63yU",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Prices: [7, 1, 5, 3, 6, 4]",
          "transientMessage": "minPrice=7, maxProfit=0",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "buy",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Day 1: price 1 < minPrice",
          "transientMessage": "New minPrice = 1",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "buy",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Day 2: sell at 5, profit=4",
          "transientMessage": "New maxProfit = 4!",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "sell",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Day 3: sell at 3, profit=2",
          "transientMessage": "maxProfit still 4",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "sell",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Day 4: sell at 6, profit=5",
          "transientMessage": "New maxProfit = 5!",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "sell",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Day 5: sell at 4, profit=3",
          "transientMessage": "maxProfit still 5",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [
            {
              "label": "sell",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Max profit: 5",
          "transientMessage": "Complete!",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "array",
      "initialState": [
        7,
        1,
        5,
        3,
        6,
        4
      ],
      "approach": "Track Minimum: Track the minimum price seen so far, maximize profit at each step!",
      "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
      "initialCode": "def maxProfit(prices):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxProfit(prices):\n    max_p = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - prices[i]\n            if profit > max_p:\n                max_p = profit\n    return max_p"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Buy LOW, Sell HIGH",
            "\ud83e\udde0 Keep track of the cheapest day to buy",
            "\ud83d\udca1 At each day, calculate: what if I sold today?"
          ],
          "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Buy LOW, Sell HIGH\n    - \ud83e\udde0 Keep track of the cheapest day to buy\n    - \ud83d\udca1 At each day, calculate: what if I sold today?\n\n    Algorithm:\n    1. Initialize Trackers - Start with infinity as min (first price will always be lower)\n    2. Walk Through Prices - Visit each day's price\n    3. Update Minimum - Always track the best buying opportunity\n    4. Calculate Profit - At each step: profit = today - min_so_far\n    \"\"\"\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:  # Iterate over elements.\n        min_price = min(min_price, price)  # Take the minimum value.\n        profit = price - min_price\n        max_profit = max(max_profit, profit)  # Take the maximum value.\n    \n    return max_profit"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "valid-palindrome": {
      "title": "Valid Palindrome",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc46",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use two pointers from both ends, skip non-alphanumeric!",
      "intuition": [
        "\ud83c\udfaf Palindrome reads same forwards & backwards",
        "\ud83e\udde0 Compare characters from outside \u2192 inside",
        "\ud83d\udca1 Skip spaces and punctuation!"
      ],
      "testCases": [
        {
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "output": "true"
        },
        {
          "input": "s = \"race a car\"",
          "output": "false"
        },
        {
          "input": "s = \" \"",
          "output": "true"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Set Up Pointers",
          "visual": "\"A man, a plan, a canal: Panama\"\n \u2191                              \u2191\nleft                          right",
          "explanation": "Start from both ends of the string"
        },
        {
          "step": 2,
          "title": "Skip Non-Letters",
          "visual": "\"...canal: Panama\"\n         \u2191      \u2191\n     skip ':'  'a'",
          "explanation": "Move pointer if not alphanumeric"
        },
        {
          "step": 3,
          "title": "Compare (Case-Insensitive)",
          "visual": "'A' == 'a' \u2705 (lowercase both)\n'M' == 'm' \u2705\n'N' == 'n' \u2705",
          "explanation": "Convert to lowercase and compare"
        },
        {
          "step": 4,
          "title": "Move Inward",
          "visual": "left \u2192 \u2190     \u2192 \u2190 right\n      Meet in middle = VALID!",
          "explanation": "Continue until pointers cross"
        }
      ],
      "code": "def isPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Palindrome reads same forwards & backwards\n    - \ud83e\udde0 Compare characters from outside \u2192 inside\n    - \ud83d\udca1 Skip spaces and punctuation!\n\n    Algorithm:\n    1. Set Up Pointers - Start from both ends of the string\n    2. Skip Non-Letters - Move pointer if not alphanumeric\n    3. Compare (Case-Insensitive) - Convert to lowercase and compare\n    4. Move Inward - Continue until pointers cross\n    \"\"\"\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False  # Condition not met.\n        \n        left += 1\n        right -= 1\n    \n    return True  # Condition satisfied.",
      "keyInsight": "Two pointers = no extra space needed for reversed string!",
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
      "examples": [
        {
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "output": "true",
          "explanation": "After filtering: 'amanaplanacanalpanama' is a palindrome."
        },
        {
          "input": "s = \"race a car\"",
          "output": "false",
          "explanation": "After filtering: 'raceacar' is not a palindrome."
        }
      ],
      "constraints": [
        "1 <= s.length <= 2 * 10^5",
        "s consists only of printable ASCII characters."
      ],
      "hints": [
        "Use two pointers from both ends.",
        "Skip non-alphanumeric characters.",
        "Compare characters (case-insensitive)."
      ],
      "relatedProblems": [
        "valid-palindrome-ii",
        "palindrome-linked-list",
        "longest-palindromic-substring"
      ],
      "videoId": "jJXJ16kPFWg",
      "animationSteps": [
        {
          "step": 1,
          "visual": "s = \"A man, a plan, a canal: Panama\"",
          "transientMessage": "Initialize left=0, right=29",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 29
            }
          ],
          "indices": [
            0,
            29
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Compare 'A' (idx 0) vs 'a' (idx 29)",
          "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 29
            }
          ],
          "indices": [
            0,
            29
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "Skip non-alphanumeric ' ' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 28
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Compare 'm' (idx 2) vs 'm' (idx 28)",
          "transientMessage": "'m' == 'm' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 28
            }
          ],
          "indices": [
            2,
            28
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compare 'a' (idx 3) vs 'a' (idx 27)",
          "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 27
            }
          ],
          "indices": [
            3,
            27
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Compare 'n' (idx 4) vs 'n' (idx 26)",
          "transientMessage": "'n' == 'n' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            },
            {
              "label": "R",
              "index": 26
            }
          ],
          "indices": [
            4,
            26
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Skip non-alphanumeric ',' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 6
            },
            {
              "label": "R",
              "index": 25
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Skip non-alphanumeric ' ' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 7
            },
            {
              "label": "R",
              "index": 25
            }
          ],
          "indices": [
            7
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Compare 'a' (idx 7) vs 'a' (idx 25)",
          "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 7
            },
            {
              "label": "R",
              "index": 25
            }
          ],
          "indices": [
            7,
            25
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Skip non-alphanumeric ' ' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 9
            },
            {
              "label": "R",
              "index": 24
            }
          ],
          "indices": [
            9
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Compare 'p' (idx 9) vs 'P' (idx 24)",
          "transientMessage": "'p' == 'p' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 9
            },
            {
              "label": "R",
              "index": 24
            }
          ],
          "indices": [
            9,
            24
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Skip non-alphanumeric ' ' on right",
          "transientMessage": "Right pointer moves left past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 10
            },
            {
              "label": "R",
              "index": 22
            }
          ],
          "indices": [
            22
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "Skip non-alphanumeric ':' on right",
          "transientMessage": "Right pointer moves left past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 10
            },
            {
              "label": "R",
              "index": 21
            }
          ],
          "indices": [
            21
          ],
          "color": "accent"
        },
        {
          "step": 14,
          "visual": "Compare 'l' (idx 10) vs 'l' (idx 21)",
          "transientMessage": "'l' == 'l' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 10
            },
            {
              "label": "R",
              "index": 21
            }
          ],
          "indices": [
            10,
            21
          ],
          "color": "success"
        },
        {
          "step": 15,
          "visual": "Compare 'a' (idx 11) vs 'a' (idx 20)",
          "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 11
            },
            {
              "label": "R",
              "index": 20
            }
          ],
          "indices": [
            11,
            20
          ],
          "color": "success"
        },
        {
          "step": 16,
          "visual": "Compare 'n' (idx 12) vs 'n' (idx 19)",
          "transientMessage": "'n' == 'n' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 12
            },
            {
              "label": "R",
              "index": 19
            }
          ],
          "indices": [
            12,
            19
          ],
          "color": "success"
        },
        {
          "step": 17,
          "visual": "Skip non-alphanumeric ',' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 14
            },
            {
              "label": "R",
              "index": 18
            }
          ],
          "indices": [
            14
          ],
          "color": "accent"
        },
        {
          "step": 18,
          "visual": "Skip non-alphanumeric ' ' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 15
            },
            {
              "label": "R",
              "index": 18
            }
          ],
          "indices": [
            15
          ],
          "color": "accent"
        },
        {
          "step": 19,
          "visual": "Compare 'a' (idx 15) vs 'a' (idx 18)",
          "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 15
            },
            {
              "label": "R",
              "index": 18
            }
          ],
          "indices": [
            15,
            18
          ],
          "color": "success"
        },
        {
          "step": 20,
          "visual": "Skip non-alphanumeric ' ' on left",
          "transientMessage": "Left pointer moves right past non-alphanumeric",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 17
            },
            {
              "label": "R",
              "index": 17
            }
          ],
          "indices": [
            17
          ],
          "color": "accent"
        },
        {
          "step": 21,
          "visual": "Result: true",
          "transientMessage": "Pointers crossed - It's a palindrome! \u2705",
          "arrayState": [
            "A",
            " ",
            "m",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "p",
            "l",
            "a",
            "n",
            ",",
            " ",
            "a",
            " ",
            "c",
            "a",
            "n",
            "a",
            "l",
            ":",
            " ",
            "P",
            "a",
            "n",
            "a",
            "m",
            "a"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "problemStatement": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "visualizationType": "array",
      "initialState": [
        "A",
        " ",
        "m",
        "a",
        "n",
        ",",
        " ",
        "a",
        " ",
        "p",
        "l",
        "a",
        "n",
        ",",
        " ",
        "a",
        " ",
        "c",
        "a",
        "n",
        "a",
        "l",
        ":",
        " ",
        "P",
        "a",
        "n",
        "a",
        "m",
        "a"
      ],
      "approach": "Two Pointers: Use two pointers from both ends, skip non-alphanumeric!",
      "suggestedNextQuestion": {
        "slug": "3sum",
        "title": "3Sum",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def isPalindrome(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def isPalindrome(s):\n    # Filter non-alphanumeric chars\n    filtered = [c.lower() for c in s if c.isalnum()]\n    # Compare with reverse\n    return filtered == filtered[::-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Palindrome reads same forwards & backwards",
            "\ud83e\udde0 Compare characters from outside \u2192 inside",
            "\ud83d\udca1 Skip spaces and punctuation!"
          ],
          "code": "def isPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Palindrome reads same forwards & backwards\n    - \ud83e\udde0 Compare characters from outside \u2192 inside\n    - \ud83d\udca1 Skip spaces and punctuation!\n\n    Algorithm:\n    1. Set Up Pointers - Start from both ends of the string\n    2. Skip Non-Letters - Move pointer if not alphanumeric\n    3. Compare (Case-Insensitive) - Convert to lowercase and compare\n    4. Move Inward - Continue until pointers cross\n    \"\"\"\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False  # Condition not met.\n        \n        left += 1\n        right -= 1\n    \n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "merge-sorted-array": {
      "title": "Merge Sorted Array",
      "pattern": "Three Pointers (Reverse)",
      "patternEmoji": "\ud83d\udd00",
      "timeComplexity": "O(m + n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Fill from the END to avoid overwriting!",
      "intuition": [
        "\ud83c\udfaf Can't start from front - would overwrite nums1!",
        "\ud83e\udde0 Start from back - empty space is there for us!",
        "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
      ],
      "testCases": [
        {
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "output": "[1,2,2,3,5,6]"
        },
        {
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "output": "[1]"
        },
        {
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "output": "[1]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Set Up 3 Pointers",
          "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            \u2191     \u2191              \u2191\n           p1    write           p2",
          "explanation": "p1 at last real element, p2 at end of nums2, write at end"
        },
        {
          "step": 2,
          "title": "Compare & Place Larger",
          "visual": "3 vs 6 \u2192 6 wins!\n[1,2,3,0,0,6] \u2190 place 6",
          "explanation": "Bigger goes to write position"
        },
        {
          "step": 3,
          "title": "Move Pointers",
          "visual": "[1,2,3,0,0,6]\n            \u2191 \u2191\n           p1 write\n           \u2190 moved left",
          "explanation": "Decrement write and the pointer that was used"
        },
        {
          "step": 4,
          "title": "Continue Until Done",
          "visual": "Result: [1,2,2,3,5,6] \u2705",
          "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
        }
      ],
      "code": "def merge(nums1, m, nums2, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can't start from front - would overwrite nums1!\n    - \ud83e\udde0 Start from back - empty space is there for us!\n    - \ud83d\udca1 Three pointers: end of nums1, end of nums2, write position\n\n    Algorithm:\n    1. Set Up 3 Pointers - p1 at last real element, p2 at end of nums2, write at end\n    2. Compare & Place Larger - Bigger goes to write position\n    3. Move Pointers - Decrement write and the pointer that was used\n    4. Continue Until Done - If nums2 remaining, copy them. nums1 remaining? Already in place!\n    \"\"\"\n    p1, p2 = m - 1, n - 1  # Initialize pointers for merging.\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    return nums1",
      "keyInsight": "Reverse iteration = in-place without overwriting!",
      "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
      "examples": [
        {
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "output": "[1,2,2,3,5,6]",
          "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]."
        },
        {
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "output": "[1]",
          "explanation": "No elements to merge from nums2."
        }
      ],
      "constraints": [
        "nums1.length == m + n",
        "nums2.length == n",
        "0 <= m, n <= 200",
        "1 <= m + n <= 200",
        "-10^9 <= nums1[i], nums2[j] <= 10^9"
      ],
      "hints": [
        "Start from the end of both arrays and work backwards.",
        "Compare elements from the end and place the larger one at the back of nums1.",
        "This avoids overwriting elements we haven't processed yet."
      ],
      "relatedProblems": [
        "merge-two-sorted-lists",
        "sort-an-array",
        "squares-of-a-sorted-array"
      ],
      "videoId": "P1Ic85RarKY",
      "animationSteps": [
        {
          "step": 1,
          "visual": "nums1: [1,2,3,0,0,0]    nums2: [2,5,6]",
          "transientMessage": "p1 at last real element, p2 at end of nums2, write at end",
          "arrayState": [
            1,
            2,
            3,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 5
            }
          ],
          "indices": [
            2,
            5
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Compare: nums1[p1]=3 vs nums2[p2]=6",
          "transientMessage": "6 > 3, so place 6 at write position",
          "arrayState": [
            1,
            2,
            3,
            0,
            0,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "Placed 6, move p2 and write left",
          "transientMessage": "p2-- \u2192 1, write-- \u2192 4",
          "arrayState": [
            1,
            2,
            3,
            0,
            0,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 4
            }
          ],
          "indices": [
            2,
            4
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Compare: nums1[p1]=3 vs nums2[p2]=5",
          "transientMessage": "5 > 3, so place 5 at write position",
          "arrayState": [
            1,
            2,
            3,
            0,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Placed 5, move p2 and write left",
          "transientMessage": "p2-- \u2192 0, write-- \u2192 3",
          "arrayState": [
            1,
            2,
            3,
            0,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Compare: nums1[p1]=3 vs nums2[p2]=2",
          "transientMessage": "3 > 2, so place 3 at write position",
          "arrayState": [
            1,
            2,
            3,
            3,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "write",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Placed 3, move p1 and write left",
          "transientMessage": "p1-- \u2192 1, write-- \u2192 2",
          "arrayState": [
            1,
            2,
            3,
            3,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 1
            },
            {
              "label": "write",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Compare: nums1[p1]=2 vs nums2[p2]=2",
          "transientMessage": "Equal! Place nums2[p2]=2 at write position",
          "arrayState": [
            1,
            2,
            2,
            3,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 1
            },
            {
              "label": "write",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Placed 2, p2 becomes -1 (exhausted)",
          "transientMessage": "nums2 exhausted! nums1 elements already in place \u2705",
          "arrayState": [
            1,
            2,
            2,
            3,
            5,
            6
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 1
            }
          ],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Final Result: [1,2,2,3,5,6]",
          "transientMessage": "Merge complete! All elements sorted in nums1",
          "arrayState": [
            1,
            2,
            2,
            3,
            5,
            6
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5
          ],
          "color": "success"
        }
      ],
      "problemStatement": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        0,
        0,
        0
      ],
      "approach": "Three Pointers (Reverse): Fill from the END to avoid overwriting!",
      "mentalModel": "Like using your fingers to track two different positions in a book at once.",
      "initialCode": "def merge(nums1, m, nums2, n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def merge(nums1, m, nums2, n):\n    # Copy nums2 into nums1's end\n    for i in range(n):\n        nums1[m + i] = nums2[i]\n    # Sort the entire array\n    nums1.sort()"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m + n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Can't start from front - would overwrite nums1!",
            "\ud83e\udde0 Start from back - empty space is there for us!",
            "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
          ],
          "code": "def merge(nums1, m, nums2, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can't start from front - would overwrite nums1!\n    - \ud83e\udde0 Start from back - empty space is there for us!\n    - \ud83d\udca1 Three pointers: end of nums1, end of nums2, write position\n\n    Algorithm:\n    1. Set Up 3 Pointers - p1 at last real element, p2 at end of nums2, write at end\n    2. Compare & Place Larger - Bigger goes to write position\n    3. Move Pointers - Decrement write and the pointer that was used\n    4. Continue Until Done - If nums2 remaining, copy them. nums1 remaining? Already in place!\n    \"\"\"\n    p1, p2 = m - 1, n - 1  # Initialize pointers for merging.\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    return nums1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "valid-parentheses": {
      "title": "Valid Parentheses",
      "pattern": "Stack",
      "patternEmoji": "(\ufe0f)\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Push open brackets; pop and match close brackets.",
      "intuition": [
        "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
        "\ud83e\udde0 Stack tracks open brackets.",
        "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
      ],
      "testCases": [
        {
          "input": "s = \"()\"",
          "output": "true"
        },
        {
          "input": "s = \"()[]{}\"",
          "output": "true"
        },
        {
          "input": "s = \"(]\"",
          "output": "false"
        },
        {
          "input": "s = \"([])\"",
          "output": "true"
        },
        {
          "input": "s = \"([)]\"",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Open",
          "visual": "Push '(', '[', '{'.",
          "explanation": "Await closing."
        },
        {
          "step": 2,
          "title": "Close",
          "visual": "Pop top. Matches current? () [] {}",
          "explanation": "Verify pairing."
        },
        {
          "step": 3,
          "title": "End",
          "visual": "Stack empty? Valid.",
          "explanation": "No unclosed brackets left."
        }
      ],
      "code": "def isValid(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Last Opened must be First Closed (LIFO).\n    - \ud83e\udde0 Stack tracks open brackets.\n    - \ud83d\udca1 Mismatch or empty stack on close? Invalid.\n\n    Algorithm:\n    1. Open - Await closing.\n    2. Close - Verify pairing.\n    3. End - No unclosed brackets left.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    closeToOpen = {')': '(', ']': '[', '}': '{'}\n    for c in s:  # Iterate over elements.\n        if c in closeToOpen:\n            if stack and stack[-1] == closeToOpen[c]:\n                stack.pop()  # Remove and return last element.\n            else:\n                return False  # Condition not met.\n        else:\n            stack.append(c)  # Add to end.\n    return not stack",
      "keyInsight": "Map only the closing brackets allows clean logic: \"Is it a closer? Check stack. Else, it must be an opener.\"",
      "visualizationType": "array",
      "initialState": [
        "(",
        "{",
        "[",
        "]",
        "}",
        ")"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "String: \"({[]})\"",
          "transientMessage": "Use stack to match brackets",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Push '(' onto stack",
          "transientMessage": "Stack: [(]",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Push '{' onto stack",
          "transientMessage": "Stack: [(, {]",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Push '[' onto stack",
          "transientMessage": "Stack: [(, {, []",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Pop '[' for ']'",
          "transientMessage": "Match!",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Pop '{' for '}'",
          "transientMessage": "Match!",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Pop '(' for ')'",
          "transientMessage": "Match!",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Stack empty: true",
          "transientMessage": "Valid!",
          "arrayState": [
            "(",
            "{",
            "[",
            "]",
            "}",
            ")"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
      "examples": [
        {
          "input": "s = \"()\"",
          "output": "true",
          "explanation": "Simple pair of matching parentheses."
        },
        {
          "input": "s = \"()[]{}\"",
          "output": "true",
          "explanation": "Multiple types of matching brackets."
        },
        {
          "input": "s = \"(]\"",
          "output": "false",
          "explanation": "Mismatched bracket types."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4",
        "s consists of parentheses only '()[]{}'."
      ],
      "hints": [
        "Use a stack to track opening brackets.",
        "When you see a closing bracket, check if it matches the top of the stack.",
        "At the end, the stack should be empty."
      ],
      "relatedProblems": [
        "generate-parentheses",
        "longest-valid-parentheses",
        "remove-invalid-parentheses"
      ],
      "videoId": "WTzjTskDFMg",
      "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize empty stack",
        "Iterate through elements",
        "Push/pop based on problem logic",
        "Maintain monotonic property if needed",
        "Process remaining stack elements if needed"
      ],
      "approach": "Stack: Push open brackets; pop and match close brackets.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def isValid(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def isValid_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
            "\ud83e\udde0 Stack tracks open brackets.",
            "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
          ],
          "code": "def isValid(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Last Opened must be First Closed (LIFO).\n    - \ud83e\udde0 Stack tracks open brackets.\n    - \ud83d\udca1 Mismatch or empty stack on close? Invalid.\n\n    Algorithm:\n    1. Open - Await closing.\n    2. Close - Verify pairing.\n    3. End - No unclosed brackets left.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    closeToOpen = {')': '(', ']': '[', '}': '{'}\n    for c in s:  # Iterate over elements.\n        if c in closeToOpen:\n            if stack and stack[-1] == closeToOpen[c]:\n                stack.pop()  # Remove and return last element.\n            else:\n                return False  # Condition not met.\n        else:\n            stack.append(c)  # Add to end.\n    return not stack"
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "maximum-subarray": {
      "title": "Maximum Subarray",
      "pattern": "Kadane's Algorithm",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Extend current sum OR start fresh - pick the better option!",
      "intuition": [
        "\ud83c\udfaf At each position: should I continue or restart?",
        "\ud83e\udde0 If current_sum < 0, better to start fresh!",
        "\ud83d\udca1 Track both current sum and overall maximum"
      ],
      "testCases": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6"
        },
        {
          "input": "nums = [1]",
          "output": "1"
        },
        {
          "input": "nums = [5,4,-1,7,8]",
          "output": "23"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Initialize",
          "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
          "explanation": "Start with first element as both"
        },
        {
          "step": 2,
          "title": "The Key Decision",
          "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         \u2191\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 \u2190 WINNER!",
          "explanation": "current_sum = max(num, current_sum + num)"
        },
        {
          "step": 3,
          "title": "Update Maximum",
          "visual": "current: 1 \u2192 -2 \u2192 4 \u2192 3 \u2192 5 \u2192 6 \u2192 1 \u2192 5\n                   \u2191           \u2191\n                 reset       max=6!",
          "explanation": "max_sum = max(max_sum, current_sum)"
        },
        {
          "step": 4,
          "title": "Result",
          "visual": "[4,-1,2,1] = 6 \u2705\n \u2191 max subarray",
          "explanation": "Return max_sum"
        }
      ],
      "code": "def maxSubArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf At each position: should I continue or restart?\n    - \ud83e\udde0 If current_sum < 0, better to start fresh!\n    - \ud83d\udca1 Track both current sum and overall maximum\n\n    Algorithm:\n    1. Initialize - Start with first element as both\n    2. The Key Decision - current_sum = max(num, current_sum + num)\n    3. Update Maximum - max_sum = max(max_sum, current_sum)\n    4. Result - Return max_sum\n    \"\"\"\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:  # Iterate over elements.\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)  # Take the maximum value.\n        max_sum = max(max_sum, current_sum)  # Take the maximum value.\n    \n    return max_sum",
      "keyInsight": "The magic: negative prefix sum is never worth keeping!",
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
      "examples": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
        },
        {
          "input": "nums = [1]",
          "output": "1",
          "explanation": "Single element is the maximum."
        },
        {
          "input": "nums = [5,4,-1,7,8]",
          "output": "23",
          "explanation": "The entire array has the largest sum."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4"
      ],
      "hints": [
        "Use Kadane's algorithm.",
        "At each position, decide: extend current subarray or start fresh.",
        "current_sum = max(nums[i], current_sum + nums[i])"
      ],
      "relatedProblems": [
        "maximum-product-subarray",
        "best-time-to-buy-and-sell-stock",
        "maximum-sum-circular-subarray"
      ],
      "videoId": "5WZl3MMT0Eg",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
          "transientMessage": "currentSum=-2, maxSum=-2",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "nums[1]=1: extend or start new?",
          "transientMessage": "currentSum=1, maxSum=1",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "nums[2]=-3: extend or start new?",
          "transientMessage": "currentSum=-2, maxSum=1",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "nums[3]=4: extend or start new?",
          "transientMessage": "currentSum=4, maxSum=4",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "nums[4]=-1: extend or start new?",
          "transientMessage": "currentSum=3, maxSum=4",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "nums[5]=2: extend or start new?",
          "transientMessage": "currentSum=5, maxSum=5",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "nums[6]=1: extend or start new?",
          "transientMessage": "currentSum=6, maxSum=6",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "nums[7]=-5: extend or start new?",
          "transientMessage": "currentSum=1, maxSum=6",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            7
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "nums[8]=4: extend or start new?",
          "transientMessage": "currentSum=5, maxSum=6",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 8
            }
          ],
          "indices": [
            8
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Maximum subarray sum: 6",
          "transientMessage": "Complete!",
          "arrayState": [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "array",
      "initialState": [
        -2,
        1,
        -3,
        4,
        -1,
        2,
        1,
        -5,
        4
      ],
      "approach": "Kadane's Algorithm: Extend current sum OR start fresh - pick the better option!",
      "mentalModel": "Like finding the sunniest part of the day. If the clouds (negative) get too heavy, you restart your streak.",
      "initialCode": "def maxSubArray(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxSubArray(nums):\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            if current_sum > max_sum:\n                max_sum = current_sum\n    return max_sum"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf At each position: should I continue or restart?",
            "\ud83e\udde0 If current_sum < 0, better to start fresh!",
            "\ud83d\udca1 Track both current sum and overall maximum"
          ],
          "code": "def maxSubArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf At each position: should I continue or restart?\n    - \ud83e\udde0 If current_sum < 0, better to start fresh!\n    - \ud83d\udca1 Track both current sum and overall maximum\n\n    Algorithm:\n    1. Initialize - Start with first element as both\n    2. The Key Decision - current_sum = max(num, current_sum + num)\n    3. Update Maximum - max_sum = max(max_sum, current_sum)\n    4. Result - Return max_sum\n    \"\"\"\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:  # Iterate over elements.\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)  # Take the maximum value.\n        max_sum = max(max_sum, current_sum)  # Take the maximum value.\n    \n    return max_sum"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "climbing-stairs": {
      "title": "Climbing Stairs",
      "pattern": "DP (Fibonacci)",
      "patternEmoji": "\ud83e\uddb7",
      "timeComplexity": "O(N)",
      "spaceComplexity": "O(1)",
      "oneliner": "ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
      "intuition": [
        "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
        "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
        "\ud83d\udca1 Use two variables to store previous results."
      ],
      "testCases": [
        {
          "input": "n = 2",
          "output": "2"
        },
        {
          "input": "n = 3",
          "output": "3"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "one, two = 1, 1",
          "explanation": "Base cases."
        },
        {
          "step": 2,
          "title": "Loop",
          "visual": "temp=one. one=one+two. two=temp.",
          "explanation": "Shift."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "return one.",
          "explanation": "Result."
        }
      ],
      "code": "def climbStairs(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.\n    - \ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).\n    - \ud83d\udca1 Use two variables to store previous results.\n\n    Algorithm:\n    1. Init - Base cases.\n    2. Loop - Shift.\n    3. Return - Result.\n    \"\"\"\n    one, two = 1, 1\n    for i in range(n - 1):  # Iterate through the range.\n        temp = one\n        one = one + two\n        two = temp\n    return one",
      "keyInsight": "Notice the subproblem structure overlap. Memorization or Iterative DP solves it efficiently.",
      "visualizationType": "array",
      "initialState": [
        1,
        1,
        0,
        0,
        0,
        0
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "n = 5, ways to climb stairs",
          "transientMessage": "dp[0] = 1, dp[1] = 1 (base cases)",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "dp[2] = dp[1] + dp[0] = 1 + 1",
          "transientMessage": "dp[2] = 2",
          "arrayState": [
            1,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "dp[3] = dp[2] + dp[1] = 2 + 1",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            1,
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            1,
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "dp[4] = dp[3] + dp[2] = 3 + 2",
          "transientMessage": "dp[4] = 5",
          "arrayState": [
            1,
            1,
            2,
            3,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            2,
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "dp[5] = dp[4] + dp[3] = 5 + 3",
          "transientMessage": "dp[5] = 8",
          "arrayState": [
            1,
            1,
            2,
            3,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            3,
            4,
            5
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Result: 8 ways",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            1,
            2,
            3,
            5,
            8
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        }
      ],
      "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "examples": [
        {
          "input": "n = 2",
          "output": "2",
          "explanation": "Two ways: (1+1) or (2)."
        },
        {
          "input": "n = 3",
          "output": "3",
          "explanation": "Three ways: (1+1+1), (1+2), (2+1)."
        }
      ],
      "constraints": [
        "1 <= n <= 45"
      ],
      "hints": [
        "This is a classic dynamic programming problem.",
        "The number of ways to reach step n = ways to reach (n-1) + ways to reach (n-2).",
        "This is essentially the Fibonacci sequence!"
      ],
      "relatedProblems": [
        "min-cost-climbing-stairs",
        "house-robber",
        "fibonacci-number"
      ],
      "videoId": "Y0lT9Fck7qI",
      "problemStatement": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DP (Fibonacci): ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
      "suggestedNextQuestion": {
        "slug": "min-cost-climbing-stairs",
        "title": "Min Cost Climbing Stairs",
        "difficulty": "Easy",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like a Fibonacci sequence. Step N depends on N-1 and N-2.",
      "initialCode": "def climbStairs(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def climbStairs(n):\n    if n <= 2: return n\n    return climbStairs(n - 1) + climbStairs(n - 2)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
            "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
            "\ud83d\udca1 Use two variables to store previous results."
          ],
          "code": "def climbStairs(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.\n    - \ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).\n    - \ud83d\udca1 Use two variables to store previous results.\n\n    Algorithm:\n    1. Init - Base cases.\n    2. Loop - Shift.\n    3. Return - Result.\n    \"\"\"\n    one, two = 1, 1\n    for i in range(n - 1):  # Iterate through the range.\n        temp = one\n        one = one + two\n        two = temp\n    return one"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "linked-list-cycle": {
      "title": "Linked List Cycle",
      "pattern": "Fast & Slow Pointers",
      "patternEmoji": "\ud83d\udc07\ud83d\udc22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
      "intuition": [
        "\ud83c\udfaf Floyd's Tortoise and Hare.",
        "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
        "\ud83d\udca1 If Fast reaches null, no cycle."
      ],
      "testCases": [
        {
          "input": "head = [3,2,0,-4], pos = 1",
          "output": "true"
        },
        {
          "input": "head = [1,2], pos = 0",
          "output": "true"
        },
        {
          "input": "head = [1], pos = -1",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Run",
          "visual": "Slow=Head, Fast=Head. Loop.",
          "explanation": "Start race."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "Slow == Fast? Return True.",
          "explanation": "Collision!"
        },
        {
          "step": 3,
          "title": "End",
          "visual": "Fast is None? Return False.",
          "explanation": "Reached end."
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Floyd's Tortoise and Hare.\n    - \ud83e\udde0 If cycle exists, Fast will eventually lap Slow.\n    - \ud83d\udca1 If Fast reaches null, no cycle.\n\n    Algorithm:\n    1. Run - Start race.\n    2. Check - Collision!\n    3. End - Reached end.\n    \"\"\"\n    slow, fast = head, head  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True  # Condition satisfied.\n    return False  # Condition not met.",
      "keyInsight": "Fast pointer MUST check `fast.next` before jumping two steps to avoid AttributeError.",
      "visualizationType": "linkedlist",
      "initialState": [
        3,
        2,
        0,
        -4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "3 \u2192 2 \u2192 0 \u2192 -4 \u21a9 (cycle to 2)",
          "transientMessage": "slow=3, fast=3 (both at head)",
          "arrayState": [
            3,
            2,
            0,
            -4
          ],
          "pointers": [
            {
              "label": "slow",
              "index": 0
            },
            {
              "label": "fast",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Move: slow+1, fast+2",
          "transientMessage": "slow=2, fast=0",
          "arrayState": [
            3,
            2,
            0,
            -4
          ],
          "pointers": [
            {
              "label": "slow",
              "index": 1
            },
            {
              "label": "fast",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Move: slow+1, fast+2",
          "transientMessage": "slow=0, fast=2 (in cycle)",
          "arrayState": [
            3,
            2,
            0,
            -4
          ],
          "pointers": [
            {
              "label": "slow",
              "index": 2
            },
            {
              "label": "fast",
              "index": 1
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "slow catches up to fast!",
          "transientMessage": "They meet at node with value 2 \u2192 Cycle detected! \ud83c\udfaf",
          "arrayState": [
            3,
            2,
            0,
            -4
          ],
          "pointers": [
            {
              "label": "meet!",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Result: true",
          "transientMessage": "Cycle exists (Floyd's algorithm) \u2705",
          "arrayState": [
            3,
            2,
            0,
            -4
          ],
          "pointers": [],
          "indices": [
            1,
            2,
            3
          ],
          "color": "success"
        }
      ],
      "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
      "examples": [
        {
          "input": "head = [3,2,0,-4], pos = 1",
          "output": "true",
          "explanation": "There is a cycle where the tail connects to node at index 1."
        },
        {
          "input": "head = [1,2], pos = 0",
          "output": "true",
          "explanation": "Tail connects to node at index 0."
        },
        {
          "input": "head = [1], pos = -1",
          "output": "false",
          "explanation": "No cycle in the list."
        }
      ],
      "constraints": [
        "The number of nodes is in range [0, 10^4]",
        "-10^5 <= Node.val <= 10^5",
        "pos is -1 or a valid index."
      ],
      "hints": [
        "Use Floyd's Cycle Detection (Tortoise and Hare).",
        "Have a slow pointer move by 1 and fast pointer move by 2.",
        "If they meet, there's a cycle."
      ],
      "relatedProblems": [
        "linked-list-cycle-ii",
        "happy-number",
        "find-the-duplicate-number"
      ],
      "videoId": "gBTe7lFR3vc",
      "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Fast & Slow Pointers: Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
      "suggestedNextQuestion": {
        "slug": "merge-two-sorted-lists",
        "title": "Merge Two Sorted Lists",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like using your fingers to track two different positions in a book at once.",
      "initialCode": "def hasCycle(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def hasCycle(head):\n    seen = set()\n    curr = head\n    while curr:\n        if curr in seen:\n            return True\n        seen.add(curr)\n        curr = curr.next\n    return False"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Floyd's Tortoise and Hare.",
            "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
            "\ud83d\udca1 If Fast reaches null, no cycle."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Floyd's Tortoise and Hare.\n    - \ud83e\udde0 If cycle exists, Fast will eventually lap Slow.\n    - \ud83d\udca1 If Fast reaches null, no cycle.\n\n    Algorithm:\n    1. Run - Start race.\n    2. Check - Collision!\n    3. End - Reached end.\n    \"\"\"\n    slow, fast = head, head  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True  # Condition satisfied.\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "binary-search": {
      "title": "Binary Search",
      "pattern": "Divide & Conquer",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Half the search space each time by checking the middle!",
      "intuition": [
        "\ud83c\udfaf Array is SORTED - exploit this!",
        "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
        "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
      ],
      "testCases": [
        {
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "output": "4"
        },
        {
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "output": "-1"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Set Boundaries",
          "visual": "[1, 3, 5, 7, 9, 11, 13]\n \u2191                    \u2191\nleft                right",
          "explanation": "Start with full array range"
        },
        {
          "step": 2,
          "title": "Find Middle",
          "visual": "[1, 3, 5, 7, 9, 11, 13]\n          \u2191\n         mid (index 3, value 7)",
          "explanation": "mid = (left + right) // 2"
        },
        {
          "step": 3,
          "title": "Compare & Narrow",
          "visual": "target = 11\n7 < 11 \u2192 search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             \u2191       \u2191\n           left    right",
          "explanation": "Eliminate half the options!"
        },
        {
          "step": 4,
          "title": "Repeat Until Found",
          "visual": "mid = 11 \u2705 FOUND!\nOR left > right = Not found",
          "explanation": "Continue halving until match or exhausted"
        }
      ],
      "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Array is SORTED - exploit this!\n    - \ud83e\udde0 Check middle: too big? go left. Too small? go right.\n    - \ud83d\udca1 Halving = log\u2082(n) steps maximum\n\n    Algorithm:\n    1. Set Boundaries - Start with full array range\n    2. Find Middle - mid = (left + right) // 2\n    3. Compare & Narrow - Eliminate half the options!\n    4. Repeat Until Found - Continue halving until match or exhausted\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1",
      "keyInsight": "Each step eliminates HALF - that's why it's O(log n)!",
      "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.",
      "examples": [
        {
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "output": "4",
          "explanation": "9 exists in nums and its index is 4."
        },
        {
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "output": "-1",
          "explanation": "2 does not exist in nums."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^4 < nums[i], target < 10^4",
        "All the integers in nums are unique.",
        "nums is sorted in ascending order."
      ],
      "hints": [
        "Use two pointers: left and right.",
        "Calculate mid = (left + right) // 2.",
        "Compare nums[mid] with target and narrow the search range."
      ],
      "relatedProblems": [
        "search-insert-position",
        "search-in-rotated-sorted-array",
        "find-first-and-last-position-of-element-in-sorted-array"
      ],
      "videoId": "s4DPM8ct1pI",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Search for 9 in [-1, 0, 3, 5, 9, 12]",
          "transientMessage": "Initialize left=0, right=5",
          "arrayState": [
            -1,
            0,
            3,
            5,
            9,
            12
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            5
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "mid = (0 + 5) / 2 = 2",
          "transientMessage": "Check arr[2] = 3",
          "arrayState": [
            -1,
            0,
            3,
            5,
            9,
            12
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "M",
              "index": 2
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "3 < 9",
          "transientMessage": "Target is in right half, move left",
          "arrayState": [
            -1,
            0,
            3,
            5,
            9,
            12
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            3,
            5
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "mid = (3 + 5) / 2 = 4",
          "transientMessage": "Check arr[4] = 9",
          "arrayState": [
            -1,
            0,
            3,
            5,
            9,
            12
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "M",
              "index": 4
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "arr[4] = 9 \u2713",
          "transientMessage": "Found target at index 4!",
          "arrayState": [
            -1,
            0,
            3,
            5,
            9,
            12
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        }
      ],
      "problemStatement": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "array",
      "initialState": [
        -1,
        0,
        3,
        5,
        9,
        12
      ],
      "approach": "Divide & Conquer: Half the search space each time by checking the middle!",
      "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
      "initialCode": "def search(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def search(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Array is SORTED - exploit this!",
            "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
            "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
          ],
          "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Array is SORTED - exploit this!\n    - \ud83e\udde0 Check middle: too big? go left. Too small? go right.\n    - \ud83d\udca1 Halving = log\u2082(n) steps maximum\n\n    Algorithm:\n    1. Set Boundaries - Start with full array range\n    2. Find Middle - mid = (left + right) // 2\n    3. Compare & Narrow - Eliminate half the options!\n    4. Repeat Until Found - Continue halving until match or exhausted\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "number-of-islands": {
      "title": "Number of Islands",
      "pattern": "Matrix DFS / BFS",
      "patternEmoji": "\ud83c\udfdd\ufe0f",
      "timeComplexity": "O(M*N)",
      "spaceComplexity": "O(M*N)",
      "oneliner": "Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
      "intuition": [
        "\ud83c\udfaf '1' is land. Connected '1's form one island.",
        "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
        "\ud83d\udca1 Flood fill."
      ],
      "testCases": [
        {
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "output": "1"
        },
        {
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "output": "3"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Scan",
          "visual": "Find '1' at (r, c). Count++.",
          "explanation": "Discovery."
        },
        {
          "step": 2,
          "title": "Sink",
          "visual": "DFS(r, c). Turn '1' to '0'. Recurse 4 dirs.",
          "explanation": "Erase."
        },
        {
          "step": 3,
          "title": "Repeat",
          "visual": "Continue scan till end.",
          "explanation": "Completion."
        }
      ],
      "code": "def numIslands(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf '1' is land. Connected '1's form one island.\n    - \ud83e\udde0 When we find an island, destroy it so we don't count it again.\n    - \ud83d\udca1 Flood fill.\n\n    Algorithm:\n    1. Scan - Discovery.\n    2. Sink - Erase.\n    3. Repeat - Completion.\n    \"\"\"\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    islands = 0\n    \n    def bfs(r, c):\n        q = []\n        q.append((r, c))  # Add to end.\n        visit.add((r,c))\n        while q:\n            row, col = q.pop(0)  # Remove and return last element.\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:  # Iterate over elements.\n                r, c = row + dr, col + dc\n                if (r in range(rows) and c in range(cols) and\n                    grid[r][c] == \"1\" and (r, c) not in visit):\n                    q.append((r, c))  # Add to end.\n                    visit.add((r, c))\n\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == \"1\" and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1\n    return islands",
      "keyInsight": "You can modify the grid in-place (change '1' to '0') to save O(MN) space for the visited set.",
      "visualizationType": "grid",
      "initialState": [
        [
          "1",
          "1",
          "0"
        ],
        [
          "1",
          "1",
          "0"
        ],
        [
          "0",
          "0",
          "1"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Number of Islands",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "1",
              "1",
              "0"
            ],
            [
              "1",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "examples": [
        {
          "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
          "output": "1",
          "explanation": "One connected land mass."
        },
        {
          "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
          "output": "3",
          "explanation": "Three separate islands."
        }
      ],
      "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 300",
        "grid[i][j] is '0' or '1'."
      ],
      "hints": [
        "Use DFS or BFS to explore connected land.",
        "When you find a '1', increment count and mark all connected land as visited.",
        "Continue scanning the grid."
      ],
      "relatedProblems": [
        "surrounded-regions",
        "max-area-of-island",
        "number-of-enclaves"
      ],
      "videoId": "pV2kpPD66nE",
      "problemStatement": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Matrix DFS / BFS: Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
      "suggestedNextQuestion": {
        "slug": "pacific-atlantic-water-flow",
        "title": "Pacific Atlantic Water Flow",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def numIslands(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def numIslands(grid):\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    count = 0\n    \n    def bfs(r, c):\n        q = [((r, c))]\n        while q:\n            row, col = q.pop(0)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = row + dr, col + dc\n                if (0 <= nr < rows and 0 <= nc < cols and\n                    grid[nr][nc] == \"1\" and (nr, nc) not in visited):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                count += 1\n                visited.add((r, c))\n                bfs(r, c)\n    return count"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(M*N)",
          "spaceComplexity": "O(M*N)",
          "intuition": [
            "\ud83c\udfaf '1' is land. Connected '1's form one island.",
            "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
            "\ud83d\udca1 Flood fill."
          ],
          "code": "def numIslands(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf '1' is land. Connected '1's form one island.\n    - \ud83e\udde0 When we find an island, destroy it so we don't count it again.\n    - \ud83d\udca1 Flood fill.\n\n    Algorithm:\n    1. Scan - Discovery.\n    2. Sink - Erase.\n    3. Repeat - Completion.\n    \"\"\"\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    islands = 0\n    \n    def bfs(r, c):\n        q = []\n        q.append((r, c))  # Add to end.\n        visit.add((r,c))\n        while q:\n            row, col = q.pop(0)  # Remove and return last element.\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:  # Iterate over elements.\n                r, c = row + dr, col + dc\n                if (r in range(rows) and c in range(cols) and\n                    grid[r][c] == \"1\" and (r, c) not in visit):\n                    q.append((r, c))  # Add to end.\n                    visit.add((r, c))\n\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == \"1\" and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1\n    return islands"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reverse-linked-list": {
      "title": "Reverse Linked List",
      "pattern": "Iterative Pointer Swap",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Change each node's pointer to point backwards!",
      "intuition": [
        "\ud83c\udfaf Each node.next should point to previous node",
        "\ud83e\udde0 Need to save 'next' before changing pointer",
        "\ud83d\udca1 Use 3 pointers: prev, current, next"
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[5,4,3,2,1]"
        },
        {
          "input": "head = [1,2]",
          "output": "[2,1]"
        },
        {
          "input": "head = []",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Initialize",
          "visual": "None \u2190 1 \u2192 2 \u2192 3 \u2192 None\n \u2191    \u2191\nprev  curr",
          "explanation": "prev starts at None (new tail)"
        },
        {
          "step": 2,
          "title": "Save Next",
          "visual": "1 \u2192 2 \u2192 3\n    \u2191\n   next_node (save before we lose it!)",
          "explanation": "Must save before changing pointer"
        },
        {
          "step": 3,
          "title": "Reverse Pointer",
          "visual": "None \u2190 1   2 \u2192 3\n \u2191    \u2191   \u2191\nprev curr next",
          "explanation": "curr.next = prev"
        },
        {
          "step": 4,
          "title": "Move Forward",
          "visual": "None \u2190 1 \u2190 2 \u2190 3\n               \u2191\n              prev (new head!)",
          "explanation": "Shift all pointers right, repeat"
        }
      ],
      "code": "def reverseList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node.next should point to previous node\n    - \ud83e\udde0 Need to save 'next' before changing pointer\n    - \ud83d\udca1 Use 3 pointers: prev, current, next\n\n    Algorithm:\n    1. Initialize - prev starts at None (new tail)\n    2. Save Next - Must save before changing pointer\n    3. Reverse Pointer - curr.next = prev\n    4. Move Forward - Shift all pointers right, repeat\n    \"\"\"\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head",
      "keyInsight": "Three-pointer technique is fundamental for linked list operations!",
      "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[5,4,3,2,1]",
          "explanation": "The list is reversed."
        },
        {
          "input": "head = [1,2]",
          "output": "[2,1]",
          "explanation": "Two-element list reversed."
        },
        {
          "input": "head = []",
          "output": "[]",
          "explanation": "Empty list remains empty."
        }
      ],
      "constraints": [
        "The number of nodes in the list is the range [0, 5000].",
        "-5000 <= Node.val <= 5000"
      ],
      "hints": [
        "Use three pointers: prev, curr, next.",
        "At each step, reverse curr's pointer to prev.",
        "Move all pointers one step forward."
      ],
      "relatedProblems": [
        "reverse-linked-list-ii",
        "palindrome-linked-list",
        "reverse-nodes-in-k-group"
      ],
      "videoId": "G0_I-ZF0S38",
      "animationSteps": [
        {
          "step": 1,
          "visual": "1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 null",
          "transientMessage": "prev=null, curr=head(1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": -1
            },
            {
              "label": "curr",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Save next: next = 2",
          "transientMessage": "Reverse link: 1.next = null (prev)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": -1
            },
            {
              "label": "curr",
              "index": 0
            },
            {
              "label": "next",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "null \u2190 1    2 \u2192 3 \u2192 4 \u2192 5",
          "transientMessage": "Move: prev=1, curr=2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": 0
            },
            {
              "label": "curr",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "null \u2190 1 \u2190 2    3 \u2192 4 \u2192 5",
          "transientMessage": "Reverse link: 2.next = 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": 1
            },
            {
              "label": "curr",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "null \u2190 1 \u2190 2 \u2190 3    4 \u2192 5",
          "transientMessage": "Reverse link: 3.next = 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": 2
            },
            {
              "label": "curr",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "null \u2190 1 \u2190 2 \u2190 3 \u2190 4    5",
          "transientMessage": "Reverse link: 4.next = 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "prev",
              "index": 3
            },
            {
              "label": "curr",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "null \u2190 1 \u2190 2 \u2190 3 \u2190 4 \u2190 5",
          "transientMessage": "Reverse link: 5.next = 4, curr=null (done!)",
          "arrayState": [
            5,
            4,
            3,
            2,
            1
          ],
          "pointers": [
            {
              "label": "prev",
              "index": 0
            }
          ],
          "indices": [
            0,
            1,
            2,
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "5 \u2192 4 \u2192 3 \u2192 2 \u2192 1 \u2192 null",
          "transientMessage": "Return prev (new head = 5) \u2705",
          "arrayState": [
            5,
            4,
            3,
            2,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3,
            4
          ],
          "color": "success"
        }
      ],
      "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "approach": "Iterative Pointer Swap: Change each node's pointer to point backwards!",
      "mentalModel": "Like using your fingers to track two different positions in a book at once.",
      "initialCode": "def reverseList(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def reverseList(head):\n    # Convert to list, reverse, rebuild\n    if not head: return None\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    \n    vals.reverse()\n    dummy = ListNode(0)\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Each node.next should point to previous node",
            "\ud83e\udde0 Need to save 'next' before changing pointer",
            "\ud83d\udca1 Use 3 pointers: prev, current, next"
          ],
          "code": "def reverseList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node.next should point to previous node\n    - \ud83e\udde0 Need to save 'next' before changing pointer\n    - \ud83d\udca1 Use 3 pointers: prev, current, next\n\n    Algorithm:\n    1. Initialize - prev starts at None (new tail)\n    2. Save Next - Must save before changing pointer\n    3. Reverse Pointer - curr.next = prev\n    4. Move Forward - Shift all pointers right, repeat\n    \"\"\"\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "contains-duplicate": {
      "title": "Contains Duplicate",
      "pattern": "Hash Set",
      "patternEmoji": "\ud83d\udc6f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Add to set; if exists, return True.",
      "intuition": [
        "\ud83c\udfaf Any number appearing twice?",
        "\ud83e\udde0 Set stores unique elements.",
        "\ud83d\udca1 Check membership before adding."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "true"
        },
        {
          "input": "nums = [1,2,3,4]",
          "output": "false"
        },
        {
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "output": "true"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Scan",
          "visual": "Iterate numbers.",
          "explanation": "Standard pass."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "In set? True.",
          "explanation": "Collision."
        },
        {
          "step": 3,
          "title": "Add",
          "visual": "Add to set.",
          "explanation": "Track seen."
        }
      ],
      "code": "def containsDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Any number appearing twice?\n    - \ud83e\udde0 Set stores unique elements.\n    - \ud83d\udca1 Check membership before adding.\n\n    Algorithm:\n    1. Scan - Standard pass.\n    2. Check - Collision.\n    3. Add - Track seen.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    for n in nums:  # Iterate over elements.\n        if n in seen: return True  # Check if already visited.\n        seen.add(n)\n    return False  # Condition not met.",
      "keyInsight": "HashSet provides immediate collision detection.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [1, 2, 3, 1]",
          "transientMessage": "Check for duplicates using HashSet",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Add 1 to set",
          "transientMessage": "Set: {1}",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Add 2 to set",
          "transientMessage": "Set: {1, 2}",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Add 3 to set",
          "transientMessage": "Set: {1, 2, 3}",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "nums[3]=1 already in set!",
          "transientMessage": "Duplicate found! Return true",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "!",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "examples": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "true",
          "explanation": "1 appears twice."
        },
        {
          "input": "nums = [1,2,3,4]",
          "output": "false",
          "explanation": "All elements are distinct."
        },
        {
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "output": "true",
          "explanation": "Multiple duplicates exist."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^9 <= nums[i] <= 10^9"
      ],
      "hints": [
        "Use a hash set to track seen numbers.",
        "If you see a number already in the set, return true.",
        "Alternatively, sort the array and check adjacent elements."
      ],
      "relatedProblems": [
        "contains-duplicate-ii",
        "contains-duplicate-iii",
        "find-the-duplicate-number"
      ],
      "videoId": "3OamzN90kPg",
      "problemStatement": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Set: Add to set; if exists, return True.",
      "suggestedNextQuestion": {
        "slug": "copy-list-with-random-pointer",
        "title": "Copy List with Random Pointer",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def containsDuplicate(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def containsDuplicate(nums):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n    return False"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Any number appearing twice?",
            "\ud83e\udde0 Set stores unique elements.",
            "\ud83d\udca1 Check membership before adding."
          ],
          "code": "def containsDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Any number appearing twice?\n    - \ud83e\udde0 Set stores unique elements.\n    - \ud83d\udca1 Check membership before adding.\n\n    Algorithm:\n    1. Scan - Standard pass.\n    2. Check - Collision.\n    3. Add - Track seen.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    for n in nums:  # Iterate over elements.\n        if n in seen: return True  # Check if already visited.\n        seen.add(n)\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "invert-binary-tree": {
      "title": "Invert Binary Tree",
      "pattern": "DFS (Recursion)",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Swap left and right children, then recurse.",
      "intuition": [
        "\ud83c\udfaf Mirror image.",
        "\ud83e\udde0 For every node, left becomes right.",
        "\ud83d\udca1 Post-order or Pre-order traversal works fine."
      ],
      "testCases": [
        {
          "input": "root = [4,2,7,1,3,6,9]",
          "output": "[4,7,2,9,6,3,1]"
        },
        {
          "input": "root = [2,1,3]",
          "output": "[2,3,1]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Swap",
          "visual": "root.left, root.right = root.right, root.left.",
          "explanation": "Action."
        },
        {
          "step": 2,
          "title": "Recurse",
          "visual": "invert(left), invert(right).",
          "explanation": "Propagate."
        },
        {
          "step": 3,
          "title": "Base",
          "visual": "If null, return null.",
          "explanation": "Stop."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef invertTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Mirror image.\n    - \ud83e\udde0 For every node, left becomes right.\n    - \ud83d\udca1 Post-order or Pre-order traversal works fine.\n\n    Algorithm:\n    1. Swap - Action.\n    2. Recurse - Propagate.\n    3. Base - Stop.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root",
      "keyInsight": "Max Howell famously got rejected by Google for not solving this on a whiteboard.",
      "visualizationType": "tree",
      "initialState": [
        4,
        2,
        7,
        1,
        3,
        6,
        9
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "    4\n   / \\\n  2   7\n / \\ / \\\n1  3 6  9",
          "transientMessage": "Recursively swap left and right children",
          "arrayState": [
            4,
            2,
            7,
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "At node 4: swap children",
          "transientMessage": "4.left \u2194 4.right \u2192 2 \u2194 7",
          "arrayState": [
            4,
            7,
            2,
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "swap",
              "index": 0
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "At node 7 (now left): swap children",
          "transientMessage": "7.left \u2194 7.right \u2192 6 \u2194 9",
          "arrayState": [
            4,
            7,
            2,
            9,
            6,
            3,
            1
          ],
          "pointers": [
            {
              "label": "swap",
              "index": 1
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "At node 2 (now right): swap children",
          "transientMessage": "2.left \u2194 2.right \u2192 1 \u2194 3",
          "arrayState": [
            4,
            7,
            2,
            9,
            6,
            3,
            1
          ],
          "pointers": [
            {
              "label": "swap",
              "index": 2
            }
          ],
          "indices": [
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "    4\n   / \\\n  7   2\n / \\ / \\\n9  6 3  1",
          "transientMessage": "Tree inverted! \u2705",
          "arrayState": [
            4,
            7,
            2,
            9,
            6,
            3,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "color": "success"
        }
      ],
      "description": "Given the root of a binary tree, invert the tree, and return its root.",
      "examples": [
        {
          "input": "root = [4,2,7,1,3,6,9]",
          "output": "[4,7,2,9,6,3,1]",
          "explanation": "Mirror the tree."
        },
        {
          "input": "root = [2,1,3]",
          "output": "[2,3,1]",
          "explanation": "Swap children."
        }
      ],
      "constraints": [
        "The number of nodes is in range [0, 100].",
        "-100 <= Node.val <= 100"
      ],
      "hints": [
        "Recursively swap left and right children.",
        "Base case: null node returns null.",
        "DFS or BFS both work."
      ],
      "relatedProblems": [
        "same-tree",
        "symmetric-tree"
      ],
      "videoId": "OnSn2XEQ4MY",
      "problemStatement": "Given the root of a binary tree, invert the tree, and return its root.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS (Recursion): Swap left and right children, then recurse.",
      "suggestedNextQuestion": {
        "slug": "maximum-depth-of-binary-tree",
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def invertTree(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def invertTree(root):\n    if not root:\n        return None\n    # Swap children\n    root.left, root.right = root.right, root.left\n    # Recurse\n    invertTree(root.left)\n    invertTree(root.right)\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Mirror image.",
            "\ud83e\udde0 For every node, left becomes right.",
            "\ud83d\udca1 Post-order or Pre-order traversal works fine."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef invertTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Mirror image.\n    - \ud83e\udde0 For every node, left becomes right.\n    - \ud83d\udca1 Post-order or Pre-order traversal works fine.\n\n    Algorithm:\n    1. Swap - Action.\n    2. Recurse - Propagate.\n    3. Base - Stop.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "coin-change": {
      "title": "Coin Change",
      "pattern": "1D DP",
      "patternEmoji": "\ud83e\ude99",
      "timeComplexity": "O(amount * n)",
      "spaceComplexity": "O(amount)",
      "oneliner": "dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
      "intuition": [
        "\ud83c\udfaf Min coins to make amount.",
        "\ud83e\udde0 dp[i] = min coins for amount i.",
        "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
      ],
      "testCases": [
        {
          "input": "coins = [1,2,5], amount = 11",
          "output": "3"
        },
        {
          "input": "coins = [2], amount = 3",
          "output": "-1"
        },
        {
          "input": "coins = [1], amount = 0",
          "output": "0"
        }
      ],
      "code": "def coinChange(coins, amount):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min coins to make amount.\n    - \ud83e\udde0 dp[i] = min coins for amount i.\n    - \ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1).\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 0\n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] = min(dp[i], dp[i - coin] + 1)  # Take the minimum value.\n    return dp[amount] if dp[amount] != float('inf') else -1",
      "keyInsight": "Bottom-up DP iterating coins first or amount first.",
      "visualizationType": "array",
      "initialState": [
        0,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        3,
        3,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "coins=[1,2,5], amount=11",
          "transientMessage": "dp[0]=0, rest=\u221e",
          "arrayState": [
            0,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "dp[1] = dp[0] + 1 = 1 (using coin 1)",
          "transientMessage": "Amount 1 needs 1 coins",
          "arrayState": [
            0,
            1,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "dp[2] = dp[1] + 1 = 2 (using coin 1)",
          "transientMessage": "Amount 2 needs 2 coins",
          "arrayState": [
            0,
            1,
            2,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "dp[2] = dp[0] + 1 = 1 (using coin 2)",
          "transientMessage": "Amount 2 needs 1 coins",
          "arrayState": [
            0,
            1,
            1,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "dp[3] = dp[2] + 1 = 2 (using coin 1)",
          "transientMessage": "Amount 3 needs 2 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "dp[4] = dp[3] + 1 = 3 (using coin 1)",
          "transientMessage": "Amount 4 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            3,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "dp[4] = dp[2] + 1 = 2 (using coin 2)",
          "transientMessage": "Amount 4 needs 2 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            2,
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "dp[5] = dp[4] + 1 = 3 (using coin 1)",
          "transientMessage": "Amount 5 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            3,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            4,
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "dp[5] = dp[0] + 1 = 1 (using coin 5)",
          "transientMessage": "Amount 5 needs 1 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            0,
            5
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "dp[6] = dp[5] + 1 = 2 (using coin 1)",
          "transientMessage": "Amount 6 needs 2 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "dp[7] = dp[6] + 1 = 3 (using coin 1)",
          "transientMessage": "Amount 7 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            3,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            6,
            7
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "dp[7] = dp[5] + 1 = 2 (using coin 2)",
          "transientMessage": "Amount 7 needs 2 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            "\u221e",
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            5,
            7
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "dp[8] = dp[7] + 1 = 3 (using coin 1)",
          "transientMessage": "Amount 8 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            "\u221e",
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 8
            }
          ],
          "indices": [
            7,
            8
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "dp[9] = dp[8] + 1 = 4 (using coin 1)",
          "transientMessage": "Amount 9 needs 4 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            4,
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 9
            }
          ],
          "indices": [
            8,
            9
          ],
          "color": "success"
        },
        {
          "step": 15,
          "visual": "dp[9] = dp[7] + 1 = 3 (using coin 2)",
          "transientMessage": "Amount 9 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            3,
            "\u221e",
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 9
            }
          ],
          "indices": [
            7,
            9
          ],
          "color": "success"
        },
        {
          "step": 16,
          "visual": "dp[10] = dp[9] + 1 = 4 (using coin 1)",
          "transientMessage": "Amount 10 needs 4 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            3,
            4,
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 10
            }
          ],
          "indices": [
            9,
            10
          ],
          "color": "success"
        },
        {
          "step": 17,
          "visual": "dp[10] = dp[5] + 1 = 2 (using coin 5)",
          "transientMessage": "Amount 10 needs 2 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            3,
            2,
            "\u221e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 10
            }
          ],
          "indices": [
            5,
            10
          ],
          "color": "success"
        },
        {
          "step": 18,
          "visual": "dp[11] = dp[10] + 1 = 3 (using coin 1)",
          "transientMessage": "Amount 11 needs 3 coins",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            3,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 11
            }
          ],
          "indices": [
            10,
            11
          ],
          "color": "success"
        },
        {
          "step": 19,
          "visual": "Result: 3 coins",
          "transientMessage": "Minimum coins found!",
          "arrayState": [
            0,
            1,
            1,
            2,
            2,
            1,
            2,
            2,
            3,
            3,
            2,
            3
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 11
            }
          ],
          "indices": [
            11
          ],
          "color": "success"
        }
      ],
      "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
      "examples": [
        {
          "input": "coins = [1,2,5], amount = 11",
          "output": "3",
          "explanation": "11 = 5 + 5 + 1"
        },
        {
          "input": "coins = [2], amount = 3",
          "output": "-1",
          "explanation": "Cannot make 3 with only 2s."
        },
        {
          "input": "coins = [1], amount = 0",
          "output": "0",
          "explanation": "No coins needed for amount 0."
        }
      ],
      "constraints": [
        "1 <= coins.length <= 12",
        "1 <= coins[i] <= 2^31 - 1",
        "0 <= amount <= 10^4"
      ],
      "hints": [
        "Use dynamic programming.",
        "dp[i] = minimum coins needed to make amount i.",
        "For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
      ],
      "relatedProblems": [
        "coin-change-ii",
        "minimum-cost-for-tickets",
        "perfect-squares"
      ],
      "videoId": "H9bfqozjoqs",
      "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "1D DP: dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
      "suggestedNextQuestion": {
        "slug": "coin-change-ii",
        "title": "Coin Change II",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def coinChange(coins, amount):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def coinChange(coins, amount):\n    # Brute force (DFS)\n    def dfs(rem):\n        if rem < 0: return -1\n        if rem == 0: return 0\n        min_cost = float('inf')\n        for c in coins:\n            res = dfs(rem - c)\n            if res != -1:\n                min_cost = min(min_cost, res + 1)\n        return min_cost if min_cost != float('inf') else -1\n    return dfs(amount)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(amount * n)",
          "spaceComplexity": "O(amount)",
          "intuition": [
            "\ud83c\udfaf Min coins to make amount.",
            "\ud83e\udde0 dp[i] = min coins for amount i.",
            "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
          ],
          "code": "def coinChange(coins, amount):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min coins to make amount.\n    - \ud83e\udde0 dp[i] = min coins for amount i.\n    - \ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1).\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 0\n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] = min(dp[i], dp[i - coin] + 1)  # Take the minimum value.\n    return dp[amount] if dp[amount] != float('inf') else -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "two-sum": {
      "title": "Two Sum",
      "pattern": "Hash Map",
      "patternEmoji": "\u2795",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Store seen numbers; check if (target - current) exists in map.",
      "intuition": [
        "\ud83c\udfaf We need: nums[j] = target - nums[i].",
        "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
        "\ud83d\udca1 Look back: do we have the complement?"
      ],
      "testCases": [
        {
          "input": "nums = [2,7,11,15], target = 9",
          "output": "[0,1]"
        },
        {
          "input": "nums = [3,2,4], target = 6",
          "output": "[1,2]"
        },
        {
          "input": "nums = [3,3], target = 6",
          "output": "[0,1]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Scan",
          "visual": "Visit 2. Need 7. Map: {2:0}.",
          "explanation": "Remember 2."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "Visit 7. Need 2. 2 is in Map!",
          "explanation": "Pair found."
        },
        {
          "step": 3,
          "title": "Found",
          "visual": "Return [Map[2], CurrentIndex].",
          "explanation": "Indices found."
        }
      ],
      "code": "def twoSum(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need: nums[j] = target - nums[i].\n    - \ud83e\udde0 While iterating, store {val: index} of what we've seen.\n    - \ud83d\udca1 Look back: do we have the complement?\n\n    Algorithm:\n    1. Scan - Remember 2.\n    2. Check - Pair found.\n    3. Found - Indices found.\n    \"\"\"\n    prevMap = {}\n    for i, n in enumerate(nums):  # Iterate over elements.\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []",
      "keyInsight": "One pass is sufficient because the pair is commutative; we find it when we reach the *second* number.",
      "visualizationType": "array",
      "initialState": [
        2,
        7,
        11,
        15
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Find two numbers that sum to 9",
          "transientMessage": "Initialize empty hash map",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Check arr[0] = 2",
          "transientMessage": "Need complement: 9 - 2 = 7",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Store 2 \u2192 index 0 in map",
          "transientMessage": "Map: {2:0}",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Check arr[1] = 7",
          "transientMessage": "Need complement: 9 - 7 = 2",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Found 2 at index 0!",
          "transientMessage": "Return [0, 1]",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "j",
              "index": 0
            },
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        }
      ],
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
      "examples": [
        {
          "input": "nums = [2,7,11,15], target = 9",
          "output": "[0,1]",
          "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
        },
        {
          "input": "nums = [3,2,4], target = 6",
          "output": "[1,2]",
          "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
        },
        {
          "input": "nums = [3,3], target = 6",
          "output": "[0,1]",
          "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
        }
      ],
      "constraints": [
        "2 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "-10^9 <= target <= 10^9",
        "Only one valid answer exists."
      ],
      "hints": [
        "A really brute force way would be to search for all possible pairs of numbers but that would be too slow.",
        "Try using a hash map to store the complement of each number.",
        "Can you do it in one pass through the array?"
      ],
      "relatedProblems": [
        "three-sum",
        "two-sum-ii---input-array-is-sorted",
        "two-sum-iv---input-is-a-bst"
      ],
      "videoId": "KLlXCFG5TnA",
      "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map: Store seen numbers; check if (target - current) exists in map.",
      "suggestedNextQuestion": {
        "slug": "valid-anagram",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def twoSum(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def twoSum_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf We need: nums[j] = target - nums[i].",
            "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
            "\ud83d\udca1 Look back: do we have the complement?"
          ],
          "code": "def twoSum(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need: nums[j] = target - nums[i].\n    - \ud83e\udde0 While iterating, store {val: index} of what we've seen.\n    - \ud83d\udca1 Look back: do we have the complement?\n\n    Algorithm:\n    1. Scan - Remember 2.\n    2. Check - Pair found.\n    3. Found - Indices found.\n    \"\"\"\n    prevMap = {}\n    for i, n in enumerate(nums):  # Iterate over elements.\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "remove-element": {
      "title": "Remove Element",
      "pattern": "Two Pointers",
      "patternEmoji": "\u270c\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use a read pointer and a write pointer to filter in-place.",
      "intuition": [
        "\ud83c\udfaf We need to remove all instances of val in-place",
        "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
        "\ud83d\udca1 If current element != val, put it at k and increment k"
      ],
      "testCases": [
        {
          "input": "nums = [3,2,2,3], val = 3",
          "output": "2"
        },
        {
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "output": "5"
        }
      ],
      "code": "def removeElement(nums, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove all instances of val in-place\n    - \ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements\n    - \ud83d\udca1 If current element != val, put it at k and increment k\n    \"\"\"\n    k = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k",
      "keyInsight": "Overwrite values we don't want with the ones we keep!",
      "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.",
      "examples": [
        {
          "input": "nums = [3,2,2,3], val = 3",
          "output": "2, nums = [2,2,_,_]",
          "explanation": "Your function should return k = 2, with the first two elements of nums being 2."
        },
        {
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "output": "5, nums = [0,1,4,0,3,_,_,_]",
          "explanation": "Your function should return k = 5."
        }
      ],
      "constraints": [
        "0 <= nums.length <= 100",
        "0 <= nums[i] <= 50",
        "0 <= val <= 100"
      ],
      "hints": [
        "Use two pointers - one for iteration, one for placing valid elements.",
        "Overwrite elements equal to val with elements from the end.",
        "The order doesn't matter, so we can swap freely."
      ],
      "relatedProblems": [
        "remove-duplicates-from-sorted-array",
        "move-zeroes",
        "remove-linked-list-elements"
      ],
      "videoId": "Pcd1ii9P9ZI",
      "problemStatement": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "visualizationType": "array",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [3, 2, 2, 3], val=3",
          "transientMessage": "Remove all occurrences of val",
          "arrayState": [
            3,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "k",
              "index": 0
            }
          ],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "nums[0]=3 == 3",
          "transientMessage": "Skip",
          "arrayState": [
            3,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "nums[1]=2 != 3",
          "transientMessage": "Keep at position 0",
          "arrayState": [
            2,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "k",
              "index": 0
            },
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "nums[2]=2 != 3",
          "transientMessage": "Keep at position 1",
          "arrayState": [
            2,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "k",
              "index": 1
            },
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "nums[3]=3 == 3",
          "transientMessage": "Skip",
          "arrayState": [
            2,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "2 elements remaining",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        }
      ],
      "initialState": [
        3,
        2,
        2,
        3
      ],
      "approach": "Two Pointers: Use a read pointer and a write pointer to filter in-place.",
      "suggestedNextQuestion": {
        "slug": "valid-palindrome",
        "title": "Valid Palindrome",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def removeElement(nums, val):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def removeElement(nums, val):\n    idx = 0\n    for x in nums:\n        if x != val:\n            nums[idx] = x\n            idx += 1\n    return idx"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf We need to remove all instances of val in-place",
            "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
            "\ud83d\udca1 If current element != val, put it at k and increment k"
          ],
          "code": "def removeElement(nums, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove all instances of val in-place\n    - \ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements\n    - \ud83d\udca1 If current element != val, put it at k and increment k\n    \"\"\"\n    k = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "majority-element": {
      "title": "Majority Element",
      "pattern": "Boyer-Moore Voting",
      "patternEmoji": "\ud83d\uddf3\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Cancel out different elements; the majority always survives!",
      "intuition": [
        "\ud83c\udfaf Majority element appears > n/2 times",
        "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
        "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
      ],
      "testCases": [
        {
          "input": "nums = [3,2,3]",
          "output": "3"
        },
        {
          "input": "nums = [2,2,1,1,1,2,2]",
          "output": "2"
        }
      ],
      "code": "def majorityElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Majority element appears > n/2 times\n    - \ud83e\udde0 Think of it as a war: mixed pair die, majority wins\n    - \ud83d\udca1 Count +, Count -. If count 0, pick new candidate.\n    \"\"\"\n    count = 0\n    candidate = None\n    \n    for num in nums:  # Iterate over elements.\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate",
      "keyInsight": "If >50% of people vote Red, even if everyone else pairs up against them, Red wins!",
      "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
      "examples": [
        {
          "input": "nums = [3,2,3]",
          "output": "3",
          "explanation": "3 appears 2 times out of 3."
        },
        {
          "input": "nums = [2,2,1,1,1,2,2]",
          "output": "2",
          "explanation": "2 appears 4 times out of 7."
        }
      ],
      "constraints": [
        "n == nums.length",
        "1 <= n <= 5 * 10^4",
        "-10^9 <= nums[i] <= 10^9"
      ],
      "hints": [
        "Use Boyer-Moore Voting Algorithm.",
        "Maintain a candidate and count.",
        "If count is 0, pick new candidate. If same, increment, else decrement."
      ],
      "relatedProblems": [
        "majority-element-ii",
        "check-if-a-number-is-majority-element-in-a-sorted-array"
      ],
      "videoId": "7pnhv842keE",
      "problemStatement": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "array",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [2, 2, 1, 1, 1, 2, 2]",
          "transientMessage": "Boyer-Moore Voting Algorithm",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "New candidate: 2",
          "transientMessage": "count = 1",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "c",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "2 == candidate",
          "transientMessage": "count++ = 2",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "1 != candidate",
          "transientMessage": "count-- = 1",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "1 != candidate",
          "transientMessage": "count-- = 0",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "New candidate: 1",
          "transientMessage": "count = 1",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "c",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "2 != candidate",
          "transientMessage": "count-- = 0",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "New candidate: 2",
          "transientMessage": "count = 1",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "c",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Majority element: 2",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            2,
            1,
            1,
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "initialState": [
        2,
        2,
        1,
        1,
        1,
        2,
        2
      ],
      "approach": "Boyer-Moore Voting: Cancel out different elements; the majority always survives!",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def majorityElement(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def majorityElement(nums):\n    # Brute force: Count occurance of each element\n    majority_count = len(nums) // 2\n    for num in nums:\n        count = sum(1 for x in nums if x == num)\n        if count > majority_count:\n            return num"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Majority element appears > n/2 times",
            "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
            "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
          ],
          "code": "def majorityElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Majority element appears > n/2 times\n    - \ud83e\udde0 Think of it as a war: mixed pair die, majority wins\n    - \ud83d\udca1 Count +, Count -. If count 0, pick new candidate.\n    \"\"\"\n    count = 0\n    candidate = None\n    \n    for num in nums:  # Iterate over elements.\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "ransom-note": {
      "title": "Ransom Note",
      "pattern": "Hash Map / Counter",
      "patternEmoji": "\ud83d\udcc3",
      "timeComplexity": "O(m+n)",
      "spaceComplexity": "O(1) (26 chars)",
      "oneliner": "Count letters in magazine; ensure every letter in note is available.",
      "intuition": [
        "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
        "\ud83e\udde0 Count frequency of each char in magazine.",
        "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
      ],
      "testCases": [
        {
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "output": "false"
        },
        {
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "output": "false"
        },
        {
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "output": "true"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Count Magazine",
          "visual": "Map: {a:2, b:1}",
          "explanation": "Available resources."
        },
        {
          "step": 2,
          "title": "Check Note",
          "visual": "Need 'a'? Map['a']--. Remaining: 1.",
          "explanation": "Consume resource."
        },
        {
          "step": 3,
          "title": "Verify",
          "visual": "If Map[char] < 0, impossible.",
          "explanation": "Not enough letters."
        }
      ],
      "code": "def canConstruct(ransomNote, magazine):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can we construct 'note' from 'magazine' letters?\n    - \ud83e\udde0 Count frequency of each char in magazine.\n    - \ud83d\udca1 For each char in note, subtract count. If count < 0, False.\n\n    Algorithm:\n    1. Count Magazine - Available resources.\n    2. Check Note - Consume resource.\n    3. Verify - Not enough letters.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(magazine)\n    for c in ransomNote:  # Iterate over elements.\n        counts[c] -= 1\n        if counts[c] < 0: return False  # Condition not met.\n    return True  # Condition satisfied.",
      "keyInsight": "Using an array of size 26 is slightly faster than a hashmap, but Counter is cleaner.",
      "visualizationType": "array",
      "initialState": "ransomNote='aa', magazine='aab'",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Input: [r, a, n, s, o, m...]",
          "transientMessage": "HashMap approach",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process r",
          "transientMessage": "Map: {\"r\":1}",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process a",
          "transientMessage": "Map: {\"r\":1,\"a\":1}",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process n",
          "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1}",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Process s",
          "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1,\"s\":1}",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process o",
          "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1,\"s\":1,\"o\":1}",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "HashMap complete",
          "transientMessage": "Found 5 unique elements",
          "arrayState": [
            "r",
            "a",
            "n",
            "s",
            "o",
            "m",
            "N",
            "o"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote.",
      "examples": [
        {
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "output": "false",
          "explanation": "'a' is not in magazine."
        },
        {
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "output": "true",
          "explanation": "Both 'a's can be found in magazine."
        }
      ],
      "constraints": [
        "1 <= ransomNote.length, magazine.length <= 10^5",
        "ransomNote and magazine consist of lowercase English letters."
      ],
      "hints": [
        "Count character frequencies in magazine.",
        "Check if ransomNote's frequencies are all <= magazine's.",
        "Use a hash map or array of size 26."
      ],
      "relatedProblems": [
        "stickers-to-spell-word",
        "first-unique-character-in-a-string"
      ],
      "videoId": "i3bvxJyUB40",
      "problemStatement": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map / Counter: Count letters in magazine; ensure every letter in note is available.",
      "suggestedNextQuestion": {
        "slug": "roman-to-integer",
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def canConstruct(ransomNote, magazine):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def canConstruct_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m+n)",
          "spaceComplexity": "O(1) (26 chars)",
          "intuition": [
            "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
            "\ud83e\udde0 Count frequency of each char in magazine.",
            "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
          ],
          "code": "def canConstruct(ransomNote, magazine):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can we construct 'note' from 'magazine' letters?\n    - \ud83e\udde0 Count frequency of each char in magazine.\n    - \ud83d\udca1 For each char in note, subtract count. If count < 0, False.\n\n    Algorithm:\n    1. Count Magazine - Available resources.\n    2. Check Note - Consume resource.\n    3. Verify - Not enough letters.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(magazine)\n    for c in ransomNote:  # Iterate over elements.\n        counts[c] -= 1\n        if counts[c] < 0: return False  # Condition not met.\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "valid-anagram": {
      "title": "Valid Anagram",
      "pattern": "Hash Map / Sorting",
      "patternEmoji": "\ud83d\udd00",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Check if character counts are identical.",
      "intuition": [
        "\ud83c\udfaf Anagram = same letters, rearranged.",
        "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
        "\ud83d\udca1 Count S, subtract T. All zero? True."
      ],
      "testCases": [
        {
          "input": "s = \"anagram\", t = \"nagaram\"",
          "output": "true"
        },
        {
          "input": "s = \"rat\", t = \"car\"",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Count S",
          "visual": "{a:3, n:1, g:1, r:1, m:1}",
          "explanation": "Tally up."
        },
        {
          "step": 2,
          "title": "Subtract T",
          "visual": "Decrement counts for 'nagaram'.",
          "explanation": "Cancel out."
        },
        {
          "step": 3,
          "title": "Result",
          "visual": "All zero? Match.",
          "explanation": "Any non-zero means mismatch."
        }
      ],
      "code": "def isAnagram(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Anagram = same letters, rearranged.\n    - \ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).\n    - \ud83d\udca1 Count S, subtract T. All zero? True.\n\n    Algorithm:\n    1. Count S - Tally up.\n    2. Subtract T - Cancel out.\n    3. Result - Any non-zero means mismatch.\n    \"\"\"\n    if len(s) != len(t): return False  # Condition not met.\n    # return sorted(s) == sorted(t)\n    from collections import Counter\n    return Counter(s) == Counter(t)",
      "keyInsight": "Length check first is a cheap optimization.",
      "visualizationType": "array",
      "initialState": [
        "a",
        "n",
        "a",
        "g",
        "r",
        "a",
        "m"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "s=\"anagram\", t=\"nagaram\"",
          "transientMessage": "Count characters in s",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Count 'a': 1",
          "transientMessage": "Map: {\"a\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Count 'n': 1",
          "transientMessage": "Map: {\"a\":1,\"n\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Count 'a': 2",
          "transientMessage": "Map: {\"a\":2,\"n\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Count 'g': 1",
          "transientMessage": "Map: {\"a\":2,\"n\":1,\"g\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Count 'r': 1",
          "transientMessage": "Map: {\"a\":2,\"n\":1,\"g\":1,\"r\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Count 'a': 3",
          "transientMessage": "Map: {\"a\":3,\"n\":1,\"g\":1,\"r\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Count 'm': 1",
          "transientMessage": "Map: {\"a\":3,\"n\":1,\"g\":1,\"r\":1,\"m\":1}",
          "arrayState": [
            "a",
            "n",
            "a",
            "g",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Now subtract using t",
          "transientMessage": "Check if all counts become 0",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Subtract 'n': 0",
          "transientMessage": "Matched!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Subtract 'a': 2",
          "transientMessage": "Updated",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Subtract 'g': 0",
          "transientMessage": "Matched!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "Subtract 'a': 1",
          "transientMessage": "Updated",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 14,
          "visual": "Subtract 'r': 0",
          "transientMessage": "Matched!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 15,
          "visual": "Subtract 'a': 0",
          "transientMessage": "Matched!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 16,
          "visual": "Subtract 'm': 0",
          "transientMessage": "Matched!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 17,
          "visual": "Result: Valid Anagram",
          "transientMessage": "Complete!",
          "arrayState": [
            "n",
            "a",
            "g",
            "a",
            "r",
            "a",
            "m"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "examples": [
        {
          "input": "s = \"anagram\", t = \"nagaram\"",
          "output": "true",
          "explanation": "Both have same letter counts."
        },
        {
          "input": "s = \"rat\", t = \"car\"",
          "output": "false",
          "explanation": "Different letter counts."
        }
      ],
      "constraints": [
        "1 <= s.length, t.length <= 5 * 10^4",
        "s and t consist of lowercase English letters."
      ],
      "hints": [
        "If lengths differ, return false immediately.",
        "Count character frequencies and compare.",
        "Or sort both strings and compare."
      ],
      "relatedProblems": [
        "group-anagrams",
        "find-all-anagrams-in-a-string",
        "find-resultant-array-after-removing-anagrams"
      ],
      "videoId": "9UtInBqnCgA",
      "problemStatement": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map / Sorting: Check if character counts are identical.",
      "suggestedNextQuestion": {
        "slug": "word-pattern",
        "title": "Word Pattern",
        "difficulty": "Easy",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def isAnagram(s, t):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def isAnagram_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Anagram = same letters, rearranged.",
            "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
            "\ud83d\udca1 Count S, subtract T. All zero? True."
          ],
          "code": "def isAnagram(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Anagram = same letters, rearranged.\n    - \ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).\n    - \ud83d\udca1 Count S, subtract T. All zero? True.\n\n    Algorithm:\n    1. Count S - Tally up.\n    2. Subtract T - Cancel out.\n    3. Result - Any non-zero means mismatch.\n    \"\"\"\n    if len(s) != len(t): return False  # Condition not met.\n    # return sorted(s) == sorted(t)\n    from collections import Counter\n    return Counter(s) == Counter(t)"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "happy-number": {
      "title": "Happy Number",
      "pattern": "Floyd's Cycle Finding",
      "patternEmoji": "\ud83d\ude00",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
      "intuition": [
        "\ud83c\udfaf Process: replace n with sum of squares of digits.",
        "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
        "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
      ],
      "testCases": [
        {
          "input": "n = 19",
          "output": "true"
        },
        {
          "input": "n = 2",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Simulate",
          "visual": "19 -> 1^2+9^2=82 -> 68 -> 100 -> 1.",
          "explanation": "Converged to 1."
        },
        {
          "step": 2,
          "title": "Cycle",
          "visual": "2 -> 4 -> 16... -> 4 (Loop!).",
          "explanation": "Detected visited number."
        },
        {
          "step": 3,
          "title": "Result",
          "visual": "If 1: True. If Cycle: False.",
          "explanation": "Decision."
        }
      ],
      "code": "def isHappy(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Process: replace n with sum of squares of digits.\n    - \ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).\n    - \ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop.\n\n    Algorithm:\n    1. Simulate - Converged to 1.\n    2. Cycle - Detected visited number.\n    3. Result - Decision.\n    \"\"\"\n    visit = set()\n    while n not in visit:\n        visit.add(n)\n        n = sum(int(d)**2 for d in str(n))\n        if n == 1: return True  # Condition satisfied.\n    return False  # Condition not met.",
      "keyInsight": "The cycle doesn't grow infinitely; digits reduce numbers drastically (999 -> 243). Loop is guaranteed small.",
      "visualizationType": "linkedlist",
      "initialState": "19",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Happy Number",
          "transientMessage": "Input: [1, 9]",
          "arrayState": [
            "1",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "1",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 2",
          "arrayState": [
            "1",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 9",
          "transientMessage": "Step 2 of 2",
          "arrayState": [
            "1",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            "1",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.",
      "examples": [
        {
          "input": "n = 19",
          "output": "true",
          "explanation": "1\u00b2 + 9\u00b2 = 82 \u2192 8\u00b2 + 2\u00b2 = 68 \u2192 ... \u2192 1"
        },
        {
          "input": "n = 2",
          "output": "false",
          "explanation": "2 \u2192 4 \u2192 16 \u2192 37 \u2192 58 \u2192 89 \u2192 145 \u2192 42 \u2192 20 \u2192 4 (cycle)"
        }
      ],
      "constraints": [
        "1 <= n <= 2^31 - 1"
      ],
      "hints": [
        "Use Floyd's cycle detection (fast and slow).",
        "Or use a hash set to detect cycles.",
        "If you see a number twice, it's not happy."
      ],
      "relatedProblems": [
        "linked-list-cycle",
        "add-digits",
        "ugly-number"
      ],
      "videoId": "ljz85bxOYJ0",
      "problemStatement": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nReturn true if n is a happy number, and false if not.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Floyd's Cycle Finding: Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
      "suggestedNextQuestion": {
        "slug": "is-subsequence",
        "title": "Is Subsequence",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
      "initialCode": "def isHappy(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(d)**2 for d in str(n))\n    return n == 1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Process: replace n with sum of squares of digits.",
            "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
            "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
          ],
          "code": "def isHappy(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Process: replace n with sum of squares of digits.\n    - \ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).\n    - \ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop.\n\n    Algorithm:\n    1. Simulate - Converged to 1.\n    2. Cycle - Detected visited number.\n    3. Result - Decision.\n    \"\"\"\n    visit = set()\n    while n not in visit:\n        visit.add(n)\n        n = sum(int(d)**2 for d in str(n))\n        if n == 1: return True  # Condition satisfied.\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "middle-of-the-linked-list": {
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use two pointers, one moving twice as fast as the other, to find the middle.",
      "intuition": [
        "The faster pointer will reach the end when the slower one is at the middle.",
        "Move slow and fast pointers; fast moves two steps while slow moves one."
      ],
      "visualizationType": "linkedlist",
      "initialState": [
        "A",
        "B",
        "C",
        "D",
        "E"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Middle of the Linked List",
          "transientMessage": "Input: [A, B, C, D, E]",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: A",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: B",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: C",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: D",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: E",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def middleNode(head):\n    \"\"\"\n    Intuition:\n    - The faster pointer will reach the end when the slower one is at the middle.\n    - Move slow and fast pointers; fast moves two steps while slow moves one.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n    return slow  # Return the result node.",
      "keyInsight": "The fast pointer will reach the end when the slow one is at the middle.",
      "testCases": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[3,4,5]"
        },
        {
          "input": "head = [1,2,3,4,5,6]",
          "output": "[4,5,6]"
        }
      ],
      "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[3,4,5]",
          "explanation": "The middle node is 3."
        },
        {
          "input": "head = [1,2,3,4,5,6]",
          "output": "[4,5,6]",
          "explanation": "There are two middles, return the second one."
        }
      ],
      "constraints": [
        "The number of nodes is in range [1, 100].",
        "1 <= Node.val <= 100"
      ],
      "hints": [
        "Use slow and fast pointers.",
        "Slow moves 1 step, fast moves 2 steps.",
        "When fast reaches end, slow is at middle."
      ],
      "relatedProblems": [
        "delete-the-middle-node-of-a-linked-list",
        "linked-list-cycle",
        "reorder-list"
      ],
      "videoId": "A2_ldqM4QcY",
      "problemStatement": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
      "title": "Middle of the Linked List",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use two pointers, one moving twice as fast as the other, to find the middle.",
      "suggestedNextQuestion": {
        "slug": "minimum-absolute-difference",
        "title": "Minimum Absolute Difference",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def middleNode(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def middleNode(head):\n    # Count length first\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n    \n    # Move to middle\n    curr = head\n    for _ in range(length // 2):\n        curr = curr.next\n    return curr"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "The faster pointer will reach the end when the slower one is at the middle.",
            "Move slow and fast pointers; fast moves two steps while slow moves one."
          ],
          "code": "def middleNode(head):\n    \"\"\"\n    Intuition:\n    - The faster pointer will reach the end when the slower one is at the middle.\n    - Move slow and fast pointers; fast moves two steps while slow moves one.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n    return slow  # Return the result node."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "time-needed-to-buy-tickets": {
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use two pointers to simulate buying tickets in a queue.",
      "intuition": [
        "Track the time taken for each person to buy their ticket using two pointers.",
        "Adjust pointers based on the number of tickets needed and available."
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Time Needed to Buy Tickets",
          "transientMessage": "Input: [2, 3, 2]",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 2",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 3",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 2",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def time_needed_to_buy(tickets, k):\n    \"\"\"\n    Intuition:\n    - Track the time taken for each person to buy their ticket using two pointers.\n    - Adjust pointers based on the number of tickets needed and available.\n    \"\"\"\n    time = 0\n    n = len(tickets)\n    while tickets[k] > 0:\n        for i in range(n):  # Iterate through the range.\n            if tickets[i] == 0:\n                continue\n            tickets[i] -= 1\n            time += 1\n            if tickets[k] == 0:\n                return time",
      "keyInsight": "Simulate the queue by decrementing ticket counts and incrementing time.",
      "testCases": [
        {
          "input": "tickets = [2,3,2], k = 2",
          "output": "6"
        },
        {
          "input": "tickets = [5,1,1,1], k = 0",
          "output": "8"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Time Needed to Buy Tickets",
      "description": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line to buy more tickets. Return the time taken for the person at position k to finish buying all their tickets.",
      "examples": [
        {
          "input": "tickets = [2,3,2], k = 2",
          "output": "6",
          "explanation": "Person 2 finishes after 6 seconds."
        },
        {
          "input": "tickets = [5,1,1,1], k = 0",
          "output": "8",
          "explanation": "Person 0 needs 5 tickets, takes 8 seconds total."
        }
      ],
      "constraints": [
        "n == tickets.length",
        "1 <= n <= 100",
        "1 <= tickets[i] <= 100",
        "0 <= k < n"
      ],
      "hints": [
        "For people before k: min(tickets[i], tickets[k]).",
        "For people at k: tickets[k].",
        "For people after k: min(tickets[i], tickets[k] - 1)."
      ],
      "relatedProblems": [
        "number-of-students-unable-to-eat-lunch"
      ],
      "videoId": "cVmS9N6kf2Y",
      "problemStatement": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\nYou are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\nEach person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\nReturn the time taken for the person initially at position k (0-indexed) to finish buying tickets.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use two pointers to simulate buying tickets in a queue.",
      "suggestedNextQuestion": {
        "slug": "two-sum-ii---input-array-is-sorted",
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def time_needed_to_buy(tickets, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def timeRequiredToBuy(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[k] == 0: break\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n    return time"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Track the time taken for each person to buy their ticket using two pointers.",
            "Adjust pointers based on the number of tickets needed and available."
          ],
          "code": "def time_needed_to_buy(tickets, k):\n    \"\"\"\n    Intuition:\n    - Track the time taken for each person to buy their ticket using two pointers.\n    - Adjust pointers based on the number of tickets needed and available.\n    \"\"\"\n    time = 0\n    n = len(tickets)\n    while tickets[k] > 0:\n        for i in range(n):  # Iterate through the range.\n            if tickets[i] == 0:\n                continue\n            tickets[i] -= 1\n            time += 1\n            if tickets[k] == 0:\n                return time"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "minimum-absolute-difference": {
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Sort the array and use two pointers to find the minimum absolute difference.",
      "intuition": [
        "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
        "Two pointers starting from consecutive positions can efficiently track the smallest difference."
      ],
      "visualizationType": "array",
      "initialState": [
        4,
        2,
        1,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Absolute Difference",
          "transientMessage": "Input: [4, 2, 1, 3]",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 4",
          "transientMessage": "Step 1 of 4",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 4",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 1",
          "transientMessage": "Step 3 of 4",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 3",
          "transientMessage": "Step 4 of 4",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def minimumAbsDifference(nums):\n    \"\"\"\n    Intuition:\n    - Sorting helps in easily finding the closest pairs by comparing adjacent elements.\n    - Two pointers starting from consecutive positions can efficiently track the smallest difference.\n    \"\"\"\n    nums.sort()\n    min_diff = float('inf')\n    result = []\n    for i in range(1, len(nums)):  # Iterate through the range.\n        diff = nums[i] - nums[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = [[nums[i-1], nums[i]]]\n        elif diff == min_diff:\n            result.append([nums[i-1], nums[i]])  # Add to end.\n    return result  # Return the final result.",
      "keyInsight": "Sorting the array allows us to only check adjacent elements for the minimum difference.",
      "testCases": [
        {
          "input": "arr = [4,2,1,3]",
          "output": "[[1,2],[2,3],[3,4]]"
        },
        {
          "input": "arr = [1,3,6,10,15]",
          "output": "[[1,3]]"
        },
        {
          "input": "arr = [3,8,-10,23,19,-4,-14,27]",
          "output": "[[-14,-10],[19,23],[23,27]]"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Minimum Absolute Difference",
      "description": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order (with respect to pairs), each pair [a, b] follows a < b.",
      "examples": [
        {
          "input": "arr = [4,2,1,3]",
          "output": "[[1,2],[2,3],[3,4]]",
          "explanation": "Min diff is 1, all adjacent pairs after sorting."
        },
        {
          "input": "arr = [1,3,6,10,15]",
          "output": "[[1,3]]",
          "explanation": "Min diff is 2."
        }
      ],
      "constraints": [
        "2 <= arr.length <= 10^5",
        "-10^6 <= arr[i] <= 10^6"
      ],
      "hints": [
        "Sort the array first.",
        "Minimum difference must be between adjacent elements.",
        "Find min diff, then collect all pairs with that diff."
      ],
      "relatedProblems": [
        "minimum-absolute-difference-in-bst",
        "k-diff-pairs-in-an-array"
      ],
      "videoId": "mH1aEjOEjcQ",
      "problemStatement": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Sort the array and use two pointers to find the minimum absolute difference.",
      "suggestedNextQuestion": {
        "slug": "minimum-time-visiting-all-points",
        "title": "Minimum Time Visiting All Points",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def minimumAbsDifference(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def minimumAbsDifference(arr):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        min_diff = min(min_diff, arr[i+1] - arr[i])\n    \n    res = []\n    for i in range(len(arr) - 1):\n        if arr[i+1] - arr[i] == min_diff:\n            res.append([arr[i], arr[i+1]])\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
            "Two pointers starting from consecutive positions can efficiently track the smallest difference."
          ],
          "code": "def minimumAbsDifference(nums):\n    \"\"\"\n    Intuition:\n    - Sorting helps in easily finding the closest pairs by comparing adjacent elements.\n    - Two pointers starting from consecutive positions can efficiently track the smallest difference.\n    \"\"\"\n    nums.sort()\n    min_diff = float('inf')\n    result = []\n    for i in range(1, len(nums)):  # Iterate through the range.\n        diff = nums[i] - nums[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = [[nums[i-1], nums[i]]]\n        elif diff == min_diff:\n            result.append([nums[i-1], nums[i]])  # Add to end.\n    return result  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "missing-number": {
      "pattern": "Math",
      "patternEmoji": "\u2716\ufe0f\u2795",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Calculate the expected sum and subtract the actual sum.",
      "intuition": [
        "Use the formula for the sum of the first n natural numbers.",
        "Subtract the actual sum from this expected sum to find the missing number."
      ],
      "visualizationType": "array",
      "initialState": [
        3,
        0,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [3, 0, 1], n=3",
          "transientMessage": "Sum formula: n*(n+1)/2",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Expected sum: 3*4/2 = 6",
          "transientMessage": "Sum of 0 to n",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Add 3: sum = 3",
          "transientMessage": "Running total",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Add 0: sum = 3",
          "transientMessage": "Running total",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Add 1: sum = 4",
          "transientMessage": "Running total",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Missing: 6 - 4 = 2",
          "transientMessage": "Found missing number!",
          "arrayState": [
            3,
            0,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def missingNumber(nums):\n    \"\"\"\n    Intuition:\n    - Use the formula for the sum of the first n natural numbers.\n    - Subtract the actual sum from this expected sum to find the missing number.\n    \"\"\"\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2  # Gauss formula for sum of N numbers.\n    actual_sum = sum(nums)  # Calculate sum of all elements.\n    return expected_sum - actual_sum",
      "keyInsight": "The sum of numbers from 0 to n is a known formula: n(n+1)/2.",
      "testCases": [
        {
          "input": "nums = [3,0,1]",
          "output": "2"
        },
        {
          "input": "nums = [0,1]",
          "output": "2"
        },
        {
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "output": "8"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Missing Number",
      "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "examples": [
        {
          "input": "nums = [3,0,1]",
          "output": "2",
          "explanation": "n = 3, range is [0,3], 2 is missing."
        },
        {
          "input": "nums = [0,1]",
          "output": "2",
          "explanation": "n = 2, range is [0,2], 2 is missing."
        }
      ],
      "constraints": [
        "n == nums.length",
        "1 <= n <= 10^4",
        "0 <= nums[i] <= n",
        "All numbers in nums are unique."
      ],
      "hints": [
        "Use XOR: XOR all numbers 0 to n, then XOR with array.",
        "Or use sum formula: n*(n+1)/2 - sum(nums).",
        "Both approaches are O(n) time, O(1) space."
      ],
      "relatedProblems": [
        "single-number",
        "find-the-duplicate-number",
        "first-missing-positive"
      ],
      "videoId": "WnPLSRLSANE",
      "problemStatement": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "difficulty": "Easy",
      "walkthrough": [
        "Identify mathematical pattern or formula",
        "Handle edge cases (zero, negative, overflow)",
        "Apply mathematical operations",
        "Optimize with mathematical properties",
        "Return computed result"
      ],
      "approach": "Math: Calculate the expected sum and subtract the actual sum.",
      "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
      "initialCode": "def missingNumber(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def missingNumber(nums):\n    n = len(nums)\n    # Check 0 to n\n    for i in range(n + 1):\n        if i not in nums:\n            return i"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use the formula for the sum of the first n natural numbers.",
            "Subtract the actual sum from this expected sum to find the missing number."
          ],
          "code": "def missingNumber(nums):\n    \"\"\"\n    Intuition:\n    - Use the formula for the sum of the first n natural numbers.\n    - Subtract the actual sum from this expected sum to find the missing number.\n    \"\"\"\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2  # Gauss formula for sum of N numbers.\n    actual_sum = sum(nums)  # Calculate sum of all elements.\n    return expected_sum - actual_sum"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-time-visiting-all-points": {
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use two pointers to traverse points and calculate min time.",
      "intuition": [
        "Calculate the time to move from one point to another using Manhattan distance.",
        "Traverse through all points sequentially."
      ],
      "visualizationType": "array",
      "initialState": [
        [
          1,
          1
        ],
        [
          3,
          4
        ],
        [
          -1,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Time Visiting All Points",
          "transientMessage": "Input: [1,1, 3,4, -1,0]",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1,1",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 3,4",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: -1,0",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            [
              1,
              1
            ],
            [
              3,
              4
            ],
            [
              -1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def minTimeToVisitAllPoints(points):\n    \"\"\"\n    Intuition:\n    - Calculate the time to move from one point to another using Manhattan distance.\n    - Traverse through all points sequentially.\n    \"\"\"\n    total_time = 0\n    for i in range(len(points) - 1):  # Iterate through the range.\n        current_point = points[i]\n        next_point = points[i + 1]\n        time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))  # Take the maximum value.\n        total_time += time_to_next\n    return total_time",
      "keyInsight": "Manhattan distance gives the minimum time to move between two points.",
      "testCases": [
        {
          "input": "points = [[1,1],[3,4],[-1,0]]",
          "output": "7"
        },
        {
          "input": "points = [[3,2],[-2,2]]",
          "output": "5"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Minimum Time Visiting All Points",
      "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move diagonally 1 unit in 1 second, or move horizontally or vertically 1 unit in 1 second.",
      "examples": [
        {
          "input": "points = [[1,1],[3,4],[-1,0]]",
          "output": "7",
          "explanation": "(1,1) to (3,4) = 3 steps, (3,4) to (-1,0) = 4 steps."
        },
        {
          "input": "points = [[3,2],[-2,2]]",
          "output": "5",
          "explanation": "5 horizontal steps."
        }
      ],
      "constraints": [
        "points.length == n",
        "1 <= n <= 100",
        "-1000 <= points[i][0], points[i][1] <= 1000"
      ],
      "hints": [
        "For two points, time = max(|dx|, |dy|).",
        "Chebyshev distance works here.",
        "Sum distances between consecutive points."
      ],
      "relatedProblems": [
        "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
      ],
      "videoId": "5BuKVS-Vnws",
      "problemStatement": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\nYou can move according to these rules:",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use two pointers to traverse points and calculate min time.",
      "suggestedNextQuestion": {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def minTimeToVisitAllPoints(points):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(len(points) - 1):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        time += max(abs(x2 - x1), abs(y2 - y1))\n    return time"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Calculate the time to move from one point to another using Manhattan distance.",
            "Traverse through all points sequentially."
          ],
          "code": "def minTimeToVisitAllPoints(points):\n    \"\"\"\n    Intuition:\n    - Calculate the time to move from one point to another using Manhattan distance.\n    - Traverse through all points sequentially.\n    \"\"\"\n    total_time = 0\n    for i in range(len(points) - 1):  # Iterate through the range.\n        current_point = points[i]\n        next_point = points[i + 1]\n        time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))  # Take the maximum value.\n        total_time += time_to_next\n    return total_time"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "fizz-buzz": {
      "pattern": "Iterative",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
      "intuition": [
        "Check each number for divisibility by 3 and 5.",
        "Use modulo operation to determine if a number is divisible."
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Fizz Buzz",
          "transientMessage": "Input: [1, 2, 3, 4, 5, 6, 7, 8...]",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 3",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 4",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 5",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def fizzBuzz(n):\n    \"\"\"\n    Intuition:\n    - Check each number for divisibility by 3 and 5.\n    - Use modulo operation to determine if a number is divisible.\n    \"\"\"\n    result = []\n    for i in range(1, n+1):  # Iterate through the range.\n        if i % 15 == 0:\n            result.append('FizzBuzz')  # Add to end.\n        elif i % 3 == 0:\n            result.append('Fizz')  # Add to end.\n        elif i % 5 == 0:\n            result.append('Buzz')  # Add to end.\n        else:\n            result.append(str(i))  # Add to end.\n    return result  # Return the final result.",
      "keyInsight": "Modulo operation helps in checking divisibility efficiently.",
      "testCases": [
        {
          "input": "n = 3",
          "output": "[\"1\",\"2\",\"Fizz\"]"
        },
        {
          "input": "n = 5",
          "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
        },
        {
          "input": "n = 15",
          "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Fizz Buzz",
      "description": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5, answer[i] == \"Fizz\" if i is divisible by 3, answer[i] == \"Buzz\" if i is divisible by 5, answer[i] == i (as a string) if none of the above conditions are true.",
      "examples": [
        {
          "input": "n = 3",
          "output": "[\"1\",\"2\",\"Fizz\"]",
          "explanation": "1 and 2 are neither, 3 is divisible by 3."
        },
        {
          "input": "n = 5",
          "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "explanation": "5 is divisible by 5."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4"
      ],
      "hints": [
        "Check divisibility by 15 first (3 AND 5).",
        "Then check 3, then 5, then default to number.",
        "Use string concatenation for cleaner code."
      ],
      "relatedProblems": [
        "fizz-buzz-multithreaded"
      ],
      "videoId": "AfxHGNRtFac",
      "problemStatement": "Given an integer n, return a string array answer (1-indexed) where:",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Iterative: Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def fizzBuzz(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def fizzBuzz(n):\n    res = []\n    for i in range(1, n + 1):\n        s = \"\"\n        if i % 3 == 0: s += \"Fizz\"\n        if i % 5 == 0: s += \"Buzz\"\n        if not s: s = str(i)\n        res.append(s)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Check each number for divisibility by 3 and 5.",
            "Use modulo operation to determine if a number is divisible."
          ],
          "code": "def fizzBuzz(n):\n    \"\"\"\n    Intuition:\n    - Check each number for divisibility by 3 and 5.\n    - Use modulo operation to determine if a number is divisible.\n    \"\"\"\n    result = []\n    for i in range(1, n+1):  # Iterate through the range.\n        if i % 15 == 0:\n            result.append('FizzBuzz')  # Add to end.\n        elif i % 3 == 0:\n            result.append('Fizz')  # Add to end.\n        elif i % 5 == 0:\n            result.append('Buzz')  # Add to end.\n        else:\n            result.append(str(i))  # Add to end.\n    return result  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "count-and-say": {
      "pattern": "Iterative with String Manipulation",
      "patternEmoji": "\ud83d\udd04\ud83d\udcac",
      "timeComplexity": "O(n * m)",
      "spaceComplexity": "O(m)",
      "oneliner": "Iteratively build each sequence by counting and saying the previous one.",
      "intuition": [
        "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
        "Use a loop to count consecutive digits and form the new string accordingly."
      ],
      "visualizationType": "array",
      "initialState": [
        "1"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Count and Say",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "1"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "1"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute result phase 6",
          "transientMessage": "Building solution",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def countAndSay(n):\n    \"\"\"\n    Intuition:\n    - Start with the initial '1' and iteratively generate the next sequence by describing the current one.\n    - Use a loop to count consecutive digits and form the new string accordingly.\n    \"\"\"\n    if n == 1:\n        return '1'\n    current = '1'\n    for _ in range(1, n):  # Iterate through the range.\n        next_seq = ''\n        i = 0\n        while i < len(current):\n            count = 1\n            while i + 1 < len(current) and current[i] == current[i + 1]:\n                i += 1\n                count += 1\n            next_seq += str(count) + current[i]\n            i += 1\n        current = next_seq\n    return current",
      "keyInsight": "Each number is generated by reading off the digits of the previous number.",
      "testCases": [
        {
          "input": "n = 1",
          "output": "\"1\""
        },
        {
          "input": "n = 4",
          "output": "\"1211\""
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Count and Say",
      "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\", countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1). To determine how you \"say\" a digit string, group it into runs of consecutive identical digits. Then for each group, say the number of digits, then the digit.",
      "examples": [
        {
          "input": "n = 1",
          "output": "\"1\"",
          "explanation": "Base case."
        },
        {
          "input": "n = 4",
          "output": "\"1211\"",
          "explanation": "1 -> 11 -> 21 -> 1211"
        }
      ],
      "constraints": [
        "1 <= n <= 30"
      ],
      "hints": [
        "Build iteratively from 1 to n.",
        "For each string, group consecutive digits.",
        "Build next string: count + digit for each group."
      ],
      "relatedProblems": [
        "encode-and-decode-strings",
        "string-compression"
      ],
      "videoId": "htSwmFGdFUI",
      "problemStatement": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the nth element of the count-and-say sequence.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Iterative with String Manipulation: Iteratively build each sequence by counting and saying the previous one.",
      "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
      "initialCode": "def countAndSay(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def countAndSay(n):\n    if n == 1: return \"1\"\n    prev = countAndSay(n - 1)\n    res = \"\"\n    i = 0\n    while i < len(prev):\n        count = 1\n        while i + 1 < len(prev) and prev[i] == prev[i+1]:\n            i += 1\n            count += 1\n        res += str(count) + prev[i]\n        i += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n * m)",
          "spaceComplexity": "O(m)",
          "intuition": [
            "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
            "Use a loop to count consecutive digits and form the new string accordingly."
          ],
          "code": "def countAndSay(n):\n    \"\"\"\n    Intuition:\n    - Start with the initial '1' and iteratively generate the next sequence by describing the current one.\n    - Use a loop to count consecutive digits and form the new string accordingly.\n    \"\"\"\n    if n == 1:\n        return '1'\n    current = '1'\n    for _ in range(1, n):  # Iterate through the range.\n        next_seq = ''\n        i = 0\n        while i < len(current):\n            count = 1\n            while i + 1 < len(current) and current[i] == current[i + 1]:\n                i += 1\n                count += 1\n            next_seq += str(count) + current[i]\n            i += 1\n        current = next_seq\n    return current"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "two-sum-iv---input-is-a-bst": {
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Use in-order traversal to collect elements, then apply two-pointer technique.",
      "intuition": [
        "Perform an in-order traversal of the BST to get a sorted list of numbers.",
        "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
      ],
      "visualizationType": "tree",
      "initialState": [
        2,
        7,
        11,
        15
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Two Sum IV - Input is a BST",
          "transientMessage": "Input: [2, 7, 11, 15]",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 2",
          "transientMessage": "Step 1 of 4",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 7",
          "transientMessage": "Step 2 of 4",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 11",
          "transientMessage": "Step 3 of 4",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 15",
          "transientMessage": "Step 4 of 4",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def twoSumBST(root, target):\n    \"\"\"\n    Intuition:\n    - Perform an in-order traversal of the BST to get a sorted list of numbers.\n    - Use two pointers starting from ends of this sorted list to find the pair that sums up to the target.\n    \"\"\"\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return []\n        return inorder(node.left) + [node.val] + inorder(node.right)  # Recursive inorder traversal.\n    nums = inorder(root)  # Recursive inorder traversal.\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
      "keyInsight": "The BST in-order traversal provides a sorted array, enabling the two-pointer technique.",
      "testCases": [
        {
          "input": "root = [5,3,6,2,4,null,7], k = 9",
          "output": "[2, 7]"
        },
        {
          "input": "root = [5,3,6,2,4,null,7], k = 28",
          "output": "[]"
        }
      ],
      "generated": true,
      "validationPassed": false,
      "title": "Two Sum IV - Input is a BST",
      "description": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
      "examples": [
        {
          "input": "root = [5,3,6,2,4,null,7], k = 9",
          "output": "true",
          "explanation": "5 + 4 = 9."
        },
        {
          "input": "root = [5,3,6,2,4,null,7], k = 28",
          "output": "false",
          "explanation": "No pair sums to 28."
        }
      ],
      "constraints": [
        "The number of nodes is in range [1, 10^4].",
        "-10^4 <= Node.val <= 10^4",
        "root is guaranteed to be a valid BST.",
        "-10^5 <= k <= 10^5"
      ],
      "hints": [
        "Use in-order traversal to get sorted array, then two pointers.",
        "Or use a hash set while traversing.",
        "For each node, check if k - node.val exists."
      ],
      "relatedProblems": [
        "two-sum",
        "two-sum-ii---input-array-is-sorted",
        "two-sum-iii---data-structure-design"
      ],
      "videoId": "ssL3sHwPeb4",
      "problemStatement": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use in-order traversal to collect elements, then apply two-pointer technique.",
      "suggestedNextQuestion": {
        "slug": "trapping-rain-water",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def twoSumBST(root, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def findTarget(root, k):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    \n    for i in range(len(vals)):\n        for j in range(i + 1, len(vals)):\n            if vals[i] + vals[j] == k:\n                return True\n    return False"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "Perform an in-order traversal of the BST to get a sorted list of numbers.",
            "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
          ],
          "code": "def twoSumBST(root, target):\n    \"\"\"\n    Intuition:\n    - Perform an in-order traversal of the BST to get a sorted list of numbers.\n    - Use two pointers starting from ends of this sorted list to find the pair that sums up to the target.\n    \"\"\"\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return []\n        return inorder(node.left) + [node.val] + inorder(node.right)  # Recursive inorder traversal.\n    nums = inorder(root)  # Recursive inorder traversal.\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "isomorphic-strings": {
      "title": "Isomorphic Strings",
      "pattern": "Hash Map (Bi-directional)",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
      "intuition": [
        "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
        "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
        "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
      ],
      "testCases": [
        {
          "input": "s = \"egg\", t = \"add\"",
          "output": "true"
        },
        {
          "input": "s = \"foo\", t = \"bar\"",
          "output": "false"
        },
        {
          "input": "s = \"paper\", t = \"title\"",
          "output": "true"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Iterate",
          "visual": "Pair (s[i], t[i]).",
          "explanation": "Check character mapping."
        },
        {
          "step": 2,
          "title": "Check S->T",
          "visual": "MapS[s[i]] exists? Must equal t[i].",
          "explanation": "Forward consistency."
        },
        {
          "step": 3,
          "title": "Check T->S",
          "visual": "MapT[t[i]] exists? Must equal s[i].",
          "explanation": "Backward consistency (No two chars map to same target)."
        }
      ],
      "code": "def isIsomorphic(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf 'egg' -> 'add'. e->a, g->d.\n    - \ud83e\udde0 Must be consistent (1-to-1 mapping).\n    - \ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY.\n\n    Algorithm:\n    1. Iterate - Check character mapping.\n    2. Check S->T - Forward consistency.\n    3. Check T->S - Backward consistency (No two chars map to same target).\n    \"\"\"\n    mapST, mapTS = {}, {}\n    for c1, c2 in zip(s, t):  # Iterate over elements.\n        if (c1 in mapST and mapST[c1] != c2) or \\\n           (c2 in mapTS and mapTS[c2] != c1):\n            return False  # Condition not met.\n        mapST[c1] = c2\n        mapTS[c2] = c1\n    return True  # Condition satisfied.",
      "keyInsight": "Using two maps prevents 'many-to-one' mapping errors (like 'ab' -> 'cc').",
      "visualizationType": "array",
      "initialState": [
        "e",
        "g",
        "g"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "s=\"egg\", t=\"add\"",
          "transientMessage": "Check bijective mapping",
          "arrayState": [
            "e",
            "g",
            "g"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "'e' \u2194 'a'",
          "transientMessage": "Mapping: {\"e\":\"a\"}",
          "arrayState": [
            "e",
            "g",
            "g"
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "'g' \u2194 'd'",
          "transientMessage": "Mapping: {\"e\":\"a\",\"g\":\"d\"}",
          "arrayState": [
            "e",
            "g",
            "g"
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "'g' \u2194 'd'",
          "transientMessage": "Mapping: {\"e\":\"a\",\"g\":\"d\"}",
          "arrayState": [
            "e",
            "g",
            "g"
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Result: true",
          "transientMessage": "Complete!",
          "arrayState": [
            "e",
            "g",
            "g"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
      "examples": [
        {
          "input": "s = \"egg\", t = \"add\"",
          "output": "true",
          "explanation": "e->a, g->d"
        },
        {
          "input": "s = \"foo\", t = \"bar\"",
          "output": "false",
          "explanation": "o cannot map to both a and r."
        }
      ],
      "constraints": [
        "1 <= s.length <= 5 * 10^4",
        "t.length == s.length",
        "s and t consist of any valid ascii character."
      ],
      "hints": [
        "Use two hash maps for bidirectional mapping.",
        "Map s[i] to t[i] and t[i] to s[i].",
        "If any mapping conflicts, return false."
      ],
      "relatedProblems": [
        "word-pattern",
        "word-pattern-ii"
      ],
      "videoId": "7yF-U1hLEqQ",
      "problemStatement": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map (Bi-directional): Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
      "suggestedNextQuestion": {
        "slug": "ransom-note",
        "title": "Ransom Note",
        "difficulty": "Easy",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def isIsomorphic(s, t):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def isIsomorphic_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
            "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
            "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
          ],
          "code": "def isIsomorphic(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf 'egg' -> 'add'. e->a, g->d.\n    - \ud83e\udde0 Must be consistent (1-to-1 mapping).\n    - \ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY.\n\n    Algorithm:\n    1. Iterate - Check character mapping.\n    2. Check S->T - Forward consistency.\n    3. Check T->S - Backward consistency (No two chars map to same target).\n    \"\"\"\n    mapST, mapTS = {}, {}\n    for c1, c2 in zip(s, t):  # Iterate over elements.\n        if (c1 in mapST and mapST[c1] != c2) or \\\n           (c2 in mapTS and mapTS[c2] != c1):\n            return False  # Condition not met.\n        mapST[c1] = c2\n        mapTS[c2] = c1\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "word-pattern": {
      "title": "Word Pattern",
      "pattern": "Hash Map (Bi-directional)",
      "patternEmoji": "\ud83e\udde9",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Same as Isomorphic Strings, but mapping Char -> Word.",
      "intuition": [
        "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
        "\ud83e\udde0 a -> dog, b -> cat.",
        "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
      ],
      "testCases": [
        {
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "output": "true"
        },
        {
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "output": "false"
        },
        {
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Split",
          "visual": "['dog', 'cat', 'cat', 'dog']",
          "explanation": "Get tokens."
        },
        {
          "step": 2,
          "title": "Length Check",
          "visual": "If len(pattern) != len(words): False.",
          "explanation": "Must match length."
        },
        {
          "step": 3,
          "title": "Bi-Map",
          "visual": "Map P->W and W->P. Check conflicts.",
          "explanation": "Ensure consistency."
        }
      ],
      "code": "def wordPattern(pattern, s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.\n    - \ud83e\udde0 a -> dog, b -> cat.\n    - \ud83d\udca1 Split string by space, then check 1-to-1 mapping.\n\n    Algorithm:\n    1. Split - Get tokens.\n    2. Length Check - Must match length.\n    3. Bi-Map - Ensure consistency.\n    \"\"\"\n    words = s.split()  # Split string into list.\n    if len(pattern) != len(words): return False  # Condition not met.\n    c_to_w, w_to_c = {}, {}\n    for c, w in zip(pattern, words):  # Iterate over elements.\n        if c in c_to_w and c_to_w[c] != w: return False  # Condition not met.\n        if w in w_to_c and w_to_c[w] != c: return False  # Condition not met.\n        c_to_w[c] = w\n        w_to_c[w] = c\n    return True  # Condition satisfied.",
      "keyInsight": "Don't forget to check if lengths differ first!",
      "visualizationType": "array",
      "initialState": "abba -> dog cat cat dog",
      "animationSteps": [
        {
          "step": 1,
          "visual": "pattern=\"abba\", s=\"dog cat cat dog\"",
          "transientMessage": "Split s: [dog, cat, cat, dog]",
          "arrayState": [
            "dog",
            "cat",
            "cat",
            "dog"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "a \u2192 dog",
          "transientMessage": "Map a\u2194dog",
          "arrayState": [
            "dog",
            "cat",
            "cat",
            "dog"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "b \u2192 cat",
          "transientMessage": "Map b\u2194cat",
          "arrayState": [
            "dog",
            "cat",
            "cat",
            "dog"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "b \u2192 cat (check), a \u2192 dog (check)",
          "transientMessage": "All mappings consistent!",
          "arrayState": [
            "dog",
            "cat",
            "cat",
            "dog"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Answer: true",
          "transientMessage": "Pattern matches string \u2705",
          "arrayState": [
            "dog",
            "cat",
            "cat",
            "dog"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.",
      "examples": [
        {
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "output": "true",
          "explanation": "a->dog, b->cat"
        },
        {
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "output": "false",
          "explanation": "a cannot map to both dog and fish."
        }
      ],
      "constraints": [
        "1 <= pattern.length <= 300",
        "pattern contains only lowercase letters.",
        "1 <= s.length <= 3000",
        "s contains lowercase letters and spaces."
      ],
      "hints": [
        "Split s by spaces to get words array.",
        "Use two maps: pattern[i] -> word and word -> pattern[i].",
        "Check for conflicts in both directions."
      ],
      "relatedProblems": [
        "isomorphic-strings",
        "word-pattern-ii"
      ],
      "videoId": "W_akoecmCbM",
      "problemStatement": "Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map (Bi-directional): Same as Isomorphic Strings, but mapping Char -> Word.",
      "suggestedNextQuestion": {
        "slug": "contains-duplicate",
        "title": "Contains Duplicate",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def wordPattern(pattern, s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def wordPattern_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
            "\ud83e\udde0 a -> dog, b -> cat.",
            "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
          ],
          "code": "def wordPattern(pattern, s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.\n    - \ud83e\udde0 a -> dog, b -> cat.\n    - \ud83d\udca1 Split string by space, then check 1-to-1 mapping.\n\n    Algorithm:\n    1. Split - Get tokens.\n    2. Length Check - Must match length.\n    3. Bi-Map - Ensure consistency.\n    \"\"\"\n    words = s.split()  # Split string into list.\n    if len(pattern) != len(words): return False  # Condition not met.\n    c_to_w, w_to_c = {}, {}\n    for c, w in zip(pattern, words):  # Iterate over elements.\n        if c in c_to_w and c_to_w[c] != w: return False  # Condition not met.\n        if w in w_to_c and w_to_c[w] != c: return False  # Condition not met.\n        c_to_w[c] = w\n        w_to_c[w] = c\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "group-anagrams": {
      "title": "Group Anagrams",
      "pattern": "Hash Map",
      "patternEmoji": "\ud83d\udcc2",
      "timeComplexity": "O(NK)",
      "spaceComplexity": "O(NK)",
      "oneliner": "Map sorted string (or char-count tuple) to list of strings.",
      "intuition": [
        "\ud83c\udfaf All anagrams have the same 'signature'.",
        "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
        "\ud83d\udca1 Store {signature: [list of words]}."
      ],
      "testCases": [
        {
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
        },
        {
          "input": "strs = [\"\"]",
          "output": "[[\"\"]]"
        },
        {
          "input": "strs = [\"a\"]",
          "output": "[[\"a\"]]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Hash Key",
          "visual": "\"eat\" -> (1,0,0...1...1) OR \"aet\"",
          "explanation": "Generate canonical key."
        },
        {
          "step": 2,
          "title": "Bucket",
          "visual": "Map[key].append(word).",
          "explanation": "Group them."
        },
        {
          "step": 3,
          "title": "Collect",
          "visual": "Return Map.values()",
          "explanation": "List of lists."
        }
      ],
      "code": "def groupAnagrams(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All anagrams have the same 'signature'.\n    - \ud83e\udde0 Signature = sorted string ('eat' -> 'aet').\n    - \ud83d\udca1 Store {signature: [list of words]}.\n\n    Algorithm:\n    1. Hash Key - Generate canonical key.\n    2. Bucket - Group them.\n    3. Collect - List of lists.\n    \"\"\"\n    from collections import defaultdict\n    res = defaultdict(list)\n    for s in strs:  # Iterate over elements.\n        # Using tuple(sorted(s)) as key\n        # Or char count tuple for O(N) instead of O(N log K)\n        count = [0] * 26\n        for c in s:  # Iterate over elements.\n            count[ord(c) - ord('a')] += 1\n        res[tuple(count)].append(s)  # Add to end.\n    return list(res.values())",
      "keyInsight": "Using a count-tuple `(2, 1, 0...)` as a dictionary key is efficient and avoids sorting overhead.",
      "visualizationType": "array",
      "initialState": [
        "eat",
        "tea",
        "tan",
        "ate",
        "nat",
        "bat"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Group Anagrams",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = eat",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = tea",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = tan",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = ate",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = nat",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = bat",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "examples": [
        {
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "explanation": "Grouped by sorted characters."
        },
        {
          "input": "strs = [\"\"]",
          "output": "[[\"\"]]",
          "explanation": "Empty string is its own group."
        }
      ],
      "constraints": [
        "1 <= strs.length <= 10^4",
        "0 <= strs[i].length <= 100",
        "strs[i] consists of lowercase English letters."
      ],
      "hints": [
        "Sort each word and use as key.",
        "Or use character count tuple as key.",
        "Group words with same key together."
      ],
      "relatedProblems": [
        "valid-anagram",
        "find-all-anagrams-in-a-string",
        "group-shifted-strings"
      ],
      "videoId": "vzdNOK2oB2E",
      "problemStatement": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map: Map sorted string (or char-count tuple) to list of strings.",
      "suggestedNextQuestion": {
        "slug": "insert-delete-getrandom-o1",
        "title": "Insert Delete GetRandom O(1)",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def groupAnagrams(strs):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def groupAnagrams_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(NK)",
          "spaceComplexity": "O(NK)",
          "intuition": [
            "\ud83c\udfaf All anagrams have the same 'signature'.",
            "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
            "\ud83d\udca1 Store {signature: [list of words]}."
          ],
          "code": "def groupAnagrams(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All anagrams have the same 'signature'.\n    - \ud83e\udde0 Signature = sorted string ('eat' -> 'aet').\n    - \ud83d\udca1 Store {signature: [list of words]}.\n\n    Algorithm:\n    1. Hash Key - Generate canonical key.\n    2. Bucket - Group them.\n    3. Collect - List of lists.\n    \"\"\"\n    from collections import defaultdict\n    res = defaultdict(list)\n    for s in strs:  # Iterate over elements.\n        # Using tuple(sorted(s)) as key\n        # Or char count tuple for O(N) instead of O(N log K)\n        count = [0] * 26\n        for c in s:  # Iterate over elements.\n            count[ord(c) - ord('a')] += 1\n        res[tuple(count)].append(s)  # Add to end.\n    return list(res.values())"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "contains-duplicate-ii": {
      "title": "Contains Duplicate II",
      "pattern": "Sliding Window / Hash Map",
      "patternEmoji": "\u26a0\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(k)",
      "oneliner": "Maintain a window of size k using a set; duplicate in window triggers True.",
      "intuition": [
        "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
        "\ud83e\udde0 Keep latest k elements in a set.",
        "\ud83d\udca1 If current num is in set -> found it!"
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,1], k = 3",
          "output": "true"
        },
        {
          "input": "nums = [1,0,1,1], k = 1",
          "output": "true"
        },
        {
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Expand",
          "visual": "Add nums[i] to window set.",
          "explanation": "Track recent."
        },
        {
          "step": 2,
          "title": "Shrink",
          "visual": "If window size > k, remove nums[i-k].",
          "explanation": "Maintain invariant."
        },
        {
          "step": 3,
          "title": "Check",
          "visual": "nums[i] already in set? True.",
          "explanation": "Collision detected."
        }
      ],
      "code": "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).\n    - \ud83e\udde0 Keep latest k elements in a set.\n    - \ud83d\udca1 If current num is in set -> found it!\n\n    Algorithm:\n    1. Expand - Track recent.\n    2. Shrink - Maintain invariant.\n    3. Check - Collision detected.\n    \"\"\"\n    window = set()\n    l = 0\n    for r in range(len(nums)):  # Iterate through the range.\n        if r - l > k:\n            window.remove(nums[l])\n            l += 1\n        if nums[r] in window:\n            return True  # Condition satisfied.\n        window.add(nums[r])\n    return False  # Condition not met.",
      "keyInsight": "Removing the element falling out of the window makes lookups O(1).",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "nums = [1,2,3,1], k = 3",
          "transientMessage": "Sliding window of size k. Track indices in hashmap.",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "i=0: num=1",
          "transientMessage": "1 not seen. map[1]=0",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "i=1: num=2",
          "transientMessage": "2 not seen. map[2]=1",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "i=2: num=3",
          "transientMessage": "3 not seen. map[3]=2",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "i=3: num=1 seen before!",
          "transientMessage": "1 at index 0. |3-0|=3 \u2264 k=3 \u2192 TRUE! \ud83c\udfaf",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            0,
            3
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Answer: true",
          "transientMessage": "Duplicate found within distance k \u2705",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            3
          ],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
      "examples": [
        {
          "input": "nums = [1,2,3,1], k = 3",
          "output": "true",
          "explanation": "nums[0] == nums[3] and 3-0 = 3 <= 3."
        },
        {
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "output": "false",
          "explanation": "Duplicate 1s are 3 apart, not <= 2."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^9 <= nums[i] <= 10^9",
        "0 <= k <= 10^5"
      ],
      "hints": [
        "Use sliding window with hash set of size k.",
        "Or use hash map storing last seen index.",
        "Check if current index - last index <= k."
      ],
      "relatedProblems": [
        "contains-duplicate",
        "contains-duplicate-iii"
      ],
      "videoId": "ypn0aZ0nrL4",
      "problemStatement": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Sliding Window / Hash Map: Maintain a window of size k using a set; duplicate in window triggers True.",
      "suggestedNextQuestion": {
        "slug": "longest-repeating-character-replacement",
        "title": "Longest Repeating Character Replacement",
        "difficulty": "Medium",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def containsNearbyDuplicate(nums, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def containsNearbyDuplicate_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
            "\ud83e\udde0 Keep latest k elements in a set.",
            "\ud83d\udca1 If current num is in set -> found it!"
          ],
          "code": "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).\n    - \ud83e\udde0 Keep latest k elements in a set.\n    - \ud83d\udca1 If current num is in set -> found it!\n\n    Algorithm:\n    1. Expand - Track recent.\n    2. Shrink - Maintain invariant.\n    3. Check - Collision detected.\n    \"\"\"\n    window = set()\n    l = 0\n    for r in range(len(nums)):  # Iterate through the range.\n        if r - l > k:\n            window.remove(nums[l])\n            l += 1\n        if nums[r] in window:\n            return True  # Condition satisfied.\n        window.add(nums[r])\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "longest-consecutive-sequence": {
      "title": "Longest Consecutive Sequence",
      "pattern": "Hash Set",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
      "intuition": [
        "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
        "\ud83e\udde0 Hash Set gives O(1) lookup.",
        "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
      ],
      "testCases": [
        {
          "input": "nums = [100,4,200,1,3,2]",
          "output": "4"
        },
        {
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "output": "9"
        },
        {
          "input": "nums = [1,0,1,2]",
          "output": "3"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Setify",
          "visual": "{100, 4, 200, 1, 3, 2}",
          "explanation": "Remove dupes, fast access."
        },
        {
          "step": 2,
          "title": "Check Start",
          "visual": "Is 100-1 in set? No. Start chain. 100... len 1.\nIs 4-1 (3) in set? Yes. Skip.",
          "explanation": "Ensure single traversal."
        },
        {
          "step": 3,
          "title": "Expand",
          "visual": "At 1: 1 in, 2 in, 3 in, 4 in. Stop. Len 4.",
          "explanation": "Count sequence."
        }
      ],
      "code": "def longestConsecutive(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.\n    - \ud83e\udde0 Hash Set gives O(1) lookup.\n    - \ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2).\n\n    Algorithm:\n    1. Setify - Remove dupes, fast access.\n    2. Check Start - Ensure single traversal.\n    3. Expand - Count sequence.\n    \"\"\"\n    numSet = set(nums)\n    longest = 0\n    for n in numSet:  # Iterate over elements.\n        if (n - 1) not in numSet:\n            length = 0\n            while (n + length) in numSet:\n                length += 1\n            longest = max(length, longest)  # Take the maximum value.\n    return longest",
      "keyInsight": "Checking `if (n-1) not in set` ensures each sequence is only processed ONCE, making it linear.",
      "visualizationType": "array",
      "initialState": [
        100,
        4,
        200,
        1,
        3,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Consecutive Sequence",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            100,
            4,
            200,
            1,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 100",
          "arrayState": [
            100,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            100,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 4",
          "arrayState": [
            100,
            4,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            100,
            4,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 200",
          "arrayState": [
            100,
            4,
            200,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            100,
            4,
            200,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 1",
          "arrayState": [
            100,
            4,
            200,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            100,
            4,
            200,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 3",
          "arrayState": [
            100,
            4,
            200,
            1,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            100,
            4,
            200,
            1,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            100,
            4,
            200,
            1,
            3,
            0
          ],
          "pointers": [],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            100,
            4,
            200,
            1,
            3,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
      "examples": [
        {
          "input": "nums = [100,4,200,1,3,2]",
          "output": "4",
          "explanation": "Longest consecutive is [1,2,3,4]."
        },
        {
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "output": "9",
          "explanation": "0 to 8 is 9 consecutive."
        }
      ],
      "constraints": [
        "0 <= nums.length <= 10^5",
        "-10^9 <= nums[i] <= 10^9"
      ],
      "hints": [
        "Put all numbers in a set.",
        "For each number, check if it's the start of a sequence (n-1 not in set).",
        "If so, count consecutive numbers."
      ],
      "relatedProblems": [
        "binary-tree-longest-consecutive-sequence",
        "find-three-consecutive-integers-that-sum-to-a-given-number"
      ],
      "videoId": "P6RZZMu_maU",
      "problemStatement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Set: Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
      "suggestedNextQuestion": {
        "slug": "range-sum-query---immutable",
        "title": "Range Sum Query - Immutable",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def longestConsecutive(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def longestConsecutive(nums):\n    if not nums: return 0\n    nums.sort()\n    longest = 1\n    current = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            if nums[i] == nums[i-1] + 1:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = 1\n    return max(longest, current)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
            "\ud83e\udde0 Hash Set gives O(1) lookup.",
            "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
          ],
          "code": "def longestConsecutive(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.\n    - \ud83e\udde0 Hash Set gives O(1) lookup.\n    - \ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2).\n\n    Algorithm:\n    1. Setify - Remove dupes, fast access.\n    2. Check Start - Ensure single traversal.\n    3. Expand - Count sequence.\n    \"\"\"\n    numSet = set(nums)\n    longest = 0\n    for n in numSet:  # Iterate over elements.\n        if (n - 1) not in numSet:\n            length = 0\n            while (n + length) in numSet:\n                length += 1\n            longest = max(length, longest)  # Take the maximum value.\n    return longest"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "insert-delete-getrandom-o1": {
      "title": "Insert Delete GetRandom O(1)",
      "pattern": "Hash Map + Dynamic Array",
      "patternEmoji": "\ud83c\udfb2",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(n)",
      "oneliner": "Map stores {val: index}. To delete, swap val with last element, then pop.",
      "intuition": [
        "\ud83c\udfaf List allows O(1) random access (choice).",
        "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
        "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
      ],
      "testCases": [
        {
          "input": "ops = [\"RandomizedSet\",\"insert\",\"remove\",\"getRandom\"]; args = [[],[1],[2],[]]",
          "output": "[null,true,false,1]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Insert",
          "visual": "Append to list. Map[val] = len-1.",
          "explanation": "Easy O(1)."
        },
        {
          "step": 2,
          "title": "Delete",
          "visual": "Val at index `i`. Swap list[i] with list[end]. Update map for swapped item. Pop list.",
          "explanation": "O(1) removal."
        },
        {
          "step": 3,
          "title": "Random",
          "visual": "random.choice(list)",
          "explanation": "Uniform distribution."
        }
      ],
      "code": "import random\nclass RandomizedSet:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf List allows O(1) random access (choice).\n    - \ud83e\udde0 Hashmap allows O(1) lookup/delete logic.\n    - \ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!\n\n    Algorithm:\n    1. Insert - Easy O(1).\n    2. Delete - O(1) removal.\n    3. Random - Uniform distribution.\n    \"\"\"\n        self.valMap = {}\n        self.valList = []\n    def insert(self, val):\n        if val in self.valMap: return False  # Condition not met.\n        self.valMap[val] = len(self.valList)\n        self.valList.append(val)  # Add to end.\n        return True  # Condition satisfied.\n    def remove(self, val):\n        if val not in self.valMap: return False  # Condition not met.\n        idx = self.valMap[val]\n        lastVal = self.valList[-1]\n        self.valList[idx] = lastVal\n        self.valMap[lastVal] = idx\n        self.valList.pop()  # Remove and return last element.\n        del self.valMap[val]\n        return True  # Condition satisfied.\n    def getRandom(self):\n        return random.choice(self.valList)",
      "keyInsight": "The 'Swap and Pop' technique is crucial for O(1) deletions in arrays.",
      "visualizationType": "array",
      "initialState": [
        "RandomizedSet",
        "insert",
        "remove",
        "getRandom"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Insert Delete GetRandom O(1)",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = RandomizedSet",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = insert",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = remove",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = getRandom",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "RandomizedSet",
            "insert",
            "remove",
            "getRandom"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Implement the RandomizedSet class: RandomizedSet() Initializes the object. bool insert(int val) Inserts an item val if not present. Returns true if not present, false otherwise. bool remove(int val) Removes an item val if present. Returns true if present, false otherwise. int getRandom() Returns a random element from the current set. Each element must have the same probability of being returned.",
      "examples": [
        {
          "input": "[[\"RandomizedSet\"],[\"insert\"],[\"remove\"],[\"insert\"],[\"getRandom\"],[\"remove\"],[\"insert\"],[\"getRandom\"]], [[],[1],[2],[2],[],[1],[2],[]]",
          "output": "[null,true,false,true,2,true,false,2]",
          "explanation": "Operations performed in sequence."
        }
      ],
      "constraints": [
        "-2^31 <= val <= 2^31 - 1",
        "At most 2 * 10^5 calls will be made to insert, remove, and getRandom.",
        "There will be at least one element in the data structure when getRandom is called."
      ],
      "hints": [
        "Use array + hash map.",
        "Hash map stores val -> index.",
        "On remove, swap with last element for O(1)."
      ],
      "relatedProblems": [
        "insert-delete-getrandom-o1-duplicates-allowed"
      ],
      "videoId": "j4KwhBziOpg",
      "problemStatement": "Implement the RandomizedSet class:\nYou must implement the functions of the class such that each function works in average O(1) time complexity.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map + Dynamic Array: Map stores {val: index}. To delete, swap val with last element, then pop.",
      "suggestedNextQuestion": {
        "slug": "longest-consecutive-sequence",
        "title": "Longest Consecutive Sequence",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf List allows O(1) random access (choice).",
            "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
            "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
          ],
          "code": "import random\nclass RandomizedSet:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf List allows O(1) random access (choice).\n    - \ud83e\udde0 Hashmap allows O(1) lookup/delete logic.\n    - \ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!\n\n    Algorithm:\n    1. Insert - Easy O(1).\n    2. Delete - O(1) removal.\n    3. Random - Uniform distribution.\n    \"\"\"\n        self.valMap = {}\n        self.valList = []\n    def insert(self, val):\n        if val in self.valMap: return False  # Condition not met.\n        self.valMap[val] = len(self.valList)\n        self.valList.append(val)  # Add to end.\n        return True  # Condition satisfied.\n    def remove(self, val):\n        if val not in self.valMap: return False  # Condition not met.\n        idx = self.valMap[val]\n        lastVal = self.valList[-1]\n        self.valList[idx] = lastVal\n        self.valMap[lastVal] = idx\n        self.valList.pop()  # Remove and return last element.\n        del self.valMap[val]\n        return True  # Condition satisfied.\n    def getRandom(self):\n        return random.choice(self.valList)"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "how-many-numbers-are-smaller-than-the-current-number": {
      "title": "How Many Numbers Are Smaller Than the Current Number",
      "pattern": "Bucket Sort / Counting",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1) (range limited)",
      "oneliner": "Count occurrences, prefix sum to find cumulative count smaller.",
      "intuition": [
        "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
        "\ud83e\udde0 Frequency array tracks counts.",
        "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
      ],
      "testCases": [
        {
          "input": "nums = [8,1,2,2,3]",
          "output": "[4,0,1,1,3]"
        },
        {
          "input": "nums = [6,5,4,8]",
          "output": "[2,1,0,3]"
        },
        {
          "input": "nums = [7,7,7,7]",
          "output": "[0,0,0,0]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Count",
          "visual": "Freq array of size 101.",
          "explanation": "Constraints say nums[i] <= 100."
        },
        {
          "step": 2,
          "title": "Prefix Sum",
          "visual": "freq[i] += freq[i-1].",
          "explanation": "Cumulative count."
        },
        {
          "step": 3,
          "title": "Map",
          "visual": "Res[i] = freq[nums[i]-1].",
          "explanation": "Get numbers strictly smaller."
        }
      ],
      "code": "def smallerNumbersThanCurrent(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.\n    - \ud83e\udde0 Frequency array tracks counts.\n    - \ud83d\udca1 Prefix sums give 'count of numbers <= i'.\n\n    Algorithm:\n    1. Count - Constraints say nums[i] <= 100.\n    2. Prefix Sum - Cumulative count.\n    3. Map - Get numbers strictly smaller.\n    \"\"\"\n    count = [0] * 102\n    for n in nums: count[n+1] += 1  # Iterate over elements.\n    for i in range(1, 102): count[i] += count[i-1]  # Iterate through the range.\n    return [count[n] for n in nums]",
      "keyInsight": "Using the input constraints (0-100) allows faster-than-sorting O(n) solution using counting sort ideas.",
      "visualizationType": "array",
      "initialState": [
        8,
        1,
        2,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: How Many Numbers Are Smaller Than the Current Number",
          "transientMessage": "Input: [8, 1, 2, 2, 3]",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 8",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 1",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 2",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 2",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 3",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            8,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].",
      "examples": [
        {
          "input": "nums = [8,1,2,2,3]",
          "output": "[4,0,1,1,3]",
          "explanation": "For 8, there are 4 smaller numbers."
        },
        {
          "input": "nums = [6,5,4,8]",
          "output": "[2,1,0,3]",
          "explanation": "Count smaller numbers for each."
        }
      ],
      "constraints": [
        "2 <= nums.length <= 500",
        "0 <= nums[i] <= 100"
      ],
      "hints": [
        "Use counting sort since values <= 100.",
        "Build prefix sum of counts.",
        "Answer for nums[i] is prefix[nums[i]]."
      ],
      "relatedProblems": [
        "count-of-smaller-numbers-after-self",
        "reverse-pairs"
      ],
      "videoId": "yajqqld8Svc",
      "problemStatement": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].\nReturn the answer in an array.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Bucket Sort / Counting: Count occurrences, prefix sum to find cumulative count smaller.",
      "mentalModel": "Like tallying votes. Frequency matters more than order.",
      "initialCode": "def smallerNumbersThanCurrent(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def smallerNumbersThanCurrent(nums):\n    res = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if j != i and nums[j] < nums[i]:\n                count += 1\n        res.append(count)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1) (range limited)",
          "intuition": [
            "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
            "\ud83e\udde0 Frequency array tracks counts.",
            "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
          ],
          "code": "def smallerNumbersThanCurrent(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.\n    - \ud83e\udde0 Frequency array tracks counts.\n    - \ud83d\udca1 Prefix sums give 'count of numbers <= i'.\n\n    Algorithm:\n    1. Count - Constraints say nums[i] <= 100.\n    2. Prefix Sum - Cumulative count.\n    3. Map - Get numbers strictly smaller.\n    \"\"\"\n    count = [0] * 102\n    for n in nums: count[n+1] += 1  # Iterate over elements.\n    for i in range(1, 102): count[i] += count[i-1]  # Iterate through the range.\n    return [count[n] for n in nums]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "simplify-path": {
      "title": "Simplify Path",
      "pattern": "Stack",
      "patternEmoji": "\ud83d\udcc2",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
      "intuition": [
        "\ud83c\udfaf Canonical path logic.",
        "\ud83e\udde0 '..' means go up (pop).",
        "\ud83d\udca1 '.' or empty means stay (ignore)."
      ],
      "testCases": [
        {
          "input": "path = \"/home/\"",
          "output": "\"/home\""
        },
        {
          "input": "path = \"/home//foo/\"",
          "output": "\"/home/foo\""
        },
        {
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "output": "\"/home/user/Pictures\""
        },
        {
          "input": "path = \"/../\"",
          "output": "\"/\""
        },
        {
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "output": "\"/.../b/d\""
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Split",
          "visual": "['a', '.', 'b', '..', '..', 'c']",
          "explanation": "Tokenize."
        },
        {
          "step": 2,
          "title": "Process",
          "visual": "'a': push. '.': skip. 'b': push. '..': pop(b). '..': pop(a). 'c': push.",
          "explanation": "Stack operations."
        },
        {
          "step": 3,
          "title": "Join",
          "visual": "'/' + join(stack)",
          "explanation": "Rebuild."
        }
      ],
      "code": "def simplifyPath(path):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Canonical path logic.\n    - \ud83e\udde0 '..' means go up (pop).\n    - \ud83d\udca1 '.' or empty means stay (ignore).\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Process - Stack operations.\n    3. Join - Rebuild.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for portion in path.split('/'):  # Iterate over elements.\n        if portion == '..':\n            if stack: stack.pop()  # Remove and return last element.\n        elif portion == '.' or not portion:\n            continue\n        else:\n            stack.append(portion)  # Add to end.\n    return '/' + '/'.join(stack)",
      "keyInsight": "Splitting by slash handles multiple slashes `//` automatically (producing empty strings to ignore).",
      "visualizationType": "array",
      "initialState": "/a/./b/../../c/",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Simplify Path",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            "/",
            "b",
            "/",
            ".",
            ".",
            "/",
            ".",
            ".",
            "/",
            "c",
            "/"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = /",
          "arrayState": [
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = a",
          "arrayState": [
            "/",
            "a",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            "/",
            "a",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = /",
          "arrayState": [
            "/",
            "a",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            "/",
            "a",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = .",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = /",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            14
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            "/",
            "a",
            "/",
            ".",
            "/",
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.",
      "examples": [
        {
          "input": "path = \"/home/\"",
          "output": "\"/home\"",
          "explanation": "Remove trailing slash."
        },
        {
          "input": "path = \"/../\"",
          "output": "\"/\"",
          "explanation": "Cannot go above root."
        },
        {
          "input": "path = \"/home//foo/\"",
          "output": "\"/home/foo\"",
          "explanation": "Multiple slashes treated as one."
        }
      ],
      "constraints": [
        "1 <= path.length <= 3000",
        "path consists of English letters, digits, period '.', slash '/' or '_'."
      ],
      "hints": [
        "Split by '/' and use a stack.",
        "Ignore empty strings and '.'. Pop for '..'.",
        "Join stack with '/' at the end."
      ],
      "relatedProblems": [
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "qYlHrAKJfyA",
      "problemStatement": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\nThe rules of a Unix-style file system are as follows:\nThe simplified canonical path should follow these rules:\nReturn the simplified canonical path.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize empty stack",
        "Iterate through elements",
        "Push/pop based on problem logic",
        "Maintain monotonic property if needed",
        "Process remaining stack elements if needed"
      ],
      "approach": "Stack: Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def simplifyPath(path):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def simplifyPath_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Canonical path logic.",
            "\ud83e\udde0 '..' means go up (pop).",
            "\ud83d\udca1 '.' or empty means stay (ignore)."
          ],
          "code": "def simplifyPath(path):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Canonical path logic.\n    - \ud83e\udde0 '..' means go up (pop).\n    - \ud83d\udca1 '.' or empty means stay (ignore).\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Process - Stack operations.\n    3. Join - Rebuild.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for portion in path.split('/'):  # Iterate over elements.\n        if portion == '..':\n            if stack: stack.pop()  # Remove and return last element.\n        elif portion == '.' or not portion:\n            continue\n        else:\n            stack.append(portion)  # Add to end.\n    return '/' + '/'.join(stack)"
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "min-stack": {
      "title": "Min Stack",
      "pattern": "Stack (Two Stacks)",
      "patternEmoji": "\u2b07\ufe0f",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(n)",
      "oneliner": "Maintain a second stack tracking the minimum value at each depth.",
      "intuition": [
        "\ud83c\udfaf Get Min in O(1).",
        "\ud83e\udde0 Normal stack holds values.",
        "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
      ],
      "testCases": [
        {
          "input": "ops = [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]; args = [[],[-2],[0],[-3],[],[],[],[]]",
          "output": "[null,null,null,null,-3,null,0,-2]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Push",
          "visual": "Main: [-2]. MinStack: [-2].",
          "explanation": "Init."
        },
        {
          "step": 2,
          "title": "Push Smaller",
          "visual": "Main: [-2, -3]. MinStack: [-2, -3].",
          "explanation": "New min found."
        },
        {
          "step": 3,
          "title": "Pop",
          "visual": "Pop both. Min reverts to -2.",
          "explanation": "Sync."
        }
      ],
      "code": "class MinStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Get Min in O(1).\n    - \ud83e\udde0 Normal stack holds values.\n    - \ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both.\n\n    Algorithm:\n    1. Push - Init.\n    2. Push Smaller - New min found.\n    3. Pop - Sync.\n    \"\"\"\n        self.stack = []  # Initialize stack for tracking.\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)  # Add to end.\n        val = min(val, self.minStack[-1] if self.minStack else val)  # Take the minimum value.\n        self.minStack.append(val)  # Add to end.\n    def pop(self):  # Remove and return last element.\n        self.stack.pop()  # Remove and return last element.\n        self.minStack.pop()  # Remove and return last element.\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.minStack[-1]",
      "keyInsight": "The minimum history needs to be stacked because when we pop the minimum, we need to know what the *previous* minimum was.",
      "visualizationType": "array",
      "initialState": [],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Min Stack",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
      "examples": [
        {
          "input": "[[\"MinStack\"],[\"push\"],[\"push\"],[\"push\"],[\"getMin\"],[\"pop\"],[\"top\"],[\"getMin\"]], [[],[-2],[0],[-3],[],[],[],[]]",
          "output": "[null,null,null,null,-3,null,0,-2]",
          "explanation": "Min tracking works correctly."
        }
      ],
      "constraints": [
        "-2^31 <= val <= 2^31 - 1",
        "Methods pop, top and getMin will always be called on non-empty stacks.",
        "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
      ],
      "hints": [
        "Use two stacks: one for values, one for minimums.",
        "Or store pairs (value, current_min) in single stack.",
        "Update min on each push."
      ],
      "relatedProblems": [
        "max-stack",
        "implement-stack-using-queues"
      ],
      "videoId": "qkLl7nAwDPo",
      "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nYou must implement a solution with O(1) time complexity for each function.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Stack (Two Stacks): Maintain a second stack tracking the minimum value at each depth.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def __init___brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Get Min in O(1).",
            "\ud83e\udde0 Normal stack holds values.",
            "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
          ],
          "code": "class MinStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Get Min in O(1).\n    - \ud83e\udde0 Normal stack holds values.\n    - \ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both.\n\n    Algorithm:\n    1. Push - Init.\n    2. Push Smaller - New min found.\n    3. Pop - Sync.\n    \"\"\"\n        self.stack = []  # Initialize stack for tracking.\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)  # Add to end.\n        val = min(val, self.minStack[-1] if self.minStack else val)  # Take the minimum value.\n        self.minStack.append(val)  # Add to end.\n    def pop(self):  # Remove and return last element.\n        self.stack.pop()  # Remove and return last element.\n        self.minStack.pop()  # Remove and return last element.\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.minStack[-1]"
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "evaluate-reverse-polish-notation": {
      "title": "Evaluate Reverse Polish Notation",
      "pattern": "Stack",
      "patternEmoji": "\u2797\u2796",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Push numbers. Operator? Pop two, apply, push result.",
      "intuition": [
        "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
        "\ud83e\udde0 Stack holds operands waiting for an operator.",
        "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
      ],
      "testCases": [
        {
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "output": "9"
        },
        {
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "output": "6"
        },
        {
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "output": "22"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Push",
          "visual": "Stack: [2, 1]",
          "explanation": "Operands."
        },
        {
          "step": 2,
          "title": "Op +",
          "visual": "Pop 1, 2. Add -> 3. Stack: [3].",
          "explanation": "Execute."
        },
        {
          "step": 3,
          "title": "Continue",
          "visual": "Push 3. Op *. 3 * 3 = 9.",
          "explanation": "Chain."
        }
      ],
      "code": "def evalRPN(tokens):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.\n    - \ud83e\udde0 Stack holds operands waiting for an operator.\n    - \ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7.\n\n    Algorithm:\n    1. Push - Operands.\n    2. Op + - Execute.\n    3. Continue - Chain.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for t in tokens:  # Iterate over elements.\n        if t not in \"+-*/\":\n            stack.append(int(t))  # Add to end.\n        else:\n            b, a = stack.pop(), stack.pop()  # Remove and return last element.\n            if t == \"+\": stack.append(a + b)  # Add to end.\n            elif t == \"-\": stack.append(a - b)  # Add to end.\n            elif t == \"*\": stack.append(a * b)  # Add to end.\n            else: stack.append(int(a / b))  # Add to end.\n    return stack[0]",
      "keyInsight": "Careful with division: 'int(a / b)' truncates toward zero in Python, unlike '//' which floors.",
      "visualizationType": "array",
      "initialState": [
        "2",
        "1",
        "+",
        "3",
        "*"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Evaluate Reverse Polish Notation",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = +",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 3",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = *",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "2",
            "1",
            "+",
            "3",
            "*"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
      "examples": [
        {
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "output": "9",
          "explanation": "((2 + 1) * 3) = 9"
        },
        {
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "output": "6",
          "explanation": "(4 + (13 / 5)) = 6"
        }
      ],
      "constraints": [
        "1 <= tokens.length <= 10^4",
        "tokens[i] is an operator or an integer in range [-200, 200]."
      ],
      "hints": [
        "Use a stack.",
        "Push operands. On operator, pop two operands, compute, push result.",
        "Note: division truncates toward zero."
      ],
      "relatedProblems": [
        "basic-calculator",
        "basic-calculator-ii",
        "expression-add-operators"
      ],
      "videoId": "iu0082c4HDE",
      "problemStatement": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize empty stack",
        "Iterate through elements",
        "Push/pop based on problem logic",
        "Maintain monotonic property if needed",
        "Process remaining stack elements if needed"
      ],
      "approach": "Stack: Push numbers. Operator? Pop two, apply, push result.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def evalRPN(tokens):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def evalRPN_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
            "\ud83e\udde0 Stack holds operands waiting for an operator.",
            "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
          ],
          "code": "def evalRPN(tokens):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.\n    - \ud83e\udde0 Stack holds operands waiting for an operator.\n    - \ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7.\n\n    Algorithm:\n    1. Push - Operands.\n    2. Op + - Execute.\n    3. Continue - Chain.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for t in tokens:  # Iterate over elements.\n        if t not in \"+-*/\":\n            stack.append(int(t))  # Add to end.\n        else:\n            b, a = stack.pop(), stack.pop()  # Remove and return last element.\n            if t == \"+\": stack.append(a + b)  # Add to end.\n            elif t == \"-\": stack.append(a - b)  # Add to end.\n            elif t == \"*\": stack.append(a * b)  # Add to end.\n            else: stack.append(int(a / b))  # Add to end.\n    return stack[0]"
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "basic-calculator": {
      "title": "Basic Calculator",
      "pattern": "Stack (Signs)",
      "patternEmoji": "\ud83d\udc22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Track result and sign. Parenthesis? Push current result & sign, reset.",
      "intuition": [
        "\ud83c\udfaf Linear scan with recursion simulated by stack.",
        "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
        "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
      ],
      "testCases": [
        {
          "input": "s = \"1 + 1\"",
          "output": "2"
        },
        {
          "input": "s = \" 2-1 + 2 \"",
          "output": "3"
        },
        {
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "output": "23"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Scan",
          "visual": "Update 'res' with num*sign.",
          "explanation": "Accumulate."
        },
        {
          "step": 2,
          "title": "Open (",
          "visual": "Push res, sign. Res=0, Sign=1.",
          "explanation": "Context switch."
        },
        {
          "step": 3,
          "title": "Close )",
          "visual": "Res = Res * pop_sign + pop_res.",
          "explanation": "Resolve scope."
        }
      ],
      "code": "def calculate(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Linear scan with recursion simulated by stack.\n    - \ud83e\udde0 '(': Stash current state. Start fresh sub-problem.\n    - \ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result.\n\n    Algorithm:\n    1. Scan - Accumulate.\n    2. Open ( - Context switch.\n    3. Close ) - Resolve scope.\n    \"\"\"\n    res, num, sign, stack = 0, 0, 1, []\n    for c in s:  # Iterate over elements.\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c in '+-':\n            res += sign * num\n            num = 0\n            sign = 1 if c == '+' else -1\n        elif c == '(': \n            stack.append(res)  # Add to end.\n            stack.append(sign)  # Add to end.\n            sign = 1\n            res = 0  # Initialize result variable.\n        elif c == ')':\n            res += sign * num\n            res *= stack.pop()  # Remove and return last element.\n            res += stack.pop()  # Remove and return last element.\n            num = 0\n    return res + num * sign  # Return the final result.",
      "keyInsight": "Only one 'sign' variable is needed to handle +/-, applying it lazily when a number ends.",
      "visualizationType": "array",
      "initialState": "(1+(4+5+2)-3)+(6+8)",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Basic Calculator",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = (",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = +",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = (",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 4",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = +",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "(",
            "1",
            "+",
            "(",
            "4",
            "+",
            "5",
            "+",
            "2",
            ")",
            "-",
            "3",
            ")",
            "+",
            "(",
            "6",
            "+",
            "8",
            ")"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions.",
      "examples": [
        {
          "input": "s = \"1 + 1\"",
          "output": "2",
          "explanation": "1 + 1 = 2"
        },
        {
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "output": "23",
          "explanation": "Evaluate nested parentheses."
        }
      ],
      "constraints": [
        "1 <= s.length <= 3 * 10^5",
        "s consists of digits, '+', '-', '(', ')', and ' '.",
        "s represents a valid expression.",
        "'+' is not used as unary operation."
      ],
      "hints": [
        "Use stack to handle nested parentheses.",
        "Track current result and sign.",
        "On '(', push current state. On ')', pop and apply."
      ],
      "relatedProblems": [
        "basic-calculator-ii",
        "basic-calculator-iii",
        "evaluate-reverse-polish-notation"
      ],
      "videoId": "081AqOuasw0",
      "problemStatement": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Stack (Signs): Track result and sign. Parenthesis? Push current result & sign, reset.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def calculate(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def calculate_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Linear scan with recursion simulated by stack.",
            "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
            "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
          ],
          "code": "def calculate(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Linear scan with recursion simulated by stack.\n    - \ud83e\udde0 '(': Stash current state. Start fresh sub-problem.\n    - \ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result.\n\n    Algorithm:\n    1. Scan - Accumulate.\n    2. Open ( - Context switch.\n    3. Close ) - Resolve scope.\n    \"\"\"\n    res, num, sign, stack = 0, 0, 1, []\n    for c in s:  # Iterate over elements.\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c in '+-':\n            res += sign * num\n            num = 0\n            sign = 1 if c == '+' else -1\n        elif c == '(': \n            stack.append(res)  # Add to end.\n            stack.append(sign)  # Add to end.\n            sign = 1\n            res = 0  # Initialize result variable.\n        elif c == ')':\n            res += sign * num\n            res *= stack.pop()  # Remove and return last element.\n            res += stack.pop()  # Remove and return last element.\n            num = 0\n    return res + num * sign  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "implement-stack-using-queues": {
      "title": "Implement Stack using Queues",
      "pattern": "Queue Rotation",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "Push O(n), Pop O(1)",
      "spaceComplexity": "O(n)",
      "oneliner": "Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
      "intuition": [
        "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
        "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
        "\ud83d\udca1 After appending X, rotate all other N items behind X."
      ],
      "testCases": [
        {
          "input": "ops = [\"MyStack\",\"push\",\"push\",\"pop\",\"top\",\"empty\"]; args = [[],[1],[2],[],[],[]]",
          "output": "[null,null,null,2,1,false]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Push X",
          "visual": "Q appends X. Q: [1, 2, X].",
          "explanation": "Wrong order."
        },
        {
          "step": 2,
          "title": "Rotate",
          "visual": "Pop 1, Push 1. Pop 2, Push 2. Q: [X, 1, 2].",
          "explanation": "X is now front."
        },
        {
          "step": 3,
          "title": "Pop",
          "visual": "Q.popleft() returns X.",
          "explanation": "LIFO behavior achieved."
        }
      ],
      "code": "from collections import deque\nclass MyStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Queue is FIFO. Stack is LIFO.\n    - \ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.\n    - \ud83d\udca1 After appending X, rotate all other N items behind X.\n\n    Algorithm:\n    1. Push X - Wrong order.\n    2. Rotate - X is now front.\n    3. Pop - LIFO behavior achieved.\n    \"\"\"\n        self.q = deque()  # Initialize queue for BFS.\n    def push(self, x):\n        self.q.append(x)  # Add to end.\n        for _ in range(len(self.q) - 1):  # Iterate through the range.\n            self.q.append(self.q.popleft())  # Add to end.\n    def pop(self): return self.q.popleft()  # Remove and return last element.\n    def top(self): return self.q[0]\n    def empty(self): return not self.q",
      "keyInsight": "Single queue is sufficient if we rotate it!",
      "visualizationType": "array",
      "initialState": [
        "MyStack",
        "push",
        "push",
        "pop",
        "top",
        "empty"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Input: [MyStack, push, push, pop, top, empty]",
          "transientMessage": "Stack-based solution",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Push MyStack",
          "transientMessage": "Stack: [MyStack]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Push push",
          "transientMessage": "Stack: [MyStack, push]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Push push",
          "transientMessage": "Stack: [MyStack, push, push]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Push pop",
          "transientMessage": "Stack: [MyStack, push, push, pop]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Push top",
          "transientMessage": "Stack: [MyStack, push, push, pop, top]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Pop top",
          "transientMessage": "Stack: [MyStack, push, push, pop]",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Complete!",
          "transientMessage": "Result ready",
          "arrayState": [
            "MyStack",
            "push",
            "push",
            "pop",
            "top",
            "empty"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
      "examples": [
        {
          "input": "[[\"MyStack\"],[\"push\"],[\"push\"],[\"top\"],[\"pop\"],[\"empty\"]], [[],[1],[2],[],[],[]]",
          "output": "[null,null,null,2,2,false]",
          "explanation": "Stack operations using queues."
        }
      ],
      "constraints": [
        "1 <= x <= 9",
        "At most 100 calls will be made to push, pop, top, and empty.",
        "All calls to pop and top are valid."
      ],
      "hints": [
        "On push, add to queue then rotate n-1 times.",
        "This puts new element at front.",
        "Pop and top become O(1)."
      ],
      "relatedProblems": [
        "implement-queue-using-stacks",
        "min-stack"
      ],
      "videoId": "rW4vm0-DLYc",
      "problemStatement": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nNotes:",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Queue Rotation: Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
      "mentalModel": "Like a grocery line. First come, first served (FIFO).",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class MyStack:\n    def __init__(self):\n        self.q = []\n\n    def push(self, x: int) -> None:\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.pop(0))\n\n    def pop(self) -> int:\n        return self.q.pop(0)\n\n    def top(self) -> int:\n        return self.q[0]\n\n    def empty(self) -> bool:\n        return len(self.q) == 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "Push O(n), Pop O(1)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
            "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
            "\ud83d\udca1 After appending X, rotate all other N items behind X."
          ],
          "code": "from collections import deque\nclass MyStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Queue is FIFO. Stack is LIFO.\n    - \ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.\n    - \ud83d\udca1 After appending X, rotate all other N items behind X.\n\n    Algorithm:\n    1. Push X - Wrong order.\n    2. Rotate - X is now front.\n    3. Pop - LIFO behavior achieved.\n    \"\"\"\n        self.q = deque()  # Initialize queue for BFS.\n    def push(self, x):\n        self.q.append(x)  # Add to end.\n        for _ in range(len(self.q) - 1):  # Iterate through the range.\n            self.q.append(self.q.popleft())  # Add to end.\n    def pop(self): return self.q.popleft()  # Remove and return last element.\n    def top(self): return self.q[0]\n    def empty(self): return not self.q"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "add-two-numbers": {
      "title": "Add Two Numbers",
      "pattern": "Linked List Math",
      "patternEmoji": "\ud83d\udcda",
      "timeComplexity": "O(max(m, n))",
      "spaceComplexity": "O(max(m, n))",
      "oneliner": "Traverse both lists, add digits + carry, create new node.",
      "intuition": [
        "\ud83c\udfaf Just like elementary math: add right-to-left.",
        "\ud83e\udde0 Lists are already reversed (digits at head).",
        "\ud83d\udca1 Don't forget the final carry if it exists!"
      ],
      "testCases": [
        {
          "input": "l1 = [2,4,3], l2 = [5,6,4]",
          "output": "[7,0,8]"
        },
        {
          "input": "l1 = [0], l2 = [0]",
          "output": "[0]"
        },
        {
          "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
          "output": "[8,9,9,9,0,0,0,1]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "Dummy node. Carry = 0.",
          "explanation": "Base setup."
        },
        {
          "step": 2,
          "title": "Add",
          "visual": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum // 10.",
          "explanation": "Standard addition."
        },
        {
          "step": 3,
          "title": "Next",
          "visual": "Move l1, l2 pointers if not null.",
          "explanation": "Iterate."
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef addTwoNumbers(l1, l2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Just like elementary math: add right-to-left.\n    - \ud83e\udde0 Lists are already reversed (digits at head).\n    - \ud83d\udca1 Don't forget the final carry if it exists!\n\n    Algorithm:\n    1. Init - Base setup.\n    2. Add - Standard addition.\n    3. Next - Iterate.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    cur = dummy  # Initialize current pointer.\n    carry = 0\n    while l1 or l2 or carry:  # Process digits and carry.\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        val = v1 + v2 + carry\n        carry = val // 10\n        val = val % 10\n        cur.next = ListNode(val)\n        cur = cur.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "Using 'v1 = l1.val if l1 else 0' cleans up the code significantly, removing null checks inside the addition.",
      "visualizationType": "linkedlist",
      "initialState": [
        2,
        4,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Add Two Numbers",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            2,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
      "examples": [
        {
          "input": "l1 = [2,4,3], l2 = [5,6,4]",
          "output": "[7,0,8]",
          "explanation": "342 + 465 = 807"
        },
        {
          "input": "l1 = [9,9,9,9], l2 = [9,9,9]",
          "output": "[8,9,9,0,1]",
          "explanation": "9999 + 999 = 10998"
        }
      ],
      "constraints": [
        "The number of nodes in each list is in range [1, 100].",
        "0 <= Node.val <= 9",
        "The lists represent numbers without leading zeros (except 0 itself)."
      ],
      "hints": [
        "Iterate both lists simultaneously.",
        "Track carry for sums >= 10.",
        "Don't forget the final carry!"
      ],
      "relatedProblems": [
        "multiply-strings",
        "add-binary",
        "add-two-numbers-ii"
      ],
      "videoId": "wgFPrzTjm7s",
      "problemStatement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Linked List Math: Traverse both lists, add digits + carry, create new node.",
      "suggestedNextQuestion": {
        "slug": "remove-linked-list-elements",
        "title": "Remove Linked List Elements",
        "difficulty": "Medium",
        "pattern": "Linked List"
      },
      "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
      "initialCode": "def addTwoNumbers(l1, l2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Use extra array to store all values.",
            "Process in array, then rebuild list."
          ],
          "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(max(m, n))",
          "spaceComplexity": "O(max(m, n))",
          "intuition": [
            "\ud83c\udfaf Just like elementary math: add right-to-left.",
            "\ud83e\udde0 Lists are already reversed (digits at head).",
            "\ud83d\udca1 Don't forget the final carry if it exists!"
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef addTwoNumbers(l1, l2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Just like elementary math: add right-to-left.\n    - \ud83e\udde0 Lists are already reversed (digits at head).\n    - \ud83d\udca1 Don't forget the final carry if it exists!\n\n    Algorithm:\n    1. Init - Base setup.\n    2. Add - Standard addition.\n    3. Next - Iterate.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    cur = dummy  # Initialize current pointer.\n    carry = 0\n    while l1 or l2 or carry:  # Process digits and carry.\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        val = v1 + v2 + carry\n        carry = val // 10\n        val = val % 10\n        cur.next = ListNode(val)\n        cur = cur.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Losing reference to head",
        "Not handling single node case",
        "Creating cycles accidentally"
      ],
      "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification."
    },
    "merge-two-sorted-lists": {
      "title": "Merge Two Sorted Lists",
      "pattern": "Linked List / Two Pointers",
      "patternEmoji": "\ud83d\udd00",
      "timeComplexity": "O(m+n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
      "intuition": [
        "\ud83c\udfaf Zipper merge.",
        "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
        "\ud83d\udca1 Advance the chosen one."
      ],
      "testCases": [
        {
          "input": "list1 = [1,2,4], list2 = [1,3,4]",
          "output": "[1,1,2,3,4,4]"
        },
        {
          "input": "list1 = [], list2 = []",
          "output": "[]"
        },
        {
          "input": "list1 = [], list2 = [0]",
          "output": "[0]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Dummy",
          "visual": "Tail -> Dummy.",
          "explanation": "Simplifies edge cases."
        },
        {
          "step": 2,
          "title": "Stitch",
          "visual": "l1.val < l2.val? Tail.next = l1. l1 = l1.next.",
          "explanation": "Pick smallest."
        },
        {
          "step": 3,
          "title": "Cleanup",
          "visual": "Tail.next = l1 or l2 (whichever remains).",
          "explanation": "Attach rest."
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Zipper merge.\n    - \ud83e\udde0 Compare heads. Attach smaller to 'tail'.\n    - \ud83d\udca1 Advance the chosen one.\n\n    Algorithm:\n    1. Dummy - Simplifies edge cases.\n    2. Stitch - Pick smallest.\n    3. Cleanup - Attach rest.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    tail = dummy  # Initialize tail pointer.\n    while list1 and list2:\n        if list1.val < list2.val:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    if list1:\n        tail.next = list1\n    elif list2:\n        tail.next = list2\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "We don't create new nodes; we just re-link existing ones.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "list1: 1\u21922\u21924, list2: 1\u21923\u21924",
          "transientMessage": "Create dummy head, compare first elements",
          "arrayState": [
            1,
            2,
            4,
            1,
            3,
            4
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 0
            },
            {
              "label": "p2",
              "index": 3
            }
          ],
          "indices": [
            0,
            3
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "1 vs 1 \u2192 pick list1's 1",
          "transientMessage": "result: 1\u2192, move p1",
          "arrayState": [
            1,
            2,
            4,
            1,
            3,
            4
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 1
            },
            {
              "label": "p2",
              "index": 3
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "2 vs 1 \u2192 pick list2's 1",
          "transientMessage": "result: 1\u21921\u2192, move p2",
          "arrayState": [
            1,
            2,
            4,
            1,
            3,
            4
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 1
            },
            {
              "label": "p2",
              "index": 4
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "2 vs 3 \u2192 pick 2",
          "transientMessage": "result: 1\u21921\u21922\u2192, move p1",
          "arrayState": [
            1,
            2,
            4,
            1,
            3,
            4
          ],
          "pointers": [
            {
              "label": "p1",
              "index": 2
            },
            {
              "label": "p2",
              "index": 4
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Continue merging...",
          "transientMessage": "result: 1\u21921\u21922\u21923\u21924\u21924",
          "arrayState": [
            1,
            1,
            2,
            3,
            4,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5
          ],
          "color": "success"
        }
      ],
      "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
      "examples": [
        {
          "input": "list1 = [1,2,4], list2 = [1,3,4]",
          "output": "[1,1,2,3,4,4]",
          "explanation": "Merged in sorted order."
        },
        {
          "input": "list1 = [], list2 = []",
          "output": "[]",
          "explanation": "Both empty."
        },
        {
          "input": "list1 = [], list2 = [0]",
          "output": "[0]",
          "explanation": "One empty, one with element."
        }
      ],
      "constraints": [
        "The number of nodes in both lists is in range [0, 50].",
        "-100 <= Node.val <= 100",
        "Both lists are sorted in non-decreasing order."
      ],
      "hints": [
        "Use a dummy node to simplify the code.",
        "Compare heads of both lists, take the smaller one.",
        "Move the pointer forward on the list you took from."
      ],
      "relatedProblems": [
        "merge-sorted-array",
        "merge-k-sorted-lists",
        "sort-list"
      ],
      "videoId": "XIdigk956u0",
      "problemStatement": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Linked List / Two Pointers: Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
      "suggestedNextQuestion": {
        "slug": "remove-duplicates-from-sorted-array",
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def mergeTwoLists(list1, list2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def mergeTwoLists(list1, list2):\n    if not list1: return list2\n    if not list2: return list1\n    if list1.val < list2.val:\n        list1.next = mergeTwoLists(list1.next, list2)\n        return list1\n    else:\n        list2.next = mergeTwoLists(list1, list2.next)\n        return list2"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m+n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Zipper merge.",
            "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
            "\ud83d\udca1 Advance the chosen one."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Zipper merge.\n    - \ud83e\udde0 Compare heads. Attach smaller to 'tail'.\n    - \ud83d\udca1 Advance the chosen one.\n\n    Algorithm:\n    1. Dummy - Simplifies edge cases.\n    2. Stitch - Pick smallest.\n    3. Cleanup - Attach rest.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    tail = dummy  # Initialize tail pointer.\n    while list1 and list2:\n        if list1.val < list2.val:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    if list1:\n        tail.next = list1\n    elif list2:\n        tail.next = list2\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "copy-list-with-random-pointer": {
      "title": "Copy List with Random Pointer",
      "pattern": "Hash Map / Interweaving",
      "patternEmoji": "\ud83d\udcc3",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n) (or O(1) interweave)",
      "oneliner": "Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
      "intuition": [
        "\ud83c\udfaf Deep copy means new nodes.",
        "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
        "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
      ],
      "testCases": [
        {
          "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
          "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
        },
        {
          "input": "head = [[1,1],[2,1]]",
          "output": "[[1,1],[2,1]]"
        },
        {
          "input": "head = [[3,null],[3,0],[3,null]]",
          "output": "[[3,null],[3,0],[3,null]]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Map",
          "visual": "Iterate. Map[old] = Node(old.val).",
          "explanation": "Create clones."
        },
        {
          "step": 2,
          "title": "Link",
          "visual": "Iterate. copy.next = map[old.next]. copy.random = map[old.random].",
          "explanation": "Wire up."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "Return map[head].",
          "explanation": "Done."
        }
      ],
      "code": "class Node:  # Node definition with random pointer.\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means new nodes.\n    - \ud83e\udde0 Random pointers might point to nodes not visited yet.\n    - \ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues.\n\n    Algorithm:\n    1. Map - Create clones.\n    2. Link - Wire up.\n    3. Return - Done.\n    \"\"\"\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head: return None\n    oldToCopy = {None: None}  # Map old nodes to new copies.\n    cur = head\n    while cur:\n        copy = Node(cur.val)\n        oldToCopy[cur] = copy\n        cur = cur.next\n    cur = head\n    while cur:\n        copy = oldToCopy[cur]\n        copy.next = oldToCopy[cur.next]\n        copy.random = oldToCopy[cur.random]\n        cur = cur.next\n    return oldToCopy[head]",
      "keyInsight": "The hashmap approach is simplest. The O(1) space 'interweaving' approach is clever but much harder to implement correctly in an interview.",
      "visualizationType": "linkedlist",
      "initialState": [
        [
          7
        ],
        [
          13,
          0
        ],
        [
          11,
          4
        ],
        [
          10,
          2
        ],
        [
          1,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Copy List with Random Pointer",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 7",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 13,0",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 11,4",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 10,2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 1,0",
          "transientMessage": "Iteration 5",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              7
            ],
            [
              13,
              0
            ],
            [
              11,
              4
            ],
            [
              10,
              2
            ],
            [
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list.",
      "examples": [
        {
          "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
          "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
          "explanation": "Deep copy with same structure."
        }
      ],
      "constraints": [
        "0 <= n <= 1000",
        "-10^4 <= Node.val <= 10^4",
        "Node.random is null or points to a node in the list."
      ],
      "hints": [
        "Use hash map: old node -> new node.",
        "First pass: create all new nodes.",
        "Second pass: connect next and random pointers."
      ],
      "relatedProblems": [
        "clone-graph",
        "clone-binary-tree-with-random-pointer"
      ],
      "videoId": "5Y2EiZST97Y",
      "problemStatement": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nYour code will only be given the head of the original linked list.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map / Interweaving: Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
      "suggestedNextQuestion": {
        "slug": "design-twitter",
        "title": "Design Twitter",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n) (or O(1) interweave)",
          "intuition": [
            "\ud83c\udfaf Deep copy means new nodes.",
            "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
            "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
          ],
          "code": "class Node:  # Node definition with random pointer.\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means new nodes.\n    - \ud83e\udde0 Random pointers might point to nodes not visited yet.\n    - \ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues.\n\n    Algorithm:\n    1. Map - Create clones.\n    2. Link - Wire up.\n    3. Return - Done.\n    \"\"\"\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head: return None\n    oldToCopy = {None: None}  # Map old nodes to new copies.\n    cur = head\n    while cur:\n        copy = Node(cur.val)\n        oldToCopy[cur] = copy\n        cur = cur.next\n    cur = head\n    while cur:\n        copy = oldToCopy[cur]\n        copy.next = oldToCopy[cur.next]\n        copy.random = oldToCopy[cur.random]\n        cur = cur.next\n    return oldToCopy[head]"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "reverse-linked-list-ii": {
      "title": "Reverse Linked List II",
      "pattern": "Linked List Manipulation",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Reach 'left'; reverse 'right-left' times; reconnect.",
      "intuition": [
        "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
        "\ud83e\udde0 'prev' sits before reversing starts.",
        "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,4,5], left = 2, right = 4",
          "output": "[1,4,3,2,5]"
        },
        {
          "input": "head = [5], left = 1, right = 1",
          "output": "[5]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Reach",
          "visual": "Move prev to left-1.",
          "explanation": "Positioning."
        },
        {
          "step": 2,
          "title": "Reverse",
          "visual": "For i in range(r-l): temp=curr.next; curr.next=temp.next; temp.next=prev.next; prev.next=temp.",
          "explanation": "Bubble swap."
        },
        {
          "step": 3,
          "title": "Done",
          "visual": "Return dummy.next.",
          "explanation": "Head might change."
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseBetween(head, left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use a Dummy to handle edge case (left=1).\n    - \ud83e\udde0 'prev' sits before reversing starts.\n    - \ud83d\udca1 Reverse the sub-segment standard way. Fix connections.\n\n    Algorithm:\n    1. Reach - Positioning.\n    2. Reverse - Bubble swap.\n    3. Done - Head might change.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    leftPrev, cur = dummy, head  # Initialize current pointer.\n    for i in range(left - 1):  # Iterate through the range.\n        leftPrev, cur = cur, cur.next\n    prev = None\n    for i in range(right - left + 1):  # Iterate through the range.\n        tmp = cur.next\n        cur.next = prev\n        prev, cur = cur, tmp\n    # Connect\n    leftPrev.next.next = cur\n    leftPrev.next = prev\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "It's easier to fully reverse the sublist using standard Prev/Curr/Next logic, then stitch the ends `leftPrev` and `cur` back.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reverse Linked List II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5], left = 2, right = 4",
          "output": "[1,4,3,2,5]",
          "explanation": "Nodes 2-4 are reversed."
        },
        {
          "input": "head = [5], left = 1, right = 1",
          "output": "[5]",
          "explanation": "Single node, nothing to reverse."
        }
      ],
      "constraints": [
        "The number of nodes is n.",
        "1 <= n <= 500",
        "-500 <= Node.val <= 500",
        "1 <= left <= right <= n"
      ],
      "hints": [
        "Use dummy node for clean edge cases.",
        "Find the node before 'left' position.",
        "Reverse nodes from left to right using standard technique."
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "reverse-nodes-in-k-group"
      ],
      "videoId": "RF_M9tX4Eag",
      "problemStatement": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Linked List Manipulation: Reach 'left'; reverse 'right-left' times; reconnect.",
      "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
      "initialCode": "def reverseBetween(head, left, right):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Use extra array to store all values.",
            "Process in array, then rebuild list."
          ],
          "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
            "\ud83e\udde0 'prev' sits before reversing starts.",
            "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseBetween(head, left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use a Dummy to handle edge case (left=1).\n    - \ud83e\udde0 'prev' sits before reversing starts.\n    - \ud83d\udca1 Reverse the sub-segment standard way. Fix connections.\n\n    Algorithm:\n    1. Reach - Positioning.\n    2. Reverse - Bubble swap.\n    3. Done - Head might change.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    leftPrev, cur = dummy, head  # Initialize current pointer.\n    for i in range(left - 1):  # Iterate through the range.\n        leftPrev, cur = cur, cur.next\n    prev = None\n    for i in range(right - left + 1):  # Iterate through the range.\n        tmp = cur.next\n        cur.next = prev\n        prev, cur = cur, tmp\n    # Connect\n    leftPrev.next.next = cur\n    leftPrev.next = prev\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Losing reference to head",
        "Not handling single node case",
        "Creating cycles accidentally"
      ],
      "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification."
    },
    "maximum-depth-of-binary-tree": {
      "title": "Maximum Depth of Binary Tree",
      "pattern": "DFS (Recursion)",
      "patternEmoji": "\ud83d\udccf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "1 + max(dfs(left), dfs(right))",
      "intuition": [
        "\ud83c\udfaf Base case: Null node has depth 0.",
        "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
        "\ud83d\udca1 Return 1 + max(L, R)."
      ],
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "3"
        },
        {
          "input": "root = [1,null,2]",
          "output": "2"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Base",
          "visual": "If zero? Ret 0.",
          "explanation": "Leaf check."
        },
        {
          "step": 2,
          "title": "Recurse",
          "visual": "L = depth(left), R = depth(right).",
          "explanation": "Explore."
        },
        {
          "step": 3,
          "title": "Combine",
          "visual": "Ret 1 + max(L, R).",
          "explanation": "Count me."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef maxDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Base case: Null node has depth 0.\n    - \ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.\n    - \ud83d\udca1 Return 1 + max(L, R).\n\n    Algorithm:\n    1. Base - Leaf check.\n    2. Recurse - Explore.\n    3. Combine - Count me.\n    \"\"\"\n    if not root: return 0  # Base case: Check if tree is empty.\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))  # Take the maximum value.",
      "keyInsight": "Simplest recursion pattern. BFS also works for level counting.",
      "visualizationType": "tree",
      "initialState": [
        3,
        9,
        20,
        15,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "    3\n   / \\\n  9  20\n    /  \\\n   15   7",
          "transientMessage": "DFS from root, track depth",
          "arrayState": [
            3,
            9,
            20,
            15,
            7
          ],
          "pointers": [
            {
              "label": "node",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "At node 9: depth=2, no children",
          "transientMessage": "Left subtree max depth = 2",
          "arrayState": [
            3,
            9,
            20,
            15,
            7
          ],
          "pointers": [
            {
              "label": "node",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "At node 20: go deeper",
          "transientMessage": "Check children 15 and 7 at depth 3",
          "arrayState": [
            3,
            9,
            20,
            15,
            7
          ],
          "pointers": [
            {
              "label": "node",
              "index": 2
            }
          ],
          "indices": [
            2,
            5,
            6
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Right subtree max depth = 3",
          "transientMessage": "max(left=2, right=3) + 1 = 3",
          "arrayState": [
            3,
            9,
            20,
            15,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            2,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Answer: 3",
          "transientMessage": "Maximum depth is 3 \u2705",
          "arrayState": [
            3,
            9,
            20,
            15,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "3",
          "explanation": "Root -> 20 -> 15 or 7 is 3 levels."
        },
        {
          "input": "root = [1,null,2]",
          "output": "2",
          "explanation": "Root -> 2 is 2 levels."
        }
      ],
      "constraints": [
        "The number of nodes is in range [0, 10^4].",
        "-100 <= Node.val <= 100"
      ],
      "hints": [
        "Use recursion: depth = 1 + max(left, right).",
        "Or use BFS level order traversal.",
        "Count levels as you traverse."
      ],
      "relatedProblems": [
        "minimum-depth-of-binary-tree",
        "balanced-binary-tree",
        "maximum-depth-of-n-ary-tree"
      ],
      "videoId": "hTM3phVI6YQ",
      "problemStatement": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS (Recursion): 1 + max(dfs(left), dfs(right))",
      "suggestedNextQuestion": {
        "slug": "path-sum",
        "title": "Path Sum",
        "difficulty": "Easy",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def maxDepth(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Base case: Null node has depth 0.",
            "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
            "\ud83d\udca1 Return 1 + max(L, R)."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef maxDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Base case: Null node has depth 0.\n    - \ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.\n    - \ud83d\udca1 Return 1 + max(L, R).\n\n    Algorithm:\n    1. Base - Leaf check.\n    2. Recurse - Explore.\n    3. Combine - Count me.\n    \"\"\"\n    if not root: return 0  # Base case: Check if tree is empty.\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))  # Take the maximum value."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "same-tree": {
      "title": "Same Tree",
      "pattern": "DFS (Recursion)",
      "patternEmoji": "\ud83d\udc6f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
      "intuition": [
        "\ud83c\udfaf Are they structural clones with same values?",
        "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
        "\ud83d\udca1 Else, check children recursively."
      ],
      "testCases": [
        {
          "input": "p = [1,2,3], q = [1,2,3]",
          "output": "true"
        },
        {
          "input": "p = [1,2], q = [1,null,2]",
          "output": "false"
        },
        {
          "input": "p = [1,2,1], q = [1,1,2]",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Null Check",
          "visual": "Both None -> True. One None -> False.",
          "explanation": "Structure."
        },
        {
          "step": 2,
          "title": "Val Check",
          "visual": "p.val != q.val -> False.",
          "explanation": "Data."
        },
        {
          "step": 3,
          "title": "Recurse",
          "visual": "return same(L,L) and same(R,R).",
          "explanation": "Deep check."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSameTree(p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Are they structural clones with same values?\n    - \ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.\n    - \ud83d\udca1 Else, check children recursively.\n\n    Algorithm:\n    1. Null Check - Structure.\n    2. Val Check - Data.\n    3. Recurse - Deep check.\n    \"\"\"\n    if not p and not q: return True  # Condition satisfied.\n    if not p or not q or p.val != q.val: return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
      "keyInsight": "Checking 'not p and not q' handles the leaf success case naturally.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Same Tree",
          "transientMessage": "Input: [1, 2, 3]",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 3",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
      "examples": [
        {
          "input": "p = [1,2,3], q = [1,2,3]",
          "output": "true",
          "explanation": "Both trees have same structure and values."
        },
        {
          "input": "p = [1,2], q = [1,null,2]",
          "output": "false",
          "explanation": "Different structure."
        }
      ],
      "constraints": [
        "The number of nodes in both trees is in range [0, 100].",
        "-10^4 <= Node.val <= 10^4"
      ],
      "hints": [
        "If both null, return true. If one null, return false.",
        "If values differ, return false.",
        "Recursively check left and right subtrees."
      ],
      "relatedProblems": [
        "symmetric-tree",
        "subtree-of-another-tree"
      ],
      "videoId": "vRbbcKXCxOw",
      "problemStatement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS (Recursion): Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
      "suggestedNextQuestion": {
        "slug": "symmetric-tree",
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def isSameTree(p, q):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isSameTree(p, q):\n    if not p and not q: return True\n    if not p or not q or p.val != q.val: return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Are they structural clones with same values?",
            "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
            "\ud83d\udca1 Else, check children recursively."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSameTree(p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Are they structural clones with same values?\n    - \ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.\n    - \ud83d\udca1 Else, check children recursively.\n\n    Algorithm:\n    1. Null Check - Structure.\n    2. Val Check - Data.\n    3. Recurse - Deep check.\n    \"\"\"\n    if not p and not q: return True  # Condition satisfied.\n    if not p or not q or p.val != q.val: return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "symmetric-tree": {
      "title": "Symmetric Tree",
      "pattern": "DFS (Helpers)",
      "patternEmoji": "\ud83e\ude9e",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
      "intuition": [
        "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
        "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
        "\ud83d\udca1 Key is crossing the comparison."
      ],
      "testCases": [
        {
          "input": "root = [1,2,2,3,4,4,3]",
          "output": "true"
        },
        {
          "input": "root = [1,2,2,null,3,null,3]",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Helper",
          "visual": "check(L, R)",
          "explanation": "Start split."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "L.val == R.val?",
          "explanation": "Values."
        },
        {
          "step": 3,
          "title": "Recurse",
          "visual": "check(L.left, R.right) AND check(L.right, R.left).",
          "explanation": "Mirror logic."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSymmetric(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.\n    - \ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?\n    - \ud83d\udca1 Key is crossing the comparison.\n\n    Algorithm:\n    1. Helper - Start split.\n    2. Check - Values.\n    3. Recurse - Mirror logic.\n    \"\"\"\n    if not root: return True  # Base case: Check if tree is empty.\n    def dfs(left, right):\n        if not left and not right: return True  # Condition satisfied.\n        if not left or not right: return False  # Condition not met.\n        return (left.val == right.val and \n                dfs(left.left, right.right) and \n                dfs(left.right, right.left))\n    return dfs(root.left, root.right)",
      "keyInsight": "You need a helper function because the 'root' only has specific logic, while the recursive step compares TWO nodes.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        2,
        3,
        4,
        4,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Symmetric Tree",
          "transientMessage": "Input: [1, 2, 2, 3, 4, 4, 3]",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 2",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 3",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 4",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            2,
            3,
            4,
            4,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
      "examples": [
        {
          "input": "root = [1,2,2,3,4,4,3]",
          "output": "true",
          "explanation": "Left and right subtrees are mirrors."
        },
        {
          "input": "root = [1,2,2,null,3,null,3]",
          "output": "false",
          "explanation": "Not symmetric."
        }
      ],
      "constraints": [
        "The number of nodes is in range [1, 1000].",
        "-100 <= Node.val <= 100"
      ],
      "hints": [
        "Compare left subtree with right subtree.",
        "Left's left should equal Right's right.",
        "Left's right should equal Right's left."
      ],
      "relatedProblems": [
        "same-tree",
        "flip-equivalent-binary-trees"
      ],
      "videoId": "Mao9uzxwvmc",
      "problemStatement": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS (Helpers): Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
      "suggestedNextQuestion": {
        "slug": "binary-tree-level-order-traversal",
        "title": "Binary Tree Level Order Traversal",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def isSymmetric(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isSymmetric(root):\n    if not root: return True\n    def isMirror(t1, t2):\n        if not t1 and not t2: return True\n        if not t1 or not t2 or t1.val != t2.val: return False\n        return isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n    return isMirror(root.left, root.right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
            "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
            "\ud83d\udca1 Key is crossing the comparison."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSymmetric(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.\n    - \ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?\n    - \ud83d\udca1 Key is crossing the comparison.\n\n    Algorithm:\n    1. Helper - Start split.\n    2. Check - Values.\n    3. Recurse - Mirror logic.\n    \"\"\"\n    if not root: return True  # Base case: Check if tree is empty.\n    def dfs(left, right):\n        if not left and not right: return True  # Condition satisfied.\n        if not left or not right: return False  # Condition not met.\n        return (left.val == right.val and \n                dfs(left.left, right.right) and \n                dfs(left.right, right.left))\n    return dfs(root.left, root.right)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "binary-tree-level-order-traversal": {
      "title": "Binary Tree Level Order Traversal",
      "pattern": "BFS (Queue)",
      "patternEmoji": "\ud83d\udcc2",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use a deque; process current level sizet times; append children.",
      "intuition": [
        "\ud83c\udfaf Breadth-first.",
        "\ud83e\udde0 Queue valid nodes.",
        "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
      ],
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[9,20],[15,7]]"
        },
        {
          "input": "root = [1]",
          "output": "[[1]]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "Q = [root]",
          "explanation": "Start."
        },
        {
          "step": 2,
          "title": "Level Loop",
          "visual": "For _ in range(len(Q)): Pop, Add data, Push children.",
          "explanation": "Batch process."
        },
        {
          "step": 3,
          "title": "Result",
          "visual": "Append level list to results.",
          "explanation": "Structure."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef levelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Breadth-first.\n    - \ud83e\udde0 Queue valid nodes.\n    - \ud83d\udca1 Snapshot queue length 'L' to know boundary of current level.\n\n    Algorithm:\n    1. Init - Start.\n    2. Level Loop - Batch process.\n    3. Result - Structure.\n    \"\"\"\n    import collections\n    res = []  # Initialize list to store results.\n    q = collections.deque()\n    q.append(root)  # Add to end.\n    while q:\n        qLen = len(q)\n        level = []\n        for i in range(qLen):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if node:\n                level.append(node.val)  # Add to end.\n                q.append(node.left)  # Add to end.\n                q.append(node.right)  # Add to end.\n        if level:\n            res.append(level)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "Checking `if node:` inside the loop is cleaner than checking children individually before appending.",
      "visualizationType": "tree",
      "initialState": [
        3,
        9,
        20,
        15,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Binary Tree Level Order Traversal",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[9,20],[15,7]]",
          "explanation": "Level by level from top to bottom."
        },
        {
          "input": "root = [1]",
          "output": "[[1]]",
          "explanation": "Single node."
        }
      ],
      "constraints": [
        "The number of nodes is in range [0, 2000].",
        "-1000 <= Node.val <= 1000"
      ],
      "hints": [
        "Use BFS with a queue.",
        "Track level size to separate levels.",
        "Add all nodes at current level, then move to next."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal-ii",
        "binary-tree-zigzag-level-order-traversal",
        "average-of-levels-in-binary-tree"
      ],
      "videoId": "6ZnyEApgFYg",
      "problemStatement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BFS (Queue): Use a deque; process current level sizet times; append children.",
      "suggestedNextQuestion": {
        "slug": "binary-tree-right-side-view",
        "title": "Binary Tree Right Side View",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def levelOrder(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def levelOrder(root):\n    if not root: return []\n    res = []\n    q = [root]\n    while q:\n        level = []\n        next_q = []\n        for node in q:\n            level.append(node.val)\n            if node.left: next_q.append(node.left)\n            if node.right: next_q.append(node.right)\n        res.append(level)\n        q = next_q\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Breadth-first.",
            "\ud83e\udde0 Queue valid nodes.",
            "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef levelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Breadth-first.\n    - \ud83e\udde0 Queue valid nodes.\n    - \ud83d\udca1 Snapshot queue length 'L' to know boundary of current level.\n\n    Algorithm:\n    1. Init - Start.\n    2. Level Loop - Batch process.\n    3. Result - Structure.\n    \"\"\"\n    import collections\n    res = []  # Initialize list to store results.\n    q = collections.deque()\n    q.append(root)  # Add to end.\n    while q:\n        qLen = len(q)\n        level = []\n        for i in range(qLen):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if node:\n                level.append(node.val)  # Add to end.\n                q.append(node.left)  # Add to end.\n                q.append(node.right)  # Add to end.\n        if level:\n            res.append(level)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "clone-graph": {
      "title": "Clone Graph",
      "pattern": "Graph (Hashtable + DFS)",
      "patternEmoji": "\ud83d\udd78",
      "timeComplexity": "O(N + E)",
      "spaceComplexity": "O(N)",
      "oneliner": "Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
      "intuition": [
        "\ud83c\udfaf Deep copy means creating new instances for every node.",
        "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
        "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
      ],
      "testCases": [
        {
          "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
          "output": "[[2,4],[1,3],[2,4],[1,3]]"
        },
        {
          "input": "adjList = [[]]",
          "output": "[[]]"
        },
        {
          "input": "adjList = []",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Map",
          "visual": "Init map = {}. DFS(node).",
          "explanation": "Start traversal."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "If node in map? Return map[node].",
          "explanation": "Cycle handled."
        },
        {
          "step": 3,
          "title": "Copy",
          "visual": "copy = Node(node.val). map[node] = copy.",
          "explanation": "Create node."
        },
        {
          "step": 4,
          "title": "Neighbors",
          "visual": "For nei in neighbors: copy.neighbors.append(dfs(nei)).",
          "explanation": "Recurse."
        }
      ],
      "code": "# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\nclass Node:  # Node definition with random pointer.\n    def __init__(self, val = 0, neighbors = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means creating new instances for every node.\n    - \ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.\n    - \ud83d\udca1 Map acts as 'visited' set AND reference storage.\n\n    Algorithm:\n    1. Map - Start traversal.\n    2. Check - Cycle handled.\n    3. Copy - Create node.\n    4. Neighbors - Recurse.\n    \"\"\"\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node: return None\n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        \n        for nei in node.neighbors:  # Iterate over elements.\n            copy.neighbors.append(dfs(nei))  # Add to end.\n        return copy\n        \n    return dfs(node)",
      "keyInsight": "The hashmap is essential. Without it, you'd get stuck in an infinite loop due to cycles.",
      "visualizationType": "graph",
      "initialState": [
        [
          2,
          4
        ],
        [
          1,
          3
        ],
        [
          2,
          4
        ],
        [
          1,
          3
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Input: Connected Graph",
          "transientMessage": "node.val = 1, neighbors = [2,4]",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 100
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 200
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 200
              },
              {
                "id": "4",
                "label": "4",
                "x": 200,
                "y": 300
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "1",
                "to": "4"
              },
              {
                "from": "2",
                "to": "3"
              },
              {
                "from": "3",
                "to": "4"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "BFS: Start at node 1",
          "transientMessage": "Create clone, add to visited",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 200
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 200
              },
              {
                "id": "4",
                "label": "4",
                "x": 200,
                "y": 300
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "1",
                "to": "4"
              },
              {
                "from": "2",
                "to": "3"
              },
              {
                "from": "3",
                "to": "4"
              }
            ]
          },
          "pointers": [
            {
              "label": "curr",
              "node": "1"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Clone neighbors 2, 4",
          "transientMessage": "Connect clones to node 1",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 100,
                "y": 200,
                "visited": true
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 200
              },
              {
                "id": "4",
                "label": "4 \u2713",
                "x": 200,
                "y": 300,
                "visited": true
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2",
                "highlight": true
              },
              {
                "from": "1",
                "to": "4",
                "highlight": true
              },
              {
                "from": "2",
                "to": "3"
              },
              {
                "from": "3",
                "to": "4"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Clone neighbor 3",
          "transientMessage": "Complete all edges",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 100,
                "y": 200,
                "visited": true
              },
              {
                "id": "3",
                "label": "3 \u2713",
                "x": 300,
                "y": 200,
                "visited": true
              },
              {
                "id": "4",
                "label": "4 \u2713",
                "x": 200,
                "y": 300,
                "visited": true
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "1",
                "to": "4"
              },
              {
                "from": "2",
                "to": "3",
                "highlight": true
              },
              {
                "from": "3",
                "to": "4",
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "success"
        }
      ],
      "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.",
      "examples": [
        {
          "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
          "output": "[[2,4],[1,3],[2,4],[1,3]]",
          "explanation": "Deep copy of the graph."
        }
      ],
      "constraints": [
        "The number of nodes is in range [0, 100].",
        "1 <= Node.val <= 100",
        "Node.val is unique for each node.",
        "There are no repeated edges and no self-loops."
      ],
      "hints": [
        "Use hash map: old node -> cloned node.",
        "Use BFS or DFS to traverse.",
        "Clone node first, then clone neighbors."
      ],
      "relatedProblems": [
        "copy-list-with-random-pointer",
        "clone-n-ary-tree",
        "clone-binary-tree-with-random-pointer"
      ],
      "videoId": "mQeF6bN8hMk",
      "problemStatement": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nTest case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Graph (Hashtable + DFS): Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
      "graphNodes": [
        {
          "id": 1,
          "label": "1"
        },
        {
          "id": 2,
          "label": "2"
        },
        {
          "id": 3,
          "label": "3"
        },
        {
          "id": 4,
          "label": "4"
        }
      ],
      "graphEdges": [
        {
          "from": 1,
          "to": 2
        },
        {
          "from": 1,
          "to": 4
        },
        {
          "from": 2,
          "to": 3
        },
        {
          "from": 3,
          "to": 4
        }
      ],
      "suggestedNextQuestion": {
        "slug": "count-good-nodes-in-binary-tree",
        "title": "Count Good Nodes In Binary Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\n    def __init__(self, val = 0, neighbors = None):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(V * E) or O(V!)",
          "spaceComplexity": "O(V)",
          "intuition": [
            "Explore all possible paths.",
            "Use DFS/BFS without optimization."
          ],
          "code": "def __init___brute(graph, start, end):\n    # DFS all paths\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start, set())"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N + E)",
          "spaceComplexity": "O(N)",
          "intuition": [
            "\ud83c\udfaf Deep copy means creating new instances for every node.",
            "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
            "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
          ],
          "code": "# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\nclass Node:  # Node definition with random pointer.\n    def __init__(self, val = 0, neighbors = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means creating new instances for every node.\n    - \ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.\n    - \ud83d\udca1 Map acts as 'visited' set AND reference storage.\n\n    Algorithm:\n    1. Map - Start traversal.\n    2. Check - Cycle handled.\n    3. Copy - Create node.\n    4. Neighbors - Recurse.\n    \"\"\"\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node: return None\n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        \n        for nei in node.neighbors:  # Iterate over elements.\n            copy.neighbors.append(dfs(nei))  # Add to end.\n        return copy\n        \n    return dfs(node)"
        }
      ],
      "commonMistakes": [
        "Forgetting to mark nodes as visited",
        "Not handling disconnected components",
        "Wrong initialization of distance array"
      ],
      "interviewTip": "Clarify: directed/undirected, weighted/unweighted. Mention BFS for shortest path."
    },
    "course-schedule": {
      "title": "Course Schedule",
      "pattern": "Topological Sort (DFS/BFS)",
      "patternEmoji": "\ud83d\udcc3",
      "timeComplexity": "O(N + E)",
      "spaceComplexity": "O(N + E)",
      "oneliner": "Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
      "intuition": [
        "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
        "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
        "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
      ],
      "testCases": [
        {
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "output": "true"
        },
        {
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Build",
          "visual": "Adj List: {0: [1]}.",
          "explanation": "Graph rep."
        },
        {
          "step": 2,
          "title": "DFS",
          "visual": "Visit 0. State[0]=Visiting. Visit children.",
          "explanation": "Traverse."
        },
        {
          "step": 3,
          "title": "Cycle?",
          "visual": "Back edge to Visiting? Cycle! Finish: State[0]=Visited.",
          "explanation": "Detection."
        }
      ],
      "code": "def canFinish(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.\n    - \ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.\n    - \ud83d\udca1 If we meet '1' (visiting), cycle detected.\n\n    Algorithm:\n    1. Build - Graph rep.\n    2. DFS - Traverse.\n    3. Cycle? - Detection.\n    \"\"\"\n    preMap = { i: [] for i in range(numCourses) }  # Iterate through the range.\n    for crs, pre in prerequisites:  # Iterate over elements.\n        preMap[crs].append(pre)  # Add to end.\n        \n    visitSet = set() # Visiting\n    \n    def dfs(crs):\n        if crs in visitSet:\n            return False  # Condition not met.\n        if preMap[crs] == []: # No prereqs or already verified\n            return True  # Condition satisfied.\n            \n        visitSet.add(crs)\n        for pre in preMap[crs]:  # Iterate over elements.\n            if not dfs(pre): return False  # Condition not met.\n        visitSet.remove(crs)\n        preMap[crs] = [] # Optimization: marked as verified\n        return True  # Condition satisfied.\n        \n    for crs in range(numCourses):  # Iterate through the range.\n        if not dfs(crs): return False  # Condition not met.\n    return True  # Condition satisfied.",
      "keyInsight": "Clearing `preMap[crs] = []` acts as marking it 'Visited' (safe), optimizing so we don't re-check safe nodes.",
      "visualizationType": "graph",
      "initialState": {
        "numCourses": 2,
        "prerequisites": [
          [
            1,
            0
          ]
        ]
      },
      "animationSteps": [
        {
          "step": 1,
          "visual": "Build DAG",
          "transientMessage": "prereqs=[[1,0],[2,0],[3,1],[3,2]]",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0",
                "x": 200,
                "y": 50
              },
              {
                "id": "1",
                "label": "1",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Indegree = [0,1,1,2]",
          "transientMessage": "Course 0 has no prereqs",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 (in:0)",
                "x": 200,
                "y": 50,
                "highlight": true
              },
              {
                "id": "1",
                "label": "1 (in:1)",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 (in:1)",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3 (in:2)",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Take course 0",
          "transientMessage": "Decrement neighbors",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 (in:0)",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "2",
                "label": "2 (in:0)",
                "x": 300,
                "y": 150,
                "highlight": true
              },
              {
                "id": "3",
                "label": "3",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "highlight": true
              },
              {
                "from": "0",
                "to": "2",
                "highlight": true
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [
            {
              "label": "taken",
              "value": "1"
            }
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Take 1 & 2",
          "transientMessage": "Both ready (indegree=0)",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 150,
                "visited": true
              },
              {
                "id": "3",
                "label": "3 (in:0)",
                "x": 200,
                "y": 250,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [
            {
              "label": "taken",
              "value": "3"
            }
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Result: True",
          "transientMessage": "All 4 courses completed!",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3 \u2713",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [],
          "color": "success"
        }
      ],
      "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
      "examples": [
        {
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "output": "true",
          "explanation": "Take 0 first, then 1."
        },
        {
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "output": "false",
          "explanation": "Cycle exists, impossible."
        }
      ],
      "constraints": [
        "1 <= numCourses <= 2000",
        "0 <= prerequisites.length <= 5000",
        "prerequisites[i].length == 2",
        "0 <= ai, bi < numCourses"
      ],
      "hints": [
        "This is cycle detection in a directed graph.",
        "Use topological sort (Kahn's algorithm or DFS).",
        "If cycle exists, cannot complete all courses."
      ],
      "relatedProblems": [
        "course-schedule-ii",
        "course-schedule-iv",
        "minimum-height-trees"
      ],
      "videoId": "EgI5nU9etnU",
      "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn true if you can finish all courses. Otherwise, return false.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Topological Sort (DFS/BFS): Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
      "suggestedNextQuestion": {
        "slug": "course-schedule-ii",
        "title": "Course Schedule II",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def canFinish(numCourses, prerequisites):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def canFinish(numCourses, prerequisites):\n    # Build graph\n    adj = [[] for _ in range(numCourses)]\n    for dest, src in prerequisites:\n        adj[src].append(dest)\n    \n    visited = [0] * numCourses # 0=unvisited, 1=visiting, 2=visited\n    def hasCycle(node):\n        if visited[node] == 1: return True\n        if visited[node] == 2: return False\n        visited[node] = 1\n        for neighbor in adj[node]:\n            if hasCycle(neighbor): return True\n        visited[node] = 2\n        return False\n        \n    for i in range(numCourses):\n        if hasCycle(i): return False\n    return True"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N + E)",
          "spaceComplexity": "O(N + E)",
          "intuition": [
            "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
            "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
            "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
          ],
          "code": "def canFinish(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.\n    - \ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.\n    - \ud83d\udca1 If we meet '1' (visiting), cycle detected.\n\n    Algorithm:\n    1. Build - Graph rep.\n    2. DFS - Traverse.\n    3. Cycle? - Detection.\n    \"\"\"\n    preMap = { i: [] for i in range(numCourses) }  # Iterate through the range.\n    for crs, pre in prerequisites:  # Iterate over elements.\n        preMap[crs].append(pre)  # Add to end.\n        \n    visitSet = set() # Visiting\n    \n    def dfs(crs):\n        if crs in visitSet:\n            return False  # Condition not met.\n        if preMap[crs] == []: # No prereqs or already verified\n            return True  # Condition satisfied.\n            \n        visitSet.add(crs)\n        for pre in preMap[crs]:  # Iterate over elements.\n            if not dfs(pre): return False  # Condition not met.\n        visitSet.remove(crs)\n        preMap[crs] = [] # Optimization: marked as verified\n        return True  # Condition satisfied.\n        \n    for crs in range(numCourses):  # Iterate through the range.\n        if not dfs(crs): return False  # Condition not met.\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "permutations": {
      "title": "Permutations",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(N!)",
      "spaceComplexity": "O(N)",
      "oneliner": "Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
      "intuition": [
        "\ud83c\udfaf Ordering matters.",
        "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
        "\ud83d\udca1 Base case: len(path) == len(nums)."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3]",
          "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
        },
        {
          "input": "nums = [0,1]",
          "output": "[[0,1],[1,0]]"
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Choose",
          "visual": "Pick 1. Remaining: [2,3].",
          "explanation": "Branch."
        },
        {
          "step": 2,
          "title": "Recurse",
          "visual": "dfs(path + [1]).",
          "explanation": "Explore."
        },
        {
          "step": 3,
          "title": "Backtrack",
          "visual": "Pop 1. Try 2.",
          "explanation": "Undo."
        }
      ],
      "code": "def permute(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Ordering matters.\n    - \ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...\n    - \ud83d\udca1 Base case: len(path) == len(nums).\n\n    Algorithm:\n    1. Choose - Branch.\n    2. Recurse - Explore.\n    3. Backtrack - Undo.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    if (len(nums) == 1):\n        return [nums[:]]\n        \n    for i in range(len(nums)):  # Iterate through the range.\n        n = nums.pop(0)  # Remove and return last element.\n        perms = permute(nums)\n        \n        for p in perms:  # Iterate over elements.\n            p.append(n)  # Add to end.\n        res.extend(perms)\n        nums.append(n)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "The iterative swapping or popping/appending creates the variations without explicit visited sets.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [1, 2, 3]",
          "transientMessage": "Generate all permutations",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Pick 1, remaining: [2, 3]",
          "transientMessage": "Path: [1]",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Pick 2, remaining: [3]",
          "transientMessage": "Path: [1, 2]",
          "arrayState": [
            2,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Pick 3, remaining: []",
          "transientMessage": "Path: [1, 2, 3]",
          "arrayState": [
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Found: [1, 2, 3]",
          "transientMessage": "1 permutations",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Pick 3, remaining: [2]",
          "transientMessage": "Path: [1, 3]",
          "arrayState": [
            2,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Pick 2, remaining: []",
          "transientMessage": "Path: [1, 3, 2]",
          "arrayState": [
            2
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Found: [1, 3, 2]",
          "transientMessage": "2 permutations",
          "arrayState": [
            1,
            3,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Pick 2, remaining: [1, 3]",
          "transientMessage": "Path: [2]",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Pick 1, remaining: [3]",
          "transientMessage": "Path: [2, 1]",
          "arrayState": [
            1,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Pick 3, remaining: []",
          "transientMessage": "Path: [2, 1, 3]",
          "arrayState": [
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Found: [2, 1, 3]",
          "transientMessage": "3 permutations",
          "arrayState": [
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "Pick 3, remaining: [1]",
          "transientMessage": "Path: [2, 3]",
          "arrayState": [
            1,
            3
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 14,
          "visual": "Pick 1, remaining: []",
          "transientMessage": "Path: [2, 3, 1]",
          "arrayState": [
            1
          ],
          "pointers": [
            {
              "label": "pick",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 15,
          "visual": "Found: [2, 3, 1]",
          "transientMessage": "4 permutations",
          "arrayState": [
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 16,
          "visual": "Total: 4 permutations",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
      "examples": [
        {
          "input": "nums = [1,2,3]",
          "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "explanation": "All 6 permutations."
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]",
          "explanation": "Only one permutation."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 6",
        "-10 <= nums[i] <= 10",
        "All integers in nums are unique."
      ],
      "hints": [
        "Use backtracking.",
        "At each position, try all remaining numbers.",
        "Swap elements to avoid using extra space."
      ],
      "relatedProblems": [
        "permutations-ii",
        "next-permutation",
        "combinations"
      ],
      "videoId": "s7AvT7cGdSo",
      "problemStatement": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
      "suggestedNextQuestion": {
        "slug": "subsets",
        "title": "Subsets",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def permute(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def permute_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N!)",
          "spaceComplexity": "O(N)",
          "intuition": [
            "\ud83c\udfaf Ordering matters.",
            "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
            "\ud83d\udca1 Base case: len(path) == len(nums)."
          ],
          "code": "def permute(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Ordering matters.\n    - \ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...\n    - \ud83d\udca1 Base case: len(path) == len(nums).\n\n    Algorithm:\n    1. Choose - Branch.\n    2. Recurse - Explore.\n    3. Backtrack - Undo.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    if (len(nums) == 1):\n        return [nums[:]]\n        \n    for i in range(len(nums)):  # Iterate through the range.\n        n = nums.pop(0)  # Remove and return last element.\n        perms = permute(nums)\n        \n        for p in perms:  # Iterate over elements.\n            p.append(n)  # Add to end.\n        res.extend(perms)\n        nums.append(n)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "combination-sum": {
      "title": "Combination Sum",
      "pattern": "Backtracking (Decision Tree)",
      "patternEmoji": "\ud83c\udf81",
      "timeComplexity": "O(2^Target)",
      "spaceComplexity": "O(Target)",
      "oneliner": "At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
      "intuition": [
        "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
        "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
        "\ud83d\udca1 Avoid duplicates by only moving forward index."
      ],
      "testCases": [
        {
          "input": "candidates = [2,3,6,7], target = 7",
          "output": "[[2,2,3],[7]]"
        },
        {
          "input": "candidates = [2,3,5], target = 8",
          "output": "[[2,2,2,2],[2,3,3],[3,5]]"
        },
        {
          "input": "candidates = [2], target = 1",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Include",
          "visual": "Add 2. New sum. Recurse(i).",
          "explanation": "Reuse."
        },
        {
          "step": 2,
          "title": "Exclude",
          "visual": "Pop 2. Recurse(i+1).",
          "explanation": "Skip."
        },
        {
          "step": 3,
          "title": "Base",
          "visual": "Sum > Target? Return.",
          "explanation": "Prune."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef combinationSum(candidates, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited use of same number -> stay at index `i`.\n    - \ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.\n    - \ud83d\udca1 Avoid duplicates by only moving forward index.\n\n    Algorithm:\n    1. Include - Reuse.\n    2. Exclude - Skip.\n    3. Base - Prune.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    def dfs(i, cur, total):\n        if total == target:\n            res.append(cur.copy())  # Add to end.\n            return\n        if i >= len(candidates) or total > target:\n            return\n            \n        # Decision 1: Include candidate[i] -> stay at i\n        cur.append(candidates[i])  # Add to end.\n        dfs(i, cur, total + candidates[i])\n        \n        # Decision 2: Exclude candidate[i] -> move to i+1\n        cur.pop()  # Remove and return last element.\n        dfs(i + 1, cur, total)\n        \n    dfs(0, [], 0)\n    return res  # Return the final result.",
      "keyInsight": "Splitting the decision into 'include current' OR 'never use current again' avoids duplicate combinations perfectly.",
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Candidates: [2, 3, 6, 7], target: 7",
          "transientMessage": "Backtracking search",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Try 2: [2] = 2",
          "transientMessage": "Continue",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try 2: [2, 2] = 4",
          "transientMessage": "Continue",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Try 2: [2, 2, 2] = 6",
          "transientMessage": "Continue",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try 2: [2, 2, 2, 2] = 8",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Try 3: [2, 2, 2, 3] = 9",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Try 6: [2, 2, 2, 6] = 12",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try 7: [2, 2, 2, 7] = 13",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Try 3: [2, 2, 3] = 7",
          "transientMessage": "Continue",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found: [2, 2, 3] = 7",
          "transientMessage": "1 solution(s)",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Try 6: [2, 2, 6] = 10",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Try 7: [2, 2, 7] = 11",
          "transientMessage": "Too big, backtrack",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "Try 3: [2, 3] = 5",
          "transientMessage": "Continue",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "+",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 14,
          "visual": "Found 1 combinations",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            3,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.",
      "examples": [
        {
          "input": "candidates = [2,3,6,7], target = 7",
          "output": "[[2,2,3],[7]]",
          "explanation": "2+2+3=7 and 7=7."
        },
        {
          "input": "candidates = [2,3,5], target = 8",
          "output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "explanation": "Three valid combinations."
        }
      ],
      "constraints": [
        "1 <= candidates.length <= 30",
        "2 <= candidates[i] <= 40",
        "All elements in candidates are distinct.",
        "1 <= target <= 40"
      ],
      "hints": [
        "Use backtracking.",
        "Allow reusing same element (start index doesn't advance).",
        "Prune when sum exceeds target."
      ],
      "relatedProblems": [
        "combination-sum-ii",
        "combination-sum-iii",
        "subsets"
      ],
      "videoId": "GBKI9VSKdGg",
      "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Backtracking (Decision Tree): At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
      "suggestedNextQuestion": {
        "slug": "combination-sum-ii",
        "title": "Combination Sum II",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef combinationSum(candidates, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(2^Target)",
          "spaceComplexity": "O(Target)",
          "intuition": [
            "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
            "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
            "\ud83d\udca1 Avoid duplicates by only moving forward index."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef combinationSum(candidates, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited use of same number -> stay at index `i`.\n    - \ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.\n    - \ud83d\udca1 Avoid duplicates by only moving forward index.\n\n    Algorithm:\n    1. Include - Reuse.\n    2. Exclude - Skip.\n    3. Base - Prune.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    def dfs(i, cur, total):\n        if total == target:\n            res.append(cur.copy())  # Add to end.\n            return\n        if i >= len(candidates) or total > target:\n            return\n            \n        # Decision 1: Include candidate[i] -> stay at i\n        cur.append(candidates[i])  # Add to end.\n        dfs(i, cur, total + candidates[i])\n        \n        # Decision 2: Exclude candidate[i] -> move to i+1\n        cur.pop()  # Remove and return last element.\n        dfs(i + 1, cur, total)\n        \n    dfs(0, [], 0)\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs."
    },
    "word-search": {
      "title": "Word Search",
      "pattern": "Backtracking (Matrix)",
      "patternEmoji": "\ud83d\udd0e",
      "timeComplexity": "O(N * M * 4^L)",
      "spaceComplexity": "O(L)",
      "oneliner": "DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
      "intuition": [
        "\ud83c\udfaf Snake through the grid.",
        "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
        "\ud83d\udca1 Prune immediately if char mismatch."
      ],
      "testCases": [
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
          "output": "true"
        },
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
          "output": "true"
        },
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Find Start",
          "visual": "Scan for word[0]. Start DFS.",
          "explanation": "Init."
        },
        {
          "step": 2,
          "title": "DFS",
          "visual": "Match? Path.add. Recurse 4 dirs.",
          "explanation": "Pathfinding."
        },
        {
          "step": 3,
          "title": "Backtrack",
          "visual": "Return. Path.remove.",
          "explanation": "Cleanup."
        }
      ],
      "code": "def exist(board, word):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Snake through the grid.\n    - \ud83e\udde0 Cannot reuse cell in same path (need path_visited set).\n    - \ud83d\udca1 Prune immediately if char mismatch.\n\n    Algorithm:\n    1. Find Start - Init.\n    2. DFS - Pathfinding.\n    3. Backtrack - Cleanup.\n    \"\"\"\n    ROWS, COLS = len(board), len(board[0])\n    path = set()\n    \n    def dfs(r, c, i):\n        if i == len(word):\n            return True  # Condition satisfied.\n        if (r < 0 or c < 0 or \n            r >= ROWS or c >= COLS or \n            word[i] != board[r][c] or \n            (r,c) in path):\n            return False  # Condition not met.\n            \n        path.add((r, c))\n        res = (dfs(r + 1, c, i + 1) or\n               dfs(r - 1, c, i + 1) or\n               dfs(r, c + 1, i + 1) or\n               dfs(r, c - 1, i + 1))\n        path.remove((r, c))\n        return res  # Return the final result.\n        \n    for r in range(ROWS):  # Iterate through the range.\n        for c in range(COLS):  # Iterate through the range.\n            if dfs(r, c, 0): return True  # Condition satisfied.\n    return False  # Condition not met.",
      "keyInsight": "Using a set for the current path is cleaner than modifying the board, though board modification (e.g. replacing with '#') saves space.",
      "visualizationType": "grid",
      "initialState": [
        [
          "A",
          "B",
          "C",
          "E"
        ],
        [
          "S",
          "F",
          "C",
          "S"
        ],
        [
          "A",
          "D",
          "E",
          "E"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Word Search",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: A",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: B",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: S",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: F",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
      "examples": [
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
          "output": "true",
          "explanation": "Path exists."
        },
        {
          "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
          "output": "false",
          "explanation": "Cannot reuse cells."
        }
      ],
      "constraints": [
        "m == board.length",
        "n = board[i].length",
        "1 <= m, n <= 6",
        "1 <= word.length <= 15",
        "board and word only contain uppercase and lowercase English letters."
      ],
      "hints": [
        "Use backtracking with DFS.",
        "Mark visited cells temporarily.",
        "Restore after backtracking."
      ],
      "relatedProblems": [
        "word-search-ii"
      ],
      "videoId": "pfiQ_PS1g8E",
      "problemStatement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Backtracking (Matrix): DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
      "suggestedNextQuestion": {
        "slug": "n-queens",
        "title": "N Queens",
        "difficulty": "Hard",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def exist(board, word):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def exist_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N * M * 4^L)",
          "spaceComplexity": "O(L)",
          "intuition": [
            "\ud83c\udfaf Snake through the grid.",
            "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
            "\ud83d\udca1 Prune immediately if char mismatch."
          ],
          "code": "def exist(board, word):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Snake through the grid.\n    - \ud83e\udde0 Cannot reuse cell in same path (need path_visited set).\n    - \ud83d\udca1 Prune immediately if char mismatch.\n\n    Algorithm:\n    1. Find Start - Init.\n    2. DFS - Pathfinding.\n    3. Backtrack - Cleanup.\n    \"\"\"\n    ROWS, COLS = len(board), len(board[0])\n    path = set()\n    \n    def dfs(r, c, i):\n        if i == len(word):\n            return True  # Condition satisfied.\n        if (r < 0 or c < 0 or \n            r >= ROWS or c >= COLS or \n            word[i] != board[r][c] or \n            (r,c) in path):\n            return False  # Condition not met.\n            \n        path.add((r, c))\n        res = (dfs(r + 1, c, i + 1) or\n               dfs(r - 1, c, i + 1) or\n               dfs(r, c + 1, i + 1) or\n               dfs(r, c - 1, i + 1))\n        path.remove((r, c))\n        return res  # Return the final result.\n        \n    for r in range(ROWS):  # Iterate through the range.\n        for c in range(COLS):  # Iterate through the range.\n            if dfs(r, c, 0): return True  # Condition satisfied.\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "kth-largest-element-in-an-array": {
      "title": "Kth Largest Element in an Array",
      "pattern": "Heap / QuickSelect",
      "patternEmoji": "\ud83e\udd47",
      "timeComplexity": "O(N) avg",
      "spaceComplexity": "O(1) / O(K)",
      "oneliner": "QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
      "intuition": [
        "\ud83c\udfaf We want the Kth item if sorted descending.",
        "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
        "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
      ],
      "testCases": [
        {
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "output": "5"
        },
        {
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "output": "4"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Pivot",
          "visual": "Pick pivot, partition < pivot, > pivot.",
          "explanation": "Split."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "Is pivot index == len-k? Return pivot.",
          "explanation": "Target?"
        },
        {
          "step": 3,
          "title": "Recurse",
          "visual": "If idx < target, go right. Else left.",
          "explanation": "Search."
        }
      ],
      "code": "def findKthLargest(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want the Kth item if sorted descending.\n    - \ud83e\udde0 Sorting is O(NlogN). Can we do better?\n    - \ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half.\n\n    Algorithm:\n    1. Pivot - Split.\n    2. Check - Target?\n    3. Recurse - Search.\n    \"\"\"\n    k = len(nums) - k\n    \n    def quickSelect(l, r):\n        pivot, p = nums[r], l\n        for i in range(l, r):  # Iterate through the range.\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        nums[p], nums[r] = nums[r], nums[p]\n        \n        if p > k: return quickSelect(l, p - 1)\n        elif p < k: return quickSelect(p + 1, r)\n        else: return nums[p]\n        \n    return quickSelect(0, len(nums) - 1)",
      "keyInsight": "Running QuickSelect is theoretically O(N) average, superior to Heap's O(N log K) if K is large, although Python's `heapq.nlargest` is very optimized.",
      "visualizationType": "array",
      "initialState": [
        3,
        2,
        1,
        5,
        6,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Kth Largest Element in an Array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 5",
          "transientMessage": "Iteration 4",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 6",
          "transientMessage": "Iteration 5",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 4",
          "transientMessage": "Iteration 6",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
      "examples": [
        {
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "output": "5",
          "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5."
        },
        {
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "output": "4",
          "explanation": "4th largest is 4."
        }
      ],
      "constraints": [
        "1 <= k <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4"
      ],
      "hints": [
        "Use a min-heap of size k.",
        "Or use Quickselect for O(n) average.",
        "Heap gives O(n log k)."
      ],
      "relatedProblems": [
        "top-k-frequent-elements",
        "find-k-pairs-with-smallest-sums",
        "kth-smallest-element-in-a-sorted-matrix"
      ],
      "videoId": "XEmy13g1Qxc",
      "problemStatement": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Heap / QuickSelect: QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def findKthLargest(nums, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def findKthLargest_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N) avg",
          "spaceComplexity": "O(1) / O(K)",
          "intuition": [
            "\ud83c\udfaf We want the Kth item if sorted descending.",
            "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
            "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
          ],
          "code": "def findKthLargest(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want the Kth item if sorted descending.\n    - \ud83e\udde0 Sorting is O(NlogN). Can we do better?\n    - \ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half.\n\n    Algorithm:\n    1. Pivot - Split.\n    2. Check - Target?\n    3. Recurse - Search.\n    \"\"\"\n    k = len(nums) - k\n    \n    def quickSelect(l, r):\n        pivot, p = nums[r], l\n        for i in range(l, r):  # Iterate through the range.\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        nums[p], nums[r] = nums[r], nums[p]\n        \n        if p > k: return quickSelect(l, p - 1)\n        elif p < k: return quickSelect(p + 1, r)\n        else: return nums[p]\n        \n    return quickSelect(0, len(nums) - 1)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "top-k-frequent-elements": {
      "title": "Top K Frequent Elements",
      "pattern": "Bucket Sort / Heap",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(N)",
      "spaceComplexity": "O(N)",
      "oneliner": "Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
      "intuition": [
        "\ud83c\udfaf Map {num -> count}.",
        "\ud83e\udde0 Max freq is N. Create array where index is freq.",
        "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
      ],
      "testCases": [
        {
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "output": "[1,2]"
        },
        {
          "input": "nums = [1], k = 1",
          "output": "[1]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Count",
          "visual": "Hashmap counts.",
          "explanation": "Freqs."
        },
        {
          "step": 2,
          "title": "Bucket",
          "visual": "bucket[count].append(num).",
          "explanation": "Group."
        },
        {
          "step": 3,
          "title": "Gather",
          "visual": "Flatten buckets in reverse.",
          "explanation": "Result."
        }
      ],
      "code": "def topKFrequent(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Map {num -> count}.\n    - \ud83e\udde0 Max freq is N. Create array where index is freq.\n    - \ud83d\udca1 Iterate bucket from N down to 1 to find most frequent.\n\n    Algorithm:\n    1. Count - Freqs.\n    2. Bucket - Group.\n    3. Gather - Result.\n    \"\"\"\n    count = {}\n    freq = [[] for i in range(len(nums) + 1)]  # Iterate through the range.\n    \n    for n in nums:  # Iterate over elements.\n        count[n] = 1 + count.get(n, 0)\n    for n, c in count.items():  # Iterate over elements.\n        freq[c].append(n)  # Add to end.\n        \n    res = []  # Initialize list to store results.\n    for i in range(len(freq) - 1, 0, -1):  # Iterate through the range.\n        for n in freq[i]:  # Iterate over elements.\n            res.append(n)  # Add to end.\n            if len(res) == k:\n                return res  # Return the final result.",
      "keyInsight": "Bucket Sort is essentially O(N) here because frequencies are bounded by array size.",
      "visualizationType": "array",
      "initialState": [
        1,
        1,
        1,
        2,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Top K Frequent Elements",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 3",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
      "examples": [
        {
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "output": "[1,2]",
          "explanation": "1 appears 3 times, 2 appears 2 times."
        },
        {
          "input": "nums = [1], k = 1",
          "output": "[1]",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4",
        "k is in range [1, the number of unique elements].",
        "It is guaranteed that the answer is unique."
      ],
      "hints": [
        "Count frequencies with a hash map.",
        "Use a min-heap of size k.",
        "Or use bucket sort for O(n)."
      ],
      "relatedProblems": [
        "kth-largest-element-in-an-array",
        "sort-characters-by-frequency",
        "top-k-frequent-words"
      ],
      "videoId": "YPTqKIgVk-k",
      "problemStatement": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Bucket Sort / Heap: Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def topKFrequent(nums, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def topKFrequent_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N)",
          "spaceComplexity": "O(N)",
          "intuition": [
            "\ud83c\udfaf Map {num -> count}.",
            "\ud83e\udde0 Max freq is N. Create array where index is freq.",
            "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
          ],
          "code": "def topKFrequent(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Map {num -> count}.\n    - \ud83e\udde0 Max freq is N. Create array where index is freq.\n    - \ud83d\udca1 Iterate bucket from N down to 1 to find most frequent.\n\n    Algorithm:\n    1. Count - Freqs.\n    2. Bucket - Group.\n    3. Gather - Result.\n    \"\"\"\n    count = {}\n    freq = [[] for i in range(len(nums) + 1)]  # Iterate through the range.\n    \n    for n in nums:  # Iterate over elements.\n        count[n] = 1 + count.get(n, 0)\n    for n, c in count.items():  # Iterate over elements.\n        freq[c].append(n)  # Add to end.\n        \n    res = []  # Initialize list to store results.\n    for i in range(len(freq) - 1, 0, -1):  # Iterate through the range.\n        for n in freq[i]:  # Iterate over elements.\n            res.append(n)  # Add to end.\n            if len(res) == k:\n                return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "remove-duplicates-from-sorted-array": {
      "title": "Remove Duplicates from Sorted Array",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc46\ud83d\udc46",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
      "intuition": [
        "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
        "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
        "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
      ],
      "testCases": [
        {
          "input": "nums = [1,1,2]",
          "output": "2"
        },
        {
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "output": "5"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "slow=0, fast=1",
          "explanation": "Start pointers."
        },
        {
          "step": 2,
          "title": "Compare",
          "visual": "nums[fast] != nums[slow]? Move slow, copy.",
          "explanation": "Unique found."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "Return slow + 1",
          "explanation": "Length of unique elements."
        }
      ],
      "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.\n    - \ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.\n    - \ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1].\n\n    Algorithm:\n    1. Init - Start pointers.\n    2. Compare - Unique found.\n    3. Return - Length of unique elements.\n    \"\"\"\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1  # Return the result node.",
      "keyInsight": "The slow pointer always points to the last unique element.",
      "visualizationType": "array",
      "initialState": [
        0,
        0,
        1,
        1,
        1,
        2,
        2,
        3,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
          "transientMessage": "Two pointer approach",
          "arrayState": [
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "nums[1]=0 is duplicate",
          "transientMessage": "Skip",
          "arrayState": [
            0,
            0,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 0
            },
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "nums[2]=1 is new",
          "transientMessage": "Place at k=1",
          "arrayState": [
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 1
            },
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "nums[3]=1 is duplicate",
          "transientMessage": "Skip",
          "arrayState": [
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 1
            },
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "nums[4]=1 is duplicate",
          "transientMessage": "Skip",
          "arrayState": [
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 1
            },
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "nums[5]=2 is new",
          "transientMessage": "Place at k=2",
          "arrayState": [
            0,
            1,
            2,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 2
            },
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            2,
            5
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "nums[6]=2 is duplicate",
          "transientMessage": "Skip",
          "arrayState": [
            0,
            1,
            2,
            1,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 2
            },
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "nums[7]=3 is new",
          "transientMessage": "Place at k=3",
          "arrayState": [
            0,
            1,
            2,
            3,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 3
            },
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            3,
            7
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "nums[8]=3 is duplicate",
          "transientMessage": "Skip",
          "arrayState": [
            0,
            1,
            2,
            3,
            1,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 3
            },
            {
              "label": "i",
              "index": 8
            }
          ],
          "indices": [
            8
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "nums[9]=4 is new",
          "transientMessage": "Place at k=4",
          "arrayState": [
            0,
            1,
            2,
            3,
            4,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "k",
              "index": 4
            },
            {
              "label": "i",
              "index": 9
            }
          ],
          "indices": [
            4,
            9
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "5 unique elements",
          "transientMessage": "Complete!",
          "arrayState": [
            0,
            1,
            2,
            3,
            4,
            2,
            2,
            3,
            3,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3,
            4
          ],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.",
      "examples": [
        {
          "input": "nums = [1,1,2]",
          "output": "2, nums = [1,2,_]",
          "explanation": "Return k=2, first 2 elements are unique."
        },
        {
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "explanation": "5 unique elements."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 10^4",
        "-100 <= nums[i] <= 100",
        "nums is sorted in non-decreasing order."
      ],
      "hints": [
        "Use two pointers - slow for unique position, fast for scanning.",
        "If nums[fast] != nums[slow], copy to slow+1.",
        "Return slow + 1 as count."
      ],
      "relatedProblems": [
        "remove-duplicates-from-sorted-array-ii",
        "remove-element",
        "move-zeroes"
      ],
      "videoId": "DEJAZBq0FDA",
      "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
      "suggestedNextQuestion": {
        "slug": "remove-element",
        "title": "Remove Element",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def removeDuplicates(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
            "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
            "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
          ],
          "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.\n    - \ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.\n    - \ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1].\n\n    Algorithm:\n    1. Init - Start pointers.\n    2. Compare - Unique found.\n    3. Return - Length of unique elements.\n    \"\"\"\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1  # Return the result node."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "remove-duplicates-from-sorted-array-ii": {
      "title": "Remove Duplicates from Sorted Array II",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc46\ud83d\udc46",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
      "intuition": [
        "\ud83c\udfaf Each unique element can appear at most twice.",
        "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
        "\ud83d\udca1 If different, copy and advance slow."
      ],
      "testCases": [
        {
          "input": "nums = [1,1,1,2,2,3]",
          "output": "5"
        },
        {
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "output": "7"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "slow=2, fast=2",
          "explanation": "First 2 are always kept."
        },
        {
          "step": 2,
          "title": "Compare",
          "visual": "nums[fast] != nums[slow-2]?",
          "explanation": "Check 2 back."
        },
        {
          "step": 3,
          "title": "Copy",
          "visual": "nums[slow] = nums[fast]; slow++",
          "explanation": "Keep element."
        }
      ],
      "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each unique element can appear at most twice.\n    - \ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).\n    - \ud83d\udca1 If different, copy and advance slow.\n\n    Algorithm:\n    1. Init - First 2 are always kept.\n    2. Compare - Check 2 back.\n    3. Copy - Keep element.\n    \"\"\"\n    if len(nums) <= 2: return len(nums)\n    slow = 2\n    for fast in range(2, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow  # Return the result node.",
      "keyInsight": "The key insight is comparing with slow-2, not slow-1.",
      "visualizationType": "array",
      "initialState": [
        1,
        1,
        1,
        2,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Remove Duplicates from Sorted Array II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 3",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.",
      "examples": [
        {
          "input": "nums = [1,1,1,2,2,3]",
          "output": "5, nums = [1,1,2,2,3,_]",
          "explanation": "Keep at most 2 of each."
        },
        {
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "explanation": "7 elements after removing extras."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "nums is sorted in non-decreasing order."
      ],
      "hints": [
        "Use two pointers with a count variable.",
        "Allow at most 2 of each element.",
        "Compare with element 2 positions back."
      ],
      "relatedProblems": [
        "remove-duplicates-from-sorted-array",
        "remove-duplicates-from-sorted-list-ii"
      ],
      "videoId": "ycAq8iqh0TI",
      "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
      "suggestedNextQuestion": {
        "slug": "remove-duplicates-from-sorted-list-ii",
        "title": "Remove Duplicates from Sorted List II",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def removeDuplicates(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def removeDuplicates(nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Each unique element can appear at most twice.",
            "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
            "\ud83d\udca1 If different, copy and advance slow."
          ],
          "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each unique element can appear at most twice.\n    - \ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).\n    - \ud83d\udca1 If different, copy and advance slow.\n\n    Algorithm:\n    1. Init - First 2 are always kept.\n    2. Compare - Check 2 back.\n    3. Copy - Keep element.\n    \"\"\"\n    if len(nums) <= 2: return len(nums)\n    slow = 2\n    for fast in range(2, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow  # Return the result node."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "rotate-array": {
      "title": "Rotate Array",
      "pattern": "Reverse Trick",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Reverse entire array, then reverse first k, then reverse rest.",
      "intuition": [
        "\ud83c\udfaf Rotate array right by k steps.",
        "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
        "\ud83d\udca1 Handles k > len(nums) with k %= len."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "output": "[5,6,7,1,2,3,4]"
        },
        {
          "input": "nums = [-1,-100,3,99], k = 2",
          "output": "[3,99,-1,-100]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Normalize",
          "visual": "k = k % n",
          "explanation": "Handle overflow."
        },
        {
          "step": 2,
          "title": "Reverse All",
          "visual": "[7,6,5,4,3,2,1]",
          "explanation": "Flip entire array."
        },
        {
          "step": 3,
          "title": "Reverse Parts",
          "visual": "[5,6,7] + [1,2,3,4]",
          "explanation": "Flip both halves."
        }
      ],
      "code": "def rotate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate array right by k steps.\n    - \ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].\n    - \ud83d\udca1 Handles k > len(nums) with k %= len.\n\n    Algorithm:\n    1. Normalize - Handle overflow.\n    2. Reverse All - Flip entire array.\n    3. Reverse Parts - Flip both halves.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    def reverse(l, r):\n        while l < r:  # Continue until pointers meet.\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1  # Initialize two pointers.\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums",
      "keyInsight": "Three reverses is more elegant than slicing or cyclic replacement.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Rotate Array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 6",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
      "examples": [
        {
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "output": "[5,6,7,1,2,3,4]",
          "explanation": "Rotate right 3 times."
        },
        {
          "input": "nums = [-1,-100,3,99], k = 2",
          "output": "[3,99,-1,-100]",
          "explanation": "Rotate right 2 times."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^5",
        "-2^31 <= nums[i] <= 2^31 - 1",
        "0 <= k <= 10^5"
      ],
      "hints": [
        "Use the reverse technique.",
        "Reverse the entire array.",
        "Reverse first k elements, then reverse remaining elements."
      ],
      "relatedProblems": [
        "rotate-list",
        "reverse-words-in-a-string",
        "rotate-image"
      ],
      "videoId": "BHr381Guz3Y",
      "problemStatement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Reverse Trick: Reverse entire array, then reverse first k, then reverse rest.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def rotate(nums, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rotate(nums, k):\n    k %= len(nums)\n    # 1. Reverse whole array\n    # 2. Reverse first k\n    # 3. Reverse last n-k\n    def rev(l, r):\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n    n = len(nums)\n    rev(0, n - 1)\n    rev(0, k - 1)\n    rev(k, n - 1)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Rotate array right by k steps.",
            "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
            "\ud83d\udca1 Handles k > len(nums) with k %= len."
          ],
          "code": "def rotate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate array right by k steps.\n    - \ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].\n    - \ud83d\udca1 Handles k > len(nums) with k %= len.\n\n    Algorithm:\n    1. Normalize - Handle overflow.\n    2. Reverse All - Flip entire array.\n    3. Reverse Parts - Flip both halves.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    def reverse(l, r):\n        while l < r:  # Continue until pointers meet.\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1  # Initialize two pointers.\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "best-time-to-buy-and-sell-stock-ii": {
      "title": "Best Time to Buy and Sell Stock II",
      "pattern": "Greedy",
      "patternEmoji": "\ud83d\udcb0",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Buy before every rise, sell after every rise. Collect all profits.",
      "intuition": [
        "\ud83c\udfaf Unlimited transactions allowed.",
        "\ud83e\udde0 Collect profit for every upward movement.",
        "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
      ],
      "testCases": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "7"
        },
        {
          "input": "prices = [1,2,3,4,5]",
          "output": "4"
        },
        {
          "input": "prices = [7,6,4,3,1]",
          "output": "0"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Scan",
          "visual": "Check pairs",
          "explanation": "Compare consecutive."
        },
        {
          "step": 2,
          "title": "Profit",
          "visual": "If up, add diff",
          "explanation": "Greedy gain."
        },
        {
          "step": 3,
          "title": "Sum",
          "visual": "Total = 7",
          "explanation": "All upward moves."
        }
      ],
      "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited transactions allowed.\n    - \ud83e\udde0 Collect profit for every upward movement.\n    - \ud83d\udca1 If prices[i] > prices[i-1], add the difference.\n\n    Algorithm:\n    1. Scan - Compare consecutive.\n    2. Profit - Greedy gain.\n    3. Sum - All upward moves.\n    \"\"\"\n    profit = 0\n    for i in range(1, len(prices)):  # Iterate through the range.\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit",
      "keyInsight": "Every upward slope contributes to profit. Just sum them all.",
      "visualizationType": "array",
      "initialState": [
        7,
        1,
        5,
        3,
        6,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Best Time to Buy and Sell Stock II",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 7",
          "arrayState": [
            7,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            7,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 1",
          "arrayState": [
            7,
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            7,
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 5",
          "arrayState": [
            7,
            1,
            5,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            7,
            1,
            5,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            7,
            1,
            5,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            7,
            1,
            5,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 6",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            0
          ],
          "pointers": [],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            7,
            1,
            5,
            3,
            6,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",
      "examples": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "output": "7",
          "explanation": "Buy at 1, sell at 5, profit 4. Buy at 3, sell at 6, profit 3. Total 7."
        },
        {
          "input": "prices = [1,2,3,4,5]",
          "output": "4",
          "explanation": "Buy at 1, sell at 5, or sum all increases."
        }
      ],
      "constraints": [
        "1 <= prices.length <= 3 * 10^4",
        "0 <= prices[i] <= 10^4"
      ],
      "hints": [
        "Capture every upward price movement.",
        "Sum of (prices[i] - prices[i-1]) for all increases.",
        "Greedy approach works here."
      ],
      "relatedProblems": [
        "best-time-to-buy-and-sell-stock",
        "best-time-to-buy-and-sell-stock-iii",
        "best-time-to-buy-and-sell-stock-with-cooldown"
      ],
      "videoId": "3SJ3pUkPQMc",
      "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
      "difficulty": "Medium",
      "walkthrough": [
        "Sort input if needed for optimal substructure",
        "Make locally optimal choice at each step",
        "Update state based on current choice",
        "Validate choice doesn't violate constraints",
        "Build solution incrementally"
      ],
      "approach": "Greedy: Buy before every rise, sell after every rise. Collect all profits.",
      "suggestedNextQuestion": {
        "slug": "gas-station",
        "title": "Gas Station",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
      "initialCode": "def maxProfit(prices):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            profit += (prices[i] - prices[i-1])\n    return profit"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Unlimited transactions allowed.",
            "\ud83e\udde0 Collect profit for every upward movement.",
            "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
          ],
          "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited transactions allowed.\n    - \ud83e\udde0 Collect profit for every upward movement.\n    - \ud83d\udca1 If prices[i] > prices[i-1], add the difference.\n\n    Algorithm:\n    1. Scan - Compare consecutive.\n    2. Profit - Greedy gain.\n    3. Sum - All upward moves.\n    \"\"\"\n    profit = 0\n    for i in range(1, len(prices)):  # Iterate through the range.\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "jump-game": {
      "title": "Jump Game",
      "pattern": "Greedy",
      "patternEmoji": "\ud83e\udd98",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track the farthest reachable index. If i > maxReach, return False.",
      "intuition": [
        "\ud83c\udfaf Can you reach the last index?",
        "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
        "\ud83d\udca1 If current index exceeds reach, we're stuck."
      ],
      "testCases": [
        {
          "input": "nums = [2,3,1,1,4]",
          "output": "true"
        },
        {
          "input": "nums = [3,2,1,0,4]",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "reach = 0",
          "explanation": "Start."
        },
        {
          "step": 2,
          "title": "Update",
          "visual": "reach = max(reach, i + nums[i])",
          "explanation": "Extend."
        },
        {
          "step": 3,
          "title": "Check",
          "visual": "reach >= n-1?",
          "explanation": "Can reach end."
        }
      ],
      "code": "def canJump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can you reach the last index?\n    - \ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).\n    - \ud83d\udca1 If current index exceeds reach, we're stuck.\n\n    Algorithm:\n    1. Init - Start.\n    2. Update - Extend.\n    3. Check - Can reach end.\n    \"\"\"\n    reach = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if i > reach:\n            return False  # Condition not met.\n        reach = max(reach, i + nums[i])  # Take the maximum value.\n    return True  # Condition satisfied.",
      "keyInsight": "Greedy approach: always track the maximum reachable position.",
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        1,
        1,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Jump Game",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 4",
          "transientMessage": "Iteration 5",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
      "examples": [
        {
          "input": "nums = [2,3,1,1,4]",
          "output": "true",
          "explanation": "Jump 1 step from 0 to 1, then 3 steps to last."
        },
        {
          "input": "nums = [3,2,1,0,4]",
          "output": "false",
          "explanation": "Always stuck at index 3."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "0 <= nums[i] <= 10^5"
      ],
      "hints": [
        "Track the farthest reachable index.",
        "If current index > farthest, return false.",
        "If farthest >= last index, return true."
      ],
      "relatedProblems": [
        "jump-game-ii",
        "jump-game-iii",
        "jump-game-iv"
      ],
      "videoId": "Yan0cv2cLy8",
      "problemStatement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.",
      "difficulty": "Medium",
      "walkthrough": [
        "Sort input if needed for optimal substructure",
        "Make locally optimal choice at each step",
        "Update state based on current choice",
        "Validate choice doesn't violate constraints",
        "Build solution incrementally"
      ],
      "approach": "Greedy: Track the farthest reachable index. If i > maxReach, return False.",
      "suggestedNextQuestion": {
        "slug": "merge-triplets-to-form-target-triplet",
        "title": "Merge Triplets to Form Target Triplet",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def canJump(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def canJump(nums):\n    # Backtrack from last index\n    target = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n        if i + nums[i] >= target:\n            target = i\n    return target == 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Can you reach the last index?",
            "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
            "\ud83d\udca1 If current index exceeds reach, we're stuck."
          ],
          "code": "def canJump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can you reach the last index?\n    - \ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).\n    - \ud83d\udca1 If current index exceeds reach, we're stuck.\n\n    Algorithm:\n    1. Init - Start.\n    2. Update - Extend.\n    3. Check - Can reach end.\n    \"\"\"\n    reach = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if i > reach:\n            return False  # Condition not met.\n        reach = max(reach, i + nums[i])  # Take the maximum value.\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "jump-game-ii": {
      "title": "Jump Game II",
      "pattern": "Greedy BFS",
      "patternEmoji": "\ud83e\udd98\ud83e\udd98",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "BFS-style: track current level end and farthest reachable.",
      "intuition": [
        "\ud83c\udfaf Minimum jumps to reach end.",
        "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
        "\ud83d\udca1 When we pass current level end, increment jumps."
      ],
      "testCases": [
        {
          "input": "nums = [2,3,1,1,4]",
          "output": "2"
        },
        {
          "input": "nums = [2,3,0,1,4]",
          "output": "2"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "jumps=0, end=0, far=0",
          "explanation": "Setup."
        },
        {
          "step": 2,
          "title": "Expand",
          "visual": "far = max(far, i+nums[i])",
          "explanation": "Track farthest."
        },
        {
          "step": 3,
          "title": "Level",
          "visual": "i == end? jumps++, end=far",
          "explanation": "Next jump."
        }
      ],
      "code": "def jump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum jumps to reach end.\n    - \ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.\n    - \ud83d\udca1 When we pass current level end, increment jumps.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Expand - Track farthest.\n    3. Level - Next jump.\n    \"\"\"\n    jumps = 0\n    end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):  # Iterate through the range.\n        farthest = max(farthest, i + nums[i])  # Take the maximum value.\n        if i == end:\n            jumps += 1\n            end = farthest\n    return jumps",
      "keyInsight": "Think of it as BFS where each 'level' represents one jump.",
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        1,
        1,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Jump Game II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 4",
          "transientMessage": "Iteration 5",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            3,
            1,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. Return the minimum number of jumps to reach nums[n - 1].",
      "examples": [
        {
          "input": "nums = [2,3,1,1,4]",
          "output": "2",
          "explanation": "Jump 1 to index 1, then 3 to last index."
        },
        {
          "input": "nums = [2,3,0,1,4]",
          "output": "2",
          "explanation": "Same minimum jumps."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "0 <= nums[i] <= 1000",
        "It's guaranteed you can reach nums[n - 1]."
      ],
      "hints": [
        "Use BFS-like approach with levels.",
        "Track current jump's end and farthest reachable.",
        "Increment jumps when reaching current end."
      ],
      "relatedProblems": [
        "jump-game",
        "jump-game-iii",
        "minimum-jumps-to-reach-home"
      ],
      "videoId": "dJ7sWiOoK7g",
      "problemStatement": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Greedy BFS: BFS-style: track current level end and farthest reachable.",
      "suggestedNextQuestion": {
        "slug": "lowest-common-ancestor-of-a-binary-tree",
        "title": "Lowest Common Ancestor of a Binary Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def jump(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def jump(nums):\n    jumps = 0\n    cur_end = 0\n    cur_farthest = 0\n    for i in range(len(nums) - 1):\n        cur_farthest = max(cur_farthest, i + nums[i])\n        if i == cur_end:\n            jumps += 1\n            cur_end = cur_farthest\n    return jumps"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Minimum jumps to reach end.",
            "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
            "\ud83d\udca1 When we pass current level end, increment jumps."
          ],
          "code": "def jump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum jumps to reach end.\n    - \ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.\n    - \ud83d\udca1 When we pass current level end, increment jumps.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Expand - Track farthest.\n    3. Level - Next jump.\n    \"\"\"\n    jumps = 0\n    end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):  # Iterate through the range.\n        farthest = max(farthest, i + nums[i])  # Take the maximum value.\n        if i == end:\n            jumps += 1\n            end = farthest\n    return jumps"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "h-index": {
      "title": "H-Index",
      "pattern": "Counting Sort / Binary Search",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "videoId": "mgG5KFTvfPw",
      "oneliner": "Count papers at each citation level. Scan from high to low.",
      "intuition": [
        "\ud83c\udfaf H-index: h papers with at least h citations.",
        "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
        "\ud83d\udca1 Accumulate from high to find h where count >= h."
      ],
      "testCases": [
        {
          "input": "citations = [3,0,6,1,5]",
          "output": "3"
        },
        {
          "input": "citations = [1,3,1]",
          "output": "1"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Bucket",
          "visual": "Count citations",
          "explanation": "Counting sort."
        },
        {
          "step": 2,
          "title": "Accumulate",
          "visual": "From n down to 0",
          "explanation": "Sum papers."
        },
        {
          "step": 3,
          "title": "Find h",
          "visual": "total >= h",
          "explanation": "First valid."
        }
      ],
      "code": "def hIndex(citations):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf H-index: h papers with at least h citations.\n    - \ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.\n    - \ud83d\udca1 Accumulate from high to find h where count >= h.\n\n    Algorithm:\n    1. Bucket - Counting sort.\n    2. Accumulate - Sum papers.\n    3. Find h - First valid.\n    \"\"\"\n    n = len(citations)\n    papers = [0] * (n + 1)\n    for c in citations:  # Iterate over elements.\n        papers[min(n, c)] += 1  # Take the minimum value.\n    total = 0\n    for h in range(n, -1, -1):  # Iterate through the range.\n        total += papers[h]\n        if total >= h:\n            return h\n    return 0",
      "keyInsight": "Counting sort avoids O(n log n) sort. Cap citations at n.",
      "visualizationType": "array",
      "initialState": [
        3,
        0,
        6,
        1,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: H-Index",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 0",
          "transientMessage": "Iteration 2",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            3,
            0,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Count papers at each citation level. Scan from high to low.\n\nH-index: h papers with at least h citations.\nUse counting sort bucket. papers[i] = count of papers with i citations.",
      "examples": [
        {
          "input": "citations = [3,0,6,1,5]",
          "output": "3"
        },
        {
          "input": "citations = [1,3,1]",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "H-index: h papers with at least h citations.",
        "Use counting sort bucket. papers[i] = count of papers with i citations.",
        "Accumulate from high to find h where count >= h."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "problemStatement": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Counting Sort / Binary Search: Count papers at each citation level. Scan from high to low.",
      "suggestedNextQuestion": {
        "slug": "koko-eating-bananas",
        "title": "Koko Eating Bananas",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def hIndex(citations):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def hIndex_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf H-index: h papers with at least h citations.",
            "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
            "\ud83d\udca1 Accumulate from high to find h where count >= h."
          ],
          "code": "def hIndex(citations):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf H-index: h papers with at least h citations.\n    - \ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.\n    - \ud83d\udca1 Accumulate from high to find h where count >= h.\n\n    Algorithm:\n    1. Bucket - Counting sort.\n    2. Accumulate - Sum papers.\n    3. Find h - First valid.\n    \"\"\"\n    n = len(citations)\n    papers = [0] * (n + 1)\n    for c in citations:  # Iterate over elements.\n        papers[min(n, c)] += 1  # Take the minimum value.\n    total = 0\n    for h in range(n, -1, -1):  # Iterate through the range.\n        total += papers[h]\n        if total >= h:\n            return h\n    return 0"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "product-of-array-except-self": {
      "title": "Product of Array Except Self",
      "pattern": "Prefix/Suffix Products",
      "patternEmoji": "\u2716\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Two passes: left products, then right products multiplied in.",
      "intuition": [
        "\ud83c\udfaf res[i] = product of all except nums[i].",
        "\ud83e\udde0 res[i] = (product of left) * (product of right).",
        "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,4]",
          "output": "[24,12,8,6]"
        },
        {
          "input": "nums = [-1,1,0,-3,3]",
          "output": "[0,0,9,0,0]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Left",
          "visual": "res = [1, 1, 2, 6]",
          "explanation": "Prefix products."
        },
        {
          "step": 2,
          "title": "Right",
          "visual": "Multiply suffix",
          "explanation": "Right to left."
        },
        {
          "step": 3,
          "title": "Result",
          "visual": "[24,12,8,6]",
          "explanation": "Combined."
        }
      ],
      "code": "def productExceptSelf(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf res[i] = product of all except nums[i].\n    - \ud83e\udde0 res[i] = (product of left) * (product of right).\n    - \ud83d\udca1 First pass: left products. Second pass: multiply right products.\n\n    Algorithm:\n    1. Left - Prefix products.\n    2. Right - Right to left.\n    3. Result - Combined.\n    \"\"\"\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):  # Iterate through the range.\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):  # Iterate through the range.\n        res[i] *= right\n        right *= nums[i]\n    return res  # Return the final result.",
      "keyInsight": "Use output array for left products, then multiply right products in-place.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [1, 2, 3, 4]",
          "transientMessage": "Calculate product except self for each position",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Left pass: result[0] = 1",
          "transientMessage": "Product of elements to the left",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Left pass: result[1] = 1",
          "transientMessage": "Product of elements to the left",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Left pass: result[2] = 2",
          "transientMessage": "Product of elements to the left",
          "arrayState": [
            1,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Left pass: result[3] = 6",
          "transientMessage": "Product of elements to the left",
          "arrayState": [
            1,
            1,
            2,
            6
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Right pass: result[3] *= 1 = 6",
          "transientMessage": "Multiply by product of elements to the right",
          "arrayState": [
            1,
            1,
            2,
            6
          ],
          "pointers": [
            {
              "label": "R",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Right pass: result[2] *= 4 = 8",
          "transientMessage": "Multiply by product of elements to the right",
          "arrayState": [
            1,
            1,
            8,
            6
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Right pass: result[1] *= 12 = 12",
          "transientMessage": "Multiply by product of elements to the right",
          "arrayState": [
            1,
            12,
            8,
            6
          ],
          "pointers": [
            {
              "label": "R",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Right pass: result[0] *= 24 = 24",
          "transientMessage": "Multiply by product of elements to the right",
          "arrayState": [
            24,
            12,
            8,
            6
          ],
          "pointers": [
            {
              "label": "R",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Result: [24, 12, 8, 6]",
          "transientMessage": "Complete!",
          "arrayState": [
            24,
            12,
            8,
            6
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
      "examples": [
        {
          "input": "nums = [1,2,3,4]",
          "output": "[24,12,8,6]",
          "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."
        },
        {
          "input": "nums = [-1,1,0,-3,3]",
          "output": "[0,0,9,0,0]",
          "explanation": "Products accounting for the zero."
        }
      ],
      "constraints": [
        "2 <= nums.length <= 10^5",
        "-30 <= nums[i] <= 30",
        "Product of any prefix or suffix fits in 32-bit integer."
      ],
      "hints": [
        "Calculate prefix products from left.",
        "Calculate suffix products from right.",
        "answer[i] = prefix[i-1] * suffix[i+1]."
      ],
      "relatedProblems": [
        "trapping-rain-water",
        "maximum-product-subarray",
        "paint-house-ii"
      ],
      "videoId": "bNvIQI2wAjk",
      "problemStatement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Prefix/Suffix Products: Two passes: left products, then right products multiplied in.",
      "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
      "initialCode": "def productExceptSelf(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def productExceptSelf(nums):\n    n = len(nums)\n    res = [1] * n\n    # Prefix\n    pre = 1\n    for i in range(n):\n        res[i] = pre\n        pre *= nums[i]\n    # Postfix\n    post = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= post\n        post *= nums[i]\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf res[i] = product of all except nums[i].",
            "\ud83e\udde0 res[i] = (product of left) * (product of right).",
            "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
          ],
          "code": "def productExceptSelf(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf res[i] = product of all except nums[i].\n    - \ud83e\udde0 res[i] = (product of left) * (product of right).\n    - \ud83d\udca1 First pass: left products. Second pass: multiply right products.\n\n    Algorithm:\n    1. Left - Prefix products.\n    2. Right - Right to left.\n    3. Result - Combined.\n    \"\"\"\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):  # Iterate through the range.\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):  # Iterate through the range.\n        res[i] *= right\n        right *= nums[i]\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "gas-station": {
      "title": "Gas Station",
      "pattern": "Greedy",
      "patternEmoji": "\u26fd",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "If total gas >= total cost, solution exists. Start from where deficit resets.",
      "intuition": [
        "\ud83c\udfaf Find the starting gas station to complete the circuit.",
        "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
        "\ud83d\udca1 If total >= 0, answer is the last reset point."
      ],
      "testCases": [
        {
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "output": "3"
        },
        {
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "output": "-1"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Track",
          "visual": "total, tank, start",
          "explanation": "Initialize."
        },
        {
          "step": 2,
          "title": "Add",
          "visual": "tank += gas[i] - cost[i]",
          "explanation": "Net gain."
        },
        {
          "step": 3,
          "title": "Reset",
          "visual": "tank<0? start=i+1, tank=0",
          "explanation": "New start."
        }
      ],
      "code": "def canCompleteCircuit(gas, cost):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the starting gas station to complete the circuit.\n    - \ud83e\udde0 Track total and current tank. Reset start when current < 0.\n    - \ud83d\udca1 If total >= 0, answer is the last reset point.\n\n    Algorithm:\n    1. Track - Initialize.\n    2. Add - Net gain.\n    3. Reset - New start.\n    \"\"\"\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):  # Iterate through the range.\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1",
      "keyInsight": "If you can't reach station i+1 from some start, try starting from i+1.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "gas: [1, 2, 3, 4, 5]",
          "transientMessage": "cost: [3, 4, 5, 1, 2]",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Station 0: gas=1, cost=3, net=-2",
          "transientMessage": "currTank=-2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "start",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Tank empty! Reset start to 1",
          "transientMessage": "Cannot start from earlier stations",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "start",
              "index": 1
            }
          ],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Station 1: gas=2, cost=4, net=-2",
          "transientMessage": "currTank=-2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "start",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Tank empty! Reset start to 2",
          "transientMessage": "Cannot start from earlier stations",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "start",
              "index": 2
            }
          ],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Station 2: gas=3, cost=5, net=-2",
          "transientMessage": "currTank=-2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            },
            {
              "label": "start",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Tank empty! Reset start to 3",
          "transientMessage": "Cannot start from earlier stations",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "start",
              "index": 3
            }
          ],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Station 3: gas=4, cost=1, net=3",
          "transientMessage": "currTank=3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            },
            {
              "label": "start",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Station 4: gas=5, cost=2, net=3",
          "transientMessage": "currTank=6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            },
            {
              "label": "start",
              "index": 3
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Start from station: 3",
          "transientMessage": "Solution exists!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "\u2713",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        }
      ],
      "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.",
      "examples": [
        {
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "output": "3",
          "explanation": "Start at station 3, you can complete the circuit."
        },
        {
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "output": "-1",
          "explanation": "Not possible to complete."
        }
      ],
      "constraints": [
        "n == gas.length == cost.length",
        "1 <= n <= 10^5",
        "0 <= gas[i], cost[i] <= 10^4"
      ],
      "hints": [
        "If total gas < total cost, impossible.",
        "If we run out at station j, start can't be 0 to j.",
        "Greedy: reset start when tank goes negative."
      ],
      "relatedProblems": [
        "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
      ],
      "videoId": "lJwbPZGo05A",
      "problemStatement": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
      "difficulty": "Medium",
      "walkthrough": [
        "Sort input if needed for optimal substructure",
        "Make locally optimal choice at each step",
        "Update state based on current choice",
        "Validate choice doesn't violate constraints",
        "Build solution incrementally"
      ],
      "approach": "Greedy: If total gas >= total cost, solution exists. Start from where deficit resets.",
      "suggestedNextQuestion": {
        "slug": "hand-of-straights",
        "title": "Hand of Straights",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def canCompleteCircuit(gas, cost):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def canCompleteCircuit(gas, cost):\n    total_gas = 0\n    total_cost = 0\n    start = 0\n    tank = 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        tank += gas[i] - cost[i]\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total_gas >= total_cost else -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find the starting gas station to complete the circuit.",
            "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
            "\ud83d\udca1 If total >= 0, answer is the last reset point."
          ],
          "code": "def canCompleteCircuit(gas, cost):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the starting gas station to complete the circuit.\n    - \ud83e\udde0 Track total and current tank. Reset start when current < 0.\n    - \ud83d\udca1 If total >= 0, answer is the last reset point.\n\n    Algorithm:\n    1. Track - Initialize.\n    2. Add - Net gain.\n    3. Reset - New start.\n    \"\"\"\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):  # Iterate through the range.\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "candy": {
      "title": "Candy",
      "pattern": "Two Pass Greedy",
      "patternEmoji": "\ud83c\udf6c",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
      "intuition": [
        "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
        "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
        "\ud83d\udca1 Right-to-left: same logic, take max."
      ],
      "testCases": [
        {
          "input": "ratings = [1,0,2]",
          "output": "5"
        },
        {
          "input": "ratings = [1,2,2]",
          "output": "4"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "candy = [1,1,1...]",
          "explanation": "Everyone gets 1."
        },
        {
          "step": 2,
          "title": "Left",
          "visual": "Increasing? +1",
          "explanation": "Left rule."
        },
        {
          "step": 3,
          "title": "Right",
          "visual": "Decreasing? max",
          "explanation": "Right rule."
        }
      ],
      "code": "def candy(ratings):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.\n    - \ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.\n    - \ud83d\udca1 Right-to-left: same logic, take max.\n\n    Algorithm:\n    1. Init - Everyone gets 1.\n    2. Left - Left rule.\n    3. Right - Right rule.\n    \"\"\"\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):  # Iterate through the range.\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):  # Iterate through the range.\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Take the maximum value.\n    return sum(candies)",
      "keyInsight": "Two passes handle left and right neighbors independently, then combine.",
      "visualizationType": "array",
      "initialState": [
        1,
        0,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Candy",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 0",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 2",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            0,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.\n\nEach child gets at least 1 candy. Higher rating = more than neighbors.\nLeft-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
      "examples": [
        {
          "input": "ratings = [1,0,2]",
          "output": "5"
        },
        {
          "input": "ratings = [1,2,2]",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Each child gets at least 1 candy. Higher rating = more than neighbors.",
        "Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
        "Right-to-left: same logic, take max."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "1IzCRCcK17A",
      "problemStatement": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nReturn the minimum number of candies you need to have to distribute the candies to the children.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Pass Greedy: Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
      "suggestedNextQuestion": {
        "slug": "text-justification",
        "title": "Text Justification",
        "difficulty": "Hard",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def candy(ratings):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1] + 1\n    for i in range(n-2, -1, -1):\n        if ratings[i] > ratings[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n    return sum(candies)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
            "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
            "\ud83d\udca1 Right-to-left: same logic, take max."
          ],
          "code": "def candy(ratings):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.\n    - \ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.\n    - \ud83d\udca1 Right-to-left: same logic, take max.\n\n    Algorithm:\n    1. Init - Everyone gets 1.\n    2. Left - Left rule.\n    3. Right - Right rule.\n    \"\"\"\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):  # Iterate through the range.\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):  # Iterate through the range.\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Take the maximum value.\n    return sum(candies)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "trapping-rain-water": {
      "title": "Trapping Rain Water",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udca7",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
      "intuition": [
        "\ud83c\udfaf How much water can be trapped?",
        "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
        "\ud83d\udca1 Two pointers: move the smaller side inward."
      ],
      "testCases": [
        {
          "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
          "output": "6"
        },
        {
          "input": "height = [4,2,0,3,2,5]",
          "output": "9"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "l=0, r=n-1, maxL=maxR=0",
          "explanation": "Pointers."
        },
        {
          "step": 2,
          "title": "Compare",
          "visual": "Move smaller side",
          "explanation": "Bottleneck."
        },
        {
          "step": 3,
          "title": "Add",
          "visual": "water += max - height[i]",
          "explanation": "Accumulate."
        }
      ],
      "code": "def trap(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf How much water can be trapped?\n    - \ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.\n    - \ud83d\udca1 Two pointers: move the smaller side inward.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Bottleneck.\n    3. Add - Accumulate.\n    \"\"\"\n    if not height: return 0\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    leftMax, rightMax = height[l], height[r]\n    water = 0\n    while l < r:  # Continue until pointers meet.\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])  # Take the maximum value.\n            water += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])  # Take the maximum value.\n            water += rightMax - height[r]\n    return water",
      "keyInsight": "The smaller of leftMax/rightMax determines water level at current position.",
      "visualizationType": "array",
      "initialState": [
        0,
        1,
        0,
        2,
        1,
        0,
        1,
        3,
        2,
        1,
        2,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]",
          "transientMessage": "Initialize left=0, right=11",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 11
            }
          ],
          "indices": [
            0,
            11
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Update leftMax = 0",
          "transientMessage": "New left boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 11
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Update rightMax = 1",
          "transientMessage": "New right boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 11
            }
          ],
          "indices": [
            11
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update leftMax = 1",
          "transientMessage": "New left boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 10
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Trap 1 water at index 2",
          "transientMessage": "Total water: 1",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 10
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Update rightMax = 2",
          "transientMessage": "New right boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 10
            }
          ],
          "indices": [
            10
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Trap 1 water at index 9",
          "transientMessage": "Total water: 2",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 9
            }
          ],
          "indices": [
            9
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Update rightMax = 2",
          "transientMessage": "New right boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 8
            }
          ],
          "indices": [
            8
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Update leftMax = 2",
          "transientMessage": "New left boundary",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Trap 1 water at index 4",
          "transientMessage": "Total water: 3",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Trap 2 water at index 5",
          "transientMessage": "Total water: 5",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 5
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Trap 1 water at index 6",
          "transientMessage": "Total water: 6",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "L",
              "index": 6
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "Result: 6 units of water",
          "transientMessage": "Complete!",
          "arrayState": [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "examples": [
        {
          "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
          "output": "6",
          "explanation": "Water fills between bars."
        },
        {
          "input": "height = [4,2,0,3,2,5]",
          "output": "9",
          "explanation": "Water fills between 4,5 and intermediate bars."
        }
      ],
      "constraints": [
        "n == height.length",
        "1 <= n <= 2 * 10^4",
        "0 <= height[i] <= 10^5"
      ],
      "hints": [
        "Water at position i = min(maxLeft, maxRight) - height[i].",
        "Use two pointers from both ends.",
        "Or precompute maxLeft and maxRight arrays."
      ],
      "relatedProblems": [
        "container-with-most-water",
        "product-of-array-except-self",
        "trapping-rain-water-ii"
      ],
      "videoId": "ZI2z5pq0TqA",
      "problemStatement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "difficulty": "Hard",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
      "mentalModel": "Imagine filling a landscape with water. The water level is determined by the shortest enclosing wall.",
      "initialCode": "def trap(height):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def trap(height):\n    if not height: return 0\n    l, r = 0, len(height) - 1\n    leftMax, rightMax = height[l], height[r]\n    res = 0\n    while l < r:\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])\n            res += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])\n            res += rightMax - height[r]\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf How much water can be trapped?",
            "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
            "\ud83d\udca1 Two pointers: move the smaller side inward."
          ],
          "code": "def trap(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf How much water can be trapped?\n    - \ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.\n    - \ud83d\udca1 Two pointers: move the smaller side inward.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Bottleneck.\n    3. Add - Accumulate.\n    \"\"\"\n    if not height: return 0\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    leftMax, rightMax = height[l], height[r]\n    water = 0\n    while l < r:  # Continue until pointers meet.\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])  # Take the maximum value.\n            water += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])  # Take the maximum value.\n            water += rightMax - height[r]\n    return water"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "roman-to-integer": {
      "title": "Roman to Integer",
      "pattern": "Hash Map",
      "patternEmoji": "\ud83c\udfdb\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "If current < next, subtract; else add.",
      "intuition": [
        "\ud83c\udfaf Convert Roman numeral to integer.",
        "\ud83e\udde0 Map each symbol to value.",
        "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
      ],
      "testCases": [
        {
          "input": "s = \"III\"",
          "output": "3"
        },
        {
          "input": "s = \"LVIII\"",
          "output": "58"
        },
        {
          "input": "s = \"MCMXCIV\"",
          "output": "1994"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Map",
          "visual": "I=1, V=5, X=10...",
          "explanation": "Values."
        },
        {
          "step": 2,
          "title": "Scan",
          "visual": "Compare curr and next",
          "explanation": "Direction."
        },
        {
          "step": 3,
          "title": "Add/Sub",
          "visual": "Accumulate result",
          "explanation": "Total."
        }
      ],
      "code": "def romanToInt(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert Roman numeral to integer.\n    - \ud83e\udde0 Map each symbol to value.\n    - \ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add.\n\n    Algorithm:\n    1. Map - Values.\n    2. Scan - Direction.\n    3. Add/Sub - Total.\n    \"\"\"\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i in range(len(s)):  # Iterate through the range.\n        if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total",
      "keyInsight": "Subtraction happens when a smaller value precedes a larger one.",
      "visualizationType": "array",
      "initialState": [
        "M",
        "C",
        "M",
        "X",
        "C",
        "I",
        "V"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Roman: \"MCMXCIV\"",
          "transientMessage": "Convert to integer",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "M=1000",
          "transientMessage": "Add: result = 1000",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "+",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "C=100 < M=1000",
          "transientMessage": "Subtract: result = 900",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "-",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "M=1000",
          "transientMessage": "Add: result = 1900",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "+",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "X=10 < C=100",
          "transientMessage": "Subtract: result = 1890",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "-",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "C=100",
          "transientMessage": "Add: result = 1990",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "+",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "I=1 < V=5",
          "transientMessage": "Subtract: result = 1989",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "-",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "V=5",
          "transientMessage": "Add: result = 1994",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [
            {
              "label": "+",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Result: 1994",
          "transientMessage": "Complete!",
          "arrayState": [
            "M",
            "C",
            "M",
            "X",
            "C",
            "I",
            "V"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.",
      "examples": [
        {
          "input": "s = \"III\"",
          "output": "3",
          "explanation": "III = 1 + 1 + 1 = 3."
        },
        {
          "input": "s = \"LVIII\"",
          "output": "58",
          "explanation": "L = 50, V= 5, III = 3."
        },
        {
          "input": "s = \"MCMXCIV\"",
          "output": "1994",
          "explanation": "M = 1000, CM = 900, XC = 90, IV = 4."
        }
      ],
      "constraints": [
        "1 <= s.length <= 15",
        "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
        "It is guaranteed that s is a valid roman numeral."
      ],
      "hints": [
        "Create a mapping of symbols to values.",
        "If current < next, subtract current.",
        "Otherwise add current."
      ],
      "relatedProblems": [
        "integer-to-roman"
      ],
      "videoId": "3jdxYj3DD98",
      "problemStatement": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nGiven a roman numeral, convert it to an integer.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map: If current < next, subtract; else add.",
      "suggestedNextQuestion": {
        "slug": "two-sum",
        "title": "Two Sum",
        "difficulty": "Easy",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def romanToInt(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def romanToInt_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Convert Roman numeral to integer.",
            "\ud83e\udde0 Map each symbol to value.",
            "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
          ],
          "code": "def romanToInt(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert Roman numeral to integer.\n    - \ud83e\udde0 Map each symbol to value.\n    - \ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add.\n\n    Algorithm:\n    1. Map - Values.\n    2. Scan - Direction.\n    3. Add/Sub - Total.\n    \"\"\"\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i in range(len(s)):  # Iterate through the range.\n        if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "integer-to-roman": {
      "title": "Integer to Roman",
      "pattern": "Greedy",
      "patternEmoji": "\ud83c\udfdb\ufe0f",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "oneliner": "Greedily subtract largest possible value and append symbol.",
      "intuition": [
        "\ud83c\udfaf Convert integer to Roman numeral.",
        "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
        "\ud83d\udca1 Repeatedly subtract and append until num is 0."
      ],
      "testCases": [
        {
          "input": "num = 3749",
          "output": "\"MMMDCCXLIX\""
        },
        {
          "input": "num = 58",
          "output": "\"LVIII\""
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "List",
          "visual": "(1000,M), (900,CM)...",
          "explanation": "All values."
        },
        {
          "step": 2,
          "title": "Greed",
          "visual": "While num >= val: append",
          "explanation": "Subtract."
        },
        {
          "step": 3,
          "title": "Build",
          "visual": "Concatenate symbols",
          "explanation": "Result."
        }
      ],
      "code": "def intToRoman(num):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert integer to Roman numeral.\n    - \ud83e\udde0 Use a list of (value, symbol) pairs in descending order.\n    - \ud83d\udca1 Repeatedly subtract and append until num is 0.\n\n    Algorithm:\n    1. List - All values.\n    2. Greed - Subtract.\n    3. Build - Result.\n    \"\"\"\n    val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    res = []  # Initialize list to store results.\n    for val, sym in val_sym:  # Iterate over elements.\n        while num >= val:\n            res.append(sym)  # Add to end.\n            num -= val\n    return ''.join(res)",
      "keyInsight": "Include subtraction pairs (CM, CD, XC, etc.) in the lookup table.",
      "visualizationType": "array",
      "initialState": "3749",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Integer to Roman",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 7",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 4",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 9",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "3",
            "7",
            "4",
            "9"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Greedily subtract largest possible value and append symbol.\n\nConvert integer to Roman numeral.\nUse a list of (value, symbol) pairs in descending order.",
      "examples": [
        {
          "input": "num = 3749",
          "output": "\"MMMDCCXLIX\""
        },
        {
          "input": "num = 58",
          "output": "\"LVIII\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Convert integer to Roman numeral.",
        "Use a list of (value, symbol) pairs in descending order.",
        "Repeatedly subtract and append until num is 0."
      ],
      "relatedProblems": [
        "jump-game",
        "gas-station",
        "best-time-to-buy-and-sell-stock-ii"
      ],
      "videoId": "ohBNdSJyLh8",
      "problemStatement": "Seven different symbols represent Roman numerals with the following values:\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nGiven an integer, convert it to a Roman numeral.",
      "difficulty": "Medium",
      "walkthrough": [
        "Sort input if needed for optimal substructure",
        "Make locally optimal choice at each step",
        "Update state based on current choice",
        "Validate choice doesn't violate constraints",
        "Build solution incrementally"
      ],
      "approach": "Greedy: Greedily subtract largest possible value and append symbol.",
      "suggestedNextQuestion": {
        "slug": "jump-game",
        "title": "Jump Game",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def intToRoman(num):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def intToRoman(num):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n        ]\n    syb = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n        ]\n    roman_num = ''\n    i = 0\n    while  num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syb[i]\n            num -= val[i]\n        i += 1\n    return roman_num"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Convert integer to Roman numeral.",
            "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
            "\ud83d\udca1 Repeatedly subtract and append until num is 0."
          ],
          "code": "def intToRoman(num):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert integer to Roman numeral.\n    - \ud83e\udde0 Use a list of (value, symbol) pairs in descending order.\n    - \ud83d\udca1 Repeatedly subtract and append until num is 0.\n\n    Algorithm:\n    1. List - All values.\n    2. Greed - Subtract.\n    3. Build - Result.\n    \"\"\"\n    val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    res = []  # Initialize list to store results.\n    for val, sym in val_sym:  # Iterate over elements.\n        while num >= val:\n            res.append(sym)  # Add to end.\n            num -= val\n    return ''.join(res)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "length-of-last-word": {
      "title": "Length of Last Word",
      "pattern": "String Traversal",
      "patternEmoji": "\ud83d\udccf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Strip trailing spaces, find last space, return len - last_space - 1.",
      "intuition": [
        "\ud83c\udfaf Find length of last word.",
        "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
        "\ud83d\udca1 Or just use split()[-1]."
      ],
      "testCases": [
        {
          "input": "s = \"Hello World\"",
          "output": "5"
        },
        {
          "input": "s = \"   fly me   to   the moon  \"",
          "output": "4"
        },
        {
          "input": "s = \"luffy is still joyboy\"",
          "output": "6"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Trim",
          "visual": "Skip trailing spaces",
          "explanation": "Find word."
        },
        {
          "step": 2,
          "title": "Count",
          "visual": "Count until space",
          "explanation": "Length."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "Length = 5",
          "explanation": "Done."
        }
      ],
      "code": "def lengthOfLastWord(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find length of last word.\n    - \ud83e\udde0 Iterate from end, skip trailing spaces, count letters.\n    - \ud83d\udca1 Or just use split()[-1].\n\n    Algorithm:\n    1. Trim - Find word.\n    2. Count - Length.\n    3. Return - Done.\n    \"\"\"\n    return len(s.strip().split()[-1])  # Remove whitespace.",
      "keyInsight": "Python's split() handles multiple spaces elegantly.",
      "visualizationType": "array",
      "initialState": "Hello World",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Length of Last Word",
          "transientMessage": "Input: [H, e, l, l, o,  , W, o...]",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: H",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: e",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: l",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: l",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: o",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            "H",
            "e",
            "l",
            "l",
            "o",
            " ",
            "W",
            "o",
            "r",
            "l",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Strip trailing spaces, find last space, return len - last_space - 1.\n\nFind length of last word.\nIterate from end, skip trailing spaces, count letters.",
      "examples": [
        {
          "input": "s = \"Hello World\"",
          "output": "5"
        },
        {
          "input": "s = \"   fly me   to   the moon  \"",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find length of last word.",
        "Iterate from end, skip trailing spaces, count letters.",
        "Or just use split()[-1]."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "KT9rltZTybQ",
      "problemStatement": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "String Traversal: Strip trailing spaces, find last space, return len - last_space - 1.",
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "def lengthOfLastWord(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def lengthOfLastWord(s):\n    # Strip trailing spaces then split\n    words = s.strip().split(' ')\n    if not words: return 0\n    return len(words[-1])"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find length of last word.",
            "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
            "\ud83d\udca1 Or just use split()[-1]."
          ],
          "code": "def lengthOfLastWord(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find length of last word.\n    - \ud83e\udde0 Iterate from end, skip trailing spaces, count letters.\n    - \ud83d\udca1 Or just use split()[-1].\n\n    Algorithm:\n    1. Trim - Find word.\n    2. Count - Length.\n    3. Return - Done.\n    \"\"\"\n    return len(s.strip().split()[-1])  # Remove whitespace."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "longest-common-prefix": {
      "title": "Longest Common Prefix",
      "pattern": "Horizontal Scan",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(S)",
      "spaceComplexity": "O(1)",
      "oneliner": "Compare characters at same position across all strings.",
      "intuition": [
        "\ud83c\udfaf Find the longest common prefix among all strings.",
        "\ud83e\udde0 Iterate character by character.",
        "\ud83d\udca1 Stop when any string differs or ends."
      ],
      "testCases": [
        {
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "output": "\"fl\""
        },
        {
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "output": "\"\""
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Zip",
          "visual": "Compare columns",
          "explanation": "Char by char."
        },
        {
          "step": 2,
          "title": "Check",
          "visual": "All same?",
          "explanation": "Continue."
        },
        {
          "step": 3,
          "title": "Stop",
          "visual": "Mismatch found",
          "explanation": "Return prefix."
        }
      ],
      "code": "def longestCommonPrefix(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the longest common prefix among all strings.\n    - \ud83e\udde0 Iterate character by character.\n    - \ud83d\udca1 Stop when any string differs or ends.\n\n    Algorithm:\n    1. Zip - Char by char.\n    2. Check - Continue.\n    3. Stop - Return prefix.\n    \"\"\"\n    if not strs: return ''\n    for i in range(len(strs[0])):  # Iterate through the range.\n        char = strs[0][i]\n        for s in strs[1:]:  # Iterate over elements.\n            if i >= len(s) or s[i] != char:\n                return strs[0][:i]\n    return strs[0]",
      "keyInsight": "Vertical scanning is more efficient than horizontal pairwise comparison.",
      "visualizationType": "array",
      "initialState": [
        "flower",
        "flow",
        "flight"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Common Prefix",
          "transientMessage": "Input: [flower, flow, flight]",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: flower",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: flow",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: flight",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            "flower",
            "flow",
            "flight"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Compare characters at same position across all strings.\n\nFind the longest common prefix among all strings.\nIterate character by character.",
      "examples": [
        {
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "output": "\"fl\""
        },
        {
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "output": "\"\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find the longest common prefix among all strings.",
        "Iterate character by character.",
        "Stop when any string differs or ends."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "0sWShKIJoo4",
      "problemStatement": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Horizontal Scan: Compare characters at same position across all strings.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def longestCommonPrefix(strs):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def longestCommonPrefix(strs):\n    if not strs: return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(S)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find the longest common prefix among all strings.",
            "\ud83e\udde0 Iterate character by character.",
            "\ud83d\udca1 Stop when any string differs or ends."
          ],
          "code": "def longestCommonPrefix(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the longest common prefix among all strings.\n    - \ud83e\udde0 Iterate character by character.\n    - \ud83d\udca1 Stop when any string differs or ends.\n\n    Algorithm:\n    1. Zip - Char by char.\n    2. Check - Continue.\n    3. Stop - Return prefix.\n    \"\"\"\n    if not strs: return ''\n    for i in range(len(strs[0])):  # Iterate through the range.\n        char = strs[0][i]\n        for s in strs[1:]:  # Iterate over elements.\n            if i >= len(s) or s[i] != char:\n                return strs[0][:i]\n    return strs[0]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reverse-words-in-a-string": {
      "title": "Reverse Words in a String",
      "pattern": "Two Pointers / Split",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Split by spaces, reverse, join with single space.",
      "intuition": [
        "\ud83c\udfaf Reverse the order of words in a string.",
        "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
        "\ud83d\udca1 Handle leading/trailing/multiple spaces."
      ],
      "testCases": [
        {
          "input": "s = \"the sky is blue\"",
          "output": "\"blue is sky the\""
        },
        {
          "input": "s = \"  hello world  \"",
          "output": "\"world hello\""
        },
        {
          "input": "s = \"a good   example\"",
          "output": "\"example good a\""
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Split",
          "visual": "['the', 'sky', 'is', 'blue']",
          "explanation": "Tokenize."
        },
        {
          "step": 2,
          "title": "Reverse",
          "visual": "['blue', 'is', 'sky', 'the']",
          "explanation": "Flip order."
        },
        {
          "step": 3,
          "title": "Join",
          "visual": "'blue is sky the'",
          "explanation": "Combine."
        }
      ],
      "code": "def reverseWords(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse the order of words in a string.\n    - \ud83e\udde0 Split removes extra spaces, reverse list, join.\n    - \ud83d\udca1 Handle leading/trailing/multiple spaces.\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Reverse - Flip order.\n    3. Join - Combine.\n    \"\"\"\n    return ' '.join(s.split()[::-1])  # Split string into list.",
      "keyInsight": "Python's split() without args handles multiple spaces elegantly.",
      "visualizationType": "array",
      "initialState": "the sky is blue",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reverse Words in a String",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = t",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = h",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = e",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] =  ",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = s",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = k",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "t",
            "h",
            "e",
            " ",
            "s",
            "k",
            "y",
            " ",
            "i",
            "s",
            " ",
            "b",
            "l",
            "u",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Split by spaces, reverse, join with single space.\n\nReverse the order of words in a string.\nSplit removes extra spaces, reverse list, join.",
      "examples": [
        {
          "input": "s = \"the sky is blue\"",
          "output": "\"blue is sky the\""
        },
        {
          "input": "s = \"  hello world  \"",
          "output": "\"world hello\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Reverse the order of words in a string.",
        "Split removes extra spaces, reverse list, join.",
        "Handle leading/trailing/multiple spaces."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "vhnRAaJybpA",
      "problemStatement": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Pointers / Split: Split by spaces, reverse, join with single space.",
      "suggestedNextQuestion": {
        "slug": "squares-of-a-sorted-array",
        "title": "Squares of a Sorted Array",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def reverseWords(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def reverseWords(s):\n    # Split by whitespace and reverse list\n    return \" \".join(s.split()[::-1])"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Reverse the order of words in a string.",
            "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
            "\ud83d\udca1 Handle leading/trailing/multiple spaces."
          ],
          "code": "def reverseWords(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse the order of words in a string.\n    - \ud83e\udde0 Split removes extra spaces, reverse list, join.\n    - \ud83d\udca1 Handle leading/trailing/multiple spaces.\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Reverse - Flip order.\n    3. Join - Combine.\n    \"\"\"\n    return ' '.join(s.split()[::-1])  # Split string into list."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "zigzag-conversion": {
      "title": "Zigzag Conversion",
      "pattern": "Simulation",
      "patternEmoji": "\u26a1",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use row index and direction flag. Toggle direction at bounds.",
      "intuition": [
        "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
        "\ud83e\udde0 Track current row, direction (up/down).",
        "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
      ],
      "testCases": [
        {
          "input": "s = \"PAYPALISHIRING\", numRows = 3",
          "output": "\"PAHNAPLSIIGYIR\""
        },
        {
          "input": "s = \"PAYPALISHIRING\", numRows = 4",
          "output": "\"PINALSIGYAHRPI\""
        },
        {
          "input": "s = \"A\", numRows = 1",
          "output": "\"A\""
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "rows = [''] * numRows",
          "explanation": "Setup."
        },
        {
          "step": 2,
          "title": "Traverse",
          "visual": "Add char to row[i]",
          "explanation": "Fill."
        },
        {
          "step": 3,
          "title": "Direction",
          "visual": "Bounce at edges",
          "explanation": "Zigzag."
        }
      ],
      "code": "def convert(s, numRows):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Write string in zigzag pattern, read row by row.\n    - \ud83e\udde0 Track current row, direction (up/down).\n    - \ud83d\udca1 Flip direction at row 0 and row numRows-1.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Traverse - Fill.\n    3. Direction - Zigzag.\n    \"\"\"\n    if numRows == 1 or numRows >= len(s): return s\n    rows = [''] * numRows\n    idx, step = 0, 1\n    for c in s:  # Iterate over elements.\n        rows[idx] += c\n        if idx == 0: step = 1\n        elif idx == numRows - 1: step = -1\n        idx += step\n    return ''.join(rows)",
      "keyInsight": "The pattern is: go down until bottom, then go up until top, repeat.",
      "visualizationType": "array",
      "initialState": "PAYPALISHIRING",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Zigzag Conversion",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = P",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = A",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = Y",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = P",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = A",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = L",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "P",
            "A",
            "Y",
            "P",
            "A",
            "L",
            "I",
            "S",
            "H",
            "I",
            "R",
            "I",
            "N",
            "G"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use row index and direction flag. Toggle direction at bounds.\n\nWrite string in zigzag pattern, read row by row.\nTrack current row, direction (up/down).",
      "examples": [
        {
          "input": "s = \"PAYPALISHIRING\"; numRows = 3",
          "output": "\"PAHNAPLSIIGYIR\""
        },
        {
          "input": "s = \"PAYPALISHIRING\"; numRows = 4",
          "output": "\"PINALSIGYAHRPI\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Write string in zigzag pattern, read row by row.",
        "Track current row, direction (up/down).",
        "Flip direction at row 0 and row numRows-1."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Q2Tw6gcVEwc",
      "problemStatement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Simulation: Use row index and direction flag. Toggle direction at bounds.",
      "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
      "initialCode": "def convert(s, numRows):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def convert(s, numRows):\n    if numRows == 1 or numRows >= len(s):\n        return s\n    \n    L = [''] * numRows\n    index, step = 0, 1\n    for x in s:\n        L[index] += x\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n        \n    return ''.join(L)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
            "\ud83e\udde0 Track current row, direction (up/down).",
            "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
          ],
          "code": "def convert(s, numRows):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Write string in zigzag pattern, read row by row.\n    - \ud83e\udde0 Track current row, direction (up/down).\n    - \ud83d\udca1 Flip direction at row 0 and row numRows-1.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Traverse - Fill.\n    3. Direction - Zigzag.\n    \"\"\"\n    if numRows == 1 or numRows >= len(s): return s\n    rows = [''] * numRows\n    idx, step = 0, 1\n    for c in s:  # Iterate over elements.\n        rows[idx] += c\n        if idx == 0: step = 1\n        elif idx == numRows - 1: step = -1\n        idx += step\n    return ''.join(rows)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "find-the-index-of-the-first-occurrence-in-a-string": {
      "title": "Find the Index of the First Occurrence in a String",
      "pattern": "KMP / Simple Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(n*m)",
      "spaceComplexity": "O(1)",
      "oneliner": "Slide needle over haystack, check for match.",
      "intuition": [
        "\ud83c\udfaf Find first occurrence of needle in haystack.",
        "\ud83e\udde0 Simple: check each starting position.",
        "\ud83d\udca1 Or use Python's built-in find()."
      ],
      "testCases": [
        {
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "output": "0"
        },
        {
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "output": "-1"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Slide",
          "visual": "Check each position",
          "explanation": "Linear scan."
        },
        {
          "step": 2,
          "title": "Match",
          "visual": "Compare substring",
          "explanation": "Check."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "Index or -1",
          "explanation": "Result."
        }
      ],
      "code": "def strStr(haystack, needle):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find first occurrence of needle in haystack.\n    - \ud83e\udde0 Simple: check each starting position.\n    - \ud83d\udca1 Or use Python's built-in find().\n\n    Algorithm:\n    1. Slide - Linear scan.\n    2. Match - Check.\n    3. Return - Result.\n    \"\"\"\n    return haystack.find(needle)  # Find index of substring.",
      "keyInsight": "Python's find() is optimized. For interviews, show manual sliding window.",
      "visualizationType": "array",
      "initialState": "sadbutsad",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find the Index of the First Occurrence in a String",
          "transientMessage": "Input: [s, a, d, b, u, t, s, a...]",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: s",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: a",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: d",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: b",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: u",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            "s",
            "a",
            "d",
            "b",
            "u",
            "t",
            "s",
            "a",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Slide needle over haystack, check for match.\n\nFind first occurrence of needle in haystack.\nSimple: check each starting position.",
      "examples": [
        {
          "input": "haystack = \"sadbutsad\"; needle = \"sad\"",
          "output": "0"
        },
        {
          "input": "haystack = \"leetcode\"; needle = \"leeto\"",
          "output": "-1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find first occurrence of needle in haystack.",
        "Simple: check each starting position.",
        "Or use Python's built-in find()."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "JoF0Z7nVSrA",
      "problemStatement": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "KMP / Simple Search: Slide needle over haystack, check for match.",
      "mentalModel": "Like looking for a needle in a haystack.",
      "initialCode": "def strStr(haystack, needle):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def strStr(haystack, needle):\n    # Built-in find is brute force optimized or KMP\n    return haystack.find(needle)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n*m)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find first occurrence of needle in haystack.",
            "\ud83e\udde0 Simple: check each starting position.",
            "\ud83d\udca1 Or use Python's built-in find()."
          ],
          "code": "def strStr(haystack, needle):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find first occurrence of needle in haystack.\n    - \ud83e\udde0 Simple: check each starting position.\n    - \ud83d\udca1 Or use Python's built-in find().\n\n    Algorithm:\n    1. Slide - Linear scan.\n    2. Match - Check.\n    3. Return - Result.\n    \"\"\"\n    return haystack.find(needle)  # Find index of substring."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "text-justification": {
      "title": "Text Justification",
      "pattern": "Greedy + Simulation",
      "patternEmoji": "\ud83d\udcdd",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Greedily pack words, distribute spaces evenly. Left-justify last line.",
      "intuition": [
        "\ud83c\udfaf Fully justify text to maxWidth.",
        "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
        "\ud83d\udca1 Last line: left-justified."
      ],
      "testCases": [
        {
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "output": "[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]"
        },
        {
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "output": "[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]"
        },
        {
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "output": "[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Pack",
          "visual": "Greedy word fit",
          "explanation": "Fill line."
        },
        {
          "step": 2,
          "title": "Space",
          "visual": "Distribute evenly",
          "explanation": "Justify."
        },
        {
          "step": 3,
          "title": "Last",
          "visual": "Left align",
          "explanation": "Special case."
        }
      ],
      "code": "def fullJustify(words, maxWidth):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Fully justify text to maxWidth.\n    - \ud83e\udde0 Pack as many words as fit, distribute extra spaces.\n    - \ud83d\udca1 Last line: left-justified.\n\n    Algorithm:\n    1. Pack - Fill line.\n    2. Space - Justify.\n    3. Last - Special case.\n    \"\"\"\n    res, line, width = [], [], 0\n    for w in words:  # Iterate over elements.\n        if width + len(w) + len(line) > maxWidth:\n            for i in range(maxWidth - width):  # Iterate through the range.\n                line[i % (len(line) - 1 or 1)] += ' '\n            res.append(''.join(line))  # Add to end.\n            line, width = [], 0\n        line.append(w)  # Add to end.\n        width += len(w)\n    return res + [' '.join(line).ljust(maxWidth)]  # Return the final result.",
      "keyInsight": "Distribute extra spaces using modulo for even distribution.",
      "visualizationType": "array",
      "initialState": [
        "This",
        "is",
        "an",
        "example"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Text Justification",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = This",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = is",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = an",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = example",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "This",
            "is",
            "an",
            "example"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Greedily pack words, distribute spaces evenly. Left-justify last line.\n\nFully justify text to maxWidth.\nPack as many words as fit, distribute extra spaces.",
      "examples": [
        {
          "input": "words = [\"This\", \"is\", \"an\", \"example\"]; maxWidth = 16",
          "output": "[\"This    is    an\", \"example         \"]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Fully justify text to maxWidth.",
        "Pack as many words as fit, distribute extra spaces.",
        "Last line: left-justified."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "TzMl4Z7pVh8",
      "problemStatement": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Greedy + Simulation: Greedily pack words, distribute spaces evenly. Left-justify last line.",
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def fullJustify(words, maxWidth):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def fullJustify(words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            for i in range(maxWidth - num_of_letters):\n                cur[i % (len(cur) - 1 or 1)] += ' '\n            res.append(''.join(cur))\n            cur, num_of_letters = [], 0\n        cur.append(w)\n        num_of_letters += len(w)\n    return res + [' '.join(cur).ljust(maxWidth)]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Fully justify text to maxWidth.",
            "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
            "\ud83d\udca1 Last line: left-justified."
          ],
          "code": "def fullJustify(words, maxWidth):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Fully justify text to maxWidth.\n    - \ud83e\udde0 Pack as many words as fit, distribute extra spaces.\n    - \ud83d\udca1 Last line: left-justified.\n\n    Algorithm:\n    1. Pack - Fill line.\n    2. Space - Justify.\n    3. Last - Special case.\n    \"\"\"\n    res, line, width = [], [], 0\n    for w in words:  # Iterate over elements.\n        if width + len(w) + len(line) > maxWidth:\n            for i in range(maxWidth - width):  # Iterate through the range.\n                line[i % (len(line) - 1 or 1)] += ' '\n            res.append(''.join(line))  # Add to end.\n            line, width = [], 0\n        line.append(w)  # Add to end.\n        width += len(w)\n    return res + [' '.join(line).ljust(maxWidth)]  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "find-all-numbers-disappeared-in-an-array": {
      "title": "Find All Numbers Disappeared in an Array",
      "pattern": "Index Marking",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Mark visited indices negative. Return indices still positive.",
      "intuition": [
        "\ud83c\udfaf Find numbers 1..n missing from array.",
        "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
        "\ud83d\udca1 Positive indices indicate missing numbers."
      ],
      "testCases": [
        {
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "output": "[5,6]"
        },
        {
          "input": "nums = [1,1]",
          "output": "[2]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Mark",
          "visual": "Negate at index",
          "explanation": "Seen."
        },
        {
          "step": 2,
          "title": "Scan",
          "visual": "Find positives",
          "explanation": "Missing."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "[5, 6]",
          "explanation": "Result."
        }
      ],
      "code": "def findDisappearedNumbers(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find numbers 1..n missing from array.\n    - \ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].\n    - \ud83d\udca1 Positive indices indicate missing numbers.\n\n    Algorithm:\n    1. Mark - Seen.\n    2. Scan - Missing.\n    3. Return - Result.\n    \"\"\"\n    for n in nums:  # Iterate over elements.\n        idx = abs(n) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i, n in enumerate(nums) if n > 0]",
      "keyInsight": "Using array indices as a hash set avoids extra space.",
      "visualizationType": "array",
      "initialState": [
        4,
        3,
        2,
        7,
        8,
        2,
        3,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find All Numbers Disappeared in an Array",
          "transientMessage": "Input: [4, 3, 2, 7, 8, 2, 3, 1]",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 4",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 3",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 2",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 7",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 8",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            4,
            3,
            2,
            7,
            8,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Mark visited indices negative. Return indices still positive.\n\nFind numbers 1..n missing from array.\nUse indices as markers: negate nums[nums[i]-1].",
      "examples": [
        {
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "output": "[5,6]"
        },
        {
          "input": "nums = [1,1]",
          "output": "[2]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find numbers 1..n missing from array.",
        "Use indices as markers: negate nums[nums[i]-1].",
        "Positive indices indicate missing numbers."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "8i-f24YFWC4",
      "problemStatement": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Index Marking: Mark visited indices negative. Return indices still positive.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def findDisappearedNumbers(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findDisappearedNumbers(nums):\n    # Mark existing\n    for n in nums:\n        idx = abs(n) - 1\n        if nums[idx] > 0:\n            nums[idx] *= -1\n    return [i + 1 for i, n in enumerate(nums) if n > 0]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find numbers 1..n missing from array.",
            "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
            "\ud83d\udca1 Positive indices indicate missing numbers."
          ],
          "code": "def findDisappearedNumbers(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find numbers 1..n missing from array.\n    - \ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].\n    - \ud83d\udca1 Positive indices indicate missing numbers.\n\n    Algorithm:\n    1. Mark - Seen.\n    2. Scan - Missing.\n    3. Return - Result.\n    \"\"\"\n    for n in nums:  # Iterate over elements.\n        idx = abs(n) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i, n in enumerate(nums) if n > 0]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "is-subsequence": {
      "title": "Is Subsequence",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc46\ud83d\udc46",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use pointer for s, advance when char matches in t.",
      "intuition": [
        "\ud83c\udfaf Is s a subsequence of t?",
        "\ud83e\udde0 Two pointers: advance s pointer on match.",
        "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
      ],
      "testCases": [
        {
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "output": "true"
        },
        {
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "i=0, j=0",
          "explanation": "Pointers."
        },
        {
          "step": 2,
          "title": "Match",
          "visual": "s[i]==t[j]? i++",
          "explanation": "Advance."
        },
        {
          "step": 3,
          "title": "Check",
          "visual": "i == len(s)?",
          "explanation": "Result."
        }
      ],
      "code": "def isSubsequence(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is s a subsequence of t?\n    - \ud83e\udde0 Two pointers: advance s pointer on match.\n    - \ud83d\udca1 If s pointer reaches end, it's a subsequence.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Match - Advance.\n    3. Check - Result.\n    \"\"\"\n    i = 0\n    for c in t:  # Iterate over elements.\n        if i < len(s) and c == s[i]:\n            i += 1\n    return i == len(s)",
      "keyInsight": "Characters must appear in order but not necessarily contiguous.",
      "visualizationType": "array",
      "initialState": [
        "a",
        "h",
        "b",
        "g",
        "d",
        "c"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "s=\"abc\", t=\"ahbgdc\"",
          "transientMessage": "Two pointer approach",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "s[0]='a' == t[0]='a'",
          "transientMessage": "Match! Move both pointers",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "s",
              "index": 0
            },
            {
              "label": "t",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "s[1]='b' != t[1]='h'",
          "transientMessage": "No match, move t pointer",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "t",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "s[1]='b' == t[2]='b'",
          "transientMessage": "Match! Move both pointers",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "s",
              "index": 1
            },
            {
              "label": "t",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "s[2]='c' != t[3]='g'",
          "transientMessage": "No match, move t pointer",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "t",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "s[2]='c' != t[4]='d'",
          "transientMessage": "No match, move t pointer",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "t",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "s[2]='c' == t[5]='c'",
          "transientMessage": "Match! Move both pointers",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [
            {
              "label": "s",
              "index": 2
            },
            {
              "label": "t",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Result: true",
          "transientMessage": "All chars found!",
          "arrayState": [
            "a",
            "h",
            "b",
            "g",
            "d",
            "c"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use pointer for s, advance when char matches in t.\n\nIs s a subsequence of t?\nTwo pointers: advance s pointer on match.",
      "examples": [
        {
          "input": "s = \"abc\"; t = \"ahbgdc\"",
          "output": "true"
        },
        {
          "input": "s = \"axc\"; t = \"ahbgdc\"",
          "output": "false"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Is s a subsequence of t?",
        "Two pointers: advance s pointer on match.",
        "If s pointer reaches end, it's a subsequence."
      ],
      "relatedProblems": [
        "two-sum",
        "container-with-most-water",
        "3sum"
      ],
      "videoId": "99RVfqklbCE",
      "problemStatement": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Use pointer for s, advance when char matches in t.",
      "suggestedNextQuestion": {
        "slug": "linked-list-cycle",
        "title": "Linked List Cycle",
        "difficulty": "Easy",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def isSubsequence(s, t):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def isSubsequence(s, t):\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n    return i == len(s)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Is s a subsequence of t?",
            "\ud83e\udde0 Two pointers: advance s pointer on match.",
            "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
          ],
          "code": "def isSubsequence(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is s a subsequence of t?\n    - \ud83e\udde0 Two pointers: advance s pointer on match.\n    - \ud83d\udca1 If s pointer reaches end, it's a subsequence.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Match - Advance.\n    3. Check - Result.\n    \"\"\"\n    i = 0\n    for c in t:  # Iterate over elements.\n        if i < len(s) and c == s[i]:\n            i += 1\n    return i == len(s)"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "container-with-most-water": {
      "title": "Container With Most Water",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udca7",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Two pointers from ends. Move the shorter one inward.",
      "intuition": [
        "\ud83c\udfaf Maximize water container area.",
        "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
        "\ud83d\udca1 Moving shorter line could find taller one."
      ],
      "testCases": [
        {
          "input": "height = [1,8,6,2,5,4,8,3,7]",
          "output": "49"
        },
        {
          "input": "height = [1,1]",
          "output": "1"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "l=0, r=n-1",
          "explanation": "Max width."
        },
        {
          "step": 2,
          "title": "Area",
          "visual": "min * width",
          "explanation": "Calculate."
        },
        {
          "step": 3,
          "title": "Move",
          "visual": "Shorter side",
          "explanation": "Optimize."
        }
      ],
      "code": "def maxArea(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize water container area.\n    - \ud83e\udde0 Area = min(height[l], height[r]) * (r - l).\n    - \ud83d\udca1 Moving shorter line could find taller one.\n\n    Algorithm:\n    1. Init - Max width.\n    2. Area - Calculate.\n    3. Move - Optimize.\n    \"\"\"\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    maxA = 0\n    while l < r:  # Continue until pointers meet.\n        area = min(height[l], height[r]) * (r - l)  # Take the minimum value.\n        maxA = max(maxA, area)  # Take the maximum value.\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return maxA",
      "keyInsight": "Moving the taller line can never increase area (width decreases, height capped).",
      "visualizationType": "array",
      "initialState": [
        1,
        8,
        6,
        2,
        5,
        4,
        8,
        3,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [1, 8, 6, 2, 5, 4, 8, 3, 7]",
          "transientMessage": "Initialize left=0, right=8",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 8
            }
          ],
          "indices": [
            0,
            8
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "height=1, width=8, area=8",
          "transientMessage": "New max area: 8",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 8
            }
          ],
          "indices": [
            0,
            8
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "left[0]=1 < right[8]=7",
          "transientMessage": "Move left pointer right",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 8
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "height=8, width=7, area=49",
          "transientMessage": "New max area: 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 8
            }
          ],
          "indices": [
            1,
            8
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "left[1]=8 >= right[8]=7",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            7
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "height=8, width=6, area=18",
          "transientMessage": "Area 18 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 7
            }
          ],
          "indices": [
            1,
            7
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "left[1]=8 >= right[7]=3",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "height=8, width=5, area=40",
          "transientMessage": "Area 40 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            1,
            6
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "left[1]=8 >= right[6]=8",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "height=8, width=4, area=16",
          "transientMessage": "Area 16 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            1,
            5
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "left[1]=8 >= right[5]=4",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "height=8, width=3, area=15",
          "transientMessage": "Area 15 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 4
            }
          ],
          "indices": [
            1,
            4
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "left[1]=8 >= right[4]=5",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 14,
          "visual": "height=8, width=2, area=4",
          "transientMessage": "Area 4 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 3
            }
          ],
          "indices": [
            1,
            3
          ],
          "color": "accent"
        },
        {
          "step": 15,
          "visual": "left[1]=8 >= right[3]=2",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 16,
          "visual": "height=8, width=1, area=6",
          "transientMessage": "Area 6 < max 49",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 17,
          "visual": "left[1]=8 >= right[2]=6",
          "transientMessage": "Move right pointer left",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 18,
          "visual": "Result: 49",
          "transientMessage": "Pointers crossed - Maximum area found!",
          "arrayState": [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Two pointers from ends. Move the shorter one inward.\n\nMaximize water container area.\nArea = min(height[l], height[r]) * (r - l).",
      "examples": [
        {
          "input": "height = [1,8,6,2,5,4,8,3,7]",
          "output": "49"
        },
        {
          "input": "height = [1,1]",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Maximize water container area.",
        "Area = min(height[l], height[r]) * (r - l).",
        "Moving shorter line could find taller one."
      ],
      "relatedProblems": [
        "two-sum",
        "3sum"
      ],
      "videoId": "UuiTKBwPgAo",
      "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Two pointers from ends. Move the shorter one inward.",
      "suggestedNextQuestion": {
        "slug": "find-the-duplicate-number",
        "title": "Find The Duplicate Number",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def maxArea(height):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def maxArea(height):\n    l, r = 0, len(height) - 1\n    res = 0\n    while l < r:\n        area = (r - l) * min(height[l], height[r])\n        res = max(res, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Maximize water container area.",
            "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
            "\ud83d\udca1 Moving shorter line could find taller one."
          ],
          "code": "def maxArea(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize water container area.\n    - \ud83e\udde0 Area = min(height[l], height[r]) * (r - l).\n    - \ud83d\udca1 Moving shorter line could find taller one.\n\n    Algorithm:\n    1. Init - Max width.\n    2. Area - Calculate.\n    3. Move - Optimize.\n    \"\"\"\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    maxA = 0\n    while l < r:  # Continue until pointers meet.\n        area = min(height[l], height[r]) * (r - l)  # Take the minimum value.\n        maxA = max(maxA, area)  # Take the maximum value.\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return maxA"
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "3sum": {
      "title": "3Sum",
      "pattern": "Two Pointers + Sort",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(1)",
      "oneliner": "Sort, fix one element, two-pointer for remaining two.",
      "intuition": [
        "\ud83c\udfaf Find all triplets summing to 0.",
        "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
        "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
      ],
      "testCases": [
        {
          "input": "nums = [-1,0,1,2,-1,-4]",
          "output": "[[-1,-1,2],[-1,0,1]]"
        },
        {
          "input": "nums = [0,1,1]",
          "output": "[]"
        },
        {
          "input": "nums = [0,0,0]",
          "output": "[[0,0,0]]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Sort",
          "visual": "[-4,-1,-1,0,1,2]",
          "explanation": "Order matters."
        },
        {
          "step": 2,
          "title": "Fix",
          "visual": "i = 0",
          "explanation": "First element."
        },
        {
          "step": 3,
          "title": "Two Ptr",
          "visual": "l, r narrow",
          "explanation": "Find complement."
        }
      ],
      "code": "def threeSum(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all triplets summing to 0.\n    - \ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].\n    - \ud83d\udca1 Skip duplicates to avoid duplicate triplets.\n\n    Algorithm:\n    1. Sort - Order matters.\n    2. Fix - First element.\n    3. Two Ptr - Find complement.\n    \"\"\"\n    nums.sort()\n    res = []  # Initialize list to store results.\n    for i in range(len(nums) - 2):  # Iterate through the range.\n        if i > 0 and nums[i] == nums[i - 1]: continue\n        l, r = i + 1, len(nums) - 1  # Initialize two pointers.\n        while l < r:  # Continue until pointers meet.\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])  # Add to end.\n                while l < r and nums[l] == nums[l + 1]: l += 1\n                while l < r and nums[r] == nums[r - 1]: r -= 1\n                l, r = l + 1, r - 1  # Initialize two pointers.\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res  # Return the final result.",
      "keyInsight": "Sorting enables two-pointer approach and duplicate skipping.",
      "visualizationType": "array",
      "initialState": [
        -1,
        0,
        1,
        2,
        -1,
        -4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [-1, 0, 1, 2, -1, -4]",
          "transientMessage": "Initialize left=0, right=5",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            5
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Fix arr[0]=-1, left=1, right=5",
          "transientMessage": "Start two-pointer search",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            1,
            5
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "-1 + 0 + -4 = -5",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            1,
            5
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "-1 + 1 + -4 = -4",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            2,
            5
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "-1 + 2 + -4 = -3",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            3,
            5
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "-1 + -1 + -4 = -6",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            },
            {
              "label": "L",
              "index": 4
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            4,
            5
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Fix arr[1]=0, left=2, right=5",
          "transientMessage": "Start two-pointer search",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            1,
            2,
            5
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "0 + 1 + -4 = -3",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "L",
              "index": 2
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            1,
            2,
            5
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "0 + 2 + -4 = -2",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            1,
            3,
            5
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "0 + -1 + -4 = -5",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "L",
              "index": 4
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            1,
            4,
            5
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Fix arr[2]=1, left=3, right=5",
          "transientMessage": "Start two-pointer search",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            },
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            2,
            3,
            5
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "1 + 2 + -4 = -1",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            },
            {
              "label": "L",
              "index": 3
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            2,
            3,
            5
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "1 + -1 + -4 = -4",
          "transientMessage": "Sum < 0, move left right",
          "arrayState": [
            -1,
            0,
            1,
            2,
            -1,
            -4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            },
            {
              "label": "L",
              "index": 4
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            2,
            4,
            5
          ],
          "color": "accent"
        }
      ],
      "description": "Sort, fix one element, two-pointer for remaining two.\n\nFind all triplets summing to 0.\nSort array. For each i, use two pointers on [i+1, n-1].",
      "examples": [
        {
          "input": "nums = [-1,0,1,2,-1,-4]",
          "output": "[[-1,-1,2],[-1,0,1]]"
        },
        {
          "input": "nums = [0,1,1]",
          "output": "[]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find all triplets summing to 0.",
        "Sort array. For each i, use two pointers on [i+1, n-1].",
        "Skip duplicates to avoid duplicate triplets."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "jzZsG8n2R9A",
      "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Pointers + Sort: Sort, fix one element, two-pointer for remaining two.",
      "suggestedNextQuestion": {
        "slug": "container-with-most-water",
        "title": "Container With Most Water",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def threeSum(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def threeSum(nums):\n    res = []\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0:\n                l += 1\n            elif s > 0:\n                r -= 1\n            else:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]:\n                    l += 1\n                while l < r and nums[r] == nums[r-1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find all triplets summing to 0.",
            "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
            "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
          ],
          "code": "def threeSum(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all triplets summing to 0.\n    - \ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].\n    - \ud83d\udca1 Skip duplicates to avoid duplicate triplets.\n\n    Algorithm:\n    1. Sort - Order matters.\n    2. Fix - First element.\n    3. Two Ptr - Find complement.\n    \"\"\"\n    nums.sort()\n    res = []  # Initialize list to store results.\n    for i in range(len(nums) - 2):  # Iterate through the range.\n        if i > 0 and nums[i] == nums[i - 1]: continue\n        l, r = i + 1, len(nums) - 1  # Initialize two pointers.\n        while l < r:  # Continue until pointers meet.\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])  # Add to end.\n                while l < r and nums[l] == nums[l + 1]: l += 1\n                while l < r and nums[r] == nums[r - 1]: r -= 1\n                l, r = l + 1, r - 1  # Initialize two pointers.\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "squares-of-a-sorted-array": {
      "title": "Squares of a Sorted Array",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udcd0",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Compare absolute values at ends, place larger square at end of result.",
      "intuition": [
        "\ud83c\udfaf Square each element, return sorted array.",
        "\ud83e\udde0 Largest squares at ends (negative or positive).",
        "\ud83d\udca1 Two pointers from ends, fill result from back."
      ],
      "testCases": [
        {
          "input": "nums = [-4,-1,0,3,10]",
          "output": "[0,1,9,16,100]"
        },
        {
          "input": "nums = [-7,-3,2,3,11]",
          "output": "[4,9,9,49,121]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Init",
          "visual": "l=0, r=n-1, pos=n-1",
          "explanation": "Pointers."
        },
        {
          "step": 2,
          "title": "Compare",
          "visual": "|nums[l]| vs |nums[r]|",
          "explanation": "Larger abs."
        },
        {
          "step": 3,
          "title": "Fill",
          "visual": "res[pos] = square",
          "explanation": "From back."
        }
      ],
      "code": "def sortedSquares(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Square each element, return sorted array.\n    - \ud83e\udde0 Largest squares at ends (negative or positive).\n    - \ud83d\udca1 Two pointers from ends, fill result from back.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Larger abs.\n    3. Fill - From back.\n    \"\"\"\n    n = len(nums)\n    res = [0] * n\n    l, r = 0, n - 1  # Initialize two pointers.\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            res[pos] = nums[l] ** 2\n            l += 1\n        else:\n            res[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return res  # Return the final result.",
      "keyInsight": "The largest absolute value is always at one of the ends.",
      "visualizationType": "array",
      "initialState": [
        -4,
        -1,
        0,
        3,
        10
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Squares of a Sorted Array",
          "transientMessage": "Input: [-4, -1, 0, 3, 10]",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: -4",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: -1",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 0",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 3",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 10",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            -4,
            -1,
            0,
            3,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Compare absolute values at ends, place larger square at end of result.\n\nSquare each element, return sorted array.\nLargest squares at ends (negative or positive).",
      "examples": [
        {
          "input": "nums = [-4,-1,0,3,10]",
          "output": "[0,1,9,16,100]"
        },
        {
          "input": "nums = [-7,-3,2,3,11]",
          "output": "[4,9,9,49,121]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Square each element, return sorted array.",
        "Largest squares at ends (negative or positive).",
        "Two pointers from ends, fill result from back."
      ],
      "relatedProblems": [
        "two-sum",
        "container-with-most-water",
        "3sum"
      ],
      "videoId": "FPCZsG_AkUg",
      "problemStatement": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Compare absolute values at ends, place larger square at end of result.",
      "suggestedNextQuestion": {
        "slug": "time-needed-to-buy-tickets",
        "title": "Time Needed to Buy Tickets",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def sortedSquares(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def sortedSquares(nums):\n    return sorted(x*x for x in nums)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Square each element, return sorted array.",
            "\ud83e\udde0 Largest squares at ends (negative or positive).",
            "\ud83d\udca1 Two pointers from ends, fill result from back."
          ],
          "code": "def sortedSquares(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Square each element, return sorted array.\n    - \ud83e\udde0 Largest squares at ends (negative or positive).\n    - \ud83d\udca1 Two pointers from ends, fill result from back.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Larger abs.\n    3. Fill - From back.\n    \"\"\"\n    n = len(nums)\n    res = [0] * n\n    l, r = 0, n - 1  # Initialize two pointers.\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            res[pos] = nums[l] ** 2\n            l += 1\n        else:\n            res[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "longest-mountain-in-array": {
      "title": "Longest Mountain in Array",
      "pattern": "Two Pointers / Expand",
      "patternEmoji": "\ud83c\udfd4\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
      "intuition": [
        "\ud83c\udfaf Find longest mountain subarray (up then down).",
        "\ud83e\udde0 At each peak, extend left and right.",
        "\ud83d\udca1 Mountain needs at least 3 elements."
      ],
      "testCases": [
        {
          "input": "arr = [2,1,4,7,3,2,5]",
          "output": "5"
        },
        {
          "input": "arr = [2,2,2]",
          "output": "0"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Find Peak",
          "visual": "arr[i-1] < arr[i] > arr[i+1]",
          "explanation": "Locate."
        },
        {
          "step": 2,
          "title": "Expand",
          "visual": "Left and right",
          "explanation": "Extend."
        },
        {
          "step": 3,
          "title": "Length",
          "visual": "right - left + 1",
          "explanation": "Calculate."
        }
      ],
      "code": "def longestMountain(arr):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest mountain subarray (up then down).\n    - \ud83e\udde0 At each peak, extend left and right.\n    - \ud83d\udca1 Mountain needs at least 3 elements.\n\n    Algorithm:\n    1. Find Peak - Locate.\n    2. Expand - Extend.\n    3. Length - Calculate.\n    \"\"\"\n    n = len(arr)\n    res = 0  # Initialize result variable.\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            l = i - 1\n            while l > 0 and arr[l - 1] < arr[l]: l -= 1\n            r = i + 1\n            while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n            res = max(res, r - l + 1)  # Take the maximum value.\n            i = r\n        else:\n            i += 1\n    return res  # Return the final result.",
      "keyInsight": "After finding a mountain, skip to the end of the downhill.",
      "visualizationType": "array",
      "initialState": [
        2,
        1,
        4,
        7,
        3,
        2,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Mountain in Array",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            2,
            1,
            4,
            7,
            3,
            2,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 2",
          "arrayState": [
            2,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 1",
          "arrayState": [
            2,
            1,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            1,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 4",
          "arrayState": [
            2,
            1,
            4,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            2,
            1,
            4,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 7",
          "arrayState": [
            2,
            1,
            4,
            7,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            2,
            1,
            4,
            7,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 3",
          "arrayState": [
            2,
            1,
            4,
            7,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            2,
            1,
            4,
            7,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            2,
            1,
            4,
            7,
            3,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            1,
            4,
            7,
            3,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).\n\nFind longest mountain subarray (up then down).\nAt each peak, extend left and right.",
      "examples": [
        {
          "input": "arr = [2,1,4,7,3,2,5]",
          "output": "5"
        },
        {
          "input": "arr = [2,2,2]",
          "output": "0"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find longest mountain subarray (up then down).",
        "At each peak, extend left and right.",
        "Mountain needs at least 3 elements."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "rh2Bkul2zzQ",
      "problemStatement": "You may recall that an array arr is a mountain array if and only if:\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Pointers / Expand: Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
      "suggestedNextQuestion": {
        "slug": "meeting-rooms-ii",
        "title": "Meeting Rooms II",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def longestMountain(arr):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def longestMountain(arr):\n    res = 0\n    up = down = 0\n    for i in range(1, len(arr)):\n        if down and arr[i-1] < arr[i] or arr[i-1] == arr[i]:\n            up = down = 0\n        if arr[i-1] < arr[i]:\n            up += 1\n        if arr[i-1] > arr[i]:\n            down += 1\n        if up and down:\n            res = max(res, up + down + 1)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find longest mountain subarray (up then down).",
            "\ud83e\udde0 At each peak, extend left and right.",
            "\ud83d\udca1 Mountain needs at least 3 elements."
          ],
          "code": "def longestMountain(arr):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest mountain subarray (up then down).\n    - \ud83e\udde0 At each peak, extend left and right.\n    - \ud83d\udca1 Mountain needs at least 3 elements.\n\n    Algorithm:\n    1. Find Peak - Locate.\n    2. Expand - Extend.\n    3. Length - Calculate.\n    \"\"\"\n    n = len(arr)\n    res = 0  # Initialize result variable.\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            l = i - 1\n            while l > 0 and arr[l - 1] < arr[l]: l -= 1\n            r = i + 1\n            while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n            res = max(res, r - l + 1)  # Take the maximum value.\n            i = r\n        else:\n            i += 1\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "delete-node-in-a-bst": {
      "title": "Delete Node in a BST",
      "pattern": "BST Traversal",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(h)",
      "spaceComplexity": "O(h)",
      "oneliner": "Find node, replace with successor (leftmost in right subtree).",
      "intuition": [
        "\ud83c\udfaf Delete node with given key from BST.",
        "\ud83e\udde0 Three cases: leaf, one child, two children.",
        "\ud83d\udca1 Two children: replace with inorder successor."
      ],
      "testCases": [
        {
          "input": "root = [5,3,6,2,4,null,7], key = 3",
          "output": "[5,4,6,2,null,null,7]"
        },
        {
          "input": "root = [5,3,6,2,4,null,7], key = 0",
          "output": "[5,3,6,2,4,null,7]"
        },
        {
          "input": "root = [], key = 0",
          "output": "[]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Find",
          "visual": "BST search",
          "explanation": "Locate node."
        },
        {
          "step": 2,
          "title": "Delete",
          "visual": "Handle cases",
          "explanation": "Remove."
        },
        {
          "step": 3,
          "title": "Replace",
          "visual": "Successor",
          "explanation": "Maintain BST."
        }
      ],
      "code": "def deleteNode(root, key):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Delete node with given key from BST.\n    - \ud83e\udde0 Three cases: leaf, one child, two children.\n    - \ud83d\udca1 Two children: replace with inorder successor.\n\n    Algorithm:\n    1. Find - Locate node.\n    2. Delete - Remove.\n    3. Replace - Maintain BST.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Find successor\n        succ = root.right\n        while succ.left: succ = succ.left\n        root.val = succ.val\n        root.right = deleteNode(root.right, succ.val)\n    return root",
      "keyInsight": "The successor is the leftmost node in the right subtree.",
      "visualizationType": "tree",
      "initialState": [
        5,
        3,
        6,
        2,
        4,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Delete Node in a BST",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Find node, replace with successor (leftmost in right subtree).\n\nDelete node with given key from BST.\nThree cases: leaf, one child, two children.",
      "examples": [
        {
          "input": "root = [5,3,6,2,4,null,7]; key = 3",
          "output": "[5,4,6,2,null,null,7]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Delete node with given key from BST.",
        "Three cases: leaf, one child, two children.",
        "Two children: replace with inorder successor."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "LFzAoJJt92M",
      "problemStatement": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BST Traversal: Find node, replace with successor (leftmost in right subtree).",
      "suggestedNextQuestion": {
        "slug": "flatten-binary-tree-to-linked-list",
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
      "initialCode": "def deleteNode(root, key):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def deleteNode(root, key):\n    if not root: return None\n    if key > root.val:\n        root.right = deleteNode(root.right, key)\n    elif key < root.val:\n        root.left = deleteNode(root.left, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Min from right subtree\n        curr = root.right\n        while curr.left:\n            curr = curr.left\n        root.val = curr.val\n        root.right = deleteNode(root.right, root.val)\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Delete node with given key from BST.",
            "\ud83e\udde0 Three cases: leaf, one child, two children.",
            "\ud83d\udca1 Two children: replace with inorder successor."
          ],
          "code": "def deleteNode(root, key):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Delete node with given key from BST.\n    - \ud83e\udde0 Three cases: leaf, one child, two children.\n    - \ud83d\udca1 Two children: replace with inorder successor.\n\n    Algorithm:\n    1. Find - Locate node.\n    2. Delete - Remove.\n    3. Replace - Maintain BST.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Find successor\n        succ = root.right\n        while succ.left: succ = succ.left\n        root.val = succ.val\n        root.right = deleteNode(root.right, succ.val)\n    return root"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "insert-into-a-binary-search-tree": {
      "title": "Insert into a Binary Search Tree",
      "videoUrl": "https://www.youtube.com/watch?v=K0Yl_uI-H0w",
      "pattern": "BST Traversal",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(h)",
      "spaceComplexity": "O(h)",
      "oneliner": "Navigate BST, insert at null position.",
      "intuition": [
        "\ud83c\udfaf Insert value into BST maintaining property.",
        "\ud83e\udde0 Go left if val < root, right otherwise.",
        "\ud83d\udca1 Insert at the first null spot found."
      ],
      "testCases": [
        {
          "input": "root = [4,2,7,1,3], val = 5",
          "output": "[4,2,7,1,3,5]"
        },
        {
          "input": "root = [40,20,60,10,30,50,70], val = 25",
          "output": "[40,20,60,10,30,50,70,null,null,25]"
        },
        {
          "input": "root = [4,2,7,1,3,null,null,null,null,null,null], val = 5",
          "output": "[4,2,7,1,3,5]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Navigate",
          "visual": "Compare values",
          "explanation": "BST property."
        },
        {
          "step": 2,
          "title": "Insert",
          "visual": "At null",
          "explanation": "Add node."
        },
        {
          "step": 3,
          "title": "Return",
          "visual": "Root",
          "explanation": "Done."
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef insertIntoBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert value into BST maintaining property.\n    - \ud83e\udde0 Go left if val < root, right otherwise.\n    - \ud83d\udca1 Insert at the first null spot found.\n\n    Algorithm:\n    1. Navigate - BST property.\n    2. Insert - Add node.\n    3. Return - Done.\n    \"\"\"\n    if not root: return TreeNode(val)  # Base case: Check if tree is empty.\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root",
      "keyInsight": "Always insert as a leaf node at the correct position.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Insert into a Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Navigate BST, insert at null position.\n\nInsert value into BST maintaining property.\nGo left if val < root, right otherwise.",
      "examples": [
        {
          "input": "root = [4,2,7,1,3]; val = 5",
          "output": "[4,2,7,1,3,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Insert value into BST maintaining property.",
        "Go left if val < root, right otherwise.",
        "Insert at the first null spot found."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Cpg8f79luEA",
      "problemStatement": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BST Traversal: Navigate BST, insert at null position.",
      "suggestedNextQuestion": {
        "slug": "kth-smallest-element-in-a-bst",
        "title": "Kth Smallest Element in a BST",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef insertIntoBST(root, val):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def insertIntoBST(root, val):\n    if not root:\n        return TreeNode(val)\n    if val > root.val:\n        root.right = insertIntoBST(root.right, val)\n    else:\n        root.left = insertIntoBST(root.left, val)\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Insert value into BST maintaining property.",
            "\ud83e\udde0 Go left if val < root, right otherwise.",
            "\ud83d\udca1 Insert at the first null spot found."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef insertIntoBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert value into BST maintaining property.\n    - \ud83e\udde0 Go left if val < root, right otherwise.\n    - \ud83d\udca1 Insert at the first null spot found.\n\n    Algorithm:\n    1. Navigate - BST property.\n    2. Insert - Add node.\n    3. Return - Done.\n    \"\"\"\n    if not root: return TreeNode(val)  # Base case: Check if tree is empty.\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "palindrome-linked-list": {
      "title": "Palindrome Linked List",
      "pattern": "Fast/Slow + Reverse",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Find middle, reverse second half, compare.",
      "intuition": [
        "\ud83c\udfaf Check if linked list is a palindrome.",
        "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
        "\ud83d\udca1 Compare first and second halves."
      ],
      "testCases": [
        {
          "input": "head = [1,2,2,1]",
          "output": "true"
        },
        {
          "input": "head = [1,2]",
          "output": "false"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Middle",
          "visual": "Slow at center",
          "explanation": "Fast/slow."
        },
        {
          "step": 2,
          "title": "Reverse",
          "visual": "Flip second half",
          "explanation": "In-place."
        },
        {
          "step": 3,
          "title": "Compare",
          "visual": "Match values",
          "explanation": "Check."
        }
      ],
      "code": "def isPalindrome(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if linked list is a palindrome.\n    - \ud83e\udde0 Fast/slow to find middle, reverse second half.\n    - \ud83d\udca1 Compare first and second halves.\n\n    Algorithm:\n    1. Middle - Fast/slow.\n    2. Reverse - In-place.\n    3. Compare - Check.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    # Reverse second half\n    prev = None\n    while slow:\n        slow.next, prev, slow = prev, slow, slow.next\n    # Compare\n    while prev:\n        if head.val != prev.val:\n            return False  # Condition not met.\n        head, prev = head.next, prev.next\n    return True  # Condition satisfied.",
      "keyInsight": "O(1) space by reversing half in-place rather than using a stack.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        2,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Palindrome Linked List",
          "transientMessage": "Input: [1, 2, 2, 1]",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 4",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 4",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 2",
          "transientMessage": "Step 3 of 4",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 1",
          "transientMessage": "Step 4 of 4",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            2,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Find middle, reverse second half, compare.\n\nCheck if linked list is a palindrome.\nFast/slow to find middle, reverse second half.",
      "examples": [
        {
          "input": "head = [1,2,2,1]",
          "output": "true"
        },
        {
          "input": "head = [1,2]",
          "output": "false"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Check if linked list is a palindrome.",
        "Fast/slow to find middle, reverse second half.",
        "Compare first and second halves."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "yOzXms1J6Nk",
      "problemStatement": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Fast/Slow + Reverse: Find middle, reverse second half, compare.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def isPalindrome(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isPalindrome(head):\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    return vals == vals[::-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Check if linked list is a palindrome.",
            "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
            "\ud83d\udca1 Compare first and second halves."
          ],
          "code": "def isPalindrome(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if linked list is a palindrome.\n    - \ud83e\udde0 Fast/slow to find middle, reverse second half.\n    - \ud83d\udca1 Compare first and second halves.\n\n    Algorithm:\n    1. Middle - Fast/slow.\n    2. Reverse - In-place.\n    3. Compare - Check.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    # Reverse second half\n    prev = None\n    while slow:\n        slow.next, prev, slow = prev, slow, slow.next\n    # Compare\n    while prev:\n        if head.val != prev.val:\n            return False  # Condition not met.\n        head, prev = head.next, prev.next\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "gfg---reverse-first-k-elements-of-a-queue": {
      "title": "GFG - Reverse first K elements of a Queue",
      "pattern": "Stack + Queue",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(k)",
      "oneliner": "Use stack to reverse first k, then cycle remaining elements.",
      "intuition": [
        "\ud83c\udfaf Reverse first k elements of a queue.",
        "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
        "\ud83d\udca1 Stack reverses order naturally."
      ],
      "testCases": [
        {
          "input": "k = 3, queue = [10, 20, 30, 40, 50]",
          "output": "[30, 20, 10, 40, 50]"
        },
        {
          "input": "k = 4, queue = [10, 20, 30, 40, 50]",
          "output": "[40, 30, 20, 10, 50]"
        }
      ],
      "steps": [
        {
          "step": 1,
          "title": "Stack",
          "visual": "Push k elements",
          "explanation": "Reverse."
        },
        {
          "step": 2,
          "title": "Push",
          "visual": "Pop stack to queue",
          "explanation": "Reversed."
        },
        {
          "step": 3,
          "title": "Cycle",
          "visual": "Move n-k to back",
          "explanation": "Reorder."
        }
      ],
      "code": "from collections import deque\n\ndef reverseFirstK(queue, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse first k elements of a queue.\n    - \ud83e\udde0 Pop k to stack, push back, cycle n-k elements.\n    - \ud83d\udca1 Stack reverses order naturally.\n\n    Algorithm:\n    1. Stack - Reverse.\n    2. Push - Reversed.\n    3. Cycle - Reorder.\n    \"\"\"\n    queue = deque(queue)\n    if not queue or k <= 0 or k > len(queue):\n        return list(queue)\n    stack = []  # Initialize stack for tracking.\n    for _ in range(k):  # Iterate through the range.\n        stack.append(queue.popleft())  # Add to end.\n    while stack:\n        queue.append(stack.pop())  # Add to end.\n    for _ in range(len(queue) - k):  # Iterate through the range.\n        queue.append(queue.popleft())  # Add to end.\n    return list(queue)",
      "keyInsight": "Use a stack to reverse order, then cycle the remaining elements.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: GFG - Reverse first K elements of a Queue",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use stack to reverse first k, then cycle remaining elements.\n\nReverse first k elements of a queue.\nPop k to stack, push back, cycle n-k elements.",
      "examples": [
        {
          "input": "queue = [1,2,3,4,5]; k = 3",
          "output": "[3,2,1,4,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Reverse first k elements of a queue.",
        "Pop k to stack, push back, cycle n-k elements.",
        "Stack reverses order naturally."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "VAZkSMoNHik",
      "problemStatement": "Given an integer K and a queue of integers, we need to reverse the order of the first K elements of the queue, leaving the other elements in the same relative order.",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Stack + Queue: Use stack to reverse first k, then cycle remaining elements.",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "difficulty": "Medium",
      "initialCode": "def reverseFirstK(queue, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def reverseFirstK_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Reverse first k elements of a queue.",
            "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
            "\ud83d\udca1 Stack reverses order naturally."
          ],
          "code": "from collections import deque\n\ndef reverseFirstK(queue, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse first k elements of a queue.\n    - \ud83e\udde0 Pop k to stack, push back, cycle n-k elements.\n    - \ud83d\udca1 Stack reverses order naturally.\n\n    Algorithm:\n    1. Stack - Reverse.\n    2. Push - Reversed.\n    3. Cycle - Reorder.\n    \"\"\"\n    queue = deque(queue)\n    if not queue or k <= 0 or k > len(queue):\n        return list(queue)\n    stack = []  # Initialize stack for tracking.\n    for _ in range(k):  # Iterate through the range.\n        stack.append(queue.popleft())  # Add to end.\n    while stack:\n        queue.append(stack.pop())  # Add to end.\n    for _ in range(len(queue) - k):  # Iterate through the range.\n        queue.append(queue.popleft())  # Add to end.\n    return list(queue)"
        }
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-size-subarray-sum": {
      "title": "Minimum Size Subarray Sum",
      "pattern": "Sliding Window",
      "patternEmoji": "\ud83e\ude9f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Expand right until sum >= target, shrink left while valid.",
      "intuition": [
        "\ud83c\udfaf Find minimal length subarray with sum >= target.",
        "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
        "\ud83d\udca1 Track minimum length when sum >= target."
      ],
      "testCases": [
        {
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "output": "2"
        },
        {
          "input": "target = 4, nums = [1,4,4]",
          "output": "1"
        },
        {
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "output": "0"
        }
      ],
      "code": "def minSubArrayLen(target, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimal length subarray with sum >= target.\n    - \ud83e\udde0 Sliding window: expand right, shrink left when valid.\n    - \ud83d\udca1 Track minimum length when sum >= target.\n    \"\"\"\n    left = 0\n    total = 0\n    minLen = float('inf')\n    for right in range(len(nums)):  # Iterate through the range.\n        total += nums[right]\n        while total >= target:\n            minLen = min(minLen, right - left + 1)  # Take the minimum value.\n            total -= nums[left]\n            left += 1\n    return minLen if minLen != float('inf') else 0",
      "keyInsight": "Shrink window while maintaining validity to find minimum.",
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        1,
        2,
        4,
        3
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Initialize pointers and total sum",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 1,
              "label": "right"
            }
          ],
          "transientMessage": "Add nums[1] to total",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 2,
              "label": "right"
            }
          ],
          "transientMessage": "Total >= target, check window size",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 2,
              "label": "right"
            }
          ],
          "transientMessage": "Move left pointer to reduce total",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Add nums[3] to total",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 4,
              "label": "right"
            }
          ],
          "transientMessage": "Total >= target, check window size",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Add nums[5] to total",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3,
            5
          ],
          "color": "success",
          "pointers": [
            {
              "index": 3,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Minimum window size found",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 4,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Total >= target, check window size",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 5,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "No more elements to process",
          "arrayState": [
            2,
            3,
            1,
            2,
            4,
            3
          ]
        }
      ],
      "description": "Expand right until sum >= target, shrink left while valid.\n\nFind minimal length subarray with sum >= target.\nSliding window: expand right, shrink left when valid.",
      "examples": [
        {
          "input": "target = 7; nums = [2,3,1,2,4,3]",
          "output": "2"
        },
        {
          "input": "target = 4; nums = [1,4,4]",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find minimal length subarray with sum >= target.",
        "Sliding window: expand right, shrink left when valid.",
        "Track minimum length when sum >= target."
      ],
      "relatedProblems": [
        "longest-substring-without-repeating-characters",
        "minimum-window-substring"
      ],
      "videoId": "aYqYMIqZx5s",
      "problemStatement": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize window boundaries (left, right)",
        "Expand window by moving right pointer",
        "Update window state with new element",
        "Shrink window when condition violated",
        "Track optimal result throughout"
      ],
      "approach": "Sliding Window: Expand right until sum >= target, shrink left while valid.",
      "suggestedNextQuestion": {
        "slug": "permutation-in-string",
        "title": "Permutation In String",
        "difficulty": "Medium",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def minSubArrayLen(target, nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def minSubArrayLen_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find minimal length subarray with sum >= target.",
            "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
            "\ud83d\udca1 Track minimum length when sum >= target."
          ],
          "code": "def minSubArrayLen(target, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimal length subarray with sum >= target.\n    - \ud83e\udde0 Sliding window: expand right, shrink left when valid.\n    - \ud83d\udca1 Track minimum length when sum >= target.\n    \"\"\"\n    left = 0\n    total = 0\n    minLen = float('inf')\n    for right in range(len(nums)):  # Iterate through the range.\n        total += nums[right]\n        while total >= target:\n            minLen = min(minLen, right - left + 1)  # Take the minimum value.\n            total -= nums[left]\n            left += 1\n    return minLen if minLen != float('inf') else 0"
        }
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "longest-substring-without-repeating-characters": {
      "title": "Longest Substring Without Repeating Characters",
      "pattern": "Sliding Window + Hash Set",
      "patternEmoji": "\ud83e\ude9f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(min(n,m))",
      "oneliner": "Expand right, shrink left when duplicate found.",
      "intuition": [
        "\ud83c\udfaf Find longest substring with all unique characters.",
        "\ud83e\udde0 Use set to track current window characters.",
        "\ud83d\udca1 Remove from left when duplicate encountered."
      ],
      "testCases": [
        {
          "input": "s = \"abcabcbb\"",
          "output": "3"
        },
        {
          "input": "s = \"bbbbb\"",
          "output": "1"
        },
        {
          "input": "s = \"pwwkew\"",
          "output": "3"
        }
      ],
      "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest substring with all unique characters.\n    - \ud83e\udde0 Use set to track current window characters.\n    - \ud83d\udca1 Remove from left when duplicate encountered.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    left = 0\n    maxLen = 0\n    for right in range(len(s)):  # Iterate through the range.\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        maxLen = max(maxLen, right - left + 1)  # Take the maximum value.\n    return maxLen",
      "keyInsight": "Use a hash set/map to detect duplicates in O(1).",
      "visualizationType": "tree",
      "initialState": "abcabcbb",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Initialize 'seen' set and pointers 'left' and 'right' at 0",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 1,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 1, add 'b' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 2,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 2, add 'c' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 3, 'a' is in 'seen', remove 'b' and move 'left' to 1",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 3, add 'a' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 4,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 4, 'b' is in 'seen', remove 'c' and move 'left' to 2",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 4,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 4, add 'b' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 5, 'c' is in 'seen', remove 'a' and move 'left' to 3",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 5, add 'c' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            6
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "left"
            },
            {
              "index": 6,
              "label": "right"
            }
          ],
          "transientMessage": "Move 'right' to index 6, add 'b' to 'seen'",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "color": "success",
          "transientMessage": "Final result: Length of the longest substring without repeating characters is 3",
          "arrayState": [
            "a",
            "b",
            "c",
            "a",
            "b",
            "c",
            "b",
            "b"
          ]
        }
      ],
      "description": "Given a string s, find the length of the longest substring without repeating characters.",
      "examples": [
        {
          "input": "s = \"abcabcbb\"",
          "output": "3",
          "explanation": "The answer is 'abc', with length 3."
        },
        {
          "input": "s = \"bbbbb\"",
          "output": "1",
          "explanation": "The answer is 'b', with length 1."
        },
        {
          "input": "s = \"pwwkew\"",
          "output": "3",
          "explanation": "The answer is 'wke', with length 3."
        }
      ],
      "constraints": [
        "0 <= s.length <= 5 * 10^4",
        "s consists of English letters, digits, symbols and spaces."
      ],
      "hints": [
        "Use the sliding window technique.",
        "Maintain a set of characters in current window.",
        "When you see a duplicate, shrink window from left."
      ],
      "relatedProblems": [
        "longest-repeating-character-replacement",
        "minimum-window-substring",
        "substring-with-concatenation-of-all-words"
      ],
      "videoId": "wiGpQwVHdE0",
      "problemStatement": "Given a string s, find the length of the longest substring without duplicate characters.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Sliding Window + Hash Set: Expand right, shrink left when duplicate found.",
      "suggestedNextQuestion": {
        "slug": "minimum-size-subarray-sum",
        "title": "Minimum Size Subarray Sum",
        "difficulty": "Medium",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def lengthOfLongestSubstring(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def lengthOfLongestSubstring_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(min(n,m))",
          "intuition": [
            "\ud83c\udfaf Find longest substring with all unique characters.",
            "\ud83e\udde0 Use set to track current window characters.",
            "\ud83d\udca1 Remove from left when duplicate encountered."
          ],
          "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest substring with all unique characters.\n    - \ud83e\udde0 Use set to track current window characters.\n    - \ud83d\udca1 Remove from left when duplicate encountered.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    left = 0\n    maxLen = 0\n    for right in range(len(s)):  # Iterate through the range.\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        maxLen = max(maxLen, right - left + 1)  # Take the maximum value.\n    return maxLen"
        }
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "substring-with-concatenation-of-all-words": {
      "title": "Substring with Concatenation of All Words",
      "pattern": "Sliding Window + Hash Map",
      "patternEmoji": "\ud83e\ude9f",
      "timeComplexity": "O(n*m)",
      "spaceComplexity": "O(m)",
      "oneliner": "Sliding window of size wordLen*numWords, check if all words match.",
      "intuition": [
        "\ud83c\udfaf Find all starting indices of concatenated substrings.",
        "\ud83e\udde0 All words have same length, total window = len*count.",
        "\ud83d\udca1 Slide window, compare word frequency maps."
      ],
      "testCases": [
        {
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "output": "[0,9]"
        },
        {
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "output": "[]"
        },
        {
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "output": "[6,9,12]"
        }
      ],
      "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all starting indices of concatenated substrings.\n    - \ud83e\udde0 All words have same length, total window = len*count.\n    - \ud83d\udca1 Slide window, compare word frequency maps.\n    \"\"\"\n    if not s or not words: return []\n    wordLen = len(words[0])\n    numWords = len(words)\n    totalLen = wordLen * numWords\n    wordCount = Counter(words)\n    res = []  # Initialize list to store results.\n    for i in range(len(s) - totalLen + 1):  # Iterate through the range.\n        seen = Counter()\n        for j in range(numWords):  # Iterate through the range.\n            word = s[i + j * wordLen : i + (j + 1) * wordLen]\n            if word not in wordCount:\n                break\n            seen[word] += 1\n            if seen[word] > wordCount[word]:\n                break\n        else:\n            res.append(i)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "Fixed word length simplifies the sliding window logic.",
      "visualizationType": "tree",
      "initialState": "barfoothefoobarman",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Substring with Concatenation of All Words",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Sliding window of size wordLen*numWords, check if all words match.\n\nFind all starting indices of concatenated substrings.\nAll words have same length, total window = len*count.",
      "examples": [
        {
          "input": "s = \"barfoothefoobarman\"; words = [\"foo\",\"bar\"]",
          "output": "[0,9]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find all starting indices of concatenated substrings.",
        "All words have same length, total window = len*count.",
        "Slide window, compare word frequency maps."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "-wlDdMmaYwI",
      "problemStatement": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Sliding Window + Hash Map: Sliding window of size wordLen*numWords, check if all words match.",
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def findSubstring(s, words):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def findSubstring_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n*m)",
          "spaceComplexity": "O(m)",
          "intuition": [
            "\ud83c\udfaf Find all starting indices of concatenated substrings.",
            "\ud83e\udde0 All words have same length, total window = len*count.",
            "\ud83d\udca1 Slide window, compare word frequency maps."
          ],
          "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all starting indices of concatenated substrings.\n    - \ud83e\udde0 All words have same length, total window = len*count.\n    - \ud83d\udca1 Slide window, compare word frequency maps.\n    \"\"\"\n    if not s or not words: return []\n    wordLen = len(words[0])\n    numWords = len(words)\n    totalLen = wordLen * numWords\n    wordCount = Counter(words)\n    res = []  # Initialize list to store results.\n    for i in range(len(s) - totalLen + 1):  # Iterate through the range.\n        seen = Counter()\n        for j in range(numWords):  # Iterate through the range.\n            word = s[i + j * wordLen : i + (j + 1) * wordLen]\n            if word not in wordCount:\n                break\n            seen[word] += 1\n            if seen[word] > wordCount[word]:\n                break\n        else:\n            res.append(i)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "minimum-window-substring": {
      "title": "Minimum Window Substring",
      "pattern": "Sliding Window + Hash Map",
      "patternEmoji": "\ud83e\ude9f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(m)",
      "oneliner": "Expand right to include all t chars, shrink left to minimize.",
      "intuition": [
        "\ud83c\udfaf Find minimum window in s containing all chars of t.",
        "\ud83e\udde0 Count required chars, expand right until all satisfied.",
        "\ud83d\udca1 Shrink left while still valid, track minimum."
      ],
      "testCases": [
        {
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "output": "\"BANC\""
        },
        {
          "input": "s = \"a\", t = \"a\"",
          "output": "\"a\""
        },
        {
          "input": "s = \"a\", t = \"aa\"",
          "output": "\"\""
        }
      ],
      "code": "from collections import Counter\n\ndef minWindow(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum window in s containing all chars of t.\n    - \ud83e\udde0 Count required chars, expand right until all satisfied.\n    - \ud83d\udca1 Shrink left while still valid, track minimum.\n    \"\"\"\n    if not t or not s: return ''\n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    left = 0\n    res = (float('inf'), 0, 0)\n    for right, c in enumerate(s):  # Iterate over elements.\n        have[c] = have.get(c, 0) + 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while formed == required:\n            if right - left + 1 < res[0]:\n                res = (right - left + 1, left, right + 1)\n            have[s[left]] -= 1\n            if s[left] in need and have[s[left]] < need[s[left]]:\n                formed -= 1\n            left += 1\n    return '' if res[0] == float('inf') else s[res[1]:res[2]]",
      "keyInsight": "Track 'formed' count to know when all required chars are satisfied.",
      "visualizationType": "tree",
      "initialState": "ADOBECODEBANC",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Initializing pointers and counters",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'A' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'D' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'O' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'B' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'E' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Processing character 'C' at right pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5,
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "success",
          "pointers": [
            {
              "index": 5,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Minimum window found: 'BANC'",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            6,
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 6,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Shrinking window by moving left pointer",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            7,
            8,
            9,
            10,
            11
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 7,
              "label": "left"
            },
            {
              "index": 11,
              "label": "right"
            }
          ],
          "transientMessage": "Final minimum window: 'BANC'",
          "arrayState": [
            "A",
            "D",
            "O",
            "B",
            "E",
            "C",
            "O",
            "D",
            "E",
            "B",
            "A",
            "N",
            "C"
          ]
        }
      ],
      "description": "Expand right to include all t chars, shrink left to minimize.\n\nFind minimum window in s containing all chars of t.\nCount required chars, expand right until all satisfied.",
      "examples": [
        {
          "input": "s = \"ADOBECODEBANC\"; t = \"ABC\"",
          "output": "\"BANC\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find minimum window in s containing all chars of t.",
        "Count required chars, expand right until all satisfied.",
        "Shrink left while still valid, track minimum."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "jSto0O4AJbM",
      "problemStatement": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Sliding Window + Hash Map: Expand right to include all t chars, shrink left to minimize.",
      "suggestedNextQuestion": {
        "slug": "substring-with-concatenation-of-all-words",
        "title": "Substring with Concatenation of All Words",
        "difficulty": "Hard",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def minWindow(s, t):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def minWindow_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(m)",
          "intuition": [
            "\ud83c\udfaf Find minimum window in s containing all chars of t.",
            "\ud83e\udde0 Count required chars, expand right until all satisfied.",
            "\ud83d\udca1 Shrink left while still valid, track minimum."
          ],
          "code": "from collections import Counter\n\ndef minWindow(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum window in s containing all chars of t.\n    - \ud83e\udde0 Count required chars, expand right until all satisfied.\n    - \ud83d\udca1 Shrink left while still valid, track minimum.\n    \"\"\"\n    if not t or not s: return ''\n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    left = 0\n    res = (float('inf'), 0, 0)\n    for right, c in enumerate(s):  # Iterate over elements.\n        have[c] = have.get(c, 0) + 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while formed == required:\n            if right - left + 1 < res[0]:\n                res = (right - left + 1, left, right + 1)\n            have[s[left]] -= 1\n            if s[left] in need and have[s[left]] < need[s[left]]:\n                formed -= 1\n            left += 1\n    return '' if res[0] == float('inf') else s[res[1]:res[2]]"
        }
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "valid-sudoku": {
      "title": "Valid Sudoku",
      "pattern": "Hash Set per Row/Col/Box",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(81)",
      "spaceComplexity": "O(81)",
      "oneliner": "Check each row, column, and 3x3 box for duplicates.",
      "intuition": [
        "\ud83c\udfaf Validate a partially filled Sudoku board.",
        "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
        "\ud83d\udca1 Box index = (row//3, col//3)."
      ],
      "testCases": [
        {
          "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
          "output": "true"
        },
        {
          "input": "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
          "output": "false"
        }
      ],
      "code": "def isValidSudoku(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Validate a partially filled Sudoku board.\n    - \ud83e\udde0 Use sets for each row, column, and 3x3 box.\n    - \ud83d\udca1 Box index = (row//3, col//3).\n    \"\"\"\n    rows = [set() for _ in range(9)]  # Iterate through the range.\n    cols = [set() for _ in range(9)]  # Iterate through the range.\n    boxes = [set() for _ in range(9)]  # Iterate through the range.\n    for r in range(9):  # Iterate through the range.\n        for c in range(9):  # Iterate through the range.\n            val = board[r][c]\n            if val == '.': continue\n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False  # Condition not met.\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True  # Condition satisfied.",
      "keyInsight": "The box index formula (r//3)*3 + (c//3) maps to 0-8.",
      "visualizationType": "matrix",
      "initialState": [
        5,
        3,
        ".",
        ".",
        7,
        ".",
        ".",
        ".",
        "."
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Valid Sudoku",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Check each row, column, and 3x3 box for duplicates.\n\nValidate a partially filled Sudoku board.\nUse sets for each row, column, and 3x3 box.",
      "examples": [
        {
          "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
          "output": "true"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Validate a partially filled Sudoku board.",
        "Use sets for each row, column, and 3x3 box.",
        "Box index = (row//3, col//3)."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "TjFXEUCMqI8",
      "problemStatement": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nNote:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Set per Row/Col/Box: Check each row, column, and 3x3 box for duplicates.",
      "suggestedNextQuestion": {
        "slug": "max-points-on-a-line",
        "title": "Max Points on a Line",
        "difficulty": "Hard",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def isValidSudoku(board):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.': continue\n            \n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False\n            \n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(81)",
          "spaceComplexity": "O(81)",
          "intuition": [
            "\ud83c\udfaf Validate a partially filled Sudoku board.",
            "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
            "\ud83d\udca1 Box index = (row//3, col//3)."
          ],
          "code": "def isValidSudoku(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Validate a partially filled Sudoku board.\n    - \ud83e\udde0 Use sets for each row, column, and 3x3 box.\n    - \ud83d\udca1 Box index = (row//3, col//3).\n    \"\"\"\n    rows = [set() for _ in range(9)]  # Iterate through the range.\n    cols = [set() for _ in range(9)]  # Iterate through the range.\n    boxes = [set() for _ in range(9)]  # Iterate through the range.\n    for r in range(9):  # Iterate through the range.\n        for c in range(9):  # Iterate through the range.\n            val = board[r][c]\n            if val == '.': continue\n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False  # Condition not met.\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "spiral-matrix": {
      "title": "Spiral Matrix",
      "pattern": "Layer by Layer",
      "patternEmoji": "\ud83c\udf00",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Process layer by layer: right, down, left, up, shrink bounds.",
      "intuition": [
        "\ud83c\udfaf Return matrix elements in spiral order.",
        "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
        "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
      ],
      "testCases": [
        {
          "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
          "output": "[1,2,3,6,9,8,7,4,5]"
        },
        {
          "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
          "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
        }
      ],
      "code": "def spiralOrder(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return matrix elements in spiral order.\n    - \ud83e\udde0 Maintain top/bottom/left/right boundaries.\n    - \ud83d\udca1 Traverse each direction, shrink boundary, repeat.\n    \"\"\"\n    if not matrix: return []\n    res = []  # Initialize list to store results.\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1): res.append(matrix[top][c])  # Iterate through the range.\n        top += 1\n        for r in range(top, bottom + 1): res.append(matrix[r][right])  # Iterate through the range.\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1): res.append(matrix[bottom][c])  # Iterate through the range.\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1): res.append(matrix[r][left])  # Iterate through the range.\n            left += 1\n    return res  # Return the final result.",
      "keyInsight": "After going right and down, check bounds before going left and up.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ],
        [
          7,
          8,
          9
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Spiral Matrix",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 2",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 4",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 5",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Process layer by layer: right, down, left, up, shrink bounds.\n\nReturn matrix elements in spiral order.\nMaintain top/bottom/left/right boundaries.",
      "examples": [
        {
          "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
          "output": "[1,2,3,6,9,8,7,4,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Return matrix elements in spiral order.",
        "Maintain top/bottom/left/right boundaries.",
        "Traverse each direction, shrink boundary, repeat."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "BJnMZNwUk1M",
      "problemStatement": "Given an m x n matrix, return all elements of the matrix in spiral order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Layer by Layer: Process layer by layer: right, down, left, up, shrink bounds.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def spiralOrder(matrix):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def spiralOrder(matrix):\n    res = []\n    while matrix:\n        res += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                res.append(row.pop())\n        if matrix:\n            res += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                res.append(row.pop(0))\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Return matrix elements in spiral order.",
            "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
            "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
          ],
          "code": "def spiralOrder(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return matrix elements in spiral order.\n    - \ud83e\udde0 Maintain top/bottom/left/right boundaries.\n    - \ud83d\udca1 Traverse each direction, shrink boundary, repeat.\n    \"\"\"\n    if not matrix: return []\n    res = []  # Initialize list to store results.\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1): res.append(matrix[top][c])  # Iterate through the range.\n        top += 1\n        for r in range(top, bottom + 1): res.append(matrix[r][right])  # Iterate through the range.\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1): res.append(matrix[bottom][c])  # Iterate through the range.\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1): res.append(matrix[r][left])  # Iterate through the range.\n            left += 1\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "rotate-image": {
      "title": "Rotate Image",
      "pattern": "Transpose + Reverse",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(1)",
      "oneliner": "Transpose matrix, then reverse each row.",
      "intuition": [
        "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
        "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
        "\ud83d\udca1 Reverse each row."
      ],
      "testCases": [
        {
          "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
          "output": "[[7,4,1],[8,5,2],[9,6,3]]"
        },
        {
          "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
          "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
        }
      ],
      "code": "def rotate(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.\n    - \ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].\n    - \ud83d\udca1 Reverse each row.\n    \"\"\"\n    n = len(matrix)\n    # Transpose\n    for i in range(n):  # Iterate through the range.\n        for j in range(i + 1, n):  # Iterate through the range.\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse rows\n    for row in matrix:  # Iterate over elements.\n        row.reverse()\n    return matrix",
      "keyInsight": "Transpose + reverse = 90\u00b0 clockwise rotation.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          2,
          3
        ],
        [
          4,
          5,
          6
        ],
        [
          7,
          8,
          9
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Rotate Image",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 2",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 4",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 5",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Transpose matrix, then reverse each row.\n\nRotate matrix 90\u00b0 clockwise in-place.\nTranspose: swap matrix[i][j] with matrix[j][i].",
      "examples": [
        {
          "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
          "output": "[[7,4,1],[8,5,2],[9,6,3]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Rotate matrix 90\u00b0 clockwise in-place.",
        "Transpose: swap matrix[i][j] with matrix[j][i].",
        "Reverse each row."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "fMSJSS7eO1w",
      "problemStatement": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Transpose + Reverse: Transpose matrix, then reverse each row.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def rotate(matrix):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rotate(matrix):\n    # Transpose then reverse rows\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for i in range(n):\n        matrix[i].reverse()"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
            "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
            "\ud83d\udca1 Reverse each row."
          ],
          "code": "def rotate(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.\n    - \ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].\n    - \ud83d\udca1 Reverse each row.\n    \"\"\"\n    n = len(matrix)\n    # Transpose\n    for i in range(n):  # Iterate through the range.\n        for j in range(i + 1, n):  # Iterate through the range.\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse rows\n    for row in matrix:  # Iterate over elements.\n        row.reverse()\n    return matrix"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "set-matrix-zeroes": {
      "title": "Set Matrix Zeroes",
      "pattern": "First Row/Col as Markers",
      "patternEmoji": "0\ufe0f\u20e3",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use first row/col as markers. Track if they need zeroing separately.",
      "intuition": [
        "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
        "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
        "\ud83d\udca1 Handle first row/col separately."
      ],
      "testCases": [
        {
          "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
          "output": "[[1,0,1],[0,0,0],[1,0,1]]"
        },
        {
          "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
          "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
        }
      ],
      "code": "def setZeroes(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If cell is 0, set entire row and column to 0.\n    - \ud83e\udde0 Use first row/col to mark which rows/cols to zero.\n    - \ud83d\udca1 Handle first row/col separately.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    firstRow = firstCol = False\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            if matrix[r][c] == 0:\n                if r == 0: firstRow = True\n                if c == 0: firstCol = True\n                matrix[r][0] = matrix[0][c] = 0\n    for r in range(1, m):  # Iterate through the range.\n        for c in range(1, n):  # Iterate through the range.\n            if matrix[r][0] == 0 or matrix[0][c] == 0:\n                matrix[r][c] = 0\n    if firstRow:\n        for c in range(n): matrix[0][c] = 0  # Iterate through the range.\n    if firstCol:\n        for r in range(m): matrix[r][0] = 0  # Iterate through the range.\n    return matrix",
      "keyInsight": "First row/col store markers; use separate flags for their own zeroing.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          1,
          1
        ],
        [
          1,
          0,
          1
        ],
        [
          1,
          1,
          1
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Set Matrix Zeroes",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              0,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use first row/col as markers. Track if they need zeroing separately.\n\nIf cell is 0, set entire row and column to 0.\nUse first row/col to mark which rows/cols to zero.",
      "examples": [
        {
          "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
          "output": "[[1,0,1],[0,0,0],[1,0,1]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "If cell is 0, set entire row and column to 0.",
        "Use first row/col to mark which rows/cols to zero.",
        "Handle first row/col separately."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "T41rL0L3Pnw",
      "problemStatement": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "First Row/Col as Markers: Use first row/col as markers. Track if they need zeroing separately.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def setZeroes(matrix):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def setZeroes(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    row_zero = False\n    \n    for r in range(rows):\n        for c in range(cols):\n            if matrix[r][c] == 0:\n                matrix[0][c] = 0\n                if r > 0:\n                    matrix[r][0] = 0\n                else:\n                    row_zero = True\n                    \n    for r in range(1, rows):\n        for c in range(1, cols):\n            if matrix[0][c] == 0 or matrix[r][0] == 0:\n                matrix[r][c] = 0\n                \n    if matrix[0][0] == 0:\n        for r in range(rows): matrix[r][0] = 0\n    if row_zero:\n        for c in range(cols): matrix[0][c] = 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
            "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
            "\ud83d\udca1 Handle first row/col separately."
          ],
          "code": "def setZeroes(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If cell is 0, set entire row and column to 0.\n    - \ud83e\udde0 Use first row/col to mark which rows/cols to zero.\n    - \ud83d\udca1 Handle first row/col separately.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    firstRow = firstCol = False\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            if matrix[r][c] == 0:\n                if r == 0: firstRow = True\n                if c == 0: firstCol = True\n                matrix[r][0] = matrix[0][c] = 0\n    for r in range(1, m):  # Iterate through the range.\n        for c in range(1, n):  # Iterate through the range.\n            if matrix[r][0] == 0 or matrix[0][c] == 0:\n                matrix[r][c] = 0\n    if firstRow:\n        for c in range(n): matrix[0][c] = 0  # Iterate through the range.\n    if firstCol:\n        for r in range(m): matrix[r][0] = 0  # Iterate through the range.\n    return matrix"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "game-of-life": {
      "title": "Game of Life",
      "pattern": "State Encoding",
      "patternEmoji": "\ud83c\udfae",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
      "intuition": [
        "\ud83c\udfaf Apply Conway's Game of Life rules.",
        "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
        "\ud83d\udca1 Second pass: decode to 0/1."
      ],
      "testCases": [
        {
          "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
          "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
        },
        {
          "input": "board = [[1,1],[1,0]]",
          "output": "[[1,1],[1,1]]"
        }
      ],
      "code": "def gameOfLife(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Apply Conway's Game of Life rules.\n    - \ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.\n    - \ud83d\udca1 Second pass: decode to 0/1.\n    \"\"\"\n    m, n = len(board), len(board[0])\n    def countLive(r, c):\n        live = 0\n        for dr in [-1, 0, 1]:  # Iterate over elements.\n            for dc in [-1, 0, 1]:  # Iterate over elements.\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                    live += 1\n        return live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            live = countLive(r, c)\n            if board[r][c] == 1:\n                if live < 2 or live > 3: board[r][c] = 2  # dies\n            else:\n                if live == 3: board[r][c] = 3  # becomes live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n    return board",
      "keyInsight": "Encode transitions to update in-place without auxiliary space.",
      "visualizationType": "matrix",
      "initialState": [
        [
          0,
          1,
          0
        ],
        [
          0,
          0,
          1
        ],
        [
          1,
          1,
          1
        ],
        [
          0,
          0,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Game of Life",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.\n\nApply Conway's Game of Life rules.\nUse extra states to encode old->new: 2=was live, 3=was dead now live.",
      "examples": [
        {
          "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
          "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Apply Conway's Game of Life rules.",
        "Use extra states to encode old->new: 2=was live, 3=was dead now live.",
        "Second pass: decode to 0/1."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "fei4bJQdBUQ",
      "problemStatement": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "State Encoding: Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def gameOfLife(board):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def gameOfLife(board):\n    # 0->0=0, 1->1=1, 0->1=2, 1->0=3\n    rows, cols = len(board), len(board[0])\n    for r in range(rows):\n        for c in range(cols):\n            nei = 0\n            for i in range(max(0, r-1), min(rows, r+2)):\n                for j in range(max(0, c-1), min(cols, c+2)):\n                    if (i, j) != (r, c) and (board[i][j] in [1, 3]):\n                        nei += 1\n            if board[r][c] == 1:\n                if nei < 2 or nei > 3: board[r][c] = 3\n            else:\n                if nei == 3: board[r][c] = 2\n                \n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] in [2, 3]:\n                board[r][c] = 1 if board[r][c] == 2 else 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Apply Conway's Game of Life rules.",
            "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
            "\ud83d\udca1 Second pass: decode to 0/1."
          ],
          "code": "def gameOfLife(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Apply Conway's Game of Life rules.\n    - \ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.\n    - \ud83d\udca1 Second pass: decode to 0/1.\n    \"\"\"\n    m, n = len(board), len(board[0])\n    def countLive(r, c):\n        live = 0\n        for dr in [-1, 0, 1]:  # Iterate over elements.\n            for dc in [-1, 0, 1]:  # Iterate over elements.\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                    live += 1\n        return live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            live = countLive(r, c)\n            if board[r][c] == 1:\n                if live < 2 or live > 3: board[r][c] = 2  # dies\n            else:\n                if live == 3: board[r][c] = 3  # becomes live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n    return board"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "summary-ranges": {
      "title": "Summary Ranges",
      "pattern": "Linear Scan",
      "patternEmoji": "\ud83d\udccb",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track start, extend while consecutive, format range.",
      "intuition": [
        "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
        "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
        "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
      ],
      "testCases": [
        {
          "input": "nums = [0,1,2,4,5,7]",
          "output": "[\"0->2\",\"4->5\",\"7\"]"
        },
        {
          "input": "nums = [0,2,3,4,6,8,9]",
          "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
        }
      ],
      "code": "def summaryRanges(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return smallest sorted list of ranges covering all numbers.\n    - \ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].\n    - \ud83d\udca1 Format as 'a->b' or just 'a' if single.\n    \"\"\"\n    if not nums: return []\n    res = []  # Initialize list to store results.\n    start = nums[0]\n    for i in range(1, len(nums) + 1):  # Iterate through the range.\n        if i == len(nums) or nums[i] != nums[i - 1] + 1:\n            if start == nums[i - 1]:\n                res.append(str(start))  # Add to end.\n            else:\n                res.append(f'{start}->{nums[i - 1]}')  # Add to end.\n            if i < len(nums):\n                start = nums[i]\n    return res  # Return the final result.",
      "keyInsight": "Use index i-1 for end of range when gap detected.",
      "visualizationType": "array",
      "initialState": [
        0,
        1,
        2,
        4,
        5,
        7
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            }
          ],
          "transientMessage": "Initialization: start = nums[0] = 0",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Checking if nums[1] == nums[0] + 1 (1 == 0 + 1)",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 2,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Checking if nums[2] == nums[1] + 1 (2 == 1 + 1)",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 3,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Checking if nums[3] == nums[2] + 1 (4 != 2 + 1)",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 2,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Appending range '0->2' to result",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 3,
              "label": "nums[i]"
            }
          ],
          "transientMessage": "Updating start to nums[3] = 4",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 4,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Checking if nums[4] == nums[3] + 1 (5 == 4 + 1)",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 5,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Checking if nums[5] == nums[4] + 1 (7 != 5 + 1)",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4,
            5
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 4,
              "label": "nums[i-1]"
            }
          ],
          "transientMessage": "Appending range '4->5' to result",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 5,
              "label": "nums[i]"
            }
          ],
          "transientMessage": "Updating start to nums[5] = 7",
          "arrayState": [
            0,
            1,
            2,
            4,
            5,
            7
          ]
        }
      ],
      "description": "Track start, extend while consecutive, format range.\n\nReturn smallest sorted list of ranges covering all numbers.\nStart a range, extend while nums[i]+1 == nums[i+1].",
      "examples": [
        {
          "input": "nums = [0,1,2,4,5,7]",
          "output": "[\"0->2\",\"4->5\",\"7\"]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Return smallest sorted list of ranges covering all numbers.",
        "Start a range, extend while nums[i]+1 == nums[i+1].",
        "Format as 'a->b' or just 'a' if single."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "ZHJDwbfqoa8",
      "problemStatement": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Linear Scan: Track start, extend while consecutive, format range.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def summaryRanges(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def summaryRanges(nums):\n    res = []\n    i = 0\n    while i < len(nums):\n        start = nums[i]\n        while i + 1 < len(nums) and nums[i+1] == nums[i] + 1:\n            i += 1\n        if start != nums[i]:\n            res.append(str(start) + \"->\" + str(nums[i]))\n        else:\n            res.append(str(start))\n        i += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
            "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
            "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
          ],
          "code": "def summaryRanges(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return smallest sorted list of ranges covering all numbers.\n    - \ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].\n    - \ud83d\udca1 Format as 'a->b' or just 'a' if single.\n    \"\"\"\n    if not nums: return []\n    res = []  # Initialize list to store results.\n    start = nums[0]\n    for i in range(1, len(nums) + 1):  # Iterate through the range.\n        if i == len(nums) or nums[i] != nums[i - 1] + 1:\n            if start == nums[i - 1]:\n                res.append(str(start))  # Add to end.\n            else:\n                res.append(f'{start}->{nums[i - 1]}')  # Add to end.\n            if i < len(nums):\n                start = nums[i]\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "merge-intervals": {
      "title": "Merge Intervals",
      "pattern": "Sort + Merge",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Sort by start, merge overlaps into result.",
      "intuition": [
        "\ud83c\udfaf Merge all overlapping intervals.",
        "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
        "\ud83d\udca1 Otherwise, add as new interval."
      ],
      "testCases": [
        {
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "output": "[[1,6],[8,10],[15,18]]"
        },
        {
          "input": "intervals = [[1,4],[4,5]]",
          "output": "[[1,5]]"
        }
      ],
      "code": "def merge(intervals):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge all overlapping intervals.\n    - \ud83e\udde0 Sort by start. If current overlaps last, extend end.\n    - \ud83d\udca1 Otherwise, add as new interval.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    res = []  # Initialize list to store results.\n    for interval in intervals:  # Iterate over elements.\n        if res and res[-1][1] >= interval[0]:\n            res[-1][1] = max(res[-1][1], interval[1])  # Take the maximum value.\n        else:\n            res.append(interval)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "After sorting, overlapping intervals are adjacent.",
      "visualizationType": "array",
      "initialState": [
        1,
        3,
        2,
        6,
        8,
        10,
        15,
        18
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Merge Intervals",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 2",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 6",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 8",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 10",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            3,
            2,
            6,
            8,
            10,
            15,
            18
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Sort by start, merge overlaps into result.\n\nMerge all overlapping intervals.\nSort by start. If current overlaps last, extend end.",
      "examples": [
        {
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "output": "[[1,6],[8,10],[15,18]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Merge all overlapping intervals.",
        "Sort by start. If current overlaps last, extend end.",
        "Otherwise, add as new interval."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "44H3cEC2fFM",
      "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Sort + Merge: Sort by start, merge overlaps into result.",
      "mentalModel": "Like arranging a hand of cards by rank and suit.",
      "initialCode": "def merge(intervals):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_end = res[-1][1]\n        if start <= last_end:\n            res[-1][1] = max(last_end, end)\n        else:\n            res.append([start, end])\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Merge all overlapping intervals.",
            "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
            "\ud83d\udca1 Otherwise, add as new interval."
          ],
          "code": "def merge(intervals):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge all overlapping intervals.\n    - \ud83e\udde0 Sort by start. If current overlaps last, extend end.\n    - \ud83d\udca1 Otherwise, add as new interval.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    res = []  # Initialize list to store results.\n    for interval in intervals:  # Iterate over elements.\n        if res and res[-1][1] >= interval[0]:\n            res[-1][1] = max(res[-1][1], interval[1])  # Take the maximum value.\n        else:\n            res.append(interval)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "insert-interval": {
      "title": "Insert Interval",
      "pattern": "Merge on Insert",
      "patternEmoji": "\u2795",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Add all before, merge overlaps, add all after.",
      "intuition": [
        "\ud83c\udfaf Insert and merge new interval into sorted list.",
        "\ud83e\udde0 Three phases: before, during overlap, after.",
        "\ud83d\udca1 Merge during overlap by extending bounds."
      ],
      "testCases": [
        {
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "output": "[[1,5],[6,9]]"
        },
        {
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "output": "[[1,2],[3,10],[12,16]]"
        }
      ],
      "code": "def insert(intervals, newInterval):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert and merge new interval into sorted list.\n    - \ud83e\udde0 Three phases: before, during overlap, after.\n    - \ud83d\udca1 Merge during overlap by extending bounds.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    for i, intv in enumerate(intervals):  # Iterate over elements.\n        if newInterval[1] < intv[0]:\n            res.append(newInterval)  # Add to end.\n            return res + intervals[i:]  # Return the final result.\n        elif newInterval[0] > intv[1]:\n            res.append(intv)  # Add to end.\n        else:\n            newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]  # Take the maximum value.\n    res.append(newInterval)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "Keep merging into newInterval until no more overlap.",
      "visualizationType": "array",
      "initialState": [
        1,
        3,
        6,
        9
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Insert Interval",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 9",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            3,
            6,
            9
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Add all before, merge overlaps, add all after.\n\nInsert and merge new interval into sorted list.\nThree phases: before, during overlap, after.",
      "examples": [
        {
          "input": "intervals = [[1,3],[6,9]]; newInterval = [2,5]",
          "output": "[[1,5],[6,9]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Insert and merge new interval into sorted list.",
        "Three phases: before, during overlap, after.",
        "Merge during overlap by extending bounds."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "A8NUOmlwOlM",
      "problemStatement": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Merge on Insert: Add all before, merge overlaps, add all after.",
      "mentalModel": "Like combining two sorted piles of papers into one sorted stack.",
      "initialCode": "def insert(intervals, newInterval):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def insert(intervals, newInterval):\n    res = []\n    for i in range(len(intervals)):\n        if newInterval[1] < intervals[i][0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intervals[i][1]:\n            res.append(intervals[i])\n        else:\n            newInterval = [min(newInterval[0], intervals[i][0]),\n                           max(newInterval[1], intervals[i][1])]\n    res.append(newInterval)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Insert and merge new interval into sorted list.",
            "\ud83e\udde0 Three phases: before, during overlap, after.",
            "\ud83d\udca1 Merge during overlap by extending bounds."
          ],
          "code": "def insert(intervals, newInterval):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert and merge new interval into sorted list.\n    - \ud83e\udde0 Three phases: before, during overlap, after.\n    - \ud83d\udca1 Merge during overlap by extending bounds.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    for i, intv in enumerate(intervals):  # Iterate over elements.\n        if newInterval[1] < intv[0]:\n            res.append(newInterval)  # Add to end.\n            return res + intervals[i:]  # Return the final result.\n        elif newInterval[0] > intv[1]:\n            res.append(intv)  # Add to end.\n        else:\n            newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]  # Take the maximum value.\n    res.append(newInterval)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-number-of-arrows-to-burst-balloons": {
      "title": "Minimum Number of Arrows to Burst Balloons",
      "pattern": "Greedy Interval",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Sort by end. Shoot at end of first, skip all overlapping.",
      "intuition": [
        "\ud83c\udfaf Minimum arrows to burst all balloons.",
        "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
        "\ud83d\udca1 Greedy: shoot as late as possible within current set."
      ],
      "testCases": [
        {
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "output": "2"
        },
        {
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "output": "4"
        },
        {
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "output": "2"
        }
      ],
      "code": "def findMinArrowPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum arrows to burst all balloons.\n    - \ud83e\udde0 Sort by end point. Each arrow at end pops all touching.\n    - \ud83d\udca1 Greedy: shoot as late as possible within current set.\n    \"\"\"\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for start, e in points[1:]:  # Iterate over elements.\n        if start > end:\n            arrows += 1\n            end = e\n    return arrows",
      "keyInsight": "Sorting by end allows greedy selection of arrow positions.",
      "visualizationType": "array",
      "initialState": [
        [
          10,
          16
        ],
        [
          2,
          8
        ],
        [
          1,
          6
        ],
        [
          7,
          12
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Number of Arrows to Burst Balloons",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 10,16",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2,8",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1,6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 7,12",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Sort by end. Shoot at end of first, skip all overlapping.\n\nMinimum arrows to burst all balloons.\nSort by end point. Each arrow at end pops all touching.",
      "examples": [
        {
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Minimum arrows to burst all balloons.",
        "Sort by end point. Each arrow at end pops all touching.",
        "Greedy: shoot as late as possible within current set."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "lPmkKnvNPrw",
      "problemStatement": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Greedy Interval: Sort by end. Shoot at end of first, skip all overlapping.",
      "suggestedNextQuestion": {
        "slug": "non-overlapping-intervals",
        "title": "Non Overlapping Intervals",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def findMinArrowPoints(points):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findMinArrowShots(points):\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n    return arrows"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Minimum arrows to burst all balloons.",
            "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
            "\ud83d\udca1 Greedy: shoot as late as possible within current set."
          ],
          "code": "def findMinArrowPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum arrows to burst all balloons.\n    - \ud83e\udde0 Sort by end point. Each arrow at end pops all touching.\n    - \ud83d\udca1 Greedy: shoot as late as possible within current set.\n    \"\"\"\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for start, e in points[1:]:  # Iterate over elements.\n        if start > end:\n            arrows += 1\n            end = e\n    return arrows"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reverse-nodes-in-k-group": {
      "title": "Reverse Nodes in k-Group",
      "pattern": "Iterative Reversal",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Reverse k nodes at a time, connect reversed groups.",
      "intuition": [
        "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
        "\ud83e\udde0 Find kth node, reverse that segment, connect.",
        "\ud83d\udca1 Use dummy head for cleaner edge case handling."
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,4,5], k = 2",
          "output": "[2,1,4,3,5]"
        },
        {
          "input": "head = [1,2,3,4,5], k = 3",
          "output": "[3,2,1,4,5]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseKGroup(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse every k nodes, leave remainder as-is.\n    - \ud83e\udde0 Find kth node, reverse that segment, connect.\n    - \ud83d\udca1 Use dummy head for cleaner edge case handling.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prevGroup = dummy\n    while True:\n        kth = prevGroup\n        for _ in range(k):  # Iterate through the range.\n            kth = kth.next\n            if not kth:\n                return dummy.next  # Return head of the new list.\n        nextGroup = kth.next\n        prev, curr = kth.next, prevGroup.next\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        tmp = prevGroup.next\n        prevGroup.next = kth\n        prevGroup = tmp\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "Track prevGroup to connect reversed segments.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reverse Nodes in k-Group",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Reverse k nodes at a time, connect reversed groups.\n\nReverse every k nodes, leave remainder as-is.\nFind kth node, reverse that segment, connect.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]; k = 2",
          "output": "[2,1,4,3,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Reverse every k nodes, leave remainder as-is.",
        "Find kth node, reverse that segment, connect.",
        "Use dummy head for cleaner edge case handling."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "1UOPsfP85V4",
      "problemStatement": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Iterative Reversal: Reverse k nodes at a time, connect reversed groups.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseKGroup(head, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def reverseKGroup(head, k):\n    dummy = ListNode(0, head)\n    groupPrev = dummy\n    \n    while True:\n        kth = groupPrev\n        for i in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        \n        groupNext = kth.next\n        \n        # Reverse group\n        prev, curr = kth.next, groupPrev.next\n        while curr != groupNext:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n            \n        tmp = groupPrev.next\n        groupPrev.next = kth\n        groupPrev = tmp"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
            "\ud83e\udde0 Find kth node, reverse that segment, connect.",
            "\ud83d\udca1 Use dummy head for cleaner edge case handling."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseKGroup(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse every k nodes, leave remainder as-is.\n    - \ud83e\udde0 Find kth node, reverse that segment, connect.\n    - \ud83d\udca1 Use dummy head for cleaner edge case handling.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prevGroup = dummy\n    while True:\n        kth = prevGroup\n        for _ in range(k):  # Iterate through the range.\n            kth = kth.next\n            if not kth:\n                return dummy.next  # Return head of the new list.\n        nextGroup = kth.next\n        prev, curr = kth.next, prevGroup.next\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        tmp = prevGroup.next\n        prevGroup.next = kth\n        prevGroup = tmp\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "remove-nth-node-from-end-of-list": {
      "title": "Remove Nth Node From End of List",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc46\ud83d\udc46",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Advance fast by n, then move both until fast reaches end.",
      "intuition": [
        "\ud83c\udfaf Remove nth node from end in one pass.",
        "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
        "\ud83d\udca1 Use dummy to handle removing head."
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,4,5], n = 2",
          "output": "[1,2,3,5]"
        },
        {
          "input": "head = [1], n = 1",
          "output": "[]"
        },
        {
          "input": "head = [1,2], n = 1",
          "output": "[1]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeNthFromEnd(head, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove nth node from end in one pass.\n    - \ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.\n    - \ud83d\udca1 Use dummy to handle removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    slow = fast = dummy\n    for _ in range(n + 1):  # Iterate through the range.\n        fast = fast.next\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    slow.next = slow.next.next\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "Dummy node simplifies removing the head case.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Remove Nth Node From End of List",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Advance fast by n, then move both until fast reaches end.\n\nRemove nth node from end in one pass.\nFast pointer leads by n. When fast ends, slow is at target.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]; n = 2",
          "output": "[1,2,3,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Remove nth node from end in one pass.",
        "Fast pointer leads by n. When fast ends, slow is at target.",
        "Use dummy to handle removing head."
      ],
      "relatedProblems": [
        "two-sum",
        "container-with-most-water",
        "3sum"
      ],
      "videoId": "XVuQxVej6y8",
      "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Advance fast by n, then move both until fast reaches end.",
      "suggestedNextQuestion": {
        "slug": "reverse-words-in-a-string",
        "title": "Reverse Words in a String",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeNthFromEnd(head, n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    left = right = dummy\n    for _ in range(n + 1):\n        right = right.next\n    while right:\n        left = left.next\n        right = right.next\n    left.next = left.next.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Remove nth node from end in one pass.",
            "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
            "\ud83d\udca1 Use dummy to handle removing head."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeNthFromEnd(head, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove nth node from end in one pass.\n    - \ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.\n    - \ud83d\udca1 Use dummy to handle removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    slow = fast = dummy\n    for _ in range(n + 1):  # Iterate through the range.\n        fast = fast.next\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    slow.next = slow.next.next\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "remove-duplicates-from-sorted-list-ii": {
      "title": "Remove Duplicates from Sorted List II",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Skip all nodes with duplicate values, keep only unique.",
      "intuition": [
        "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
        "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
        "\ud83d\udca1 Dummy head handles removing head."
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,3,4,4,5]",
          "output": "[1,2,5]"
        },
        {
          "input": "head = [1,1,1,2,3]",
          "output": "[2,3]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef deleteDuplicates(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all duplicated nodes (not just extra copies).\n    - \ud83e\udde0 If cur.val == cur.next.val, skip all with that value.\n    - \ud83d\udca1 Dummy head handles removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prev = dummy  # Initialize previous pointer.\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "Skip entire duplicate sequences, not just individual copies.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        3,
        4,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Remove Duplicates from Sorted List II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 3",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 4",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 4",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            3,
            4,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Skip all nodes with duplicate values, keep only unique.\n\nRemove all duplicated nodes (not just extra copies).\nIf cur.val == cur.next.val, skip all with that value.",
      "examples": [
        {
          "input": "head = [1,2,3,3,4,4,5]",
          "output": "[1,2,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Remove all duplicated nodes (not just extra copies).",
        "If cur.val == cur.next.val, skip all with that value.",
        "Dummy head handles removing head."
      ],
      "relatedProblems": [
        "two-sum",
        "container-with-most-water",
        "3sum"
      ],
      "videoId": "ycAq8iqh0TI",
      "problemStatement": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "approach": "Two Pointers: Skip all nodes with duplicate values, keep only unique.",
      "suggestedNextQuestion": {
        "slug": "remove-nth-node-from-end-of-list",
        "title": "Remove Nth Node From End of List",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef deleteDuplicates(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def deleteDuplicates(head):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
            "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
            "\ud83d\udca1 Dummy head handles removing head."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef deleteDuplicates(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all duplicated nodes (not just extra copies).\n    - \ud83e\udde0 If cur.val == cur.next.val, skip all with that value.\n    - \ud83d\udca1 Dummy head handles removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prev = dummy  # Initialize previous pointer.\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "rotate-list": {
      "title": "Rotate List",
      "pattern": "Cycle + Break",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Make cycle, find new tail at (len - k % len - 1), break.",
      "intuition": [
        "\ud83c\udfaf Rotate list right by k places.",
        "\ud83e\udde0 Connect tail to head, find new tail, break there.",
        "\ud83d\udca1 k % len handles k > len."
      ],
      "testCases": [
        {
          "input": "head = [1,2,3,4,5], k = 2",
          "output": "[4,5,1,2,3]"
        },
        {
          "input": "head = [0,1,2], k = 4",
          "output": "[2,0,1]"
        }
      ],
      "code": "def rotateRight(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate list right by k places.\n    - \ud83e\udde0 Connect tail to head, find new tail, break there.\n    - \ud83d\udca1 k % len handles k > len.\n    \"\"\"\n    if not head or not head.next or k == 0:\n        return head\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    k %= length\n    if k == 0:\n        return head\n    tail.next = head  # Make cycle\n    steps = length - k\n    newTail = head\n    for _ in range(steps - 1):  # Iterate through the range.\n        newTail = newTail.next\n    newHead = newTail.next\n    newTail.next = None\n    return newHead",
      "keyInsight": "Creating a cycle simplifies finding the new head/tail.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Rotate List",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Make cycle, find new tail at (len - k % len - 1), break.\n\nRotate list right by k places.\nConnect tail to head, find new tail, break there.",
      "examples": [
        {
          "input": "head = [1,2,3,4,5]; k = 2",
          "output": "[4,5,1,2,3]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Rotate list right by k places.",
        "Connect tail to head, find new tail, break there.",
        "k % len handles k > len."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "UcGtPs2LE_c",
      "problemStatement": "Given the head of a linked list, rotate the list to the right by k places.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Cycle + Break: Make cycle, find new tail at (len - k % len - 1), break.",
      "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
      "initialCode": "def rotateRight(head, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rotateRight(head, k):\n    if not head: return None\n    if not head.next: return head\n    \n    # Close ring\n    old_tail = head\n    n = 1\n    while old_tail.next:\n        old_tail = old_tail.next\n        n += 1\n    old_tail.next = head\n    \n    # New tail\n    new_tail = head\n    for i in range(n - k % n - 1):\n        new_tail = new_tail.next\n    new_head = new_tail.next\n    \n    # Break ring\n    new_tail.next = None\n    return new_head"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Rotate list right by k places.",
            "\ud83e\udde0 Connect tail to head, find new tail, break there.",
            "\ud83d\udca1 k % len handles k > len."
          ],
          "code": "def rotateRight(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate list right by k places.\n    - \ud83e\udde0 Connect tail to head, find new tail, break there.\n    - \ud83d\udca1 k % len handles k > len.\n    \"\"\"\n    if not head or not head.next or k == 0:\n        return head\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    k %= length\n    if k == 0:\n        return head\n    tail.next = head  # Make cycle\n    steps = length - k\n    newTail = head\n    for _ in range(steps - 1):  # Iterate through the range.\n        newTail = newTail.next\n    newHead = newTail.next\n    newTail.next = None\n    return newHead"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "partition-list": {
      "title": "Partition List",
      "pattern": "Two Dummy Lists",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Build two lists: less than x, greater or equal. Concatenate.",
      "intuition": [
        "\ud83c\udfaf Partition around x, preserving relative order.",
        "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
        "\ud83d\udca1 Connect them at the end."
      ],
      "testCases": [
        {
          "input": "head = [1,4,3,2,5,2], x = 3",
          "output": "[1,2,2,4,3,5]"
        },
        {
          "input": "head = [2,1], x = 2",
          "output": "[1,2]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef partition(head, x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Partition around x, preserving relative order.\n    - \ud83e\udde0 Two dummy heads for less and greater-or-equal lists.\n    - \ud83d\udca1 Connect them at the end.\n    \"\"\"\n    before = beforeHead = ListNode(0)  # Initialize two lists for partitioning.\n    after = afterHead = ListNode(0)\n    while head:\n        if head.val < x:  # Check logic for partition.\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = afterHead.next\n    return beforeHead.next",
      "keyInsight": "Two lists avoid in-place reordering complexity.",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        4,
        3,
        2,
        5,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Partition List",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 2",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            4,
            3,
            2,
            5,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Build two lists: less than x, greater or equal. Concatenate.\n\nPartition around x, preserving relative order.\nTwo dummy heads for less and greater-or-equal lists.",
      "examples": [
        {
          "input": "head = [1,4,3,2,5,2]; x = 3",
          "output": "[1,2,2,4,3,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Partition around x, preserving relative order.",
        "Two dummy heads for less and greater-or-equal lists.",
        "Connect them at the end."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "KT1iUciJr4g",
      "problemStatement": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Dummy Lists: Build two lists: less than x, greater or equal. Concatenate.",
      "mentalModel": "Like a scavenger hunt. Each clue points to the location of the next clue.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef partition(head, x):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def partition(head, x):\n    before = before_head = ListNode(0)\n    after = after_head = ListNode(0)\n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = after_head.next\n    return before_head.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Partition around x, preserving relative order.",
            "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
            "\ud83d\udca1 Connect them at the end."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef partition(head, x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Partition around x, preserving relative order.\n    - \ud83e\udde0 Two dummy heads for less and greater-or-equal lists.\n    - \ud83d\udca1 Connect them at the end.\n    \"\"\"\n    before = beforeHead = ListNode(0)  # Initialize two lists for partitioning.\n    after = afterHead = ListNode(0)\n    while head:\n        if head.val < x:  # Check logic for partition.\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = afterHead.next\n    return beforeHead.next"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "sort-list": {
      "title": "Sort List",
      "pattern": "Merge Sort",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(log n)",
      "oneliner": "Find middle, split, recursively sort, merge.",
      "intuition": [
        "\ud83c\udfaf Sort linked list in O(n log n) time.",
        "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
        "\ud83d\udca1 Fast/slow to find middle."
      ],
      "testCases": [
        {
          "input": "head = [4,2,1,3]",
          "output": "[1,2,3,4]"
        },
        {
          "input": "head = [-1,5,3,4,0]",
          "output": "[-1,0,3,4,5]"
        },
        {
          "input": "head = []",
          "output": "[]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef sortList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sort linked list in O(n log n) time.\n    - \ud83e\udde0 Merge sort: split at middle, recurse, merge.\n    - \ud83d\udca1 Fast/slow to find middle.\n    \"\"\"\n    if not head or not head.next:\n        return head\n    slow, fast = head, head.next  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    mid = slow.next\n    slow.next = None\n    left = sortList(head)\n    right = sortList(mid)\n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next  # Return head of the new list.",
      "keyInsight": "Merge sort is ideal for linked lists due to O(1) merge.",
      "visualizationType": "linkedlist",
      "initialState": [
        4,
        2,
        1,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Sort List",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 4",
          "transientMessage": "Iteration 1",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 3",
          "transientMessage": "Iteration 4",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            4,
            2,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Find middle, split, recursively sort, merge.\n\nSort linked list in O(n log n) time.\nMerge sort: split at middle, recurse, merge.",
      "examples": [
        {
          "input": "head = [4,2,1,3]",
          "output": "[1,2,3,4]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Sort linked list in O(n log n) time.",
        "Merge sort: split at middle, recurse, merge.",
        "Fast/slow to find middle."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "TGveA1oFhrc",
      "problemStatement": "Given the head of a linked list, return the list after sorting it in ascending order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Merge Sort: Find middle, split, recursively sort, merge.",
      "mentalModel": "Like arranging a hand of cards by rank and suit.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef sortList(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def sortList(head):\n    if not head or not head.next: return head\n    \n    # Split\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    mid = slow.next\n    slow.next = None\n    \n    # Sort\n    left = sortList(head)\n    right = sortList(mid)\n    \n    # Merge\n    dummy = ListNode(0)\n    curr = dummy\n    while left and right:\n        if left.val < right.val:\n            curr.next = left\n            left = left.next\n        else:\n            curr.next = right\n            right = right.next\n        curr = curr.next\n    curr.next = left or right\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(log n)",
          "intuition": [
            "\ud83c\udfaf Sort linked list in O(n log n) time.",
            "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
            "\ud83d\udca1 Fast/slow to find middle."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef sortList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sort linked list in O(n log n) time.\n    - \ud83e\udde0 Merge sort: split at middle, recurse, merge.\n    - \ud83d\udca1 Fast/slow to find middle.\n    \"\"\"\n    if not head or not head.next:\n        return head\n    slow, fast = head, head.next  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    mid = slow.next\n    slow.next = None\n    left = sortList(head)\n    right = sortList(mid)\n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next  # Return head of the new list."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "construct-binary-tree-from-preorder-and-inorder-traversal": {
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "pattern": "Divide and Conquer",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Preorder first is root. Find it in inorder to split left/right.",
      "intuition": [
        "\ud83c\udfaf Build tree from preorder and inorder.",
        "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
        "\ud83d\udca1 Use hashmap for O(1) index lookup."
      ],
      "testCases": [
        {
          "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
          "output": "[3,9,20,null,null,15,7]"
        },
        {
          "input": "preorder = [-1], inorder = [-1]",
          "output": "[-1]"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(preorder, inorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from preorder and inorder.\n    - \ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.\n    - \ud83d\udca1 Use hashmap for O(1) index lookup.\n    \"\"\"\n    if not preorder:\n        return None\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    def build(preL, preR, inL, inR):\n        if preL > preR:\n            return None\n        root = TreeNode(preorder[preL])  # Create a new Tree Node.\n        mid = idx_map[preorder[preL]]\n        leftSize = mid - inL\n        root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n        root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
      "keyInsight": "Preorder gives root, inorder gives subtree boundaries.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Construct Binary Tree from Preorder and Inorder Traversal",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Preorder first is root. Find it in inorder to split left/right.\n\nBuild tree from preorder and inorder.\nPreorder[0] = root. Find in inorder to know left/right sizes.",
      "examples": [
        {
          "input": "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]",
          "output": "[3,9,20,null,null,15,7]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Build tree from preorder and inorder.",
        "Preorder[0] = root. Find in inorder to know left/right sizes.",
        "Use hashmap for O(1) index lookup."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "ihj4IQGZ2zc",
      "problemStatement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Divide and Conquer: Preorder first is root. Find it in inorder to split left/right.",
      "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(preorder, inorder):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def buildTree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    root = TreeNode(preorder[0])\n    mid = inorder.index(preorder[0])\n    root.left = buildTree(preorder[1:mid+1], inorder[:mid])\n    root.right = buildTree(preorder[mid+1:], inorder[mid+1:])\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Build tree from preorder and inorder.",
            "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
            "\ud83d\udca1 Use hashmap for O(1) index lookup."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(preorder, inorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from preorder and inorder.\n    - \ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.\n    - \ud83d\udca1 Use hashmap for O(1) index lookup.\n    \"\"\"\n    if not preorder:\n        return None\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    def build(preL, preR, inL, inR):\n        if preL > preR:\n            return None\n        root = TreeNode(preorder[preL])  # Create a new Tree Node.\n        mid = idx_map[preorder[preL]]\n        leftSize = mid - inL\n        root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n        root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "construct-binary-tree-from-inorder-and-postorder-traversal": {
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "pattern": "Divide and Conquer",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Postorder last is root. Build right subtree first (reverse postorder).",
      "intuition": [
        "\ud83c\udfaf Build tree from inorder and postorder.",
        "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
        "\ud83d\udca1 Use hashmap for inorder index lookup."
      ],
      "testCases": [
        {
          "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
          "output": "[3,9,20,null,null,15,7]"
        },
        {
          "input": "inorder = [-1], postorder = [-1]",
          "output": "[-1]"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(inorder, postorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from inorder and postorder.\n    - \ud83e\udde0 Postorder[-1] = root. Process right subtree first.\n    - \ud83d\udca1 Use hashmap for inorder index lookup.\n    \"\"\"\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    self_idx = [len(postorder) - 1]\n    def build(inL, inR):\n        if inL > inR:\n            return None\n        root = TreeNode(postorder[self_idx[0]])  # Create a new Tree Node.\n        mid = idx_map[postorder[self_idx[0]]]\n        self_idx[0] -= 1\n        root.right = build(mid + 1, inR)\n        root.left = build(inL, mid - 1)\n        return root\n    return build(0, len(inorder) - 1)",
      "keyInsight": "Build right subtree first since postorder is left-right-root.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Construct Binary Tree from Inorder and Postorder Traversal",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Postorder last is root. Build right subtree first (reverse postorder).\n\nBuild tree from inorder and postorder.\nPostorder[-1] = root. Process right subtree first.",
      "examples": [
        {
          "input": "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]",
          "output": "[3,9,20,null,null,15,7]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Build tree from inorder and postorder.",
        "Postorder[-1] = root. Process right subtree first.",
        "Use hashmap for inorder index lookup."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "vm63HuIU7kw",
      "problemStatement": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Divide and Conquer: Postorder last is root. Build right subtree first (reverse postorder).",
      "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(inorder, postorder):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def buildTree(inorder, postorder):\n    if not inorder or not postorder:\n        return None\n    root = TreeNode(postorder.pop())\n    mid = inorder.index(root.val)\n    root.right = buildTree(inorder[mid+1:], postorder)\n    root.left = buildTree(inorder[:mid], postorder)\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Build tree from inorder and postorder.",
            "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
            "\ud83d\udca1 Use hashmap for inorder index lookup."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(inorder, postorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from inorder and postorder.\n    - \ud83e\udde0 Postorder[-1] = root. Process right subtree first.\n    - \ud83d\udca1 Use hashmap for inorder index lookup.\n    \"\"\"\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    self_idx = [len(postorder) - 1]\n    def build(inL, inR):\n        if inL > inR:\n            return None\n        root = TreeNode(postorder[self_idx[0]])  # Create a new Tree Node.\n        mid = idx_map[postorder[self_idx[0]]]\n        self_idx[0] -= 1\n        root.right = build(mid + 1, inR)\n        root.left = build(inL, mid - 1)\n        return root\n    return build(0, len(inorder) - 1)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "flatten-binary-tree-to-linked-list": {
      "title": "Flatten Binary Tree to Linked List",
      "pattern": "Preorder + Pointer Manipulation",
      "patternEmoji": "\ud83d\udccb",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Find rightmost of left subtree, connect to right, move left to right.",
      "intuition": [
        "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
        "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
        "\ud83d\udca1 Then move left subtree to right, nullify left."
      ],
      "testCases": [
        {
          "input": "root = [1,2,5,3,4,null,6]",
          "output": "[1,null,2,null,3,null,4,null,5,null,6]"
        },
        {
          "input": "root = []",
          "output": "[]"
        },
        {
          "input": "root = [0]",
          "output": "[0]"
        }
      ],
      "code": "def flatten(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flatten tree to right-skewed linked list (preorder).\n    - \ud83e\udde0 For each node: find rightmost of left, connect to right.\n    - \ud83d\udca1 Then move left subtree to right, nullify left.\n    \"\"\"\n    curr = root\n    while curr:\n        if curr.left:  # Check if left child exists.\n            prev = curr.left\n            while prev.right:\n                prev = prev.right\n            prev.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n        curr = curr.right\n    return root",
      "keyInsight": "Morris-like traversal without recursion or stack.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        5,
        3,
        4,
        6
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Flatten Binary Tree to Linked List",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Find rightmost of left subtree, connect to right, move left to right.\n\nFlatten tree to right-skewed linked list (preorder).\nFor each node: find rightmost of left, connect to right.",
      "examples": [
        {
          "input": "root = [1,2,5,3,4,null,6]",
          "output": "[1,null,2,null,3,null,4,null,5,null,6]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Flatten tree to right-skewed linked list (preorder).",
        "For each node: find rightmost of left, connect to right.",
        "Then move left subtree to right, nullify left."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "rKnD7rLT0lI",
      "problemStatement": "Given the root of a binary tree, flatten the tree into a \"linked list\":",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Preorder + Pointer Manipulation: Find rightmost of left subtree, connect to right, move left to right.",
      "suggestedNextQuestion": {
        "slug": "insert-into-a-binary-search-tree",
        "title": "Insert into a Binary Search Tree",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like using your fingers to track two different positions in a book at once.",
      "initialCode": "def flatten(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def flatten(root):\n    def dfs(node):\n        if not node: return None\n        leftTail = dfs(node.left)\n        rightTail = dfs(node.right)\n        \n        if leftTail:\n            leftTail.right = node.right\n            node.right = node.left\n            node.left = None\n        return rightTail or leftTail or node\n    dfs(root)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
            "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
            "\ud83d\udca1 Then move left subtree to right, nullify left."
          ],
          "code": "def flatten(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flatten tree to right-skewed linked list (preorder).\n    - \ud83e\udde0 For each node: find rightmost of left, connect to right.\n    - \ud83d\udca1 Then move left subtree to right, nullify left.\n    \"\"\"\n    curr = root\n    while curr:\n        if curr.left:  # Check if left child exists.\n            prev = curr.left\n            while prev.right:\n                prev = prev.right\n            prev.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n        curr = curr.right\n    return root"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "path-sum": {
      "title": "Path Sum",
      "pattern": "DFS",
      "patternEmoji": "\ud83d\udee4\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "DFS, subtract node value, check leaf with remaining 0.",
      "intuition": [
        "\ud83c\udfaf Does any root-to-leaf path sum to target?",
        "\ud83e\udde0 DFS: subtract current value, recurse.",
        "\ud83d\udca1 At leaf, check if remaining == 0."
      ],
      "testCases": [
        {
          "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
          "output": "true"
        },
        {
          "input": "root = [1,2,3], targetSum = 5",
          "output": "false"
        },
        {
          "input": "root = [], targetSum = 0",
          "output": "false"
        }
      ],
      "code": "def hasPathSum(root, targetSum):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Does any root-to-leaf path sum to target?\n    - \ud83e\udde0 DFS: subtract current value, recurse.\n    - \ud83d\udca1 At leaf, check if remaining == 0.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if not root.left and not root.right:\n        return targetSum == root.val\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)",
      "keyInsight": "Check leaf condition: no left AND no right child.",
      "visualizationType": "tree",
      "initialState": [
        5,
        4,
        8,
        11,
        13,
        4,
        7,
        2,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "root = 5, targetSum = 22",
          "transientMessage": "Start DFS at root (5). Rem: 22 - 5 = 17",
          "arrayState": [
            5,
            4,
            8,
            11,
            13,
            4,
            7,
            2,
            1
          ],
          "pointers": [
            {
              "label": "curr",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Go Left: node 4. Rem: 17 - 4 = 13",
          "transientMessage": "Traverse left child",
          "arrayState": [
            5,
            4,
            8,
            11,
            13,
            4,
            7,
            2,
            1
          ],
          "pointers": [
            {
              "label": "curr",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Go Left: node 11. Rem: 13 - 11 = 2",
          "transientMessage": "Traverse left child",
          "arrayState": [
            5,
            4,
            8,
            11,
            13,
            4,
            7,
            2,
            1
          ],
          "pointers": [
            {
              "label": "curr",
              "index": 3
            }
          ],
          "indices": [
            0,
            1,
            3
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Go Right: node 2. Rem: 2 - 2 = 0",
          "transientMessage": "Leaf node reached! Sum matches!",
          "arrayState": [
            5,
            4,
            8,
            11,
            13,
            4,
            7,
            2,
            1
          ],
          "pointers": [
            {
              "label": "curr",
              "index": 8
            }
          ],
          "indices": [
            0,
            1,
            3,
            8
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "True",
          "transientMessage": "Path found! \u2705",
          "arrayState": [
            5,
            4,
            8,
            11,
            13,
            4,
            7,
            2,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            3,
            8
          ],
          "color": "success"
        }
      ],
      "description": "DFS, subtract node value, check leaf with remaining 0.\n\nDoes any root-to-leaf path sum to target?\nDFS: subtract current value, recurse.",
      "examples": [
        {
          "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1]; targetSum = 22",
          "output": "true"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Does any root-to-leaf path sum to target?",
        "DFS: subtract current value, recurse.",
        "At leaf, check if remaining == 0."
      ],
      "relatedProblems": [
        "number-of-islands",
        "clone-graph",
        "course-schedule"
      ],
      "videoId": "LSKQyOz_P8I",
      "problemStatement": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.",
      "difficulty": "Easy",
      "walkthrough": [
        "Start DFS from root/starting node",
        "Mark current node as visited",
        "Recursively explore all neighbors/children",
        "Backtrack when path exhausted",
        "Return result after full traversal"
      ],
      "approach": "DFS: DFS, subtract node value, check leaf with remaining 0.",
      "suggestedNextQuestion": {
        "slug": "same-tree",
        "title": "Same Tree",
        "difficulty": "Easy",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def hasPathSum(root, targetSum):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def hasPathSum(root, targetSum):\n    if not root: return False\n    targetSum -= root.val\n    if not root.left and not root.right:\n        return targetSum == 0\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Does any root-to-leaf path sum to target?",
            "\ud83e\udde0 DFS: subtract current value, recurse.",
            "\ud83d\udca1 At leaf, check if remaining == 0."
          ],
          "code": "def hasPathSum(root, targetSum):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Does any root-to-leaf path sum to target?\n    - \ud83e\udde0 DFS: subtract current value, recurse.\n    - \ud83d\udca1 At leaf, check if remaining == 0.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if not root.left and not root.right:\n        return targetSum == root.val\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "sum-root-to-leaf-numbers": {
      "title": "Sum Root to Leaf Numbers",
      "pattern": "DFS",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "DFS carrying current number. At leaf, add to sum.",
      "intuition": [
        "\ud83c\udfaf Sum all root-to-leaf numbers.",
        "\ud83e\udde0 Pass current number * 10 + node.val down.",
        "\ud83d\udca1 At leaf, return current number."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3]",
          "output": "25"
        },
        {
          "input": "root = [4,9,0,5,1]",
          "output": "1026"
        }
      ],
      "code": "def sumNumbers(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum all root-to-leaf numbers.\n    - \ud83e\udde0 Pass current number * 10 + node.val down.\n    - \ud83d\udca1 At leaf, return current number.\n    \"\"\"\n    def dfs(node, curr):\n        if not node:\n            return 0\n        curr = curr * 10 + node.val  # Append digit to current number.\n        if not node.left and not node.right:\n            return curr\n        return dfs(node.left, curr) + dfs(node.right, curr)\n    return dfs(root, 0)",
      "keyInsight": "Build number digit by digit as you traverse.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Sum Root to Leaf Numbers",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "DFS carrying current number. At leaf, add to sum.\n\nSum all root-to-leaf numbers.\nPass current number * 10 + node.val down.",
      "examples": [
        {
          "input": "root = [1,2,3]",
          "output": "25"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Sum all root-to-leaf numbers.",
        "Pass current number * 10 + node.val down.",
        "At leaf, return current number."
      ],
      "relatedProblems": [
        "number-of-islands",
        "clone-graph",
        "course-schedule"
      ],
      "videoId": "Jk16lZGFWxE",
      "problemStatement": "You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.",
      "difficulty": "Medium",
      "walkthrough": [
        "Start DFS from root/starting node",
        "Mark current node as visited",
        "Recursively explore all neighbors/children",
        "Backtrack when path exhausted",
        "Return result after full traversal"
      ],
      "approach": "DFS: DFS carrying current number. At leaf, add to sum.",
      "suggestedNextQuestion": {
        "slug": "surrounded-regions",
        "title": "Surrounded Regions",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def sumNumbers(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def sumNumbers(root):\n    def dfs(node, num):\n        if not node: return 0\n        num = num * 10 + node.val\n        if not node.left and not node.right:\n            return num\n        return dfs(node.left, num) + dfs(node.right, num)\n    return dfs(root, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Sum all root-to-leaf numbers.",
            "\ud83e\udde0 Pass current number * 10 + node.val down.",
            "\ud83d\udca1 At leaf, return current number."
          ],
          "code": "def sumNumbers(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum all root-to-leaf numbers.\n    - \ud83e\udde0 Pass current number * 10 + node.val down.\n    - \ud83d\udca1 At leaf, return current number.\n    \"\"\"\n    def dfs(node, curr):\n        if not node:\n            return 0\n        curr = curr * 10 + node.val  # Append digit to current number.\n        if not node.left and not node.right:\n            return curr\n        return dfs(node.left, curr) + dfs(node.right, curr)\n    return dfs(root, 0)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "binary-tree-maximum-path-sum": {
      "title": "Binary Tree Maximum Path Sum",
      "pattern": "DFS + Global Max",
      "patternEmoji": "\ud83c\udfc6",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "For each node, compute max path through it. Update global max.",
      "intuition": [
        "\ud83c\udfaf Find max path sum (any path in tree).",
        "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
        "\ud83d\udca1 Use global variable to track overall max."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3]",
          "output": "6"
        },
        {
          "input": "root = [-10,9,20,null,null,15,7]",
          "output": "42"
        }
      ],
      "code": "def maxPathSum(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find max path sum (any path in tree).\n    - \ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).\n    - \ud83d\udca1 Use global variable to track overall max.\n    \"\"\"\n    maxSum = [float('-inf')]\n    def dfs(node):\n        if not node:\n            return 0\n        left = max(0, dfs(node.left))  # Take the maximum value.\n        right = max(0, dfs(node.right))  # Take the maximum value.\n        maxSum[0] = max(maxSum[0], node.val + left + right)  # Take the maximum value.\n        return node.val + max(left, right)  # Take the maximum value.\n    dfs(root)\n    return maxSum[0]",
      "keyInsight": "Return single branch max, but compute cross-node max internally.",
      "visualizationType": "tree",
      "initialState": [
        -10,
        9,
        20,
        15,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Binary Tree Maximum Path Sum",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "For each node, compute max path through it. Update global max.\n\nFind max path sum (any path in tree).\nAt each node: max = node + left + right. Return node + max(left, right).",
      "examples": [
        {
          "input": "root = [-10,9,20,null,null,15,7]",
          "output": "42"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find max path sum (any path in tree).",
        "At each node: max = node + left + right. Return node + max(left, right).",
        "Use global variable to track overall max."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Hr5cWUld4vU",
      "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS + Global Max: For each node, compute max path through it. Update global max.",
      "suggestedNextQuestion": {
        "slug": "reconstruct-itinerary",
        "title": "Reconstruct Itinerary",
        "difficulty": "Hard",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def maxPathSum(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxPathSum(root):\n    res = [root.val]\n    def dfs(root):\n        if not root: return 0\n        leftMax = max(dfs(root.left), 0)\n        rightMax = max(dfs(root.right), 0)\n        \n        res[0] = max(res[0], root.val + leftMax + rightMax)\n        return root.val + max(leftMax, rightMax)\n    dfs(root)\n    return res[0]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Find max path sum (any path in tree).",
            "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
            "\ud83d\udca1 Use global variable to track overall max."
          ],
          "code": "def maxPathSum(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find max path sum (any path in tree).\n    - \ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).\n    - \ud83d\udca1 Use global variable to track overall max.\n    \"\"\"\n    maxSum = [float('-inf')]\n    def dfs(node):\n        if not node:\n            return 0\n        left = max(0, dfs(node.left))  # Take the maximum value.\n        right = max(0, dfs(node.right))  # Take the maximum value.\n        maxSum[0] = max(maxSum[0], node.val + left + right)  # Take the maximum value.\n        return node.val + max(left, right)  # Take the maximum value.\n    dfs(root)\n    return maxSum[0]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "count-complete-tree-nodes": {
      "title": "Count Complete Tree Nodes",
      "pattern": "Binary Search on Tree",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(log\u00b2 n)",
      "spaceComplexity": "O(log n)",
      "oneliner": "Compare left/right depths. If equal, left is perfect. Otherwise right is.",
      "intuition": [
        "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
        "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
        "\ud83d\udca1 Recurse on the other side."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3,4,5,6]",
          "output": "6"
        },
        {
          "input": "root = []",
          "output": "0"
        },
        {
          "input": "root = [1]",
          "output": "1"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef countNodes(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count nodes in complete binary tree efficiently.\n    - \ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).\n    - \ud83d\udca1 Recurse on the other side.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    leftD = rightD = 0\n    l, r = root, root  # Initialize two pointers.\n    while l:\n        leftD += 1\n        l = l.left\n    while r:\n        rightD += 1\n        r = r.right\n    if leftD == rightD:\n        return (1 << leftD) - 1\n    return 1 + countNodes(root.left) + countNodes(root.right)",
      "keyInsight": "Complete tree allows O(log\u00b2 n) instead of O(n).",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Count Complete Tree Nodes",
          "transientMessage": "Input: [1, 2, 3, 4, 5, 6]",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 3",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 4",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 5",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Compare left/right depths. If equal, left is perfect. Otherwise right is.\n\nCount nodes in complete binary tree efficiently.\nIf left depth == right depth, left is perfect (2^d - 1 nodes).",
      "examples": [
        {
          "input": "root = [1,2,3,4,5,6]",
          "output": "6"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count nodes in complete binary tree efficiently.",
        "If left depth == right depth, left is perfect (2^d - 1 nodes).",
        "Recurse on the other side."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "u-yWemKGWO0",
      "problemStatement": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less than O(n) time complexity.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Binary Search on Tree: Compare left/right depths. If equal, left is perfect. Otherwise right is.",
      "suggestedNextQuestion": {
        "slug": "minimum-absolute-difference-in-bst",
        "title": "Minimum Absolute Difference in BST",
        "difficulty": "Easy",
        "pattern": "Trees"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef countNodes(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def __init___brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log\u00b2 n)",
          "spaceComplexity": "O(log n)",
          "intuition": [
            "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
            "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
            "\ud83d\udca1 Recurse on the other side."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef countNodes(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count nodes in complete binary tree efficiently.\n    - \ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).\n    - \ud83d\udca1 Recurse on the other side.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    leftD = rightD = 0\n    l, r = root, root  # Initialize two pointers.\n    while l:\n        leftD += 1\n        l = l.left\n    while r:\n        rightD += 1\n        r = r.right\n    if leftD == rightD:\n        return (1 << leftD) - 1\n    return 1 + countNodes(root.left) + countNodes(root.right)"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "binary-tree-right-side-view": {
      "title": "Binary Tree Right Side View",
      "pattern": "BFS",
      "patternEmoji": "\ud83d\udc41\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "BFS level by level, take last node of each level.",
      "intuition": [
        "\ud83c\udfaf Return rightmost node at each level.",
        "\ud83e\udde0 BFS: at each level, record last node.",
        "\ud83d\udca1 Or DFS with level tracking, process right first."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3,null,5,null,4]",
          "output": "[1,3,4]"
        },
        {
          "input": "root = [1,2,3,4,null,null,null,5]",
          "output": "[1,3,4,5]"
        },
        {
          "input": "root = [1,null,3]",
          "output": "[1,3]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "code": "from collections import deque\n\ndef rightSideView(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return rightmost node at each level.\n    - \ud83e\udde0 BFS: at each level, record last node.\n    - \ud83d\udca1 Or DFS with level tracking, process right first.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i == size - 1:\n                res.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "Take the last node at each level during BFS.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Binary Tree Right Side View",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "BFS level by level, take last node of each level.\n\nReturn rightmost node at each level.\nBFS: at each level, record last node.",
      "examples": [
        {
          "input": "root = [1,2,3,null,5,null,4]",
          "output": "[1,3,4]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Return rightmost node at each level.",
        "BFS: at each level, record last node.",
        "Or DFS with level tracking, process right first."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "word-ladder",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "d4zLyf32e3I",
      "problemStatement": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS level by level, take last node of each level.",
      "suggestedNextQuestion": {
        "slug": "binary-tree-zigzag-level-order-traversal",
        "title": "Binary Tree Zigzag Level Order Traversal",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def rightSideView(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rightSideView(root):\n    if not root: return []\n    res = []\n    q = [root]\n    while q:\n        rightSide = None\n        for i in range(len(q)):\n            node = q.pop(0)\n            if node:\n                rightSide = node\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n        if rightSide: res.append(rightSide.val)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Return rightmost node at each level.",
            "\ud83e\udde0 BFS: at each level, record last node.",
            "\ud83d\udca1 Or DFS with level tracking, process right first."
          ],
          "code": "from collections import deque\n\ndef rightSideView(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return rightmost node at each level.\n    - \ud83e\udde0 BFS: at each level, record last node.\n    - \ud83d\udca1 Or DFS with level tracking, process right first.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i == size - 1:\n                res.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "average-of-levels-in-binary-tree": {
      "title": "Average of Levels in Binary Tree",
      "pattern": "BFS",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "BFS level by level, compute average per level.",
      "intuition": [
        "\ud83c\udfaf Return average value at each level.",
        "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
        "\ud83d\udca1 Process level by level with queue."
      ],
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[3.00000,14.50000,11.00000]"
        },
        {
          "input": "root = [3,9,20,15,7]",
          "output": "[3.00000,14.50000,11.00000]"
        }
      ],
      "code": "from collections import deque\n\ndef averageOfLevels(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return average value at each level.\n    - \ud83e\udde0 BFS: sum nodes at each level, divide by count.\n    - \ud83d\udca1 Process level by level with queue.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        total = 0\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            total += node.val\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(total / size)  # Add to end.\n    return res  # Return the final result.",
      "keyInsight": "Sum all nodes at each level and divide by count.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Average of Levels in Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "BFS level by level, compute average per level.\n\nReturn average value at each level.\nBFS: sum nodes at each level, divide by count.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[3.0,14.5,11.0]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Return average value at each level.",
        "BFS: sum nodes at each level, divide by count.",
        "Process level by level with queue."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "word-ladder",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "115txA-rS5s",
      "problemStatement": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10^-5 of the actual answer will be accepted.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS level by level, compute average per level.",
      "suggestedNextQuestion": {
        "slug": "invert-binary-tree",
        "title": "Invert Binary Tree",
        "difficulty": "Easy",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def averageOfLevels(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def averageOfLevels(root):\n    q = [root]\n    res = []\n    while q:\n        qlen = len(q)\n        row = 0\n        for i in range(qlen):\n            node = q.pop(0)\n            row += node.val\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        res.append(row / qlen)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Return average value at each level.",
            "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
            "\ud83d\udca1 Process level by level with queue."
          ],
          "code": "from collections import deque\n\ndef averageOfLevels(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return average value at each level.\n    - \ud83e\udde0 BFS: sum nodes at each level, divide by count.\n    - \ud83d\udca1 Process level by level with queue.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        total = 0\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            total += node.val\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(total / size)  # Add to end.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "binary-tree-zigzag-level-order-traversal": {
      "title": "Binary Tree Zigzag Level Order Traversal",
      "pattern": "BFS + Direction Flag",
      "patternEmoji": "\u26a1",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "BFS, alternate direction each level (reverse odd levels).",
      "intuition": [
        "\ud83c\udfaf Level order but alternating left-right direction.",
        "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
        "\ud83d\udca1 Or use deque to add from different ends."
      ],
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[20,9],[15,7]]"
        },
        {
          "input": "root = [1]",
          "output": "[[1]]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "code": "from collections import deque\n\ndef zigzagLevelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Level order but alternating left-right direction.\n    - \ud83e\udde0 BFS with direction flag. Reverse level if needed.\n    - \ud83d\udca1 Or use deque to add from different ends.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    leftToRight = True\n    while q:\n        size = len(q)\n        level = deque()\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if leftToRight:\n                level.append(node.val)  # Add to end.\n            else:\n                level.appendleft(node.val)\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(list(level))  # Add to end.\n        leftToRight = not leftToRight\n    return res  # Return the final result.",
      "keyInsight": "Use deque's appendleft for reverse direction.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Binary Tree Zigzag Level Order Traversal",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "BFS, alternate direction each level (reverse odd levels).\n\nLevel order but alternating left-right direction.\nBFS with direction flag. Reverse level if needed.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "[[3],[20,9],[15,7]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Level order but alternating left-right direction.",
        "BFS with direction flag. Reverse level if needed.",
        "Or use deque to add from different ends."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "igbboQbiwqw",
      "problemStatement": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BFS + Direction Flag: BFS, alternate direction each level (reverse odd levels).",
      "suggestedNextQuestion": {
        "slug": "cheapest-flights-within-k-stops",
        "title": "Cheapest Flights Within K Stops",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def zigzagLevelOrder(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def zigzagLevelOrder(root):\n    if not root: return []\n    res = []\n    q = [root]\n    leftToRight = True\n    while q:\n        level = []\n        for i in range(len(q)):\n            node = q.pop(0)\n            level.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        if not leftToRight:\n            level.reverse()\n        res.append(level)\n        leftToRight = not leftToRight\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Level order but alternating left-right direction.",
            "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
            "\ud83d\udca1 Or use deque to add from different ends."
          ],
          "code": "from collections import deque\n\ndef zigzagLevelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Level order but alternating left-right direction.\n    - \ud83e\udde0 BFS with direction flag. Reverse level if needed.\n    - \ud83d\udca1 Or use deque to add from different ends.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    leftToRight = True\n    while q:\n        size = len(q)\n        level = deque()\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if leftToRight:\n                level.append(node.val)  # Add to end.\n            else:\n                level.appendleft(node.val)\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(list(level))  # Add to end.\n        leftToRight = not leftToRight\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-absolute-difference-in-bst": {
      "title": "Minimum Absolute Difference in BST",
      "pattern": "Inorder Traversal",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Inorder gives sorted order. Track prev, compare adjacent.",
      "intuition": [
        "\ud83c\udfaf Find min diff between any two nodes.",
        "\ud83e\udde0 Inorder traversal gives sorted values.",
        "\ud83d\udca1 Min diff is between adjacent sorted values."
      ],
      "testCases": [
        {
          "input": "root = [4,2,6,1,3]",
          "output": "1"
        },
        {
          "input": "root = [1,0,48,null,null,12,49]",
          "output": "1"
        }
      ],
      "code": "def getMinimumDifference(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find min diff between any two nodes.\n    - \ud83e\udde0 Inorder traversal gives sorted values.\n    - \ud83d\udca1 Min diff is between adjacent sorted values.\n    \"\"\"\n    prev = [None]\n    minDiff = [float('inf')]\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        if prev[0] is not None:\n            minDiff[0] = min(minDiff[0], node.val - prev[0])  # Take the minimum value.\n        prev[0] = node.val\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    return minDiff[0]",
      "keyInsight": "Inorder on BST is sorted, so min diff is between adjacent.",
      "visualizationType": "tree",
      "initialState": [
        4,
        2,
        6,
        1,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Absolute Difference in BST",
          "transientMessage": "Input: [4, 2, 6, 1, 3]",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 4",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 6",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 1",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 3",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            4,
            2,
            6,
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Inorder gives sorted order. Track prev, compare adjacent.\n\nFind min diff between any two nodes.\nInorder traversal gives sorted values.",
      "examples": [
        {
          "input": "root = [4,2,6,1,3]",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find min diff between any two nodes.",
        "Inorder traversal gives sorted values.",
        "Min diff is between adjacent sorted values."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "NttA_NC_ZhI",
      "problemStatement": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Inorder Traversal: Inorder gives sorted order. Track prev, compare adjacent.",
      "suggestedNextQuestion": {
        "slug": "subtree-of-another-tree",
        "title": "Subtree of Another Tree",
        "difficulty": "Easy",
        "pattern": "Trees"
      },
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "def getMinimumDifference(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def getMinimumDifference(root):\n    prev = [None]\n    min_diff = [float('inf')]\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        if prev[0] is not None:\n             min_diff[0] = min(min_diff[0], node.val - prev[0])\n        prev[0] = node.val\n        inorder(node.right)\n    inorder(root)\n    return min_diff[0]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Find min diff between any two nodes.",
            "\ud83e\udde0 Inorder traversal gives sorted values.",
            "\ud83d\udca1 Min diff is between adjacent sorted values."
          ],
          "code": "def getMinimumDifference(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find min diff between any two nodes.\n    - \ud83e\udde0 Inorder traversal gives sorted values.\n    - \ud83d\udca1 Min diff is between adjacent sorted values.\n    \"\"\"\n    prev = [None]\n    minDiff = [float('inf')]\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        if prev[0] is not None:\n            minDiff[0] = min(minDiff[0], node.val - prev[0])  # Take the minimum value.\n        prev[0] = node.val\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    return minDiff[0]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "kth-smallest-element-in-a-bst": {
      "title": "Kth Smallest Element in a BST",
      "pattern": "Inorder Traversal",
      "patternEmoji": "\ud83c\udfc6",
      "timeComplexity": "O(h + k)",
      "spaceComplexity": "O(h)",
      "oneliner": "Inorder traversal, return kth element.",
      "intuition": [
        "\ud83c\udfaf Find kth smallest element in BST.",
        "\ud83e\udde0 Inorder = sorted order. Count until k.",
        "\ud83d\udca1 Use iterative inorder with stack."
      ],
      "testCases": [
        {
          "input": "root = [3,1,4,null,2], k = 1",
          "output": "1"
        },
        {
          "input": "root = [5,3,6,2,4,null,null,1], k = 3",
          "output": "3"
        }
      ],
      "code": "def kthSmallest(root, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find kth smallest element in BST.\n    - \ud83e\udde0 Inorder = sorted order. Count until k.\n    - \ud83d\udca1 Use iterative inorder with stack.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    while True:\n        while root:\n            stack.append(root)  # Add to end.\n            root = root.left\n        root = stack.pop()  # Remove and return last element.\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right",
      "keyInsight": "Iterative inorder avoids full traversal for small k.",
      "visualizationType": "tree",
      "initialState": [
        3,
        1,
        4,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Kth Smallest Element in a BST",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Inorder traversal, return kth element.\n\nFind kth smallest element in BST.\nInorder = sorted order. Count until k.",
      "examples": [
        {
          "input": "root = [3,1,4,null,2]; k = 1",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find kth smallest element in BST.",
        "Inorder = sorted order. Count until k.",
        "Use iterative inorder with stack."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "5LUXSvjmGCw",
      "problemStatement": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Inorder Traversal: Inorder traversal, return kth element.",
      "suggestedNextQuestion": {
        "slug": "lowest-common-ancestor-of-a-binary-search-tree",
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "def kthSmallest(root, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def kthSmallest(root, k):\n    stack = []\n    curr = root\n    while stack or curr:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        k -= 1\n        if k == 0:\n            return curr.val\n        curr = curr.right"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h + k)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Find kth smallest element in BST.",
            "\ud83e\udde0 Inorder = sorted order. Count until k.",
            "\ud83d\udca1 Use iterative inorder with stack."
          ],
          "code": "def kthSmallest(root, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find kth smallest element in BST.\n    - \ud83e\udde0 Inorder = sorted order. Count until k.\n    - \ud83d\udca1 Use iterative inorder with stack.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    while True:\n        while root:\n            stack.append(root)  # Add to end.\n            root = root.left\n        root = stack.pop()  # Remove and return last element.\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "validate-binary-search-tree": {
      "title": "Validate Binary Search Tree",
      "pattern": "DFS with Range",
      "patternEmoji": "\u2705",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "DFS with min/max bounds. Node must be in (min, max).",
      "intuition": [
        "\ud83c\udfaf Is this a valid BST?",
        "\ud83e\udde0 Each node has a valid range (min, max).",
        "\ud83d\udca1 Left: update max. Right: update min."
      ],
      "testCases": [
        {
          "input": "root = [2,1,3]",
          "output": "true"
        },
        {
          "input": "root = [5,1,4,null,null,3,6]",
          "output": "false"
        }
      ],
      "code": "def isValidBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is this a valid BST?\n    - \ud83e\udde0 Each node has a valid range (min, max).\n    - \ud83d\udca1 Left: update max. Right: update min.\n    \"\"\"\n    def validate(node, lo, hi):\n        if not node:\n            return True  # Condition satisfied.\n        if not (lo < node.val < hi):\n            return False  # Condition not met.\n        return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n    return validate(root, float('-inf'), float('inf'))",
      "keyInsight": "Each node must satisfy min < node.val < max constraint.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Validate Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "DFS with min/max bounds. Node must be in (min, max).\n\nIs this a valid BST?\nEach node has a valid range (min, max).",
      "examples": [
        {
          "input": "root = [2,1,3]",
          "output": "true"
        },
        {
          "input": "root = [5,1,4,null,null,3,6]",
          "output": "false"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Is this a valid BST?",
        "Each node has a valid range (min, max).",
        "Left: update max. Right: update min."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "s6ATEkipzow",
      "problemStatement": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS with Range: DFS with min/max bounds. Node must be in (min, max).",
      "suggestedNextQuestion": {
        "slug": "walls-and-gates",
        "title": "Walls And Gates",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def isValidBST(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isValidBST(root):\n    def valid(node, left, right):\n        if not node: return True\n        if not (left < node.val < right):\n            return False\n        return valid(node.left, left, node.val) and                valid(node.right, node.val, right)\n    return valid(root, float('-inf'), float('inf'))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Is this a valid BST?",
            "\ud83e\udde0 Each node has a valid range (min, max).",
            "\ud83d\udca1 Left: update max. Right: update min."
          ],
          "code": "def isValidBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is this a valid BST?\n    - \ud83e\udde0 Each node has a valid range (min, max).\n    - \ud83d\udca1 Left: update max. Right: update min.\n    \"\"\"\n    def validate(node, lo, hi):\n        if not node:\n            return True  # Condition satisfied.\n        if not (lo < node.val < hi):\n            return False  # Condition not met.\n        return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n    return validate(root, float('-inf'), float('inf'))"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "lowest-common-ancestor-of-a-bst": {
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "pattern": "BST Property",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(h)",
      "spaceComplexity": "O(1)",
      "oneliner": "If both p,q < node, go left. If both > node, go right. Else LCA.",
      "intuition": [
        "\ud83c\udfaf Find LCA in BST (not general tree).",
        "\ud83e\udde0 Use BST property: p < node < q means split.",
        "\ud83d\udca1 First node where p and q split is LCA."
      ],
      "testCases": [
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
          "output": "6"
        },
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
          "output": "2"
        },
        {
          "input": "root = [2,1], p = 2, q = 1",
          "output": "2"
        }
      ],
      "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA in BST (not general tree).\n    - \ud83e\udde0 Use BST property: p < node < q means split.\n    - \ud83d\udca1 First node where p and q split is LCA.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root.val\n    return None",
      "keyInsight": "BST structure lets us decide direction without full search.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Lowest Common Ancestor of a Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "If both p,q < node, go left. If both > node, go right. Else LCA.\n\nFind LCA in BST (not general tree).\nUse BST property: p < node < q means split.",
      "examples": [
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5]; p = 2; q = 8",
          "output": "6"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find LCA in BST (not general tree).",
        "Use BST property: p < node < q means split.",
        "First node where p and q split is LCA."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "gs2LMfuOR9k",
      "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
      "difficulty": "Medium",
      "walkthrough": [
        "Start at root node",
        "Compare p.val and q.val with root.val",
        "If both less than root.val, move to left subtree",
        "If both greater than root.val, move to right subtree",
        "Otherwise, current node is the LCA (split point)",
        "Return the current node's value"
      ],
      "approach": "BST Property: If both p,q < node, go left. If both > node, go right. Else LCA.",
      "suggestedNextQuestion": {
        "slug": "min-cost-to-connect-all-points",
        "title": "Min Cost to Connect All Points",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
      "initialCode": "def lowestCommonAncestor(root, p, q):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    curr = root\n    while curr:\n        if p.val > curr.val and q.val > curr.val:\n            curr = curr.right\n        elif p.val < curr.val and q.val < curr.val:\n            curr = curr.left\n        else:\n            return curr"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find LCA in BST (not general tree).",
            "\ud83e\udde0 Use BST property: p < node < q means split.",
            "\ud83d\udca1 First node where p and q split is LCA."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA in BST (not general tree).\n    - \ud83e\udde0 Use BST property: p < node < q means split.\n    - \ud83d\udca1 First node where p and q split is LCA.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root.val\n    return None"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "balance-a-binary-search-tree": {
      "title": "Balance a Binary Search Tree",
      "pattern": "Inorder + Rebuild",
      "patternEmoji": "\u2696\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Inorder to sorted array. Build balanced BST from array.",
      "intuition": [
        "\ud83c\udfaf Convert BST to balanced BST.",
        "\ud83e\udde0 Extract sorted array via inorder.",
        "\ud83d\udca1 Recursively build from middle element."
      ],
      "testCases": [
        {
          "input": "root = [1,null,2,null,3,null,4,null,null]",
          "output": "[2,1,3,null,null,null,4]"
        },
        {
          "input": "root = [2,1,3]",
          "output": "[2,1,3]"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef balanceBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert BST to balanced BST.\n    - \ud83e\udde0 Extract sorted array via inorder.\n    - \ud83d\udca1 Recursively build from middle element.\n    \"\"\"\n    vals = []\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        vals.append(node.val)  # Add to end.\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    def build(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        node = TreeNode(vals[mid])  # Create a new Tree Node.\n        node.left = build(l, mid - 1)\n        node.right = build(mid + 1, r)\n        return node\n    return build(0, len(vals) - 1)",
      "keyInsight": "Middle element as root gives balanced tree.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Balance a Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Inorder to sorted array. Build balanced BST from array.\n\nConvert BST to balanced BST.\nExtract sorted array via inorder.",
      "examples": [
        {
          "input": "root = [1,null,2,null,3,null,4]",
          "output": "[2,1,3,null,null,null,4]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Convert BST to balanced BST.",
        "Extract sorted array via inorder.",
        "Recursively build from middle element."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "fqx8z3VepMA",
      "problemStatement": "Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Inorder + Rebuild: Inorder to sorted array. Build balanced BST from array.",
      "suggestedNextQuestion": {
        "slug": "binary-search-tree-iterator",
        "title": "Binary Search Tree Iterator",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef balanceBST(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def balanceBST(root):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    \n    def build(l, r):\n        if l > r: return None\n        m = (l + r) // 2\n        node = TreeNode(vals[m])\n        node.left = build(l, m - 1)\n        node.right = build(m + 1, r)\n        return node\n    return build(0, len(vals) - 1)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Convert BST to balanced BST.",
            "\ud83e\udde0 Extract sorted array via inorder.",
            "\ud83d\udca1 Recursively build from middle element."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef balanceBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert BST to balanced BST.\n    - \ud83e\udde0 Extract sorted array via inorder.\n    - \ud83d\udca1 Recursively build from middle element.\n    \"\"\"\n    vals = []\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        vals.append(node.val)  # Add to end.\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    def build(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        node = TreeNode(vals[mid])  # Create a new Tree Node.\n        node.left = build(l, mid - 1)\n        node.right = build(mid + 1, r)\n        return node\n    return build(0, len(vals) - 1)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "surrounded-regions": {
      "title": "Surrounded Regions",
      "pattern": "DFS from Border",
      "patternEmoji": "\ud83d\uddfa\ufe0f",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m*n)",
      "oneliner": "DFS from border Os to mark safe. Flip remaining Os to Xs.",
      "intuition": [
        "\ud83c\udfaf Flip all O regions NOT connected to border.",
        "\ud83e\udde0 Mark border-connected Os as safe.",
        "\ud83d\udca1 Flip remaining Os, restore safe ones."
      ],
      "testCases": [
        {
          "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
          "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
        },
        {
          "input": "board = [[\"X\"]]",
          "output": "[[\"X\"]]"
        }
      ],
      "code": "def solve(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flip all O regions NOT connected to border.\n    - \ud83e\udde0 Mark border-connected Os as safe.\n    - \ud83d\udca1 Flip remaining Os, restore safe ones.\n    \"\"\"\n    if not board: return board\n    m, n = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n            return\n        board[r][c] = 'S'\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    for r in range(m):  # Iterate through the range.\n        dfs(r, 0); dfs(r, n-1)\n    for c in range(n):  # Iterate through the range.\n        dfs(0, c); dfs(m-1, c)\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n    return board",
      "keyInsight": "Work from border inward to identify safe regions.",
      "visualizationType": "grid",
      "initialState": [
        [
          "X",
          "X",
          "X",
          "X"
        ],
        [
          "X",
          "O",
          "O",
          "X"
        ],
        [
          "X",
          "X",
          "O",
          "X"
        ],
        [
          "X",
          "O",
          "X",
          "X"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Surrounded Regions",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: X",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: X",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: X",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: O",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "X",
              "X",
              "X",
              "X"
            ],
            [
              "X",
              "O",
              "O",
              "X"
            ],
            [
              "X",
              "X",
              "O",
              "X"
            ],
            [
              "X",
              "O",
              "X",
              "X"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "DFS from border Os to mark safe. Flip remaining Os to Xs.\n\nFlip all O regions NOT connected to border.\nMark border-connected Os as safe.",
      "examples": [
        {
          "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
          "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Flip all O regions NOT connected to border.",
        "Mark border-connected Os as safe.",
        "Flip remaining Os, restore safe ones."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "9z2BunfoZ5Y",
      "problemStatement": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded:\nTo capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS from Border: DFS from border Os to mark safe. Flip remaining Os to Xs.",
      "suggestedNextQuestion": {
        "slug": "validate-binary-search-tree",
        "title": "Validate Binary Search Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def solve(board):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def solve(board):\n    if not board: return\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or c < 0 or r == rows or c == cols or board[r][c] != 'O':\n            return\n        board[r][c] = 'T'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n        \n    # Capture unsurrounded regions (O -> T)\n    for r in range(rows):\n        for c in range(cols):\n            if (board[r][c] == 'O' and \n                (r in [0, rows-1] or c in [0, cols-1])):\n                dfs(r, c)\n                \n    # Capture surrounded regions (O -> X, T -> O)\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O': \n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m*n)",
          "intuition": [
            "\ud83c\udfaf Flip all O regions NOT connected to border.",
            "\ud83e\udde0 Mark border-connected Os as safe.",
            "\ud83d\udca1 Flip remaining Os, restore safe ones."
          ],
          "code": "def solve(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flip all O regions NOT connected to border.\n    - \ud83e\udde0 Mark border-connected Os as safe.\n    - \ud83d\udca1 Flip remaining Os, restore safe ones.\n    \"\"\"\n    if not board: return board\n    m, n = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n            return\n        board[r][c] = 'S'\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    for r in range(m):  # Iterate through the range.\n        dfs(r, 0); dfs(r, n-1)\n    for c in range(n):  # Iterate through the range.\n        dfs(0, c); dfs(m-1, c)\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n    return board"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "evaluate-division": {
      "title": "Evaluate Division",
      "pattern": "Graph BFS/DFS",
      "patternEmoji": "\u2797",
      "timeComplexity": "O(Q*(V+E))",
      "spaceComplexity": "O(V+E)",
      "oneliner": "Build graph of ratios. DFS/BFS to find path and multiply.",
      "intuition": [
        "\ud83c\udfaf Evaluate queries given equations with values.",
        "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
        "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
      ],
      "testCases": [
        {
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
        },
        {
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "output": "[3.75000,0.40000,5.00000,0.20000]"
        },
        {
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "output": "[0.50000,2.00000,-1.00000,-1.00000]"
        }
      ],
      "code": "from collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Evaluate queries given equations with values.\n    - \ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.\n    - \ud83d\udca1 Query a/c = path from a to c, multiply weights.\n    \"\"\"\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):  # Iterate over elements.\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n    \n    def dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        visited.add(start)\n        for nei, val in graph[start].items():  # Iterate over elements.\n            if nei not in visited:\n                res = dfs(nei, end, visited)\n                if res != -1.0:\n                    return val * res\n        return -1.0\n    \n    return [dfs(a, b, set()) for a, b in queries]",
      "keyInsight": "Weighted graph where edge weight represents the ratio.",
      "visualizationType": "graph",
      "initialState": [
        [
          "a",
          "b"
        ],
        [
          "b",
          "c"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Build Graph from Equations",
          "transientMessage": "equations = [[a,b],[b,c]], values = [2.0, 3.0]",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150
              }
            ],
            "edges": []
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Add edge: a \u2192 b = 2.0",
          "transientMessage": "a / b = 2.0 means graph[a][b] = 2.0",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150,
                "highlight": true
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0,
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Add reverse: b \u2192 a = 0.5",
          "transientMessage": "Also store inverse: graph[b][a] = 1/2.0 = 0.5",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150,
                "highlight": true
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5,
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Add edge: b \u2192 c = 3.0",
          "transientMessage": "b / c = 3.0 means graph[b][c] = 3.0",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150,
                "highlight": true
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0,
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Add reverse: c \u2192 b = 0.33",
          "transientMessage": "graph[c][b] = 1/3.0 \u2248 0.33",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0
              },
              {
                "from": "c",
                "to": "b",
                "weight": 0.33,
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Query: a / c = ?",
          "transientMessage": "Find path from 'a' to 'c', multiply weights",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a (start)",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150
              },
              {
                "id": "c",
                "label": "c (goal)",
                "x": 400,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0
              },
              {
                "from": "c",
                "to": "b",
                "weight": 0.33
              }
            ]
          },
          "pointers": [
            {
              "label": "DFS",
              "node": "a"
            }
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "DFS: Start at 'a'",
          "transientMessage": "visited = {a}, result = 1.0",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0
              },
              {
                "from": "c",
                "to": "b",
                "weight": 0.33
              }
            ]
          },
          "pointers": [
            {
              "label": "curr",
              "node": "a"
            }
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "DFS: a \u2192 b (\u00d72.0)",
          "transientMessage": "Traverse edge a\u2192b, multiply: 1.0 \u00d7 2.0 = 2.0",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "b",
                "label": "b \u2713",
                "x": 250,
                "y": 150,
                "visited": true,
                "highlight": true
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0,
                "highlight": true
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0
              },
              {
                "from": "c",
                "to": "b",
                "weight": 0.33
              }
            ]
          },
          "pointers": [
            {
              "label": "curr",
              "node": "b"
            },
            {
              "label": "result",
              "value": "2.0"
            }
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "DFS: b \u2192 c (\u00d73.0)",
          "transientMessage": "Traverse edge b\u2192c, multiply: 2.0 \u00d7 3.0 = 6.0",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "b",
                "label": "b \u2713",
                "x": 250,
                "y": 150,
                "visited": true
              },
              {
                "id": "c",
                "label": "c \u2713",
                "x": 400,
                "y": 150,
                "visited": true,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0,
                "highlight": true
              },
              {
                "from": "b",
                "to": "a",
                "weight": 0.5
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0,
                "highlight": true
              },
              {
                "from": "c",
                "to": "b",
                "weight": 0.33
              }
            ]
          },
          "pointers": [
            {
              "label": "curr",
              "node": "c"
            },
            {
              "label": "result",
              "value": "6.0"
            }
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Found: a / c = 6.0",
          "transientMessage": "Path: a  b  c = 2.0  3.0 = 6.0 ",
          "graphState": {
            "nodes": [
              {
                "id": "a",
                "label": "a",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "b",
                "label": "b",
                "x": 250,
                "y": 150,
                "highlight": true
              },
              {
                "id": "c",
                "label": "c",
                "x": 400,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "a",
                "to": "b",
                "weight": 2.0,
                "highlight": true
              },
              {
                "from": "b",
                "to": "c",
                "weight": 3.0,
                "highlight": true
              }
            ]
          },
          "pointers": [
            {
              "label": "result",
              "value": "6.0"
            }
          ],
          "result": 6.0,
          "color": "success"
        }
      ],
      "description": "Build graph of ratios. DFS/BFS to find path and multiply.\n\nEvaluate queries given equations with values.\nBuild weighted graph: a/b = k means edge a->b with weight k.",
      "examples": [
        {
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]]; values = [2.0,3.0]; queries = [[\"a\",\"c\"]]",
          "output": "[6.0]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Evaluate queries given equations with values.",
        "Build weighted graph: a/b = k means edge a->b with weight k.",
        "Query a/c = path from a to c, multiply weights."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Uei1fwDoyKk",
      "problemStatement": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Graph BFS/DFS: Build graph of ratios. DFS/BFS to find path and multiply.",
      "suggestedNextQuestion": {
        "slug": "graph-valid-tree",
        "title": "Graph Valid Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def calcEquation(equations, values, queries):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(V * E) or O(V!)",
          "spaceComplexity": "O(V)",
          "intuition": [
            "Explore all possible paths.",
            "Use DFS/BFS without optimization."
          ],
          "code": "def calcEquation_brute(graph, start, end):\n    # DFS all paths\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start, set())"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(Q*(V+E))",
          "spaceComplexity": "O(V+E)",
          "intuition": [
            "\ud83c\udfaf Evaluate queries given equations with values.",
            "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
            "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
          ],
          "code": "from collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Evaluate queries given equations with values.\n    - \ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.\n    - \ud83d\udca1 Query a/c = path from a to c, multiply weights.\n    \"\"\"\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):  # Iterate over elements.\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n    \n    def dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        visited.add(start)\n        for nei, val in graph[start].items():  # Iterate over elements.\n            if nei not in visited:\n                res = dfs(nei, end, visited)\n                if res != -1.0:\n                    return val * res\n        return -1.0\n    \n    return [dfs(a, b, set()) for a, b in queries]"
        }
      ],
      "commonMistakes": [
        "Forgetting to mark nodes as visited",
        "Not handling disconnected components",
        "Wrong initialization of distance array"
      ],
      "interviewTip": "Clarify: directed/undirected, weighted/unweighted. Mention BFS for shortest path."
    },
    "course-schedule-ii": {
      "title": "Course Schedule II",
      "pattern": "Topological Sort",
      "patternEmoji": "\ud83d\udcda",
      "timeComplexity": "O(V+E)",
      "spaceComplexity": "O(V+E)",
      "oneliner": "Kahn's algorithm: BFS with indegree. Return order or [].",
      "intuition": [
        "\ud83c\udfaf Return valid course order or [] if impossible.",
        "\ud83e\udde0 Topological sort using indegree.",
        "\ud83d\udca1 If all courses processed, return order."
      ],
      "testCases": [
        {
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "output": "[0,1]"
        },
        {
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "output": "[0, 1, 2, 3]"
        },
        {
          "input": "numCourses = 1, prerequisites = []",
          "output": "[0]"
        }
      ],
      "code": "from collections import deque, defaultdict\n\ndef findOrder(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return valid course order or [] if impossible.\n    - \ud83e\udde0 Topological sort using indegree.\n    - \ud83d\udca1 If all courses processed, return order.\n    \"\"\"\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for a, b in prerequisites:  # Iterate over elements.\n        graph[b].append(a)  # Add to end.\n        indegree[a] += 1\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])  # Initialize queue for BFS.\n    order = []\n    while q:\n        course = q.popleft()  # Remove from front of queue.\n        order.append(course)  # Add to end.\n        for nei in graph[course]:  # Iterate over elements.\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                q.append(nei)  # Add to end.\n    return order if len(order) == numCourses else []",
      "keyInsight": "Topological sort returns empty if cycle exists.",
      "visualizationType": "graph",
      "initialState": [
        0,
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Build DAG",
          "transientMessage": "prereqs define order",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0",
                "x": 200,
                "y": 50
              },
              {
                "id": "1",
                "label": "1",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Kahn's: Start 0",
          "transientMessage": "order = [0]",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "1",
                "label": "1",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "highlight": true
              },
              {
                "from": "0",
                "to": "2",
                "highlight": true
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [
            {
              "label": "order",
              "value": "[0]"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Take 1, 2",
          "transientMessage": "order = [0,1,2]",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 150,
                "visited": true
              },
              {
                "id": "3",
                "label": "3",
                "x": 200,
                "y": 250,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [
            {
              "label": "order",
              "value": "[0,1,2]"
            }
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Result: [0,1,2,3]",
          "transientMessage": "Valid topological order",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 200,
                "y": 50
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 150
              },
              {
                "id": "3",
                "label": "3 \u2713",
                "x": 200,
                "y": 250
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "0",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3"
              }
            ]
          },
          "pointers": [
            {
              "label": "order",
              "value": "[0,1,2,3]"
            }
          ],
          "color": "success"
        }
      ],
      "description": "Kahn's algorithm: BFS with indegree. Return order or [].\n\nReturn valid course order or [] if impossible.\nTopological sort using indegree.",
      "examples": [
        {
          "input": "numCourses = 4; prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "output": "[0,1,2,3]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Return valid course order or [] if impossible.",
        "Topological sort using indegree.",
        "If all courses processed, return order."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Akt3glAwyfY",
      "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Topological Sort: Kahn's algorithm: BFS with indegree. Return order or [].",
      "graphNodes": [
        {
          "id": 0,
          "label": "0"
        },
        {
          "id": 1,
          "label": "1"
        },
        {
          "id": 2,
          "label": "2"
        },
        {
          "id": 3,
          "label": "3"
        }
      ],
      "graphEdges": [
        {
          "from": 1,
          "to": 0
        },
        {
          "from": 2,
          "to": 0
        },
        {
          "from": 3,
          "to": 1
        },
        {
          "from": 3,
          "to": 2
        }
      ],
      "suggestedNextQuestion": {
        "slug": "diameter-of-binary-tree",
        "title": "Diameter of Binary Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like putting on clothes. Socks before shoes. Order matters based on dependencies.",
      "initialCode": "def findOrder(numCourses, prerequisites):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findOrder(numCourses, prerequisites):\n    prereq = { c:[] for c in range(numCourses) }\n    for crs, pre in prerequisites:\n        prereq[crs].append(pre)\n        \n    output = []\n    visit, cycle = set(), set()\n    def dfs(crs):\n        if crs in cycle: return False\n        if crs in visit: return True\n        \n        cycle.add(crs)\n        for pre in prereq[crs]:\n            if not dfs(pre): return False\n        cycle.remove(crs)\n        visit.add(crs)\n        output.append(crs)\n        return True\n        \n    for c in range(numCourses):\n        if not dfs(c): return []\n    return output"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(V+E)",
          "spaceComplexity": "O(V+E)",
          "intuition": [
            "\ud83c\udfaf Return valid course order or [] if impossible.",
            "\ud83e\udde0 Topological sort using indegree.",
            "\ud83d\udca1 If all courses processed, return order."
          ],
          "code": "from collections import deque, defaultdict\n\ndef findOrder(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return valid course order or [] if impossible.\n    - \ud83e\udde0 Topological sort using indegree.\n    - \ud83d\udca1 If all courses processed, return order.\n    \"\"\"\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for a, b in prerequisites:  # Iterate over elements.\n        graph[b].append(a)  # Add to end.\n        indegree[a] += 1\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])  # Initialize queue for BFS.\n    order = []\n    while q:\n        course = q.popleft()  # Remove from front of queue.\n        order.append(course)  # Add to end.\n        for nei in graph[course]:  # Iterate over elements.\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                q.append(nei)  # Add to end.\n    return order if len(order) == numCourses else []"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "diameter-of-binary-tree": {
      "title": "Diameter of Binary Tree",
      "pattern": "DFS + Global Max",
      "patternEmoji": "\ud83d\udccf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "For each node, diameter through it = left_height + right_height.",
      "intuition": [
        "\ud83c\udfaf Longest path between any two nodes.",
        "\ud83e\udde0 At each node: path through it = left + right heights.",
        "\ud83d\udca1 Return height, but track max diameter."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3,4,5]",
          "output": "3"
        },
        {
          "input": "root = [1,2]",
          "output": "1"
        }
      ],
      "code": "def diameterOfBinaryTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Longest path between any two nodes.\n    - \ud83e\udde0 At each node: path through it = left + right heights.\n    - \ud83d\udca1 Return height, but track max diameter.\n    \"\"\"\n    diameter = [0]\n    def height(node):\n        if not node:\n            return 0\n        left = height(node.left)\n        right = height(node.right)\n        diameter[0] = max(diameter[0], left + right)  # Take the maximum value.\n        return 1 + max(left, right)  # Take the maximum value.\n    height(root)\n    return diameter[0]",
      "keyInsight": "Diameter through node = sum of left and right subtree heights.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Diameter of Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "For each node, diameter through it = left_height + right_height.\n\nLongest path between any two nodes.\nAt each node: path through it = left + right heights.",
      "examples": [
        {
          "input": "root = [1,2,3,4,5]",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Longest path between any two nodes.",
        "At each node: path through it = left + right heights.",
        "Return height, but track max diameter."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "bkxqA8Rfv04",
      "problemStatement": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DFS + Global Max: For each node, diameter through it = left_height + right_height.",
      "suggestedNextQuestion": {
        "slug": "evaluate-division",
        "title": "Evaluate Division",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def diameterOfBinaryTree(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def diameterOfBinaryTree(root):\n    res = [0]\n    def dfs(root):\n        if not root: return -1\n        left = dfs(root.left)\n        right = dfs(root.right)\n        res[0] = max(res[0], 2 + left + right)\n        return 1 + max(left, right)\n    dfs(root)\n    return res[0]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Longest path between any two nodes.",
            "\ud83e\udde0 At each node: path through it = left + right heights.",
            "\ud83d\udca1 Return height, but track max diameter."
          ],
          "code": "def diameterOfBinaryTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Longest path between any two nodes.\n    - \ud83e\udde0 At each node: path through it = left + right heights.\n    - \ud83d\udca1 Return height, but track max diameter.\n    \"\"\"\n    diameter = [0]\n    def height(node):\n        if not node:\n            return 0\n        left = height(node.left)\n        right = height(node.right)\n        diameter[0] = max(diameter[0], left + right)  # Take the maximum value.\n        return 1 + max(left, right)  # Take the maximum value.\n    height(root)\n    return diameter[0]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "cheapest-flights-within-k-stops": {
      "title": "Cheapest Flights Within K Stops",
      "pattern": "BFS / Bellman-Ford",
      "patternEmoji": "\u2708\ufe0f",
      "timeComplexity": "O(K*E)",
      "spaceComplexity": "O(V)",
      "oneliner": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
      "intuition": [
        "\ud83c\udfaf Cheapest flight with at most k stops.",
        "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
        "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
      ],
      "testCases": [
        {
          "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
          "output": "700"
        },
        {
          "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
          "output": "200"
        },
        {
          "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0",
          "output": "500"
        }
      ],
      "code": "def findCheapestPrice(n, flights, src, dst, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Cheapest flight with at most k stops.\n    - \ud83e\udde0 Bellman-Ford with k+1 relaxations.\n    - \ud83d\udca1 Use copy of distances to avoid this-iteration dependency.\n    \"\"\"\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for _ in range(k + 1):  # Iterate through the range.\n        temp = prices[:]\n        for s, d, p in flights:  # Iterate over elements.\n            if prices[s] != float('inf'):\n                temp[d] = min(temp[d], prices[s] + p)  # Take the minimum value.\n        prices = temp\n    return prices[dst] if prices[dst] != float('inf') else -1",
      "keyInsight": "Use copy of prices array to ensure correct iteration count.",
      "visualizationType": "graph",
      "initialState": [
        0,
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Flight Graph",
          "transientMessage": "src=0, dst=2, k=1",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0",
                "x": 100,
                "y": 100
              },
              {
                "id": "1",
                "label": "1",
                "x": 250,
                "y": 50
              },
              {
                "id": "2",
                "label": "2",
                "x": 400,
                "y": 100
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "weight": 100
              },
              {
                "from": "1",
                "to": "2",
                "weight": 100
              },
              {
                "from": "0",
                "to": "2",
                "weight": 500
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "BFS: Start 0",
          "transientMessage": "cost=0",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 ($0)",
                "x": 100,
                "y": 100,
                "highlight": true
              },
              {
                "id": "1",
                "label": "1 (\u221e)",
                "x": 250,
                "y": 50
              },
              {
                "id": "2",
                "label": "2 (\u221e)",
                "x": 400,
                "y": 100
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "weight": 100
              },
              {
                "from": "1",
                "to": "2",
                "weight": 100
              },
              {
                "from": "0",
                "to": "2",
                "weight": 500
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "0\u21921: $100",
          "transientMessage": "0\u21922: $500",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 ($0)",
                "x": 100,
                "y": 100,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 ($100)",
                "x": 250,
                "y": 50,
                "highlight": true
              },
              {
                "id": "2",
                "label": "2 ($500)",
                "x": 400,
                "y": 100
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "weight": 100,
                "highlight": true
              },
              {
                "from": "1",
                "to": "2",
                "weight": 100
              },
              {
                "from": "0",
                "to": "2",
                "weight": 500
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "1\u21922: $200",
          "transientMessage": "Better than $500!",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0",
                "x": 100,
                "y": 100
              },
              {
                "id": "1",
                "label": "1",
                "x": 250,
                "y": 50
              },
              {
                "id": "2",
                "label": "2",
                "x": 400,
                "y": 100
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "weight": 100,
                "highlight": true
              },
              {
                "from": "1",
                "to": "2",
                "weight": 100,
                "highlight": true
              },
              {
                "from": "0",
                "to": "2",
                "weight": 500
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "200"
            }
          ],
          "color": "success"
        }
      ],
      "description": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.\n\nCheapest flight with at most k stops.\nBellman-Ford with k+1 relaxations.",
      "examples": [
        {
          "input": "n = 4; flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]; src = 0; dst = 3; k = 1",
          "output": "700"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Cheapest flight with at most k stops.",
        "Bellman-Ford with k+1 relaxations.",
        "Use copy of distances to avoid this-iteration dependency."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "5eIK3zUdYmE",
      "problemStatement": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BFS / Bellman-Ford: Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
      "suggestedNextQuestion": {
        "slug": "clone-graph",
        "title": "Clone Graph",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def findCheapestPrice(n, flights, src, dst, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findCheapestPrice(n, flights, src, dst, k):\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    for i in range(k + 1):\n        tmpPrices = prices[:]\n        for s, d, p in flights:\n            if prices[s] == float('inf'): continue\n            if prices[s] + p < tmpPrices[d]:\n                tmpPrices[d] = prices[s] + p\n        prices = tmpPrices\n    return -1 if prices[dst] == float('inf') else prices[dst]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(K*E)",
          "spaceComplexity": "O(V)",
          "intuition": [
            "\ud83c\udfaf Cheapest flight with at most k stops.",
            "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
            "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
          ],
          "code": "def findCheapestPrice(n, flights, src, dst, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Cheapest flight with at most k stops.\n    - \ud83e\udde0 Bellman-Ford with k+1 relaxations.\n    - \ud83d\udca1 Use copy of distances to avoid this-iteration dependency.\n    \"\"\"\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for _ in range(k + 1):  # Iterate through the range.\n        temp = prices[:]\n        for s, d, p in flights:  # Iterate over elements.\n            if prices[s] != float('inf'):\n                temp[d] = min(temp[d], prices[s] + p)  # Take the minimum value.\n        prices = temp\n    return prices[dst] if prices[dst] != float('inf') else -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "snakes-and-ladders": {
      "title": "Snakes and Ladders",
      "pattern": "BFS",
      "patternEmoji": "\ud83d\udc0d",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(n\u00b2)",
      "oneliner": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
      "intuition": [
        "\ud83c\udfaf Min dice rolls to reach last square.",
        "\ud83e\udde0 BFS level = number of moves.",
        "\ud83d\udca1 Handle boustrophedon numbering."
      ],
      "testCases": [
        {
          "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
          "output": "4"
        },
        {
          "input": "board = [[-1,-1],[-1,3]]",
          "output": "1"
        }
      ],
      "code": "from collections import deque\n\ndef snakesAndLadders(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min dice rolls to reach last square.\n    - \ud83e\udde0 BFS level = number of moves.\n    - \ud83d\udca1 Handle boustrophedon numbering.\n    \"\"\"\n    n = len(board)\n    def getPos(sq):\n        r, c = divmod(sq - 1, n)\n        if r % 2 == 1:\n            c = n - 1 - c\n        return n - 1 - r, c\n    \n    q = deque([(1, 0)])  # Initialize queue for BFS.\n    visited = {1}\n    while q:\n        sq, moves = q.popleft()  # Remove from front of queue.\n        for i in range(1, 7):  # Iterate through the range.\n            nxt = sq + i\n            if nxt > n * n:\n                continue\n            r, c = getPos(nxt)\n            if board[r][c] != -1:\n                nxt = board[r][c]\n            if nxt == n * n:\n                return moves + 1\n            if nxt not in visited:\n                visited.add(nxt)\n                q.append((nxt, moves + 1))  # Add to end.\n    return -1",
      "keyInsight": "Convert 1D square number to 2D board coordinates carefully.",
      "visualizationType": "matrix",
      "initialState": [
        [
          "-1",
          "-1"
        ],
        [
          "36",
          "25"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Snakes and Ladders",
          "transientMessage": "Grid-based algorithm",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Step 1",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Step 2",
          "transientMessage": "Processing cell (0, 0)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Step 3",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Step 4",
          "transientMessage": "Processing cell (0, 0)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Step 5",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Step 6",
          "transientMessage": "Processing cell (0, 0)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Step 7",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Step 8",
          "transientMessage": "Processing cell (0, 0)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Step 9",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Step 10",
          "transientMessage": "Processing cell (0, 0)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Step 11",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "-1",
              "-1"
            ],
            [
              "36",
              "25"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "success"
        }
      ],
      "description": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.\n\nMin dice rolls to reach last square.\nBFS level = number of moves.",
      "examples": [
        {
          "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min dice rolls to reach last square.",
        "BFS level = number of moves.",
        "Handle boustrophedon numbering."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "word-ladder",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "6lH4nO3JfLk",
      "problemStatement": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 are not the starting points of any snake or ladder.\nNote that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\nReturn the least number of dice rolls required to reach the square n2. If it is not possible to reach the square, return -1.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
      "suggestedNextQuestion": {
        "slug": "sum-root-to-leaf-numbers",
        "title": "Sum Root to Leaf Numbers",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def snakesAndLadders(board):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def snakesAndLadders(board):\n    length = len(board)\n    board.reverse()\n    def intToPos(square):\n        r = (square - 1) // length\n        c = (square - 1) % length\n        if r % 2: c = length - 1 - c\n        return [r, c]\n        \n    q = [(1, 0)] # [square, moves]\n    visit = set()\n    while q:\n        square, moves = q.pop(0)\n        for i in range(1, 7):\n            nextSquare = square + i\n            r, c = intToPos(nextSquare)\n            if board[r][c] != -1:\n                nextSquare = board[r][c]\n            if nextSquare == length*length:\n                return moves + 1\n            if nextSquare not in visit:\n                visit.add(nextSquare)\n                q.append((nextSquare, moves + 1))\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(n\u00b2)",
          "intuition": [
            "\ud83c\udfaf Min dice rolls to reach last square.",
            "\ud83e\udde0 BFS level = number of moves.",
            "\ud83d\udca1 Handle boustrophedon numbering."
          ],
          "code": "from collections import deque\n\ndef snakesAndLadders(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min dice rolls to reach last square.\n    - \ud83e\udde0 BFS level = number of moves.\n    - \ud83d\udca1 Handle boustrophedon numbering.\n    \"\"\"\n    n = len(board)\n    def getPos(sq):\n        r, c = divmod(sq - 1, n)\n        if r % 2 == 1:\n            c = n - 1 - c\n        return n - 1 - r, c\n    \n    q = deque([(1, 0)])  # Initialize queue for BFS.\n    visited = {1}\n    while q:\n        sq, moves = q.popleft()  # Remove from front of queue.\n        for i in range(1, 7):  # Iterate through the range.\n            nxt = sq + i\n            if nxt > n * n:\n                continue\n            r, c = getPos(nxt)\n            if board[r][c] != -1:\n                nxt = board[r][c]\n            if nxt == n * n:\n                return moves + 1\n            if nxt not in visited:\n                visited.add(nxt)\n                q.append((nxt, moves + 1))  # Add to end.\n    return -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-genetic-mutation": {
      "title": "Minimum Genetic Mutation",
      "pattern": "BFS",
      "patternEmoji": "\ud83e\uddec",
      "timeComplexity": "O(B*8*4)",
      "spaceComplexity": "O(B)",
      "oneliner": "BFS from startGene. Each level = 1 mutation. Valid if in bank.",
      "intuition": [
        "\ud83c\udfaf Min mutations to reach endGene.",
        "\ud83e\udde0 BFS where edges are single char changes in bank.",
        "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
      ],
      "testCases": [
        {
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "output": "1"
        },
        {
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "output": "2"
        }
      ],
      "code": "from collections import deque\n\ndef minMutation(startGene, endGene, bank):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min mutations to reach endGene.\n    - \ud83e\udde0 BFS where edges are single char changes in bank.\n    - \ud83d\udca1 Each mutation changes one character to A/C/G/T.\n    \"\"\"\n    bank = set(bank)\n    if endGene not in bank:\n        return -1\n    q = deque([(startGene, 0)])  # Initialize queue for BFS.\n    visited = {startGene}\n    while q:\n        gene, mutations = q.popleft()  # Remove from front of queue.\n        if gene == endGene:\n            return mutations\n        for i in range(8):  # Iterate through the range.\n            for c in 'ACGT':  # Iterate over elements.\n                nxt = gene[:i] + c + gene[i+1:]\n                if nxt in bank and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, mutations + 1))  # Add to end.\n    return -1",
      "keyInsight": "Try all single-character mutations, check if in bank.",
      "visualizationType": "array",
      "initialState": "AACCGGTT",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Genetic Mutation",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = A",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = A",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = C",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = C",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = G",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = G",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "A",
            "A",
            "C",
            "C",
            "G",
            "G",
            "T",
            "T"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "BFS from startGene. Each level = 1 mutation. Valid if in bank.\n\nMin mutations to reach endGene.\nBFS where edges are single char changes in bank.",
      "examples": [
        {
          "input": "startGene = \"AACCGGTT\"; endGene = \"AAACGGTA\"; bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min mutations to reach endGene.",
        "BFS where edges are single char changes in bank.",
        "Each mutation changes one character to A/C/G/T."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "word-ladder",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "9lkn3rHCSLg",
      "problemStatement": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS from startGene. Each level = 1 mutation. Valid if in bank.",
      "suggestedNextQuestion": {
        "slug": "network-delay-time",
        "title": "Network Delay Time",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def minMutation(startGene, endGene, bank):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def minMutation(start, end, bank):\n    q = [(start, 0)]\n    visit = set([start])\n    bank = set(bank)\n    \n    while q:\n        curr, moves = q.pop(0)\n        if curr == end: return moves\n        \n        for i in range(8):\n            for c in \"ACGT\":\n                nei = curr[:i] + c + curr[i+1:]\n                if nei in bank and nei not in visit:\n                    visit.add(nei)\n                    q.append((nei, moves + 1))\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(B*8*4)",
          "spaceComplexity": "O(B)",
          "intuition": [
            "\ud83c\udfaf Min mutations to reach endGene.",
            "\ud83e\udde0 BFS where edges are single char changes in bank.",
            "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
          ],
          "code": "from collections import deque\n\ndef minMutation(startGene, endGene, bank):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min mutations to reach endGene.\n    - \ud83e\udde0 BFS where edges are single char changes in bank.\n    - \ud83d\udca1 Each mutation changes one character to A/C/G/T.\n    \"\"\"\n    bank = set(bank)\n    if endGene not in bank:\n        return -1\n    q = deque([(startGene, 0)])  # Initialize queue for BFS.\n    visited = {startGene}\n    while q:\n        gene, mutations = q.popleft()  # Remove from front of queue.\n        if gene == endGene:\n            return mutations\n        for i in range(8):  # Iterate through the range.\n            for c in 'ACGT':  # Iterate over elements.\n                nxt = gene[:i] + c + gene[i+1:]\n                if nxt in bank and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, mutations + 1))  # Add to end.\n    return -1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "word-ladder": {
      "title": "Word Ladder",
      "pattern": "BFS",
      "patternEmoji": "\ud83d\udd20",
      "timeComplexity": "O(M\u00b2*N)",
      "spaceComplexity": "O(M*N)",
      "oneliner": "BFS from beginWord. Valid moves = 1 char diff in wordList.",
      "intuition": [
        "\ud83c\udfaf Min transformations to endWord.",
        "\ud83e\udde0 BFS where each level = 1 transformation.",
        "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
      ],
      "testCases": [
        {
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "output": "5"
        },
        {
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "output": "0"
        }
      ],
      "code": "from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min transformations to endWord.\n    - \ud83e\udde0 BFS where each level = 1 transformation.\n    - \ud83d\udca1 Use wildcard patterns for O(M) adjacency.\n    \"\"\"\n    if endWord not in wordList:\n        return 0\n    wordList = set(wordList)\n    q = deque([(beginWord, 1)])  # Initialize queue for BFS.\n    visited = {beginWord}\n    while q:\n        word, length = q.popleft()  # Remove from front of queue.\n        if word == endWord:\n            return length\n        for i in range(len(word)):  # Iterate through the range.\n            for c in 'abcdefghijklmnopqrstuvwxyz':  # Iterate over elements.\n                nxt = word[:i] + c + word[i+1:]\n                if nxt in wordList and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, length + 1))  # Add to end.\n    return 0",
      "keyInsight": "BFS guarantees minimum transformation sequence.",
      "visualizationType": "array",
      "initialState": "hit",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "transientMessage": "Starting BFS with initial word 'hit'",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "word"
            },
            {
              "index": 1,
              "label": "length"
            }
          ],
          "transientMessage": "Processing word 'hit' with length 1",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "transientMessage": "Generating neighbors for 'hit'",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "success",
          "transientMessage": "Found valid neighbor 'hot' and added to queue",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4
          ],
          "color": "accent",
          "transientMessage": "Processing word 'hot' with length 2",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "success",
          "transientMessage": "Found valid neighbor 'dot' and added to queue",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            6
          ],
          "color": "accent",
          "transientMessage": "Processing word 'dot' with length 3",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            7
          ],
          "color": "success",
          "transientMessage": "Found valid neighbor 'dog' and added to queue",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            8
          ],
          "color": "accent",
          "transientMessage": "Processing word 'dog' with length 4",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            9
          ],
          "color": "success",
          "transientMessage": "Found valid neighbor 'cog' and added to queue",
          "arrayState": [
            "h",
            "i",
            "t"
          ]
        }
      ],
      "description": "BFS from beginWord. Valid moves = 1 char diff in wordList.\n\nMin transformations to endWord.\nBFS where each level = 1 transformation.",
      "examples": [
        {
          "input": "beginWord = \"hit\"; endWord = \"cog\"; wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "output": "5"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min transformations to endWord.",
        "BFS where each level = 1 transformation.",
        "Use wildcard patterns for O(M) adjacency."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "h9iTnkgv05E",
      "problemStatement": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
      "difficulty": "Hard",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS from beginWord. Valid moves = 1 char diff in wordList.",
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def ladderLength(beginWord, endWord, wordList):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList: return 0\n    nei = {}\n    wordList.append(beginWord)\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            nei.setdefault(pattern, []).append(word)\n            \n    visit = set([beginWord])\n    q = [(beginWord, 1)]\n    while q:\n        word, dist = q.pop(0)\n        if word == endWord: return dist\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            for neiWord in nei.get(pattern, []):\n                if neiWord not in visit:\n                    visit.add(neiWord)\n                    q.append((neiWord, dist + 1))\n    return 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(M\u00b2*N)",
          "spaceComplexity": "O(M*N)",
          "intuition": [
            "\ud83c\udfaf Min transformations to endWord.",
            "\ud83e\udde0 BFS where each level = 1 transformation.",
            "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
          ],
          "code": "from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min transformations to endWord.\n    - \ud83e\udde0 BFS where each level = 1 transformation.\n    - \ud83d\udca1 Use wildcard patterns for O(M) adjacency.\n    \"\"\"\n    if endWord not in wordList:\n        return 0\n    wordList = set(wordList)\n    q = deque([(beginWord, 1)])  # Initialize queue for BFS.\n    visited = {beginWord}\n    while q:\n        word, length = q.popleft()  # Remove from front of queue.\n        if word == endWord:\n            return length\n        for i in range(len(word)):  # Iterate through the range.\n            for c in 'abcdefghijklmnopqrstuvwxyz':  # Iterate over elements.\n                nxt = word[:i] + c + word[i+1:]\n                if nxt in wordList and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, length + 1))  # Add to end.\n    return 0"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-depth-of-binary-tree": {
      "title": "Minimum Depth of Binary Tree",
      "pattern": "BFS",
      "patternEmoji": "\ud83d\udccf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "BFS level by level. Return level when first leaf found.",
      "intuition": [
        "\ud83c\udfaf Min depth to a leaf node.",
        "\ud83e\udde0 BFS finds closest leaf first.",
        "\ud83d\udca1 Better than DFS for unbalanced trees."
      ],
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "2"
        },
        {
          "input": "root = [2,null,3,null,4,null,5,null,6]",
          "output": "5"
        }
      ],
      "code": "from collections import deque\n\ndef minDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min depth to a leaf node.\n    - \ud83e\udde0 BFS finds closest leaf first.\n    - \ud83d\udca1 Better than DFS for unbalanced trees.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    q = deque([(root, 1)])  # Initialize queue for BFS.\n    while q:\n        node, depth = q.popleft()  # Remove from front of queue.\n        if not node.left and not node.right:\n            return depth\n        if node.left:\n            q.append((node.left, depth + 1))  # Add to end.\n        if node.right:\n            q.append((node.right, depth + 1))  # Add to end.\n    return 0",
      "keyInsight": "BFS stops early when first leaf is found.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Depth of Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "BFS level by level. Return level when first leaf found.\n\nMin depth to a leaf node.\nBFS finds closest leaf first.",
      "examples": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min depth to a leaf node.",
        "BFS finds closest leaf first.",
        "Better than DFS for unbalanced trees."
      ],
      "relatedProblems": [
        "binary-tree-level-order-traversal",
        "word-ladder",
        "shortest-path-in-binary-matrix"
      ],
      "videoId": "tZS4VHtbYoo",
      "problemStatement": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "approach": "BFS: BFS level by level. Return level when first leaf found.",
      "suggestedNextQuestion": {
        "slug": "minimum-genetic-mutation",
        "title": "Minimum Genetic Mutation",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def minDepth(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def minDepth(root):\n    if not root: return 0\n    if not root.left: return 1 + minDepth(root.right)\n    if not root.right: return 1 + minDepth(root.left)\n    return 1 + min(minDepth(root.left), minDepth(root.right))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Min depth to a leaf node.",
            "\ud83e\udde0 BFS finds closest leaf first.",
            "\ud83d\udca1 Better than DFS for unbalanced trees."
          ],
          "code": "from collections import deque\n\ndef minDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min depth to a leaf node.\n    - \ud83e\udde0 BFS finds closest leaf first.\n    - \ud83d\udca1 Better than DFS for unbalanced trees.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    q = deque([(root, 1)])  # Initialize queue for BFS.\n    while q:\n        node, depth = q.popleft()  # Remove from front of queue.\n        if not node.left and not node.right:\n            return depth\n        if node.left:\n            q.append((node.left, depth + 1))  # Add to end.\n        if node.right:\n            q.append((node.right, depth + 1))  # Add to end.\n    return 0"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "letter-combinations-of-a-phone-number": {
      "title": "Letter Combinations of a Phone Number",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udcf1",
      "timeComplexity": "O(4^n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Map digits to letters. Backtrack all combinations.",
      "intuition": [
        "\ud83c\udfaf All letter combinations from digits.",
        "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
        "\ud83d\udca1 Each digit adds multiple branches."
      ],
      "testCases": [
        {
          "input": "digits = \"23\"",
          "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
        },
        {
          "input": "digits = \"\"",
          "output": "[]"
        },
        {
          "input": "digits = \"2\"",
          "output": "[\"a\",\"b\",\"c\"]"
        }
      ],
      "code": "def letterCombinations(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All letter combinations from digits.\n    - \ud83e\udde0 Digit -> letters mapping. Backtrack choices.\n    - \ud83d\udca1 Each digit adds multiple branches.\n    \"\"\"\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(digits):\n            res.append(''.join(path))  # Add to end.\n            return\n        for c in phone[digits[i]]:  # Iterate over elements.\n            path.append(c)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result.",
      "keyInsight": "Standard backtracking with fixed choices per position.",
      "visualizationType": "array",
      "initialState": [
        "2",
        "3"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Digits: \"23\"",
          "transientMessage": "2\u2192abc, 3\u2192def",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Digit 2 \u2192 'a'",
          "transientMessage": "Path: \"a\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "a",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Digit 3 \u2192 'd'",
          "transientMessage": "Path: \"ad\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "d",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Found: \"ad\"",
          "transientMessage": "1 combination(s)",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Digit 3 \u2192 'e'",
          "transientMessage": "Path: \"ae\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "e",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found: \"ae\"",
          "transientMessage": "2 combination(s)",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Digit 3 \u2192 'f'",
          "transientMessage": "Path: \"af\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "f",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Found: \"af\"",
          "transientMessage": "3 combination(s)",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Digit 2 \u2192 'b'",
          "transientMessage": "Path: \"b\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "b",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Digit 3 \u2192 'd'",
          "transientMessage": "Path: \"bd\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "d",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Found: \"bd\"",
          "transientMessage": "4 combination(s)",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Digit 3 \u2192 'e'",
          "transientMessage": "Path: \"be\"",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [
            {
              "label": "e",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "Found: \"be\"",
          "transientMessage": "5 combination(s)",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "5 combinations",
          "transientMessage": "Complete!",
          "arrayState": [
            "2",
            "3"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Map digits to letters. Backtrack all combinations.\n\nAll letter combinations from digits.\nDigit -> letters mapping. Backtrack choices.",
      "examples": [
        {
          "input": "digits = \"23\"",
          "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "All letter combinations from digits.",
        "Digit -> letters mapping. Backtrack choices.",
        "Each digit adds multiple branches."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum",
        "subsets"
      ],
      "videoId": "0snEunUacZY",
      "problemStatement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Map digits to letters. Backtrack all combinations.",
      "suggestedNextQuestion": {
        "slug": "palindrome-partitioning",
        "title": "Palindrome Partitioning",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def letterCombinations(digits):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def letterCombinations_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(4^n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf All letter combinations from digits.",
            "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
            "\ud83d\udca1 Each digit adds multiple branches."
          ],
          "code": "def letterCombinations(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All letter combinations from digits.\n    - \ud83e\udde0 Digit -> letters mapping. Backtrack choices.\n    - \ud83d\udca1 Each digit adds multiple branches.\n    \"\"\"\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(digits):\n            res.append(''.join(path))  # Add to end.\n            return\n        for c in phone[digits[i]]:  # Iterate over elements.\n            path.append(c)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "combinations": {
      "title": "Combinations",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(C(n,k))",
      "spaceComplexity": "O(k)",
      "oneliner": "Backtrack choosing k elements from 1 to n.",
      "intuition": [
        "\ud83c\udfaf All combinations of k numbers from 1 to n.",
        "\ud83e\udde0 Backtrack: pick or skip each number.",
        "\ud83d\udca1 Start from current to avoid duplicates."
      ],
      "testCases": [
        {
          "input": "n = 4, k = 2",
          "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
        },
        {
          "input": "n = 1, k = 1",
          "output": "[[1]]"
        }
      ],
      "code": "def combine(n, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All combinations of k numbers from 1 to n.\n    - \ud83e\udde0 Backtrack: pick or skip each number.\n    - \ud83d\udca1 Start from current to avoid duplicates.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])  # Add to end.\n            return\n        for i in range(start, n + 1):  # Iterate through the range.\n            path.append(i)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(1, [])\n    return res  # Return the final result.",
      "keyInsight": "Start from 'start' index to avoid duplicate combinations.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Combinations",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [1]",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 2 to path",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try 3 instead",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Backtrack choosing k elements from 1 to n.\n\nAll combinations of k numbers from 1 to n.\nBacktrack: pick or skip each number.",
      "examples": [
        {
          "input": "n = 4; k = 2",
          "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "All combinations of k numbers from 1 to n.",
        "Backtrack: pick or skip each number.",
        "Start from current to avoid duplicates."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum",
        "subsets"
      ],
      "videoId": "q0s6m7AiM7o",
      "problemStatement": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Backtrack choosing k elements from 1 to n.",
      "suggestedNextQuestion": {
        "slug": "generate-parentheses",
        "title": "Generate Parentheses",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def combine(n, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def combine_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(C(n,k))",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf All combinations of k numbers from 1 to n.",
            "\ud83e\udde0 Backtrack: pick or skip each number.",
            "\ud83d\udca1 Start from current to avoid duplicates."
          ],
          "code": "def combine(n, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All combinations of k numbers from 1 to n.\n    - \ud83e\udde0 Backtrack: pick or skip each number.\n    - \ud83d\udca1 Start from current to avoid duplicates.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])  # Add to end.\n            return\n        for i in range(start, n + 1):  # Iterate through the range.\n            path.append(i)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(1, [])\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "n-queens-ii": {
      "title": "N-Queens II",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udc51",
      "timeComplexity": "O(n!)",
      "spaceComplexity": "O(n)",
      "oneliner": "Place queens row by row. Track cols and diagonals.",
      "intuition": [
        "\ud83c\udfaf Count valid n-queens placements.",
        "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
        "\ud83d\udca1 Row is implicit in recursion depth."
      ],
      "testCases": [
        {
          "input": "n = 4",
          "output": "2"
        },
        {
          "input": "n = 1",
          "output": "1"
        }
      ],
      "code": "def totalNQueens(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count valid n-queens placements.\n    - \ud83e\udde0 Track used columns, diagonals, anti-diagonals.\n    - \ud83d\udca1 Row is implicit in recursion depth.\n    \"\"\"\n    cols = set()\n    posDiag = set()  # r + c\n    negDiag = set()  # r - c\n    count = [0]\n    def backtrack(r):\n        if r == n:\n            count[0] += 1\n            return\n        for c in range(n):  # Iterate through the range.\n            if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                continue\n            cols.add(c)\n            posDiag.add(r + c)\n            negDiag.add(r - c)\n            backtrack(r + 1)\n            cols.remove(c)\n            posDiag.remove(r + c)\n            negDiag.remove(r - c)\n    backtrack(0)\n    return count[0]",
      "keyInsight": "Diagonals identified by r+c (positive) and r-c (negative).",
      "visualizationType": "grid",
      "initialState": [
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: N-Queens II",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add .,.,.,. to path",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [.,.,.,.]",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add .,.,.,. to path",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try .,.,.,. instead",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Place queens row by row. Track cols and diagonals.\n\nCount valid n-queens placements.\nTrack used columns, diagonals, anti-diagonals.",
      "examples": [
        {
          "input": "n = 4",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count valid n-queens placements.",
        "Track used columns, diagonals, anti-diagonals.",
        "Row is implicit in recursion depth."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum",
        "subsets"
      ],
      "videoId": "nalYyLZgvCY",
      "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.",
      "difficulty": "Hard",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Place queens row by row. Track cols and diagonals.",
      "suggestedNextQuestion": {
        "slug": "word-search-ii",
        "title": "Word Search II",
        "difficulty": "Hard",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def totalNQueens(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def totalNQueens_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Count valid n-queens placements.",
            "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
            "\ud83d\udca1 Row is implicit in recursion depth."
          ],
          "code": "def totalNQueens(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count valid n-queens placements.\n    - \ud83e\udde0 Track used columns, diagonals, anti-diagonals.\n    - \ud83d\udca1 Row is implicit in recursion depth.\n    \"\"\"\n    cols = set()\n    posDiag = set()  # r + c\n    negDiag = set()  # r - c\n    count = [0]\n    def backtrack(r):\n        if r == n:\n            count[0] += 1\n            return\n        for c in range(n):  # Iterate through the range.\n            if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                continue\n            cols.add(c)\n            posDiag.add(r + c)\n            negDiag.add(r - c)\n            backtrack(r + 1)\n            cols.remove(c)\n            posDiag.remove(r + c)\n            negDiag.remove(r - c)\n    backtrack(0)\n    return count[0]"
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "generate-parentheses": {
      "title": "Generate Parentheses",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd32",
      "timeComplexity": "O(4^n / sqrt(n))",
      "spaceComplexity": "O(n)",
      "oneliner": "Add '(' if open < n. Add ')' if close < open.",
      "intuition": [
        "\ud83c\udfaf Generate all valid parentheses of n pairs.",
        "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
        "\ud83d\udca1 This ensures valid nesting."
      ],
      "testCases": [
        {
          "input": "n = 3",
          "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
        },
        {
          "input": "n = 1",
          "output": "[\"()\"]"
        }
      ],
      "code": "def generateParenthesis(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Generate all valid parentheses of n pairs.\n    - \ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.\n    - \ud83d\udca1 This ensures valid nesting.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(s, openN, closeN):\n        if len(s) == 2 * n:\n            res.append(s)  # Add to end.\n            return\n        if openN < n:\n            backtrack(s + '(', openN + 1, closeN)\n        if closeN < openN:\n            backtrack(s + ')', openN, closeN + 1)\n    backtrack('', 0, 0)\n    return res  # Return the final result.",
      "keyInsight": "Only add ')' when close count < open count.",
      "visualizationType": "array",
      "initialState": [
        ""
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "n = 2",
          "transientMessage": "Generate valid parentheses combinations",
          "arrayState": [],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Add '(': \"(\"",
          "transientMessage": "open=1, close=0",
          "arrayState": [
            "("
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Add '(': \"((\"",
          "transientMessage": "open=2, close=0",
          "arrayState": [
            "(",
            "("
          ],
          "pointers": [],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Add ')': \"(()\"",
          "transientMessage": "open=2, close=1",
          "arrayState": [
            "(",
            "(",
            ")"
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Add ')': \"(())\"",
          "transientMessage": "open=2, close=2",
          "arrayState": [
            "(",
            "(",
            ")",
            ")"
          ],
          "pointers": [],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Valid: \"(())\"",
          "transientMessage": "1 found",
          "arrayState": [
            "(",
            "(",
            ")",
            ")"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Add ')': \"()\"",
          "transientMessage": "open=1, close=1",
          "arrayState": [
            "(",
            ")"
          ],
          "pointers": [],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Add '(': \"()(\"",
          "transientMessage": "open=2, close=1",
          "arrayState": [
            "(",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Add ')': \"()()\"",
          "transientMessage": "open=2, close=2",
          "arrayState": [
            "(",
            ")",
            "(",
            ")"
          ],
          "pointers": [],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Valid: \"()()\"",
          "transientMessage": "2 found",
          "arrayState": [
            "(",
            ")",
            "(",
            ")"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "2 valid combinations",
          "transientMessage": "Complete!",
          "arrayState": [],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Add '(' if open < n. Add ')' if close < open.\n\nGenerate all valid parentheses of n pairs.\nCan add '(' if count < n. Can add ')' if close < open.",
      "examples": [
        {
          "input": "n = 3",
          "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Generate all valid parentheses of n pairs.",
        "Can add '(' if count < n. Can add ')' if close < open.",
        "This ensures valid nesting."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum",
        "subsets"
      ],
      "videoId": "s9fokUqJ76A",
      "problemStatement": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Add '(' if open < n. Add ')' if close < open.",
      "suggestedNextQuestion": {
        "slug": "letter-case-permutation",
        "title": "Letter Case Permutation",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def generateParenthesis(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def generateParenthesis_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(4^n / sqrt(n))",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Generate all valid parentheses of n pairs.",
            "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
            "\ud83d\udca1 This ensures valid nesting."
          ],
          "code": "def generateParenthesis(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Generate all valid parentheses of n pairs.\n    - \ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.\n    - \ud83d\udca1 This ensures valid nesting.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(s, openN, closeN):\n        if len(s) == 2 * n:\n            res.append(s)  # Add to end.\n            return\n        if openN < n:\n            backtrack(s + '(', openN + 1, closeN)\n        if closeN < openN:\n            backtrack(s + ')', openN, closeN + 1)\n    backtrack('', 0, 0)\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "subsets": {
      "title": "Subsets",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udce6",
      "timeComplexity": "O(2^n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Backtrack: include or exclude each element.",
      "intuition": [
        "\ud83c\udfaf All subsets of a set.",
        "\ud83e\udde0 For each element: include or exclude.",
        "\ud83d\udca1 Results at every node, not just leaves."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3]",
          "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
        },
        {
          "input": "nums = [0]",
          "output": "[[],[0]]"
        }
      ],
      "code": "def subsets(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All subsets of a set.\n    - \ud83e\udde0 For each element: include or exclude.\n    - \ud83d\udca1 Results at every node, not just leaves.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        res.append(path[:])  # Add to end.\n        for i in range(start, len(nums)):  # Iterate through the range.\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result.",
      "keyInsight": "Add current path at every node, not just at leaves.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [1, 2, 3]",
          "transientMessage": "Start with empty set: [[]]",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process 1",
          "transientMessage": "Add 1 to each existing subset",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "[] + 1 = [1]",
          "transientMessage": "Total: 2 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Process 2",
          "transientMessage": "Add 2 to each existing subset",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "[] + 2 = [2]",
          "transientMessage": "Total: 3 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "[1] + 2 = [1,2]",
          "transientMessage": "Total: 4 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process 3",
          "transientMessage": "Add 3 to each existing subset",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "[] + 3 = [3]",
          "transientMessage": "Total: 5 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "[1] + 3 = [1,3]",
          "transientMessage": "Total: 6 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "[2] + 3 = [2,3]",
          "transientMessage": "Total: 7 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "[1,2] + 3 = [1,2,3]",
          "transientMessage": "Total: 8 subsets",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Total: 8 subsets",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Backtrack: include or exclude each element.\n\nAll subsets of a set.\nFor each element: include or exclude.",
      "examples": [
        {
          "input": "nums = [1,2,3]",
          "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "All subsets of a set.",
        "For each element: include or exclude.",
        "Results at every node, not just leaves."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum"
      ],
      "videoId": "REOH22Xwdkk",
      "problemStatement": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: Backtrack: include or exclude each element.",
      "suggestedNextQuestion": {
        "slug": "subsets-ii",
        "title": "Subsets II",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def subsets(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def subsets_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf All subsets of a set.",
            "\ud83e\udde0 For each element: include or exclude.",
            "\ud83d\udca1 Results at every node, not just leaves."
          ],
          "code": "def subsets(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All subsets of a set.\n    - \ud83e\udde0 For each element: include or exclude.\n    - \ud83d\udca1 Results at every node, not just leaves.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        res.append(path[:])  # Add to end.\n        for i in range(start, len(nums)):  # Iterate through the range.\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "letter-case-permutation": {
      "title": "Letter Case Permutation",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd24",
      "timeComplexity": "O(2^n)",
      "spaceComplexity": "O(n)",
      "oneliner": "For each letter, branch on lower and upper case.",
      "intuition": [
        "\ud83c\udfaf All case permutations of letters.",
        "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
        "\ud83d\udca1 Binary branching on letters."
      ],
      "testCases": [
        {
          "input": "s = \"a1b2\"",
          "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
        },
        {
          "input": "s = \"3z4\"",
          "output": "[\"3z4\",\"3Z4\"]"
        }
      ],
      "code": "def letterCasePermutation(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All case permutations of letters.\n    - \ud83e\udde0 Digits: no choice. Letters: lower or upper.\n    - \ud83d\udca1 Binary branching on letters.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(s):\n            res.append(''.join(path))  # Add to end.\n            return\n        if s[i].isalpha():\n            path.append(s[i].lower())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n            path.append(s[i].upper())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n        else:\n            path.append(s[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result.",
      "keyInsight": "Letters create two branches; digits create one.",
      "visualizationType": "tree",
      "initialState": [
        "a",
        "1",
        "b",
        "2"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Letter Case Permutation",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add a to path",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [a]",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try b instead",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            "a",
            "1",
            "b",
            "2"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "For each letter, branch on lower and upper case.\n\nAll case permutations of letters.\nDigits: no choice. Letters: lower or upper.",
      "examples": [
        {
          "input": "s = \"a1b2\"",
          "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "All case permutations of letters.",
        "Digits: no choice. Letters: lower or upper.",
        "Binary branching on letters."
      ],
      "relatedProblems": [
        "permutations",
        "combination-sum",
        "subsets"
      ],
      "videoId": "IYXWcjwhUYo",
      "problemStatement": "Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. Return the output in any order.",
      "difficulty": "Medium",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "approach": "Backtracking: For each letter, branch on lower and upper case.",
      "suggestedNextQuestion": {
        "slug": "letter-combinations-of-a-phone-number",
        "title": "Letter Combinations of a Phone Number",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def letterCasePermutation(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def letterCasePermutation_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf All case permutations of letters.",
            "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
            "\ud83d\udca1 Binary branching on letters."
          ],
          "code": "def letterCasePermutation(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All case permutations of letters.\n    - \ud83e\udde0 Digits: no choice. Letters: lower or upper.\n    - \ud83d\udca1 Binary branching on letters.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(s):\n            res.append(''.join(path))  # Add to end.\n            return\n        if s[i].isalpha():\n            path.append(s[i].lower())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n            path.append(s[i].upper())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n        else:\n            path.append(s[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "merge-k-sorted-lists": {
      "title": "Merge k Sorted Lists",
      "pattern": "Divide and Conquer / Heap",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(N log k)",
      "spaceComplexity": "O(k)",
      "oneliner": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
      "intuition": [
        "\ud83c\udfaf Merge k sorted linked lists.",
        "\ud83e\udde0 Min-heap keeps track of smallest head.",
        "\ud83d\udca1 Pop smallest, add its next to heap."
      ],
      "testCases": [
        {
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "output": "[1,1,2,3,4,4,5,6]"
        },
        {
          "input": "lists = []",
          "output": "[]"
        },
        {
          "input": "lists = [[]]",
          "output": "[]"
        }
      ],
      "code": "import heapq\n\ndef mergeKLists(lists):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge k sorted linked lists.\n    - \ud83e\udde0 Min-heap keeps track of smallest head.\n    - \ud83d\udca1 Pop smallest, add its next to heap.\n    \"\"\"\n    heap = []\n    for i, lst in enumerate(lists):  # Iterate over elements.\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    res = []  # Initialize list to store results.\n    while heap:\n        val, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append(val)  # Add to end.\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n    return res  # Return the final result.",
      "keyInsight": "Heap gives O(log k) for each of N elements.",
      "visualizationType": "linkedlist",
      "initialState": [
        [
          1,
          4,
          5
        ],
        [
          1,
          3,
          4
        ],
        [
          2,
          6
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Merge k Sorted Lists",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1,4,5",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1,3,4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 2,6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.\n\nMerge k sorted linked lists.\nMin-heap keeps track of smallest head.",
      "examples": [
        {
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "output": "[1,1,2,3,4,4,5,6]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Merge k sorted linked lists.",
        "Min-heap keeps track of smallest head.",
        "Pop smallest, add its next to heap."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "q5a5OiGbT6Q",
      "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Divide and Conquer / Heap: Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def mergeKLists(lists):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def mergeKLists_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N log k)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Merge k sorted linked lists.",
            "\ud83e\udde0 Min-heap keeps track of smallest head.",
            "\ud83d\udca1 Pop smallest, add its next to heap."
          ],
          "code": "import heapq\n\ndef mergeKLists(lists):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge k sorted linked lists.\n    - \ud83e\udde0 Min-heap keeps track of smallest head.\n    - \ud83d\udca1 Pop smallest, add its next to heap.\n    \"\"\"\n    heap = []\n    for i, lst in enumerate(lists):  # Iterate over elements.\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    res = []  # Initialize list to store results.\n    while heap:\n        val, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append(val)  # Add to end.\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "search-insert-position": {
      "title": "Search Insert Position",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Binary search. If not found, left pointer is insert position.",
      "intuition": [
        "\ud83c\udfaf Find index to insert target in sorted array.",
        "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
        "\ud83d\udca1 Left pointer ends at correct insert position."
      ],
      "testCases": [
        {
          "input": "nums = [1,3,5,6], target = 5",
          "output": "2"
        },
        {
          "input": "nums = [1,3,5,6], target = 2",
          "output": "1"
        },
        {
          "input": "nums = [1,3,5,6], target = 7",
          "output": "4"
        }
      ],
      "code": "def searchInsert(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find index to insert target in sorted array.\n    - \ud83e\udde0 Binary search: if exact match, return. Else return left.\n    - \ud83d\udca1 Left pointer ends at correct insert position.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return left",
      "keyInsight": "When target not found, left is the insert position.",
      "visualizationType": "array",
      "initialState": [
        1,
        3,
        5,
        6
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Initialize left to 0 and right to 3",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Calculate mid as (left + right) // 2 = 1",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "error",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "mid"
            }
          ],
          "transientMessage": "Calculate new mid as (left + right) // 2 = 2",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "error",
          "pointers": [
            {
              "index": 2,
              "label": "mid"
            }
          ],
          "transientMessage": "Check if nums[mid] == target. nums[2] = 5, which is not equal to the target",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 1,
              "label": "right"
            }
          ],
          "transientMessage": "Since nums[mid] > target, update right to mid - 1 = 1",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Calculate new mid as (left + right) // 2 = 1",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "error",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "success",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            }
          ],
          "transientMessage": "Return left as the insert position for the target",
          "arrayState": [
            1,
            3,
            5,
            6
          ]
        }
      ],
      "description": "Binary search. If not found, left pointer is insert position.\n\nFind index to insert target in sorted array.\nBinary search: if exact match, return. Else return left.",
      "examples": [
        {
          "input": "nums = [1,3,5,6]; target = 5",
          "output": "2"
        },
        {
          "input": "nums = [1,3,5,6]; target = 2",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find index to insert target in sorted array.",
        "Binary search: if exact match, return. Else return left.",
        "Left pointer ends at correct insert position."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array",
        "find-peak-element"
      ],
      "videoId": "K-RYzDZkzCI",
      "problemStatement": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.",
      "difficulty": "Easy",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Binary search. If not found, left pointer is insert position.",
      "suggestedNextQuestion": {
        "slug": "sqrtx",
        "title": "Sqrt(x)",
        "difficulty": "Easy",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def searchInsert(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def searchInsert_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find index to insert target in sorted array.",
            "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
            "\ud83d\udca1 Left pointer ends at correct insert position."
          ],
          "code": "def searchInsert(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find index to insert target in sorted array.\n    - \ud83e\udde0 Binary search: if exact match, return. Else return left.\n    - \ud83d\udca1 Left pointer ends at correct insert position.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return left"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "search-a-2d-matrix": {
      "title": "Search a 2D Matrix",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(log(m*n))",
      "spaceComplexity": "O(1)",
      "oneliner": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
      "intuition": [
        "\ud83c\udfaf Search target in row-sorted matrix.",
        "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
        "\ud83d\udca1 Standard binary search on virtual 1D array."
      ],
      "testCases": [
        {
          "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
          "output": "true"
        },
        {
          "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
          "output": "false"
        }
      ],
      "code": "def searchMatrix(matrix, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search target in row-sorted matrix.\n    - \ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).\n    - \ud83d\udca1 Standard binary search on virtual 1D array.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True  # Condition satisfied.\n        elif val < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return False  # Condition not met.",
      "keyInsight": "Index conversion: row = idx // cols, col = idx % cols.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          3,
          5,
          7
        ],
        [
          10,
          11,
          16,
          20
        ],
        [
          23,
          30,
          34,
          60
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Search a 2D Matrix",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 3",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 10",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 11",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.\n\nSearch target in row-sorted matrix.\nFlatten conceptually: idx -> (idx//n, idx%n).",
      "examples": [
        {
          "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]; target = 3",
          "output": "true"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Search target in row-sorted matrix.",
        "Flatten conceptually: idx -> (idx//n, idx%n).",
        "Standard binary search on virtual 1D array."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array",
        "find-peak-element"
      ],
      "videoId": "Ber2pi2C0j0",
      "problemStatement": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.",
      "difficulty": "Medium",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
      "suggestedNextQuestion": {
        "slug": "search-in-rotated-sorted-array",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def searchMatrix(matrix, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def searchMatrix_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log(m*n))",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Search target in row-sorted matrix.",
            "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
            "\ud83d\udca1 Standard binary search on virtual 1D array."
          ],
          "code": "def searchMatrix(matrix, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search target in row-sorted matrix.\n    - \ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).\n    - \ud83d\udca1 Standard binary search on virtual 1D array.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True  # Condition satisfied.\n        elif val < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return False  # Condition not met."
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "find-peak-element": {
      "title": "Find Peak Element",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83c\udfd4\ufe0f",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Move towards larger neighbor. Guaranteed to find peak.",
      "intuition": [
        "\ud83c\udfaf Find any peak (greater than neighbors).",
        "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
        "\ud83d\udca1 Binary search converges to a peak."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "2"
        },
        {
          "input": "nums = [1,2,1,3,5,6,4]",
          "output": "5"
        }
      ],
      "code": "def findPeakElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find any peak (greater than neighbors).\n    - \ud83e\udde0 If mid < mid+1, peak is on right. Else on left.\n    - \ud83d\udca1 Binary search converges to a peak.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return left",
      "keyInsight": "Move towards the higher neighbor to find a peak.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find Peak Element",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            2,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Move towards larger neighbor. Guaranteed to find peak.\n\nFind any peak (greater than neighbors).\nIf mid < mid+1, peak is on right. Else on left.",
      "examples": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find any peak (greater than neighbors).",
        "If mid < mid+1, peak is on right. Else on left.",
        "Binary search converges to a peak."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array"
      ],
      "videoId": "kMzJy9es7Hc",
      "problemStatement": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
      "difficulty": "Medium",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Move towards larger neighbor. Guaranteed to find peak.",
      "suggestedNextQuestion": {
        "slug": "h-index",
        "title": "H-Index",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def findPeakElement(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def findPeakElement_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find any peak (greater than neighbors).",
            "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
            "\ud83d\udca1 Binary search converges to a peak."
          ],
          "code": "def findPeakElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find any peak (greater than neighbors).\n    - \ud83e\udde0 If mid < mid+1, peak is on right. Else on left.\n    - \ud83d\udca1 Binary search converges to a peak.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return left"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "search-in-rotated-sorted-array": {
      "title": "Search in Rotated Sorted Array",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Determine which half is sorted. Check if target is in that half.",
      "intuition": [
        "\ud83c\udfaf Search in rotated sorted array.",
        "\ud83e\udde0 One half is always sorted. Check if target is there.",
        "\ud83d\udca1 Narrow down to the half where target can exist."
      ],
      "testCases": [
        {
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "output": "4"
        },
        {
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "output": "-1"
        },
        {
          "input": "nums = [1], target = 0",
          "output": "-1"
        }
      ],
      "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search in rotated sorted array.\n    - \ud83e\udde0 One half is always sorted. Check if target is there.\n    - \ud83d\udca1 Narrow down to the half where target can exist.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1  # Search left half.\n            else:\n                left = mid + 1  # Search right half.\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n    return -1",
      "keyInsight": "At least one half is always sorted in a rotated array.",
      "visualizationType": "array",
      "initialState": [
        4,
        5,
        6,
        7,
        0,
        1,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Search in Rotated Sorted Array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 4",
          "transientMessage": "Iteration 1",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 5",
          "transientMessage": "Iteration 2",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 7",
          "transientMessage": "Iteration 4",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 0",
          "transientMessage": "Iteration 5",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 1",
          "transientMessage": "Iteration 6",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Determine which half is sorted. Check if target is in that half.\n\nSearch in rotated sorted array.\nOne half is always sorted. Check if target is there.",
      "examples": [
        {
          "input": "nums = [4,5,6,7,0,1,2]; target = 0",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Search in rotated sorted array.",
        "One half is always sorted. Check if target is there.",
        "Narrow down to the half where target can exist."
      ],
      "relatedProblems": [
        "binary-search",
        "find-peak-element"
      ],
      "videoId": "U8XENwh8Oy8",
      "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.",
      "difficulty": "Medium",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Determine which half is sorted. Check if target is in that half.",
      "suggestedNextQuestion": {
        "slug": "time-based-key-value-store",
        "title": "Time Based Key Value Store",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def search(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def search_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Search in rotated sorted array.",
            "\ud83e\udde0 One half is always sorted. Check if target is there.",
            "\ud83d\udca1 Narrow down to the half where target can exist."
          ],
          "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search in rotated sorted array.\n    - \ud83e\udde0 One half is always sorted. Check if target is there.\n    - \ud83d\udca1 Narrow down to the half where target can exist.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1  # Search left half.\n            else:\n                left = mid + 1  # Search right half.\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n    return -1"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "find-first-and-last-position-of-element-in-sorted-array": {
      "title": "Find First and Last Position of Element in Sorted Array",
      "pattern": "Binary Search (Bisect)",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Two binary searches: find left bound and right bound.",
      "intuition": [
        "\ud83c\udfaf Find start and end indices of target.",
        "\ud83e\udde0 Binary search for leftmost occurrence.",
        "\ud83d\udca1 Binary search for rightmost occurrence."
      ],
      "testCases": [
        {
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "output": "[3,4]"
        },
        {
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "output": "[-1,-1]"
        },
        {
          "input": "nums = [], target = 0",
          "output": "[-1,-1]"
        }
      ],
      "code": "def searchRange(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find start and end indices of target.\n    - \ud83e\udde0 Binary search for leftmost occurrence.\n    - \ud83d\udca1 Binary search for rightmost occurrence.\n    \"\"\"\n    def findLeft():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    def findRight():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    \n    l, r = findLeft(), findRight()  # Initialize two pointers.\n    return [l, r] if l <= r else [-1, -1]",
      "keyInsight": "Two separate binary searches for left and right bounds.",
      "visualizationType": "array",
      "initialState": [
        5,
        7,
        7,
        8,
        8,
        10
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Initializing search for left boundary",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "mid"
            }
          ],
          "transientMessage": "Checking mid value (8) against target (7)",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 2,
              "label": "right"
            }
          ],
          "transientMessage": "Adjusting search range to left half",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Checking mid value (7) against target (7)",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Adjusting search range to left half",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "mid"
            }
          ],
          "transientMessage": "Checking mid value (5) against target (7)",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            0
          ],
          "color": "success",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Left boundary found at index 2",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 5,
              "label": "right"
            }
          ],
          "transientMessage": "Initializing search for right boundary",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "mid"
            }
          ],
          "transientMessage": "Checking mid value (8) against target (7)",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 2,
              "label": "right"
            }
          ],
          "transientMessage": "Adjusting search range to left half",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "mid"
            }
          ],
          "transientMessage": "Checking mid value (7) against target (7)",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            0
          ],
          "color": "success",
          "pointers": [
            {
              "index": 2,
              "label": "left"
            },
            {
              "index": 0,
              "label": "right"
            }
          ],
          "transientMessage": "Right boundary found at index 3",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 2,
              "label": "l"
            },
            {
              "index": 3,
              "label": "r"
            }
          ],
          "transientMessage": "Result: [2, 3]",
          "arrayState": [
            5,
            7,
            7,
            8,
            8,
            10
          ]
        }
      ],
      "description": "Two binary searches: find left bound and right bound.\n\nFind start and end indices of target.\nBinary search for leftmost occurrence.",
      "examples": [
        {
          "input": "nums = [5,7,7,8,8,10]; target = 8",
          "output": "[3,4]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find start and end indices of target.",
        "Binary search for leftmost occurrence.",
        "Binary search for rightmost occurrence."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "4sQL7R5ySUU",
      "problemStatement": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Binary Search (Bisect): Two binary searches: find left bound and right bound.",
      "suggestedNextQuestion": {
        "slug": "find-minimum-in-rotated-sorted-array",
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def searchRange(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def searchRange_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find start and end indices of target.",
            "\ud83e\udde0 Binary search for leftmost occurrence.",
            "\ud83d\udca1 Binary search for rightmost occurrence."
          ],
          "code": "def searchRange(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find start and end indices of target.\n    - \ud83e\udde0 Binary search for leftmost occurrence.\n    - \ud83d\udca1 Binary search for rightmost occurrence.\n    \"\"\"\n    def findLeft():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    def findRight():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    \n    l, r = findLeft(), findRight()  # Initialize two pointers.\n    return [l, r] if l <= r else [-1, -1]"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "find-minimum-in-rotated-sorted-array": {
      "title": "Find Minimum in Rotated Sorted Array",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udcc9",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Compare mid with right. If mid > right, min is on right. Else on left.",
      "intuition": [
        "\ud83c\udfaf Find minimum in rotated sorted array.",
        "\ud83e\udde0 Compare mid with rightmost element.",
        "\ud83d\udca1 Rotation point is where min is."
      ],
      "testCases": [
        {
          "input": "nums = [3,4,5,1,2]",
          "output": "1"
        },
        {
          "input": "nums = [4,5,6,7,0,1,2]",
          "output": "0"
        },
        {
          "input": "nums = [11,13,15,17]",
          "output": "11"
        }
      ],
      "code": "def findMin(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum in rotated sorted array.\n    - \ud83e\udde0 Compare mid with rightmost element.\n    - \ud83d\udca1 Rotation point is where min is.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] > nums[right]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return nums[left]",
      "keyInsight": "Compare with right end to determine which half has the minimum.",
      "visualizationType": "array",
      "initialState": [
        3,
        4,
        5,
        1,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find Minimum in Rotated Sorted Array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 5",
          "transientMessage": "Iteration 3",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Compare mid with right. If mid > right, min is on right. Else on left.\n\nFind minimum in rotated sorted array.\nCompare mid with rightmost element.",
      "examples": [
        {
          "input": "nums = [3,4,5,1,2]",
          "output": "1"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find minimum in rotated sorted array.",
        "Compare mid with rightmost element.",
        "Rotation point is where min is."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array",
        "find-peak-element"
      ],
      "videoId": "nIVW4P8b1VA",
      "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.",
      "difficulty": "Medium",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Compare mid with right. If mid > right, min is on right. Else on left.",
      "suggestedNextQuestion": {
        "slug": "find-peak-element",
        "title": "Find Peak Element",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def findMin(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def findMin_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find minimum in rotated sorted array.",
            "\ud83e\udde0 Compare mid with rightmost element.",
            "\ud83d\udca1 Rotation point is where min is."
          ],
          "code": "def findMin(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum in rotated sorted array.\n    - \ud83e\udde0 Compare mid with rightmost element.\n    - \ud83d\udca1 Rotation point is where min is.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] > nums[right]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return nums[left]"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "median-of-two-sorted-arrays": {
      "title": "Median of Two Sorted Arrays",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(log(min(m,n)))",
      "spaceComplexity": "O(1)",
      "oneliner": "Binary search on smaller array. Find partition where left <= right.",
      "intuition": [
        "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
        "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
        "\ud83d\udca1 Binary search on smaller array for correct partition."
      ],
      "testCases": [
        {
          "input": "nums1 = [1,3], nums2 = [2]",
          "output": "2.00000"
        },
        {
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "output": "2.50000"
        }
      ],
      "code": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).\n    - \ud83e\udde0 Partition both arrays such that left halves = right halves.\n    - \ud83d\udca1 Binary search on smaller array for correct partition.\n    \"\"\"\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2  # Take the maximum value.\n            return max(maxLeft1, maxLeft2)  # Take the maximum value.\n        elif maxLeft1 > minRight2:\n            right = i - 1\n        else:\n            left = i + 1\n    return 0.0",
      "keyInsight": "Partition such that all left elements <= all right elements.",
      "visualizationType": "array",
      "initialState": [
        1,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Median of Two Sorted Arrays",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Binary search on smaller array. Find partition where left <= right.\n\nFind median of two sorted arrays in O(log(m+n)).\nPartition both arrays such that left halves = right halves.",
      "examples": [
        {
          "input": "nums1 = [1,3]; nums2 = [2]",
          "output": "2.0"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find median of two sorted arrays in O(log(m+n)).",
        "Partition both arrays such that left halves = right halves.",
        "Binary search on smaller array for correct partition."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array",
        "find-peak-element"
      ],
      "videoId": "q6IEA26hvXc",
      "problemStatement": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
      "difficulty": "Hard",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Binary search on smaller array. Find partition where left <= right.",
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def findMedianSortedArrays(nums1, nums2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def findMedianSortedArrays_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log(min(m,n)))",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
            "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
            "\ud83d\udca1 Binary search on smaller array for correct partition."
          ],
          "code": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).\n    - \ud83e\udde0 Partition both arrays such that left halves = right halves.\n    - \ud83d\udca1 Binary search on smaller array for correct partition.\n    \"\"\"\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2  # Take the maximum value.\n            return max(maxLeft1, maxLeft2)  # Take the maximum value.\n        elif maxLeft1 > minRight2:\n            right = i - 1\n        else:\n            left = i + 1\n    return 0.0"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "maximum-sum-circular-subarray": {
      "title": "Maximum Sum Circular Subarray",
      "pattern": "Kadane's",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Max is either normal Kadane OR total - min subarray.",
      "intuition": [
        "\ud83c\udfaf Max subarray sum in circular array.",
        "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
        "\ud83d\udca1 Wrapping = total - min subarray."
      ],
      "testCases": [
        {
          "input": "nums = [1,-2,3,-2]",
          "output": "3"
        },
        {
          "input": "nums = [5,-3,5]",
          "output": "10"
        },
        {
          "input": "nums = [-3,-2,-3]",
          "output": "-2"
        }
      ],
      "code": "def maxSubarraySumCircular(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max subarray sum in circular array.\n    - \ud83e\udde0 Two cases: normal subarray OR wrapping subarray.\n    - \ud83d\udca1 Wrapping = total - min subarray.\n    \"\"\"\n    total = 0\n    maxSum = nums[0]\n    curMax = 0\n    minSum = nums[0]\n    curMin = 0\n    for n in nums:  # Iterate over elements.\n        curMax = max(curMax + n, n)  # Take the maximum value.\n        maxSum = max(maxSum, curMax)  # Take the maximum value.\n        curMin = min(curMin + n, n)  # Take the minimum value.\n        minSum = min(minSum, curMin)  # Take the minimum value.\n        total += n\n    if maxSum > 0:\n        return max(maxSum, total - minSum)  # Take the maximum value.\n    return maxSum",
      "keyInsight": "Circular case: max = total - minSubarray.",
      "visualizationType": "array",
      "initialState": [
        1,
        -2,
        3,
        -2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Maximum Sum Circular Subarray",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = -2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = -2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            -2,
            3,
            -2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Max is either normal Kadane OR total - min subarray.\n\nMax subarray sum in circular array.\nTwo cases: normal subarray OR wrapping subarray.",
      "examples": [
        {
          "input": "nums = [1,-2,3,-2]",
          "output": "3"
        },
        {
          "input": "nums = [5,-3,5]",
          "output": "10"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Max subarray sum in circular array.",
        "Two cases: normal subarray OR wrapping subarray.",
        "Wrapping = total - min subarray."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "fxT9KjakYPM",
      "problemStatement": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Kadane's: Max is either normal Kadane OR total - min subarray.",
      "mentalModel": "Like finding the sunniest part of the day. If the clouds (negative) get too heavy, you restart your streak.",
      "initialCode": "def maxSubarraySumCircular(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxSubarraySumCircular(nums):\n    globMax, globMin = nums[0], nums[0]\n    curMax, curMin = 0, 0\n    total = 0\n    for n in nums:\n        curMax = max(curMax + n, n)\n        curMin = min(curMin + n, n)\n        total += n\n        globMax = max(globMax, curMax)\n        globMin = min(globMin, curMin)\n    return max(globMax, total - globMin) if globMax > 0 else globMax"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Max subarray sum in circular array.",
            "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
            "\ud83d\udca1 Wrapping = total - min subarray."
          ],
          "code": "def maxSubarraySumCircular(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max subarray sum in circular array.\n    - \ud83e\udde0 Two cases: normal subarray OR wrapping subarray.\n    - \ud83d\udca1 Wrapping = total - min subarray.\n    \"\"\"\n    total = 0\n    maxSum = nums[0]\n    curMax = 0\n    minSum = nums[0]\n    curMin = 0\n    for n in nums:  # Iterate over elements.\n        curMax = max(curMax + n, n)  # Take the maximum value.\n        maxSum = max(maxSum, curMax)  # Take the maximum value.\n        curMin = min(curMin + n, n)  # Take the minimum value.\n        minSum = min(minSum, curMin)  # Take the minimum value.\n        total += n\n    if maxSum > 0:\n        return max(maxSum, total - minSum)  # Take the maximum value.\n    return maxSum"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "add-binary": {
      "title": "Add Binary",
      "pattern": "Bit by Bit",
      "patternEmoji": "\u2795",
      "timeComplexity": "O(max(m,n))",
      "spaceComplexity": "O(max(m,n))",
      "oneliner": "Add digits from right, track carry.",
      "intuition": [
        "\ud83c\udfaf Add two binary strings.",
        "\ud83e\udde0 Process from right, handle carry.",
        "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
      ],
      "testCases": [
        {
          "input": "a = \"11\", b = \"1\"",
          "output": "\"100\""
        },
        {
          "input": "a = \"1010\", b = \"1011\"",
          "output": "\"10101\""
        }
      ],
      "code": "def addBinary(a, b):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add two binary strings.\n    - \ud83e\udde0 Process from right, handle carry.\n    - \ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin().\n    \"\"\"\n    res = []  # Initialize list to store results.\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))  # Add to end.\n        carry = total // 2\n    return ''.join(res[::-1])  # Reverse the sequence.",
      "keyInsight": "Handle carry same as decimal addition.",
      "visualizationType": "array",
      "initialState": "11",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Initialize i = 1 and j = 1",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Add a[i] (1) to carry (0), total = 1",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Add b[j] (1) to total, total = 2",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Append '0' (total % 2) to result, carry = 1",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Decrement i and j, i = 0, j = 0",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Add a[i] (1) to carry (1), total = 2",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Add b[j] (1) to total, total = 3",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Append '1' (total % 2) to result, carry = 1",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Decrement i and j, i = -1, j = -1",
          "arrayState": [
            "1",
            "1"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "transientMessage": "Append '1' (carry) to result, final result = '100'",
          "arrayState": [
            "1",
            "1"
          ]
        }
      ],
      "description": "Add digits from right, track carry.\n\nAdd two binary strings.\nProcess from right, handle carry.",
      "examples": [
        {
          "input": "a = \"11\"; b = \"1\"",
          "output": "\"100\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Add two binary strings.",
        "Process from right, handle carry.",
        "Or use int(a, 2) + int(b, 2), then bin()."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "keuWJ47xG8g",
      "problemStatement": "Given two binary strings a and b, return their sum as a binary string.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Bit by Bit: Add digits from right, track carry.",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def addBinary(a, b):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def addBinary(a, b):\n    res = \"\"\n    i, j, carry = len(a) - 1, len(b) - 1, 0\n    while i >= 0 or j >= 0:\n        sum = carry\n        if i >= 0: sum += int(a[i]); i -= 1\n        if j >= 0: sum += int(b[j]); j -= 1\n        carry = 1 if sum > 1 else 0\n        res += str(sum % 2)\n    if carry: res += str(carry)\n    return res[::-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(max(m,n))",
          "spaceComplexity": "O(max(m,n))",
          "intuition": [
            "\ud83c\udfaf Add two binary strings.",
            "\ud83e\udde0 Process from right, handle carry.",
            "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
          ],
          "code": "def addBinary(a, b):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add two binary strings.\n    - \ud83e\udde0 Process from right, handle carry.\n    - \ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin().\n    \"\"\"\n    res = []  # Initialize list to store results.\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))  # Add to end.\n        carry = total // 2\n    return ''.join(res[::-1])  # Reverse the sequence."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reverse-bits": {
      "title": "Reverse Bits",
      "pattern": "Bit Manipulation",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(32)",
      "spaceComplexity": "O(1)",
      "oneliner": "Shift result left, add LSB of n, shift n right. Repeat 32 times.",
      "intuition": [
        "\ud83c\udfaf Reverse all 32 bits of an integer.",
        "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
        "\ud83d\udca1 Repeat 32 times."
      ],
      "testCases": [
        {
          "input": "n = 43261596",
          "output": "964176192"
        },
        {
          "input": "n = 2147483644",
          "output": "1073741822"
        }
      ],
      "code": "def reverseBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse all 32 bits of an integer.\n    - \ud83e\udde0 Extract LSB of n, add to result, shift both.\n    - \ud83d\udca1 Repeat 32 times.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for _ in range(32):  # Iterate through the range.\n        res = (res << 1) | (n & 1)  # Check if last bit is set (odd).\n        n >>= 1  # Right shift to process next bit.\n    return res  # Return the final result.",
      "keyInsight": "Build result by shifting left and OR-ing LSB.",
      "visualizationType": "array",
      "initialState": "43261596",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "n"
            }
          ],
          "transientMessage": "Initial value of n: 43261596",
          "arrayState": [
            "4",
            "3",
            "2",
            "6",
            "1",
            "5",
            "9",
            "6"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "res"
            },
            {
              "index": 1,
              "label": "n"
            }
          ],
          "transientMessage": "Shifting res left and adding least significant bit of n",
          "arrayState": [
            "4",
            "3",
            "2",
            "6",
            "1",
            "5",
            "9",
            "6"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "n"
            }
          ],
          "transientMessage": "Right shifting n to process next bit",
          "arrayState": [
            "4",
            "3",
            "2",
            "6",
            "1",
            "5",
            "9",
            "6"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "res"
            },
            {
              "index": 1,
              "label": "n"
            }
          ],
          "transientMessage": "Repeating the process for all 32 bits",
          "arrayState": [
            "4",
            "3",
            "2",
            "6",
            "1",
            "5",
            "9",
            "6"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "res"
            }
          ],
          "transientMessage": "Final reversed bits value: 964176192",
          "arrayState": [
            "4",
            "3",
            "2",
            "6",
            "1",
            "5",
            "9",
            "6"
          ]
        }
      ],
      "description": "Shift result left, add LSB of n, shift n right. Repeat 32 times.\n\nReverse all 32 bits of an integer.\nExtract LSB of n, add to result, shift both.",
      "examples": [
        {
          "input": "n = 43261596",
          "output": "964176192"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Reverse all 32 bits of an integer.",
        "Extract LSB of n, add to result, shift both.",
        "Repeat 32 times."
      ],
      "relatedProblems": [
        "single-number",
        "counting-bits"
      ],
      "videoId": "UcoN6UjAI64",
      "problemStatement": "Reverse bits of a given 32 bits unsigned integer.\nNote:",
      "difficulty": "Easy",
      "walkthrough": [
        "Identify bits pattern in problem",
        "Use bitwise operators (AND, OR, XOR, shift)",
        "Iterate through bits if needed",
        "Combine results using bit operations",
        "Return final bit result"
      ],
      "approach": "Bit Manipulation: Shift result left, add LSB of n, shift n right. Repeat 32 times.",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def reverseBits(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def reverseBits(n):\n    res = 0\n    for i in range(32):\n        bit = (n >> i) & 1\n        res = res | (bit << (31 - i))\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(32)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Reverse all 32 bits of an integer.",
            "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
            "\ud83d\udca1 Repeat 32 times."
          ],
          "code": "def reverseBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse all 32 bits of an integer.\n    - \ud83e\udde0 Extract LSB of n, add to result, shift both.\n    - \ud83d\udca1 Repeat 32 times.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for _ in range(32):  # Iterate through the range.\n        res = (res << 1) | (n & 1)  # Check if last bit is set (odd).\n        n >>= 1  # Right shift to process next bit.\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "number-of-1-bits": {
      "title": "Number of 1 Bits",
      "pattern": "Bit Manipulation",
      "patternEmoji": "1\ufe0f\u20e3",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "oneliner": "n & (n-1) clears rightmost 1 bit. Count iterations.",
      "intuition": [
        "\ud83c\udfaf Count set bits (Hamming weight).",
        "\ud83e\udde0 n & (n-1) removes rightmost 1.",
        "\ud83d\udca1 Count until n is 0."
      ],
      "testCases": [
        {
          "input": "n = 11",
          "output": "3"
        },
        {
          "input": "n = 128",
          "output": "1"
        },
        {
          "input": "n = 2147483645",
          "output": "30"
        }
      ],
      "code": "def hammingWeight(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count set bits (Hamming weight).\n    - \ud83e\udde0 n & (n-1) removes rightmost 1.\n    - \ud83d\udca1 Count until n is 0.\n    \"\"\"\n    count = 0\n    while n:\n        n &= n - 1  # Remove lowest set bit (Brian Kernighan's Algorithm).\n        count += 1\n    return count",
      "keyInsight": "n & (n-1) trick clears the lowest set bit.",
      "visualizationType": "array",
      "initialState": [
        "1",
        "0",
        "1",
        "1"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "n = 11 = 1011",
          "transientMessage": "Count 1 bits",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Position 0: 1",
          "transientMessage": "Count = 1",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [
            {
              "label": "1",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "Position 1: 0",
          "transientMessage": "Skip",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [
            {
              "label": "0",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Position 2: 1",
          "transientMessage": "Count = 2",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [
            {
              "label": "1",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Position 3: 1",
          "transientMessage": "Count = 3",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [
            {
              "label": "1",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Result: 3 ones",
          "transientMessage": "Complete!",
          "arrayState": [
            "1",
            "0",
            "1",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "n & (n-1) clears rightmost 1 bit. Count iterations.\n\nCount set bits (Hamming weight).\nn & (n-1) removes rightmost 1.",
      "examples": [
        {
          "input": "n = 11",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count set bits (Hamming weight).",
        "n & (n-1) removes rightmost 1.",
        "Count until n is 0."
      ],
      "relatedProblems": [
        "single-number",
        "counting-bits",
        "reverse-bits"
      ],
      "videoId": "5Km3utixwZs",
      "problemStatement": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",
      "difficulty": "Easy",
      "walkthrough": [
        "Identify bits pattern in problem",
        "Use bitwise operators (AND, OR, XOR, shift)",
        "Iterate through bits if needed",
        "Combine results using bit operations",
        "Return final bit result"
      ],
      "approach": "Bit Manipulation: n & (n-1) clears rightmost 1 bit. Count iterations.",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def hammingWeight(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def hammingWeight(n):\n    res = 0\n    while n:\n        n &= (n - 1)\n        res += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Count set bits (Hamming weight).",
            "\ud83e\udde0 n & (n-1) removes rightmost 1.",
            "\ud83d\udca1 Count until n is 0."
          ],
          "code": "def hammingWeight(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count set bits (Hamming weight).\n    - \ud83e\udde0 n & (n-1) removes rightmost 1.\n    - \ud83d\udca1 Count until n is 0.\n    \"\"\"\n    count = 0\n    while n:\n        n &= n - 1  # Remove lowest set bit (Brian Kernighan's Algorithm).\n        count += 1\n    return count"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "single-number": {
      "title": "Single Number",
      "pattern": "XOR",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "XOR all elements. Pairs cancel out, leaving single.",
      "intuition": [
        "\ud83c\udfaf Find element that appears once (others twice).",
        "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
        "\ud83d\udca1 XOR all elements to get the unique one."
      ],
      "testCases": [
        {
          "input": "nums = [2,2,1]",
          "output": "1"
        },
        {
          "input": "nums = [4,1,2,1,2]",
          "output": "4"
        },
        {
          "input": "nums = [1]",
          "output": "1"
        }
      ],
      "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element that appears once (others twice).\n    - \ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.\n    - \ud83d\udca1 XOR all elements to get the unique one.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for n in nums:  # Iterate over elements.\n        res ^= n\n    return res  # Return the final result.",
      "keyInsight": "XOR is self-inverse: a ^ a = 0.",
      "visualizationType": "array",
      "initialState": [
        4,
        1,
        2,
        1,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [4, 1, 2, 1, 2]",
          "transientMessage": "XOR all elements",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "XOR 4: result = 4",
          "transientMessage": "a^a=0, a^0=a",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "XOR 1: result = 5",
          "transientMessage": "a^a=0, a^0=a",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "XOR 2: result = 7",
          "transientMessage": "a^a=0, a^0=a",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "XOR 1: result = 6",
          "transientMessage": "a^a=0, a^0=a",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "XOR 2: result = 4",
          "transientMessage": "a^a=0, a^0=a",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Single number: 4",
          "transientMessage": "Complete!",
          "arrayState": [
            4,
            1,
            2,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
      "examples": [
        {
          "input": "nums = [2,2,1]",
          "output": "1",
          "explanation": "1 appears once."
        },
        {
          "input": "nums = [4,1,2,1,2]",
          "output": "4",
          "explanation": "4 appears once."
        },
        {
          "input": "nums = [1]",
          "output": "1",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 3 * 10^4",
        "-3 * 10^4 <= nums[i] <= 3 * 10^4",
        "Each element appears twice except for one element which appears once."
      ],
      "hints": [
        "Use XOR operation.",
        "XOR of a number with itself is 0.",
        "XOR of a number with 0 is the number itself."
      ],
      "relatedProblems": [
        "single-number-ii",
        "single-number-iii",
        "missing-number"
      ],
      "videoId": "qMPX1AOa83k",
      "problemStatement": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "XOR: XOR all elements. Pairs cancel out, leaving single.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def singleNumber(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def singleNumber(nums):\n    res = 0\n    for n in nums:\n        res = n ^ res\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find element that appears once (others twice).",
            "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
            "\ud83d\udca1 XOR all elements to get the unique one."
          ],
          "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element that appears once (others twice).\n    - \ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.\n    - \ud83d\udca1 XOR all elements to get the unique one.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for n in nums:  # Iterate over elements.\n        res ^= n\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "single-number-ii": {
      "title": "Single Number II",
      "pattern": "Bit Counting",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Count bits mod 3 for each position.",
      "intuition": [
        "\ud83c\udfaf Find element appearing once (others 3 times).",
        "\ud83e\udde0 For each bit position, count 1s mod 3.",
        "\ud83d\udca1 Remaining bits form the unique number."
      ],
      "testCases": [
        {
          "input": "nums = [2,2,3,2]",
          "output": "3"
        },
        {
          "input": "nums = [0,1,0,1,0,1,99]",
          "output": "99"
        }
      ],
      "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element appearing once (others 3 times).\n    - \ud83e\udde0 For each bit position, count 1s mod 3.\n    - \ud83d\udca1 Remaining bits form the unique number.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for i in range(32):  # Iterate through the range.\n        bitSum = sum((n >> i) & 1 for n in nums)\n        if bitSum % 3:\n            res |= (1 << i)\n    # Handle negative numbers\n    if res >= 2**31:\n        res -= 2**32\n    return res  # Return the final result.",
      "keyInsight": "Count bits at each position; mod 3 reveals the unique number.",
      "visualizationType": "array",
      "initialState": [
        2,
        2,
        3,
        2
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Starting with bit position i = 0",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Calculating bitSum for i = 0: (2 >> 0) & 1 + (2 >> 0) & 1 + (3 >> 0) & 1 + (2 >> 0) & 1",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "bitSum = 4, since bitSum % 3 != 0, res remains 0",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Moving to bit position i = 1",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Calculating bitSum for i = 1: (2 >> 1) & 1 + (2 >> 1) & 1 + (3 >> 1) & 1 + (2 >> 1) & 1",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "bitSum = 2, since bitSum % 3 != 0, res remains 0",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Moving to bit position i = 2",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "Calculating bitSum for i = 2: (2 >> 2) & 1 + (2 >> 2) & 1 + (3 >> 2) & 1 + (2 >> 2) & 1",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 1,
              "label": "j"
            }
          ],
          "transientMessage": "bitSum = 1, since bitSum % 3 != 0, res becomes 1 (res |= (1 << 2))",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Finished processing all bit positions",
          "arrayState": [
            2,
            2,
            3,
            2
          ]
        }
      ],
      "description": "Count bits mod 3 for each position.\n\nFind element appearing once (others 3 times).\nFor each bit position, count 1s mod 3.",
      "examples": [
        {
          "input": "nums = [2,2,3,2]",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find element appearing once (others 3 times).",
        "For each bit position, count 1s mod 3.",
        "Remaining bits form the unique number."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "cOFAmaMBVps",
      "problemStatement": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Bit Counting: Count bits mod 3 for each position.",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def singleNumber(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find element appearing once (others 3 times).",
            "\ud83e\udde0 For each bit position, count 1s mod 3.",
            "\ud83d\udca1 Remaining bits form the unique number."
          ],
          "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element appearing once (others 3 times).\n    - \ud83e\udde0 For each bit position, count 1s mod 3.\n    - \ud83d\udca1 Remaining bits form the unique number.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for i in range(32):  # Iterate through the range.\n        bitSum = sum((n >> i) & 1 for n in nums)\n        if bitSum % 3:\n            res |= (1 << i)\n    # Handle negative numbers\n    if res >= 2**31:\n        res -= 2**32\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "bitwise-and-of-numbers-range": {
      "title": "Bitwise AND of Numbers Range",
      "pattern": "Common Prefix",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "AND of range = common prefix of left and right.",
      "intuition": [
        "\ud83c\udfaf AND of all numbers from left to right.",
        "\ud83e\udde0 Result is the common prefix bits.",
        "\ud83d\udca1 Shift until left == right, then shift back."
      ],
      "testCases": [
        {
          "input": "left = 5, right = 7",
          "output": "4"
        },
        {
          "input": "left = 0, right = 0",
          "output": "0"
        },
        {
          "input": "left = 1, right = 2147483647",
          "output": "0"
        }
      ],
      "code": "def rangeBitwiseAnd(left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf AND of all numbers from left to right.\n    - \ud83e\udde0 Result is the common prefix bits.\n    - \ud83d\udca1 Shift until left == right, then shift back.\n    \"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1  # Right shift to process next bit.\n        right >>= 1  # Right shift to process next bit.\n        shift += 1\n    return left << shift  # Left shift by count.",
      "keyInsight": "Find common prefix by shifting until equal.",
      "visualizationType": "array",
      "initialState": "5",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Bitwise AND of Numbers Range",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "5"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 5",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "5"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute result phase 6",
          "transientMessage": "Building solution",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "AND of range = common prefix of left and right.\n\nAND of all numbers from left to right.\nResult is the common prefix bits.",
      "examples": [
        {
          "input": "left = 5; right = 7",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "AND of all numbers from left to right.",
        "Result is the common prefix bits.",
        "Shift until left == right, then shift back."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "R3T0olAhUq0",
      "problemStatement": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Common Prefix: AND of range = common prefix of left and right.",
      "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
      "initialCode": "def rangeBitwiseAnd(left, right):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rangeBitwiseAnd(left, right):\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf AND of all numbers from left to right.",
            "\ud83e\udde0 Result is the common prefix bits.",
            "\ud83d\udca1 Shift until left == right, then shift back."
          ],
          "code": "def rangeBitwiseAnd(left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf AND of all numbers from left to right.\n    - \ud83e\udde0 Result is the common prefix bits.\n    - \ud83d\udca1 Shift until left == right, then shift back.\n    \"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1  # Right shift to process next bit.\n        right >>= 1  # Right shift to process next bit.\n        shift += 1\n    return left << shift  # Left shift by count."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "counting-bits": {
      "title": "Counting Bits",
      "pattern": "DP",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
      "intuition": [
        "\ud83c\udfaf Count 1s in binary for 0 to n.",
        "\ud83e\udde0 i has same bits as i/2, plus LSB.",
        "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
      ],
      "testCases": [
        {
          "input": "n = 2",
          "output": "[0,1,1]"
        },
        {
          "input": "n = 5",
          "output": "[0,1,1,2,1,2]"
        }
      ],
      "code": "def countBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count 1s in binary for 0 to n.\n    - \ud83e\udde0 i has same bits as i/2, plus LSB.\n    - \ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1).\n    \"\"\"\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    for i in range(1, n + 1):  # Iterate through the range.\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp",
      "keyInsight": "dp[i] = dp[i >> 1] + (i & 1) reuses previous computation.",
      "visualizationType": "array",
      "initialState": [
        0
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "n = 5",
          "transientMessage": "Count 1 bits for 0 to n",
          "arrayState": [
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "1 = 1",
          "transientMessage": "Bits: 1 (dp[0] + 1)",
          "arrayState": [
            0,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "2 = 10",
          "transientMessage": "Bits: 1 (dp[1] + 0)",
          "arrayState": [
            0,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "3 = 11",
          "transientMessage": "Bits: 2 (dp[1] + 1)",
          "arrayState": [
            0,
            1,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "4 = 100",
          "transientMessage": "Bits: 1 (dp[2] + 0)",
          "arrayState": [
            0,
            1,
            1,
            2,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "5 = 101",
          "transientMessage": "Bits: 2 (dp[2] + 1)",
          "arrayState": [
            0,
            1,
            1,
            2,
            1,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Result: [0, 1, 1, 2, 1, 2]",
          "transientMessage": "Complete!",
          "arrayState": [
            0,
            1,
            1,
            2,
            1,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.\n\nCount 1s in binary for 0 to n.\ni has same bits as i/2, plus LSB.",
      "examples": [
        {
          "input": "n = 5",
          "output": "[0,1,1,2,1,2]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count 1s in binary for 0 to n.",
        "i has same bits as i/2, plus LSB.",
        "dp[i] = dp[i >> 1] + (i & 1)."
      ],
      "relatedProblems": [
        "climbing-stairs",
        "coin-change",
        "longest-increasing-subsequence"
      ],
      "videoId": "RyBM56RIWrM",
      "problemStatement": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DP: dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
      "suggestedNextQuestion": {
        "slug": "decode-ways",
        "title": "Decode Ways",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def countBits(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def countBits(n):\n    res = [0] * (n + 1)\n    for i in range(1, n + 1):\n        # i >> 1 is i // 2\n        # i & 1 is i % 2\n        res[i] = res[i >> 1] + (i & 1)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Count 1s in binary for 0 to n.",
            "\ud83e\udde0 i has same bits as i/2, plus LSB.",
            "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
          ],
          "code": "def countBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count 1s in binary for 0 to n.\n    - \ud83e\udde0 i has same bits as i/2, plus LSB.\n    - \ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1).\n    \"\"\"\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    for i in range(1, n + 1):  # Iterate through the range.\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "palindrome-number": {
      "title": "Palindrome Number",
      "pattern": "Number Reversal",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Reverse half the number and compare.",
      "intuition": [
        "\ud83c\udfaf Check if number is palindrome without string.",
        "\ud83e\udde0 Reverse last half of digits.",
        "\ud83d\udca1 Compare with first half."
      ],
      "testCases": [
        {
          "input": "x = 121",
          "output": "true"
        },
        {
          "input": "x = -121",
          "output": "false"
        },
        {
          "input": "x = 10",
          "output": "false"
        }
      ],
      "code": "def isPalindrome(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if number is palindrome without string.\n    - \ud83e\udde0 Reverse last half of digits.\n    - \ud83d\udca1 Compare with first half.\n    \"\"\"\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False  # Condition not met.\n    rev = 0\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    return x == rev or x == rev // 10",
      "keyInsight": "Only reverse half to avoid overflow.",
      "visualizationType": "array",
      "initialState": [
        "1",
        "2",
        "1"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "x = 121",
          "transientMessage": "Reverse and compare",
          "arrayState": [
            "1",
            "2",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Digit: 1, reversed: 1",
          "transientMessage": "temp: 12",
          "arrayState": [
            "1",
            "2",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Digit: 2, reversed: 12",
          "transientMessage": "temp: 1",
          "arrayState": [
            "1",
            "2",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Digit: 1, reversed: 121",
          "transientMessage": "temp: 0",
          "arrayState": [
            "1",
            "2",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "121 == 121? true",
          "transientMessage": "Palindrome!",
          "arrayState": [
            "1",
            "2",
            "1"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Reverse half the number and compare.\n\nCheck if number is palindrome without string.\nReverse last half of digits.",
      "examples": [
        {
          "input": "x = 121",
          "output": "true"
        },
        {
          "input": "x = -121",
          "output": "false"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Check if number is palindrome without string.",
        "Reverse last half of digits.",
        "Compare with first half."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "yubRKwixN-U",
      "problemStatement": "Given an integer x, return true if x is a palindrome, and false otherwise.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Number Reversal: Reverse half the number and compare.",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def isPalindrome(x):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isPalindrome(x):\n    if x < 0: return False\n    return str(x) == str(x)[::-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Check if number is palindrome without string.",
            "\ud83e\udde0 Reverse last half of digits.",
            "\ud83d\udca1 Compare with first half."
          ],
          "code": "def isPalindrome(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if number is palindrome without string.\n    - \ud83e\udde0 Reverse last half of digits.\n    - \ud83d\udca1 Compare with first half.\n    \"\"\"\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False  # Condition not met.\n    rev = 0\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    return x == rev or x == rev // 10"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "plus-one": {
      "title": "Plus One",
      "pattern": "Simulation",
      "patternEmoji": "\u2795",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Add 1 to last digit, propagate carry.",
      "intuition": [
        "\ud83c\udfaf Add 1 to a number represented as array.",
        "\ud83e\udde0 Handle carry from rightmost digit.",
        "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
      ],
      "testCases": [
        {
          "input": "digits = [1,2,3]",
          "output": "[1,2,4]"
        },
        {
          "input": "digits = [4,3,2,1]",
          "output": "[4,3,2,2]"
        },
        {
          "input": "digits = [9]",
          "output": "[1,0]"
        }
      ],
      "code": "def plusOne(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add 1 to a number represented as array.\n    - \ud83e\udde0 Handle carry from rightmost digit.\n    - \ud83d\udca1 [9,9,9] -> [1,0,0,0].\n    \"\"\"\n    for i in range(len(digits) - 1, -1, -1):  # Iterate through the range.\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits",
      "keyInsight": "If no early return, all 9s -> prepend 1.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Plus One",
          "transientMessage": "Input: [1, 2, 3]",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 3",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Add 1 to last digit, propagate carry.\n\nAdd 1 to a number represented as array.\nHandle carry from rightmost digit.",
      "examples": [
        {
          "input": "digits = [1,2,3]",
          "output": "[1,2,4]"
        },
        {
          "input": "digits = [9,9,9]",
          "output": "[1,0,0,0]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Add 1 to a number represented as array.",
        "Handle carry from rightmost digit.",
        "[9,9,9] -> [1,0,0,0]."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "jIaA8boiG1s",
      "problemStatement": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Simulation: Add 1 to last digit, propagate carry.",
      "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
      "initialCode": "def plusOne(digits):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def plusOne(digits):\n    for i in range(len(digits)-1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Add 1 to a number represented as array.",
            "\ud83e\udde0 Handle carry from rightmost digit.",
            "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
          ],
          "code": "def plusOne(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add 1 to a number represented as array.\n    - \ud83e\udde0 Handle carry from rightmost digit.\n    - \ud83d\udca1 [9,9,9] -> [1,0,0,0].\n    \"\"\"\n    for i in range(len(digits) - 1, -1, -1):  # Iterate through the range.\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "factorial-trailing-zeroes": {
      "title": "Factorial Trailing Zeroes",
      "pattern": "Math",
      "patternEmoji": "0\ufe0f\u20e3",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Count factors of 5 in n!",
      "intuition": [
        "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
        "\ud83e\udde0 More 2s than 5s, so count 5s.",
        "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
      ],
      "testCases": [
        {
          "input": "n = 3",
          "output": "0"
        },
        {
          "input": "n = 5",
          "output": "1"
        },
        {
          "input": "n = 0",
          "output": "0"
        }
      ],
      "code": "def trailingZeroes(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Trailing zeros = count of (2*5) pairs.\n    - \ud83e\udde0 More 2s than 5s, so count 5s.\n    - \ud83d\udca1 n/5 + n/25 + n/125 + ...\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5  # Count factors of 5.\n        count += n\n    return count",
      "keyInsight": "Each factor of 5 contributes to a trailing zero.",
      "visualizationType": "array",
      "initialState": "25",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Factorial Trailing Zeroes",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 5",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "2",
            "5"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Count factors of 5 in n!\n\nTrailing zeros = count of (2*5) pairs.\nMore 2s than 5s, so count 5s.",
      "examples": [
        {
          "input": "n = 5",
          "output": "1"
        },
        {
          "input": "n = 25",
          "output": "6"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Trailing zeros = count of (2*5) pairs.",
        "More 2s than 5s, so count 5s.",
        "n/5 + n/25 + n/125 + ..."
      ],
      "relatedProblems": [
        "palindrome-number",
        "fizz-buzz",
        "roman-to-integer"
      ],
      "videoId": "_NxbBkunCEM",
      "problemStatement": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
      "difficulty": "Medium",
      "walkthrough": [
        "Identify mathematical pattern or formula",
        "Handle edge cases (zero, negative, overflow)",
        "Apply mathematical operations",
        "Optimize with mathematical properties",
        "Return computed result"
      ],
      "approach": "Math: Count factors of 5 in n!",
      "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
      "initialCode": "def trailingZeroes(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def trailingZeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
            "\ud83e\udde0 More 2s than 5s, so count 5s.",
            "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
          ],
          "code": "def trailingZeroes(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Trailing zeros = count of (2*5) pairs.\n    - \ud83e\udde0 More 2s than 5s, so count 5s.\n    - \ud83d\udca1 n/5 + n/25 + n/125 + ...\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5  # Count factors of 5.\n        count += n\n    return count"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "sqrtx": {
      "title": "Sqrt(x)",
      "pattern": "Binary Search",
      "patternEmoji": "\u221a",
      "timeComplexity": "O(log x)",
      "spaceComplexity": "O(1)",
      "oneliner": "Binary search for largest k where k*k <= x.",
      "intuition": [
        "\ud83c\udfaf Find integer square root.",
        "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
        "\ud83d\udca1 Track the largest valid mid."
      ],
      "testCases": [
        {
          "input": "x = 4",
          "output": "2"
        },
        {
          "input": "x = 8",
          "output": "2"
        }
      ],
      "code": "def mySqrt(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find integer square root.\n    - \ud83e\udde0 Binary search: if mid*mid <= x, go right.\n    - \ud83d\udca1 Track the largest valid mid.\n    \"\"\"\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if mid * mid == x:  # Calculate middle index.\n            return mid\n        elif mid * mid < x:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return right",
      "keyInsight": "Binary search from 1 to x/2 is sufficient.",
      "visualizationType": "array",
      "initialState": "8",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "transientMessage": "Checking if x < 2",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            1
          ],
          "newValues": {
            "left": 1,
            "right": 4
          },
          "transientMessage": "Initializing left to 1 and right to x // 2 (8 // 2 = 4)",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            1,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Starting binary search with left = 1 and right = 4",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "mid": 2
          },
          "transientMessage": "Calculating mid = (left + right) // 2 (1 + 4) // 2 = 2",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "transientMessage": "Checking if mid * mid == x (2 * 2 == 8)",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "left": 3
          },
          "transientMessage": "Since mid * mid < x, updating left to mid + 1 (2 + 1 = 3)",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            4,
            6
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 4,
              "label": "left"
            },
            {
              "index": 6,
              "label": "right"
            }
          ],
          "transientMessage": "Continuing binary search with left = 3 and right = 4",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "mid": 3
          },
          "transientMessage": "Calculating mid = (left + right) // 2 (3 + 4) // 2 = 3",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            7
          ],
          "color": "accent",
          "transientMessage": "Checking if mid * mid == x (3 * 3 == 8)",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "left": 4
          },
          "transientMessage": "Since mid * mid < x, updating left to mid + 1 (3 + 1 = 4)",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            8,
            6
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 8,
              "label": "left"
            },
            {
              "index": 6,
              "label": "right"
            }
          ],
          "transientMessage": "Continuing binary search with left = 4 and right = 4",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "mid": 4
          },
          "transientMessage": "Calculating mid = (left + right) // 2 (4 + 4) // 2 = 4",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            9
          ],
          "color": "accent",
          "transientMessage": "Checking if mid * mid == x (4 * 4 == 8)",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "updateValue",
          "indices": [
            3
          ],
          "newValues": {
            "right": 3
          },
          "transientMessage": "Since mid * mid > x, updating right to mid - 1 (4 - 1 = 3)",
          "arrayState": [
            "8"
          ],
          "color": "accent"
        },
        {
          "type": "highlight",
          "indices": [
            8,
            6
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 8,
              "label": "left"
            },
            {
              "index": 6,
              "label": "right"
            }
          ],
          "transientMessage": "Binary search terminates as left > right",
          "arrayState": [
            "8"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            6
          ],
          "color": "success",
          "transientMessage": "Returning right as the integer part of the square root (3)",
          "arrayState": [
            "8"
          ]
        }
      ],
      "description": "Binary search for largest k where k*k <= x.\n\nFind integer square root.\nBinary search: if mid*mid <= x, go right.",
      "examples": [
        {
          "input": "x = 8",
          "output": "2"
        },
        {
          "input": "x = 4",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find integer square root.",
        "Binary search: if mid*mid <= x, go right.",
        "Track the largest valid mid."
      ],
      "relatedProblems": [
        "binary-search",
        "search-in-rotated-sorted-array",
        "find-peak-element"
      ],
      "videoId": "zdMhGxRWutQ",
      "problemStatement": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.",
      "difficulty": "Easy",
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "approach": "Binary Search: Binary search for largest k where k*k <= x.",
      "suggestedNextQuestion": {
        "slug": "find-first-and-last-position-of-element-in-sorted-array",
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def mySqrt(x):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def mySqrt_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log x)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find integer square root.",
            "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
            "\ud83d\udca1 Track the largest valid mid."
          ],
          "code": "def mySqrt(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find integer square root.\n    - \ud83e\udde0 Binary search: if mid*mid <= x, go right.\n    - \ud83d\udca1 Track the largest valid mid.\n    \"\"\"\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if mid * mid == x:  # Calculate middle index.\n            return mid\n        elif mid * mid < x:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return right"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "max-points-on-a-line": {
      "title": "Max Points on a Line",
      "pattern": "Hash Map + Slopes",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(n)",
      "oneliner": "For each point, count slopes to all others.",
      "intuition": [
        "\ud83c\udfaf Max collinear points.",
        "\ud83e\udde0 For each point, map slopes to counts.",
        "\ud83d\udca1 Use fractions to avoid float precision issues."
      ],
      "testCases": [
        {
          "input": "points = [[1,1],[2,2],[3,3]]",
          "output": "3"
        },
        {
          "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
          "output": "4"
        }
      ],
      "code": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max collinear points.\n    - \ud83e\udde0 For each point, map slopes to counts.\n    - \ud83d\udca1 Use fractions to avoid float precision issues.\n    \"\"\"\n    if len(points) <= 2:\n        return len(points)\n    maxPts = 0\n    for i in range(len(points)):  # Iterate through the range.\n        slopes = defaultdict(int)\n        for j in range(len(points)):  # Iterate through the range.\n            if i == j:\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            g = gcd(dx, dy)\n            slope = (dx // g, dy // g)\n            slopes[slope] += 1\n            maxPts = max(maxPts, slopes[slope])  # Take the maximum value.\n    return maxPts + 1",
      "keyInsight": "Normalize slope using GCD to avoid float issues.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          1
        ],
        [
          2,
          2
        ],
        [
          3,
          3
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Max Points on a Line",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1,1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2,2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3,3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              1,
              1
            ],
            [
              2,
              2
            ],
            [
              3,
              3
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "For each point, count slopes to all others.\n\nMax collinear points.\nFor each point, map slopes to counts.",
      "examples": [
        {
          "input": "points = [[1,1],[2,2],[3,3]]",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Max collinear points.",
        "For each point, map slopes to counts.",
        "Use fractions to avoid float precision issues."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Bb9lOXUOnFw",
      "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Hash Map + Slopes: For each point, count slopes to all others.",
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "def maxPoints(points):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def maxPoints_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Max collinear points.",
            "\ud83e\udde0 For each point, map slopes to counts.",
            "\ud83d\udca1 Use fractions to avoid float precision issues."
          ],
          "code": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max collinear points.\n    - \ud83e\udde0 For each point, map slopes to counts.\n    - \ud83d\udca1 Use fractions to avoid float precision issues.\n    \"\"\"\n    if len(points) <= 2:\n        return len(points)\n    maxPts = 0\n    for i in range(len(points)):  # Iterate through the range.\n        slopes = defaultdict(int)\n        for j in range(len(points)):  # Iterate through the range.\n            if i == j:\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            g = gcd(dx, dy)\n            slope = (dx // g, dy // g)\n            slopes[slope] += 1\n            maxPts = max(maxPts, slopes[slope])  # Take the maximum value.\n    return maxPts + 1"
        }
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "house-robber": {
      "title": "House Robber",
      "pattern": "1D DP",
      "patternEmoji": "\ud83c\udfe0",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
      "intuition": [
        "\ud83c\udfaf Max loot without robbing adjacent houses.",
        "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
        "\ud83d\udca1 Only need last two values."
      ],
      "testCases": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "4"
        },
        {
          "input": "nums = [2,7,9,3,1]",
          "output": "12"
        }
      ],
      "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max loot without robbing adjacent houses.\n    - \ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].\n    - \ud83d\udca1 Only need last two values.\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for n in nums:  # Iterate over elements.\n        curr = max(prev1, prev2 + n)  # Take the maximum value.\n        prev2, prev1 = prev1, curr\n    return prev1",
      "keyInsight": "Classic 1D DP with space optimization.",
      "visualizationType": "array",
      "initialState": [
        2,
        7,
        9,
        3,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: House Robber",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            2,
            7,
            9,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 2",
          "arrayState": [
            2,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 7",
          "arrayState": [
            2,
            7,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            7,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 9",
          "arrayState": [
            2,
            7,
            9,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            2,
            7,
            9,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            2,
            7,
            9,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            2,
            7,
            9,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 1",
          "arrayState": [
            2,
            7,
            9,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            2,
            7,
            9,
            3,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            2,
            7,
            9,
            3,
            1
          ],
          "pointers": [],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            7,
            9,
            3,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
      "examples": [
        {
          "input": "nums = [1,2,3,1]",
          "output": "4",
          "explanation": "Rob house 1 and house 3: 1 + 3 = 4."
        },
        {
          "input": "nums = [2,7,9,3,1]",
          "output": "12",
          "explanation": "Rob house 1, 3, and 5: 2 + 9 + 1 = 12."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 100",
        "0 <= nums[i] <= 400"
      ],
      "hints": [
        "Use dynamic programming.",
        "At each house, decide: rob it or skip it.",
        "dp[i] = max(dp[i-1], dp[i-2] + nums[i])"
      ],
      "relatedProblems": [
        "house-robber-ii",
        "house-robber-iii",
        "delete-and-earn"
      ],
      "videoId": "73r3KWiEvyk",
      "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "1D DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
      "suggestedNextQuestion": {
        "slug": "house-robber-ii",
        "title": "House Robber II",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def rob(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def rob(nums):\n    # Brute Force Recursion\n    def solve(i):\n        if i >= len(nums): return 0\n        return max(solve(i+1), nums[i] + solve(i+2))\n    return solve(0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Max loot without robbing adjacent houses.",
            "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
            "\ud83d\udca1 Only need last two values."
          ],
          "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max loot without robbing adjacent houses.\n    - \ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].\n    - \ud83d\udca1 Only need last two values.\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for n in nums:  # Iterate over elements.\n        curr = max(prev1, prev2 + n)  # Take the maximum value.\n        prev2, prev1 = prev1, curr\n    return prev1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "word-break": {
      "title": "Word Break",
      "pattern": "1D DP",
      "patternEmoji": "\ud83d\udcdd",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i] = any(dp[j] and s[j:i] in wordDict).",
      "intuition": [
        "\ud83c\udfaf Can s be segmented into dictionary words?",
        "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
        "\ud83d\udca1 Check all valid word endings."
      ],
      "testCases": [
        {
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "output": "true"
        },
        {
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "output": "true"
        },
        {
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "output": "false"
        }
      ],
      "code": "def wordBreak(s, wordDict):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s be segmented into dictionary words?\n    - \ud83e\udde0 dp[i] = True if s[:i] can be segmented.\n    - \ud83d\udca1 Check all valid word endings.\n    \"\"\"\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for i in range(1, len(s) + 1):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n    return dp[len(s)]",
      "keyInsight": "dp[i] = True if any valid word ends at position i.",
      "visualizationType": "array",
      "initialState": [
        "l",
        "e",
        "e",
        "t",
        "c",
        "o",
        "d",
        "e"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Word Break",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = l",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = e",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = e",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = t",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = c",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = o",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "l",
            "e",
            "e",
            "t",
            "c",
            "o",
            "d",
            "e"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i] = any(dp[j] and s[j:i] in wordDict).\n\nCan s be segmented into dictionary words?\ndp[i] = True if s[:i] can be segmented.",
      "examples": [
        {
          "input": "s = \"leetcode\"; wordDict = [\"leet\",\"code\"]",
          "output": "true"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Can s be segmented into dictionary words?",
        "dp[i] = True if s[:i] can be segmented.",
        "Check all valid word endings."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "Sx9NNgInc3A",
      "problemStatement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "1D DP: dp[i] = any(dp[j] and s[j:i] in wordDict).",
      "suggestedNextQuestion": {
        "slug": "best-time-to-buy-and-sell-stock-iii",
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def wordBreak(s, wordDict):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def wordBreak(s, wordDict):\n    # Recursion\n    words = set(wordDict)\n    def canBreak(target):\n        if not target: return True\n        for w in words:\n             if target.startswith(w):\n                 if canBreak(target[len(w):]):\n                     return True\n        return False\n    return canBreak(s)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Can s be segmented into dictionary words?",
            "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
            "\ud83d\udca1 Check all valid word endings."
          ],
          "code": "def wordBreak(s, wordDict):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s be segmented into dictionary words?\n    - \ud83e\udde0 dp[i] = True if s[:i] can be segmented.\n    - \ud83d\udca1 Check all valid word endings.\n    \"\"\"\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for i in range(1, len(s) + 1):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n    return dp[len(s)]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "longest-increasing-subsequence": {
      "title": "Longest Increasing Subsequence",
      "pattern": "DP / Binary Search",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Maintain sorted 'tails' array. Binary search insertion point.",
      "intuition": [
        "\ud83c\udfaf Find LIS length.",
        "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
        "\ud83d\udca1 Binary search for where to insert/replace."
      ],
      "testCases": [
        {
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "output": "4"
        },
        {
          "input": "nums = [0,1,0,3,2,3]",
          "output": "4"
        },
        {
          "input": "nums = [7,7,7,7,7,7,7]",
          "output": "1"
        }
      ],
      "code": "import bisect\n\ndef lengthOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LIS length.\n    - \ud83e\udde0 O(n log n): maintain smallest tail for each length.\n    - \ud83d\udca1 Binary search for where to insert/replace.\n    \"\"\"\n    tails = []\n    for n in nums:  # Iterate over elements.\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)  # Add to end.\n        else:\n            tails[pos] = n\n    return len(tails)",
      "keyInsight": "tails[i] = smallest tail of LIS of length i+1.",
      "visualizationType": "array",
      "initialState": [
        10,
        9,
        2,
        5,
        3,
        7,
        101,
        18
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Array: [10, 9, 2, 5, 3, 7, 101, 18]",
          "transientMessage": "dp[i] = LIS ending at i",
          "arrayState": [
            10,
            9,
            2,
            5,
            3,
            7,
            101,
            18
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "nums[2]=2 < nums[3]=5",
          "transientMessage": "dp[3] = 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 2
            },
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 3,
          "visual": "nums[2]=2 < nums[4]=3",
          "transientMessage": "dp[4] = 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 2
            },
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            2,
            4
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "nums[2]=2 < nums[5]=7",
          "transientMessage": "dp[5] = 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 2
            },
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            2,
            5
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "nums[3]=5 < nums[5]=7",
          "transientMessage": "dp[5] = 3",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            1,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 3
            },
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            3,
            5
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "nums[0]=10 < nums[6]=101",
          "transientMessage": "dp[6] = 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            2,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 0
            },
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            0,
            6
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "nums[3]=5 < nums[6]=101",
          "transientMessage": "dp[6] = 3",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            3,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 3
            },
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            3,
            6
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "nums[5]=7 < nums[6]=101",
          "transientMessage": "dp[6] = 4",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            1
          ],
          "pointers": [
            {
              "label": "j",
              "index": 5
            },
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "nums[0]=10 < nums[7]=18",
          "transientMessage": "dp[7] = 2",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            2
          ],
          "pointers": [
            {
              "label": "j",
              "index": 0
            },
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            0,
            7
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "nums[3]=5 < nums[7]=18",
          "transientMessage": "dp[7] = 3",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            3
          ],
          "pointers": [
            {
              "label": "j",
              "index": 3
            },
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            3,
            7
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "nums[5]=7 < nums[7]=18",
          "transientMessage": "dp[7] = 4",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            4
          ],
          "pointers": [
            {
              "label": "j",
              "index": 5
            },
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            5,
            7
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "LIS length: 4",
          "transientMessage": "dp = [1, 1, 1, 2, 2, 3, 4, 4]",
          "arrayState": [
            1,
            1,
            1,
            2,
            2,
            3,
            4,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Maintain sorted 'tails' array. Binary search insertion point.\n\nFind LIS length.\nO(n log n): maintain smallest tail for each length.",
      "examples": [
        {
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find LIS length.",
        "O(n log n): maintain smallest tail for each length.",
        "Binary search for where to insert/replace."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "73r3KWiEvyk",
      "problemStatement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DP / Binary Search: Maintain sorted 'tails' array. Binary search insertion point.",
      "suggestedNextQuestion": {
        "slug": "maximal-square",
        "title": "Maximal Square",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def lengthOfLIS(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def lengthOfLIS_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Find LIS length.",
            "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
            "\ud83d\udca1 Binary search for where to insert/replace."
          ],
          "code": "import bisect\n\ndef lengthOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LIS length.\n    - \ud83e\udde0 O(n log n): maintain smallest tail for each length.\n    - \ud83d\udca1 Binary search for where to insert/replace.\n    \"\"\"\n    tails = []\n    for n in nums:  # Iterate over elements.\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)  # Add to end.\n        else:\n            tails[pos] = n\n    return len(tails)"
        }
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "number-of-longest-increasing-subsequence": {
      "title": "Number of Longest Increasing Subsequence",
      "pattern": "DP",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(n)",
      "oneliner": "Track both length and count at each position.",
      "intuition": [
        "\ud83c\udfaf Count all LIS.",
        "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
        "\ud83d\udca1 Aggregate counts for max length."
      ],
      "testCases": [
        {
          "input": "nums = [1,3,5,4,7]",
          "output": "2"
        },
        {
          "input": "nums = [2,2,2,2,2]",
          "output": "5"
        }
      ],
      "code": "def findNumberOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count all LIS.\n    - \ud83e\udde0 dp[i] = (length, count) of LIS ending at i.\n    - \ud83d\udca1 Aggregate counts for max length.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    lengths = [1] * n\n    counts = [1] * n\n    for i in range(n):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if nums[j] < nums[i]:\n                if lengths[j] + 1 > lengths[i]:\n                    lengths[i] = lengths[j] + 1\n                    counts[i] = counts[j]\n                elif lengths[j] + 1 == lengths[i]:\n                    counts[i] += counts[j]\n    maxLen = max(lengths)  # Take the maximum value.\n    return sum(c for l, c in zip(lengths, counts) if l == maxLen)",
      "keyInsight": "Track both LIS length and count of ways to achieve it.",
      "visualizationType": "array",
      "initialState": [
        1,
        3,
        5,
        4,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Number of Longest Increasing Subsequence",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            1,
            3,
            5,
            4,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 1",
          "arrayState": [
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 3",
          "arrayState": [
            1,
            3,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            3,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 5",
          "arrayState": [
            1,
            3,
            5,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            1,
            3,
            5,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 4",
          "arrayState": [
            1,
            3,
            5,
            4,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            1,
            3,
            5,
            4,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 7",
          "arrayState": [
            1,
            3,
            5,
            4,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            1,
            3,
            5,
            4,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            1,
            3,
            5,
            4,
            7
          ],
          "pointers": [],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            3,
            5,
            4,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Track both length and count at each position.\n\nCount all LIS.\ndp[i] = (length, count) of LIS ending at i.",
      "examples": [
        {
          "input": "nums = [1,3,5,4,7]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count all LIS.",
        "dp[i] = (length, count) of LIS ending at i.",
        "Aggregate counts for max length."
      ],
      "relatedProblems": [
        "climbing-stairs",
        "coin-change",
        "longest-increasing-subsequence"
      ],
      "videoId": "Tuc-rjJbsXU",
      "problemStatement": "Given an integer array nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DP: Track both length and count at each position.",
      "suggestedNextQuestion": {
        "slug": "partition-equal-subset-sum",
        "title": "Partition Equal Subset Sum",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def findNumberOfLIS(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findNumberOfLIS(nums):\n    if not nums: return 0\n    n = len(nums)\n    length = [1] * n\n    count = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                if length[j] + 1 > length[i]:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n                elif length[j] + 1 == length[i]:\n                    count[i] += count[j]\n                    \n    max_len = max(length)\n    return sum(c for l, c in zip(length, count) if l == max_len)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Count all LIS.",
            "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
            "\ud83d\udca1 Aggregate counts for max length."
          ],
          "code": "def findNumberOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count all LIS.\n    - \ud83e\udde0 dp[i] = (length, count) of LIS ending at i.\n    - \ud83d\udca1 Aggregate counts for max length.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    lengths = [1] * n\n    counts = [1] * n\n    for i in range(n):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if nums[j] < nums[i]:\n                if lengths[j] + 1 > lengths[i]:\n                    lengths[i] = lengths[j] + 1\n                    counts[i] = counts[j]\n                elif lengths[j] + 1 == lengths[i]:\n                    counts[i] += counts[j]\n    maxLen = max(lengths)  # Take the maximum value.\n    return sum(c for l, c in zip(lengths, counts) if l == maxLen)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "decode-ways": {
      "title": "Decode Ways",
      "pattern": "1D DP",
      "patternEmoji": "\ud83d\udd13",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
      "intuition": [
        "\ud83c\udfaf Count ways to decode digit string.",
        "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
        "\ud83d\udca1 Similar to Fibonacci with constraints."
      ],
      "testCases": [
        {
          "input": "s = \"12\"",
          "output": "2"
        },
        {
          "input": "s = \"226\"",
          "output": "3"
        },
        {
          "input": "s = \"06\"",
          "output": "0"
        }
      ],
      "code": "def numDecodings(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count ways to decode digit string.\n    - \ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.\n    - \ud83d\udca1 Similar to Fibonacci with constraints.\n    \"\"\"\n    if not s or s[0] == '0':\n        return 0\n    prev2, prev1 = 1, 1\n    for i in range(1, len(s)):  # Iterate through the range.\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two = int(s[i-1:i+1])\n        if 10 <= two <= 26:\n            curr += prev2\n        prev2, prev1 = prev1, curr\n    return prev1",
      "keyInsight": "Handle '0' carefully - it can only be part of 10 or 20.",
      "visualizationType": "array",
      "initialState": "226",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Decode Ways",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "2",
            "2",
            "6"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).\n\nCount ways to decode digit string.\nSingle digit: 1-9 valid. Two digits: 10-26 valid.",
      "examples": [
        {
          "input": "s = \"226\"",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count ways to decode digit string.",
        "Single digit: 1-9 valid. Two digits: 10-26 valid.",
        "Similar to Fibonacci with constraints."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "6aEyTjOwlJU",
      "problemStatement": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "1D DP: dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
      "suggestedNextQuestion": {
        "slug": "edit-distance",
        "title": "Edit Distance",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def numDecodings(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def numDecodings(s):\n    # Recursive\n    def dfs(i):\n        if i == len(s): return 1\n        if s[i] == '0': return 0\n        res = dfs(i + 1)\n        if i + 1 < len(s) and (s[i] == '1' or (s[i] == '2' and s[i+1] in '0123456')):\n            res += dfs(i + 2)\n        return res\n    return dfs(0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Count ways to decode digit string.",
            "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
            "\ud83d\udca1 Similar to Fibonacci with constraints."
          ],
          "code": "def numDecodings(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count ways to decode digit string.\n    - \ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.\n    - \ud83d\udca1 Similar to Fibonacci with constraints.\n    \"\"\"\n    if not s or s[0] == '0':\n        return 0\n    prev2, prev1 = 1, 1\n    for i in range(1, len(s)):  # Iterate through the range.\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two = int(s[i-1:i+1])\n        if 10 <= two <= 26:\n            curr += prev2\n        prev2, prev1 = prev1, curr\n    return prev1"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-path-sum": {
      "title": "Minimum Path Sum",
      "pattern": "2D DP",
      "patternEmoji": "\ud83d\udee4\ufe0f",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
      "intuition": [
        "\ud83c\udfaf Min sum path from top-left to bottom-right.",
        "\ud83e\udde0 Can only move right or down.",
        "\ud83d\udca1 Each cell = min of arriving from top or left."
      ],
      "testCases": [
        {
          "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
          "output": "7"
        },
        {
          "input": "grid = [[1,2,3],[4,5,6]]",
          "output": "12"
        }
      ],
      "code": "def minPathSum(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min sum path from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 Each cell = min of arriving from top or left.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])  # Take the minimum value.\n    return grid[-1][-1]",
      "keyInsight": "Modify grid in-place for O(1) extra space.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          3,
          1
        ],
        [
          1,
          5,
          1
        ],
        [
          4,
          2,
          1
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Path Sum",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 3",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 5",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).\n\nMin sum path from top-left to bottom-right.\nCan only move right or down.",
      "examples": [
        {
          "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
          "output": "7"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min sum path from top-left to bottom-right.",
        "Can only move right or down.",
        "Each cell = min of arriving from top or left."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "pGMsrvt0fpk",
      "problemStatement": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
      "suggestedNextQuestion": {
        "slug": "number-of-longest-increasing-subsequence",
        "title": "Number of Longest Increasing Subsequence",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def minPathSum(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def minPathSum(grid):\n    R, C = len(grid), len(grid[0])\n    def dfs(r, c):\n        if r == R - 1 and c == C - 1: return grid[r][c]\n        if r >= R or c >= C: return float('inf')\n        return grid[r][c] + min(dfs(r+1, c), dfs(r, c+1))\n    return dfs(0, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Min sum path from top-left to bottom-right.",
            "\ud83e\udde0 Can only move right or down.",
            "\ud83d\udca1 Each cell = min of arriving from top or left."
          ],
          "code": "def minPathSum(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min sum path from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 Each cell = min of arriving from top or left.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])  # Take the minimum value.\n    return grid[-1][-1]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "unique-paths-ii": {
      "title": "Unique Paths II",
      "pattern": "2D DP",
      "patternEmoji": "\ud83d\udee4\ufe0f",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
      "intuition": [
        "\ud83c\udfaf Count paths with obstacles.",
        "\ud83e\udde0 Obstacle = 0 paths through that cell.",
        "\ud83d\udca1 Sum paths from top and left if not blocked."
      ],
      "testCases": [
        {
          "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
          "output": "2"
        },
        {
          "input": "obstacleGrid = [[0,1],[0,0]]",
          "output": "1"
        }
      ],
      "code": "def uniquePathsWithObstacles(obstacleGrid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths with obstacles.\n    - \ud83e\udde0 Obstacle = 0 paths through that cell.\n    - \ud83d\udca1 Sum paths from top and left if not blocked.\n    \"\"\"\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    dp = [0] * n  # Initialize DP table to store results.\n    dp[0] = 1\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j-1]\n    return dp[-1]  # Return the result from DP table.",
      "keyInsight": "Set dp to 0 for obstacles.",
      "visualizationType": "matrix",
      "initialState": [
        [
          0,
          0,
          0
        ],
        [
          0,
          1,
          0
        ],
        [
          0,
          0,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Unique Paths II",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              0,
              0,
              0
            ],
            [
              0,
              1,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].\n\nCount paths with obstacles.\nObstacle = 0 paths through that cell.",
      "examples": [
        {
          "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
          "output": "2"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count paths with obstacles.",
        "Obstacle = 0 paths through that cell.",
        "Sum paths from top and left if not blocked."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "d3UOz7zdE4I",
      "problemStatement": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
      "suggestedNextQuestion": {
        "slug": "word-break",
        "title": "Word Break",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def uniquePathsWithObstacles(obstacleGrid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def uniquePathsWithObstacles(obstacleGrid):\n    R, C = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1: return 0\n    def dfs(r, c):\n        if r >= R or c >= C or obstacleGrid[r][c] == 1: return 0\n        if r == R - 1 and c == C - 1: return 1\n        return dfs(r+1, c) + dfs(r, c+1)\n    return dfs(0, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Count paths with obstacles.",
            "\ud83e\udde0 Obstacle = 0 paths through that cell.",
            "\ud83d\udca1 Sum paths from top and left if not blocked."
          ],
          "code": "def uniquePathsWithObstacles(obstacleGrid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths with obstacles.\n    - \ud83e\udde0 Obstacle = 0 paths through that cell.\n    - \ud83d\udca1 Sum paths from top and left if not blocked.\n    \"\"\"\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    dp = [0] * n  # Initialize DP table to store results.\n    dp[0] = 1\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j-1]\n    return dp[-1]  # Return the result from DP table."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "longest-palindromic-substring": {
      "title": "Longest Palindromic Substring",
      "pattern": "Expand Around Center",
      "patternEmoji": "\ud83d\udcdc",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(1)",
      "oneliner": "Expand from each center (2n-1 centers).",
      "intuition": [
        "\ud83c\udfaf Find longest palindromic substring.",
        "\ud83e\udde0 Expand from each center (odd and even length).",
        "\ud83d\udca1 Track start and maxLen."
      ],
      "testCases": [
        {
          "input": "s = \"babad\"",
          "output": "\"bab\""
        },
        {
          "input": "s = \"cbbd\"",
          "output": "\"bb\""
        }
      ],
      "code": "def longestPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest palindromic substring.\n    - \ud83e\udde0 Expand from each center (odd and even length).\n    - \ud83d\udca1 Track start and maxLen.\n    \"\"\"\n    if len(s) < 2:\n        return s\n    start, maxLen = 0, 1\n    \n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return r - l - 1\n    \n    for i in range(len(s)):  # Iterate through the range.\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        length = max(len1, len2)  # Take the maximum value.\n        if length > maxLen:\n            maxLen = length\n            start = i - (length - 1) // 2\n    return s[start:start + maxLen]",
      "keyInsight": "There are 2n-1 centers (n single + n-1 pairs).",
      "visualizationType": "tree",
      "initialState": "babad",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0,
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 4,
              "label": "end"
            }
          ],
          "transientMessage": "Initial string 'babad' with length 5, start=0, maxLen=1",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            },
            {
              "index": 0,
              "label": "l"
            },
            {
              "index": 0,
              "label": "r"
            }
          ],
          "transientMessage": "Expanding around center i=0, checking s[0] with itself",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            0
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "i"
            }
          ],
          "transientMessage": "Palindrome 'b' found with length 1, maxLen remains 1",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "i"
            },
            {
              "index": 1,
              "label": "l"
            },
            {
              "index": 1,
              "label": "r"
            }
          ],
          "transientMessage": "Expanding around center i=1, checking s[1] with itself",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            2
          ],
          "color": "success",
          "pointers": [
            {
              "index": 1,
              "label": "i"
            },
            {
              "index": 0,
              "label": "l"
            },
            {
              "index": 2,
              "label": "r"
            }
          ],
          "transientMessage": "Palindrome 'bab' found with length 3, updating maxLen=3",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "i"
            },
            {
              "index": 1,
              "label": "l"
            },
            {
              "index": 2,
              "label": "r"
            }
          ],
          "transientMessage": "Checking even-length palindrome at i=1, expanding around s[1] and s[2]",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            2
          ],
          "color": "error",
          "pointers": [
            {
              "index": 1,
              "label": "l"
            },
            {
              "index": 2,
              "label": "r"
            }
          ],
          "transientMessage": "s[1]='a' != s[2]='b', no even-length palindrome here",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "i"
            },
            {
              "index": 2,
              "label": "l"
            },
            {
              "index": 2,
              "label": "r"
            }
          ],
          "transientMessage": "Expanding around center i=2, checking s[2] with itself",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 2,
              "label": "i"
            },
            {
              "index": 1,
              "label": "l"
            },
            {
              "index": 3,
              "label": "r"
            }
          ],
          "transientMessage": "Palindrome 'aba' found with length 3, same as current maxLen",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            2
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "start"
            },
            {
              "index": 2,
              "label": "end"
            }
          ],
          "transientMessage": "Returning longest palindromic substring 'bab'",
          "arrayState": [
            "b",
            "a",
            "b",
            "a",
            "d"
          ]
        }
      ],
      "description": "Expand from each center (2n-1 centers).\n\nFind longest palindromic substring.\nExpand from each center (odd and even length).",
      "examples": [
        {
          "input": "s = \"babad\"",
          "output": "\"bab\""
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find longest palindromic substring.",
        "Expand from each center (odd and even length).",
        "Track start and maxLen."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "XYQecbcd6_c",
      "problemStatement": "Given a string s, return the longest palindromic substring in s.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Expand Around Center: Expand from each center (2n-1 centers).",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def longestPalindrome(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def longestPalindrome(s):\n    res = \"\"\n    for i in range(len(s)):\n        # Odd\n        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > len(res): res = s[l:r+1]\n            l -= 1\n            r += 1\n        # Even\n        l, r = i, i + 1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > len(res): res = s[l:r+1]\n            l -= 1\n            r += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find longest palindromic substring.",
            "\ud83e\udde0 Expand from each center (odd and even length).",
            "\ud83d\udca1 Track start and maxLen."
          ],
          "code": "def longestPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest palindromic substring.\n    - \ud83e\udde0 Expand from each center (odd and even length).\n    - \ud83d\udca1 Track start and maxLen.\n    \"\"\"\n    if len(s) < 2:\n        return s\n    start, maxLen = 0, 1\n    \n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return r - l - 1\n    \n    for i in range(len(s)):  # Iterate through the range.\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        length = max(len1, len2)  # Take the maximum value.\n        if length > maxLen:\n            maxLen = length\n            start = i - (length - 1) // 2\n    return s[start:start + maxLen]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "interleaving-string": {
      "title": "Interleaving String",
      "pattern": "2D DP",
      "patternEmoji": "\ud83e\udde9",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
      "intuition": [
        "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
        "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
        "\ud83d\udca1 Check if current char matches from s1 or s2."
      ],
      "testCases": [
        {
          "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
          "output": "true"
        },
        {
          "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
          "output": "false"
        },
        {
          "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
          "output": "true"
        }
      ],
      "code": "def isInterleave(s1, s2, s3):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s3 be formed by interleaving s1 and s2?\n    - \ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].\n    - \ud83d\udca1 Check if current char matches from s1 or s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False  # Condition not met.\n    dp = [False] * (n + 1)  # Initialize DP table to store results.\n    for i in range(m + 1):  # Iterate through the range.\n        for j in range(n + 1):  # Iterate through the range.\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i-1] == s3[i-1]\n            else:\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n    return dp[n]",
      "keyInsight": "Current s3 char must match either s1[i-1] or s2[j-1].",
      "visualizationType": "array",
      "initialState": "aadbbcbcac",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Interleaving String",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = a",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = a",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = d",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = b",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = b",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = c",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "a",
            "a",
            "d",
            "b",
            "b",
            "c",
            "b",
            "c",
            "a",
            "c"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].\n\nCan s3 be formed by interleaving s1 and s2?\ndp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
      "examples": [
        {
          "input": "s1 = \"aabcc\"; s2 = \"dbbca\"; s3 = \"aadbbcbcac\"",
          "output": "true"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Can s3 be formed by interleaving s1 and s2?",
        "dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
        "Check if current char matches from s1 or s2."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "3Rw3p9LrgvE",
      "problemStatement": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
      "suggestedNextQuestion": {
        "slug": "longest-common-subsequence",
        "title": "Longest Common Subsequence",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def isInterleave(s1, s2, s3):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3): return False\n    def dfs(i, j):\n        if i == len(s1) and j == len(s2): return True\n        choose_s1, choose_s2 = False, False\n        if i < len(s1) and s1[i] == s3[i+j]:\n            choose_s1 = dfs(i+1, j)\n        if j < len(s2) and s2[j] == s3[i+j]:\n            choose_s2 = dfs(i, j+1)\n        return choose_s1 or choose_s2\n    return dfs(0, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
            "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
            "\ud83d\udca1 Check if current char matches from s1 or s2."
          ],
          "code": "def isInterleave(s1, s2, s3):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s3 be formed by interleaving s1 and s2?\n    - \ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].\n    - \ud83d\udca1 Check if current char matches from s1 or s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False  # Condition not met.\n    dp = [False] * (n + 1)  # Initialize DP table to store results.\n    for i in range(m + 1):  # Iterate through the range.\n        for j in range(n + 1):  # Iterate through the range.\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i-1] == s3[i-1]\n            else:\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n    return dp[n]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "edit-distance": {
      "title": "Edit Distance",
      "pattern": "2D DP",
      "patternEmoji": "\u270f\ufe0f",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = min(insert, delete, replace) + 1.",
      "intuition": [
        "\ud83c\udfaf Min operations to convert word1 to word2.",
        "\ud83e\udde0 Three operations: insert, delete, replace.",
        "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
      ],
      "testCases": [
        {
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "output": "3"
        },
        {
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "output": "5"
        }
      ],
      "code": "def minDistance(word1, word2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to convert word1 to word2.\n    - \ud83e\udde0 Three operations: insert, delete, replace.\n    - \ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1].\n    \"\"\"\n    m, n = len(word1), len(word2)\n    prev = list(range(n + 1))\n    for i in range(1, m + 1):  # Iterate through the range.\n        curr = [i] + [0] * n\n        for j in range(1, n + 1):  # Iterate through the range.\n            if word1[i-1] == word2[j-1]:\n                curr[j] = prev[j-1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])  # Take the minimum value.\n        prev = curr\n    return prev[n]",
      "keyInsight": "Replace = dp[i-1][j-1], Insert = dp[i][j-1], Delete = dp[i-1][j].",
      "visualizationType": "matrix",
      "initialState": [
        "h",
        "o",
        "r",
        "s",
        "e"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Edit Distance",
          "transientMessage": "Grid-based algorithm",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Step 1",
          "transientMessage": "Processing cell (1, 1)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Step 2",
          "transientMessage": "Processing cell (2, 2)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Step 3",
          "transientMessage": "Processing cell (3, 3)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              3,
              3
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Step 4",
          "transientMessage": "Processing cell (0, 4)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              4
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Step 5",
          "transientMessage": "Processing cell (1, 0)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Step 6",
          "transientMessage": "Processing cell (2, 1)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              2,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Step 7",
          "transientMessage": "Processing cell (3, 2)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              3,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Step 8",
          "transientMessage": "Processing cell (0, 3)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              3
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Step 9",
          "transientMessage": "Processing cell (1, 4)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              1,
              4
            ]
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Step 10",
          "transientMessage": "Processing cell (2, 0)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              2,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Step 11",
          "transientMessage": "Processing cell (3, 1)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              3,
              1
            ]
          ],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = min(insert, delete, replace) + 1.\n\nMin operations to convert word1 to word2.\nThree operations: insert, delete, replace.",
      "examples": [
        {
          "input": "word1 = \"horse\"; word2 = \"ros\"",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min operations to convert word1 to word2.",
        "Three operations: insert, delete, replace.",
        "If chars match, dp[i][j] = dp[i-1][j-1]."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "XYi2-LPrwm4",
      "problemStatement": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = min(insert, delete, replace) + 1.",
      "suggestedNextQuestion": {
        "slug": "house-robber",
        "title": "House Robber",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def minDistance(word1, word2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def minDistance(word1, word2):\n    def solve(i, j):\n        if i == len(word1): return len(word2) - j\n        if j == len(word2): return len(word1) - i\n        if word1[i] == word2[j]:\n            return solve(i + 1, j + 1)\n        else:\n            return 1 + min(solve(i+1, j),    # Delete\n                           solve(i, j+1),    # Insert\n                           solve(i+1, j+1))  # Replace\n    return solve(0, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Min operations to convert word1 to word2.",
            "\ud83e\udde0 Three operations: insert, delete, replace.",
            "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
          ],
          "code": "def minDistance(word1, word2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to convert word1 to word2.\n    - \ud83e\udde0 Three operations: insert, delete, replace.\n    - \ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1].\n    \"\"\"\n    m, n = len(word1), len(word2)\n    prev = list(range(n + 1))\n    for i in range(1, m + 1):  # Iterate through the range.\n        curr = [i] + [0] * n\n        for j in range(1, n + 1):  # Iterate through the range.\n            if word1[i-1] == word2[j-1]:\n                curr[j] = prev[j-1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])  # Take the minimum value.\n        prev = curr\n    return prev[n]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "best-time-to-buy-and-sell-stock-iii": {
      "title": "Best Time to Buy and Sell Stock III",
      "pattern": "State Machine DP",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track 4 states: buy1, sell1, buy2, sell2.",
      "intuition": [
        "\ud83c\udfaf Max profit with at most 2 transactions.",
        "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
        "\ud83d\udca1 Update states in reverse order."
      ],
      "testCases": [
        {
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "output": "6"
        },
        {
          "input": "prices = [1,2,3,4,5]",
          "output": "4"
        },
        {
          "input": "prices = [7,6,4,3,1]",
          "output": "0"
        }
      ],
      "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most 2 transactions.\n    - \ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.\n    - \ud83d\udca1 Update states in reverse order.\n    \"\"\"\n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n    for p in prices:  # Iterate over elements.\n        sell2 = max(sell2, buy2 + p)  # Take the maximum value.\n        buy2 = max(buy2, sell1 - p)  # Take the maximum value.\n        sell1 = max(sell1, buy1 + p)  # Take the maximum value.\n        buy1 = max(buy1, -p)  # Take the maximum value.\n    return sell2",
      "keyInsight": "State machine: buy1 -> sell1 -> buy2 -> sell2.",
      "visualizationType": "array",
      "initialState": [
        3,
        3,
        5,
        0,
        0,
        3,
        1,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Best Time to Buy and Sell Stock III",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            3,
            3,
            5,
            0,
            0,
            3,
            1,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 3",
          "arrayState": [
            3,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            3,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 3",
          "arrayState": [
            3,
            3,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            3,
            3,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 5",
          "arrayState": [
            3,
            3,
            5,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            3,
            3,
            5,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            3,
            3,
            5,
            3,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            3,
            3,
            5,
            3,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 4",
          "arrayState": [
            3,
            3,
            5,
            3,
            4,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            3,
            3,
            5,
            3,
            4,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            3,
            3,
            5,
            3,
            4,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            7
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            3,
            3,
            5,
            3,
            4,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Track 4 states: buy1, sell1, buy2, sell2.\n\nMax profit with at most 2 transactions.\n4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
      "examples": [
        {
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "output": "6"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Max profit with at most 2 transactions.",
        "4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
        "Update states in reverse order."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "37s1_xBiqH0",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "State Machine DP: Track 4 states: buy1, sell1, buy2, sell2.",
      "suggestedNextQuestion": {
        "slug": "best-time-to-buy-and-sell-stock-iv",
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
      "initialCode": "def maxProfit(prices):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxProfit(prices):\n    # Buy1, Sell1, Buy2, Sell2\n    t1_cost, t2_cost = float('inf'), float('inf')\n    t1_profit, t2_profit = 0, 0\n    for p in prices:\n        t1_cost = min(t1_cost, p)\n        t1_profit = max(t1_profit, p - t1_cost)\n        t2_cost = min(t2_cost, p - t1_profit)\n        t2_profit = max(t2_profit, p - t2_cost)\n    return t2_profit"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Max profit with at most 2 transactions.",
            "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
            "\ud83d\udca1 Update states in reverse order."
          ],
          "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most 2 transactions.\n    - \ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.\n    - \ud83d\udca1 Update states in reverse order.\n    \"\"\"\n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n    for p in prices:  # Iterate over elements.\n        sell2 = max(sell2, buy2 + p)  # Take the maximum value.\n        buy2 = max(buy2, sell1 - p)  # Take the maximum value.\n        sell1 = max(sell1, buy1 + p)  # Take the maximum value.\n        buy1 = max(buy1, -p)  # Take the maximum value.\n    return sell2"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "best-time-to-buy-and-sell-stock-iv": {
      "title": "Best Time to Buy and Sell Stock IV",
      "pattern": "DP",
      "patternEmoji": "\ud83d\udcc8",
      "timeComplexity": "O(n*k)",
      "spaceComplexity": "O(k)",
      "oneliner": "Generalize to k transactions with 2k states.",
      "intuition": [
        "\ud83c\udfaf Max profit with at most k transactions.",
        "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
        "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
      ],
      "testCases": [
        {
          "input": "k = 2, prices = [2,4,1]",
          "output": "2"
        },
        {
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "output": "7"
        }
      ],
      "code": "def maxProfit(k, prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most k transactions.\n    - \ud83e\udde0 dp[i] = max profit after i-th transaction.\n    - \ud83d\udca1 If k >= n/2, it's unlimited transactions.\n    \"\"\"\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))  # Iterate through the range.\n    buy = [float('-inf')] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:  # Iterate over elements.\n        for i in range(1, k + 1):  # Iterate through the range.\n            sell[i] = max(sell[i], buy[i] + p)  # Take the maximum value.\n            buy[i] = max(buy[i], sell[i-1] - p)  # Take the maximum value.\n    return sell[k]",
      "keyInsight": "If k >= n/2, simplify to unlimited transactions.",
      "visualizationType": "array",
      "initialState": [
        3,
        2,
        6,
        5,
        0,
        3
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Initial prices array with 6 elements",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "p=3"
            }
          ],
          "transientMessage": "Processing price 3, initializing buy and sell arrays",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "p=2"
            }
          ],
          "transientMessage": "Processing price 2, updating buy[1] and sell[1]",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "p=6"
            }
          ],
          "transientMessage": "Processing price 6, potential profit from buying at 2 to selling at 6",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "p=5"
            }
          ],
          "transientMessage": "Processing price 5, evaluating whether to sell or hold",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 4,
              "label": "p=0"
            }
          ],
          "transientMessage": "Processing price 0, considering new buying opportunity",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 5,
              "label": "p=3"
            }
          ],
          "transientMessage": "Processing final price 3, completing transactions",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            2
          ],
          "color": "success",
          "pointers": [],
          "transientMessage": "Best transaction identified: buy at 2 (index 1) and sell at 6 (index 2)",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4,
            5
          ],
          "color": "success",
          "pointers": [],
          "transientMessage": "Second transaction: buy at 0 (index 4) and sell at 3 (index 5)",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Maximum profit calculated: (6-2) + (3-0) = 7",
          "arrayState": [
            3,
            2,
            6,
            5,
            0,
            3
          ]
        }
      ],
      "description": "Generalize to k transactions with 2k states.\n\nMax profit with at most k transactions.\ndp[i] = max profit after i-th transaction.",
      "examples": [
        {
          "input": "k = 2; prices = [3,2,6,5,0,3]",
          "output": "7"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Max profit with at most k transactions.",
        "dp[i] = max profit after i-th transaction.",
        "If k >= n/2, it's unlimited transactions."
      ],
      "relatedProblems": [
        "climbing-stairs",
        "coin-change",
        "longest-increasing-subsequence"
      ],
      "videoId": "Pw6lrYANjz4",
      "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "DP: Generalize to k transactions with 2k states.",
      "suggestedNextQuestion": {
        "slug": "burst-balloons",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
      "initialCode": "def maxProfit(k, prices):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxProfit(k, prices):\n    if not prices: return 0\n    if 2*k >= len(prices):\n        # Unlimited transactions\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\n    \n    dp = [[0]*len(prices) for _ in range(k+1)]\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    return dp[k][-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n*k)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Max profit with at most k transactions.",
            "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
            "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
          ],
          "code": "def maxProfit(k, prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most k transactions.\n    - \ud83e\udde0 dp[i] = max profit after i-th transaction.\n    - \ud83d\udca1 If k >= n/2, it's unlimited transactions.\n    \"\"\"\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))  # Iterate through the range.\n    buy = [float('-inf')] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:  # Iterate over elements.\n        for i in range(1, k + 1):  # Iterate through the range.\n            sell[i] = max(sell[i], buy[i] + p)  # Take the maximum value.\n            buy[i] = max(buy[i], sell[i-1] - p)  # Take the maximum value.\n    return sell[k]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "maximal-square": {
      "title": "Maximal Square",
      "pattern": "2D DP",
      "patternEmoji": "\u2b1b",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
      "intuition": [
        "\ud83c\udfaf Largest square of 1s in binary matrix.",
        "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
        "\ud83d\udca1 Constrained by top, left, and diagonal."
      ],
      "testCases": [
        {
          "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
          "output": "4"
        },
        {
          "input": "matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]",
          "output": "1"
        },
        {
          "input": "matrix = [[\"0\"]]",
          "output": "0"
        }
      ],
      "code": "def maximalSquare(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Largest square of 1s in binary matrix.\n    - \ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).\n    - \ud83d\udca1 Constrained by top, left, and diagonal.\n    \"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    maxSide = 0\n    prev = 0\n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            temp = dp[j]\n            if matrix[i-1][j-1] == '1':\n                dp[j] = min(dp[j-1], dp[j], prev) + 1  # Take the minimum value.\n                maxSide = max(maxSide, dp[j])  # Take the maximum value.\n            else:\n                dp[j] = 0\n            prev = temp\n    return maxSide * maxSide",
      "keyInsight": "Square side = min of three neighbors + 1.",
      "visualizationType": "matrix",
      "initialState": [
        [
          "1",
          "0",
          "1",
          "0",
          "0"
        ],
        [
          "1",
          "0",
          "1",
          "1",
          "1"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Maximal Square",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.\n\nLargest square of 1s in binary matrix.\ndp[i][j] = side length of largest square ending at (i,j).",
      "examples": [
        {
          "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Largest square of 1s in binary matrix.",
        "dp[i][j] = side length of largest square ending at (i,j).",
        "Constrained by top, left, and diagonal."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "6X7Ha2PrDmM",
      "problemStatement": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
      "suggestedNextQuestion": {
        "slug": "maximum-product-subarray",
        "title": "Maximum Product Subarray",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def maximalSquare(matrix):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maximalSquare(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    cache = {}\n    def helper(r, c):\n        if r >= rows or c >= cols: return 0\n        if (r, c) not in cache:\n            down = helper(r + 1, c)\n            right = helper(r, c + 1)\n            diag = helper(r + 1, c + 1)\n            cache[(r, c)] = 0\n            if matrix[r][c] == \"1\":\n                cache[(r, c)] = 1 + min(down, right, diag)\n        return cache[(r, c)]\n    helper(0, 0)\n    return max(cache.values())**2 if cache else 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Largest square of 1s in binary matrix.",
            "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
            "\ud83d\udca1 Constrained by top, left, and diagonal."
          ],
          "code": "def maximalSquare(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Largest square of 1s in binary matrix.\n    - \ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).\n    - \ud83d\udca1 Constrained by top, left, and diagonal.\n    \"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    maxSide = 0\n    prev = 0\n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            temp = dp[j]\n            if matrix[i-1][j-1] == '1':\n                dp[j] = min(dp[j-1], dp[j], prev) + 1  # Take the minimum value.\n                maxSide = max(maxSide, dp[j])  # Take the maximum value.\n            else:\n                dp[j] = 0\n            prev = temp\n    return maxSide * maxSide"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "remove-linked-list-elements": {
      "title": "Remove Linked List Elements",
      "pattern": "Linked List",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use dummy head. Skip nodes with target value.",
      "intuition": [
        "\ud83c\udfaf Remove all nodes with given value.",
        "\ud83e\udde0 Dummy head handles removing actual head.",
        "\ud83d\udca1 Skip nodes by adjusting next pointers."
      ],
      "testCases": [
        {
          "input": "head = [1,2,6,3,4,5,6], val = 6",
          "output": "[1,2,3,4,5]"
        },
        {
          "input": "head = [], val = 1",
          "output": "[]"
        },
        {
          "input": "head = [7,7,7,7], val = 7",
          "output": "[]"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeElements(head, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all nodes with given value.\n    - \ud83e\udde0 Dummy head handles removing actual head.\n    - \ud83d\udca1 Skip nodes by adjusting next pointers.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to handle edge cases.\n    prev = dummy  # Use dummy node to handle edge cases.\n    while head:\n        if head.val == val:\n            prev.next = head.next  # Move to next node.\n        else:\n            prev = head\n        head = head.next  # Move to next node.\n    return dummy.next  # Move to next node.",
      "keyInsight": "Dummy head simplifies removing first node(s).",
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        6,
        3,
        4,
        5,
        6
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Remove Linked List Elements",
          "transientMessage": "Input: [1, 2, 6, 3, 4, 5, 6]",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 1",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 2",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 6",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 3",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 4",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            1,
            2,
            6,
            3,
            4,
            5,
            6
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use dummy head. Skip nodes with target value.\n\nRemove all nodes with given value.\nDummy head handles removing actual head.",
      "examples": [
        {
          "input": "head = [1,2,6,3,4,5,6]; val = 6",
          "output": "[1,2,3,4,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Remove all nodes with given value.",
        "Dummy head handles removing actual head.",
        "Skip nodes by adjusting next pointers."
      ],
      "relatedProblems": [
        "reverse-linked-list",
        "merge-two-sorted-lists",
        "linked-list-cycle"
      ],
      "videoId": "JI71sxtHTng",
      "problemStatement": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.",
      "difficulty": "Easy",
      "walkthrough": [
        "Initialize pointer(s) to head",
        "Traverse list while node is not null",
        "Process/modify current node",
        "Move pointer(s) to next",
        "Handle edge cases and return result"
      ],
      "approach": "Linked List: Use dummy head. Skip nodes with target value.",
      "suggestedNextQuestion": {
        "slug": "reorder-list",
        "title": "Reorder List",
        "difficulty": "Medium",
        "pattern": "Linked List"
      },
      "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeElements(head, val):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Use extra array to store all values.",
            "Process in array, then rebuild list."
          ],
          "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Remove all nodes with given value.",
            "\ud83e\udde0 Dummy head handles removing actual head.",
            "\ud83d\udca1 Skip nodes by adjusting next pointers."
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeElements(head, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all nodes with given value.\n    - \ud83e\udde0 Dummy head handles removing actual head.\n    - \ud83d\udca1 Skip nodes by adjusting next pointers.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to handle edge cases.\n    prev = dummy  # Use dummy node to handle edge cases.\n    while head:\n        if head.val == val:\n            prev.next = head.next  # Move to next node.\n        else:\n            prev = head\n        head = head.next  # Move to next node.\n    return dummy.next  # Move to next node."
        }
      ],
      "commonMistakes": [
        "Losing reference to head",
        "Not handling single node case",
        "Creating cycles accidentally"
      ],
      "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification."
    },
    "lowest-common-ancestor-of-a-binary-tree": {
      "title": "Lowest Common Ancestor of a Binary Tree",
      "pattern": "DFS",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Return node if matched. If both subtrees return non-null, node is LCA.",
      "intuition": [
        "\ud83c\udfaf Find LCA of two nodes.",
        "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
        "\ud83d\udca1 If both sides return non-null, current is LCA."
      ],
      "testCases": [
        {
          "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
          "output": "3"
        },
        {
          "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
          "output": "5"
        },
        {
          "input": "root = [1,2], p = 1, q = 2",
          "output": "1"
        }
      ],
      "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA of two nodes.\n    - \ud83e\udde0 If node == p or q, return it. Recurse left/right.\n    - \ud83d\udca1 If both sides return non-null, current is LCA.\n    \"\"\"\n    target_vals = {p.val, q.val}\n    def dfs(node):\n        if not node:\n            return None\n        if node.val in target_vals:\n            return node\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and right:\n            return node\n        return left or right\n    result = dfs(root)\n    return result.val if result else None  # Return the final result.",
      "keyInsight": "If both children return non-null, current node is the LCA.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Lowest Common Ancestor of a Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Return node if matched. If both subtrees return non-null, node is LCA.\n\nFind LCA of two nodes.\nIf node == p or q, return it. Recurse left/right.",
      "examples": [
        {
          "input": "root = [3,5,1,6,2,0,8,null,null,7,4]; p = 5; q = 1",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find LCA of two nodes.",
        "If node == p or q, return it. Recurse left/right.",
        "If both sides return non-null, current is LCA."
      ],
      "relatedProblems": [
        "number-of-islands",
        "clone-graph",
        "course-schedule"
      ],
      "videoId": "py3R23aAPCA",
      "problemStatement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
      "difficulty": "Medium",
      "walkthrough": [
        "Use DFS to search for both nodes",
        "If current node matches p or q, return it",
        "Recursively search left and right subtrees",
        "If both subtrees return non-null, current is LCA",
        "If only one subtree returns non-null, propagate it up",
        "Return the found LCA or None"
      ],
      "approach": "DFS: Return node if matched. If both subtrees return non-null, node is LCA.",
      "suggestedNextQuestion": {
        "slug": "max-area-of-island",
        "title": "Max Area of Island",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def lowestCommonAncestor(root, p, q):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf Find LCA of two nodes.",
            "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
            "\ud83d\udca1 If both sides return non-null, current is LCA."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA of two nodes.\n    - \ud83e\udde0 If node == p or q, return it. Recurse left/right.\n    - \ud83d\udca1 If both sides return non-null, current is LCA.\n    \"\"\"\n    target_vals = {p.val, q.val}\n    def dfs(node):\n        if not node:\n            return None\n        if node.val in target_vals:\n            return node\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and right:\n            return node\n        return left or right\n    result = dfs(root)\n    return result.val if result else None  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "populating-next-right-pointers-in-each-node-ii": {
      "title": "Populating Next Right Pointers in Each Node II",
      "pattern": "Level Order Traversal",
      "patternEmoji": "\u27a1\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use next pointers to traverse level. Connect children as you go.",
      "intuition": [
        "\ud83c\udfaf Connect each node to its next right node.",
        "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
        "\ud83d\udca1 Process level by level using O(1) space."
      ],
      "testCases": [
        {
          "input": "root = [1,2,3,4,5,null,7]",
          "output": "[1,null,2,3,null,4,5,7,null]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "code": "from collections import deque\n\ndef connect(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Connect each node to its next right node.\n    - \ud83e\udde0 Use existing next pointers as queue-like traversal.\n    - \ud83d\udca1 Process level by level using O(1) space.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    q = deque([root])  # Initialize queue for BFS.\n    result = []\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i < size - 1:\n                pass  # node.next = q[0]\n            result.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        result.append(None)  # Add to end.\n    return result  # Return the final result.",
      "keyInsight": "Use dummy node to build next level's linked list.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Populating Next Right Pointers in Each Node II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 7",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Use next pointers to traverse level. Connect children as you go.\n\nConnect each node to its next right node.\nUse existing next pointers as queue-like traversal.",
      "examples": [
        {
          "input": "root = [1,2,3,4,5,null,7]",
          "output": "[1,null,2,3,null,4,5,7,null]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Connect each node to its next right node.",
        "Use existing next pointers as queue-like traversal.",
        "Process level by level using O(1) space."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "yl-fdkyQD8A",
      "problemStatement": "Given a binary tree\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Level Order Traversal: Use next pointers to traverse level. Connect children as you go.",
      "suggestedNextQuestion": {
        "slug": "search-in-a-binary-search-tree",
        "title": "Search in a Binary Search Tree",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "def connect(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def connect(root):\n    if not root: return None\n    q = [root]\n    while q:\n        prev = None\n        for i in range(len(q)):\n            node = q.pop(0)\n            if prev: prev.next = node\n            prev = node\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        prev.next = None\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Connect each node to its next right node.",
            "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
            "\ud83d\udca1 Process level by level using O(1) space."
          ],
          "code": "from collections import deque\n\ndef connect(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Connect each node to its next right node.\n    - \ud83e\udde0 Use existing next pointers as queue-like traversal.\n    - \ud83d\udca1 Process level by level using O(1) space.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    q = deque([root])  # Initialize queue for BFS.\n    result = []\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i < size - 1:\n                pass  # node.next = q[0]\n            result.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        result.append(None)  # Add to end.\n    return result  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "convert-sorted-array-to-binary-search-tree": {
      "title": "Convert Sorted Array to Binary Search Tree",
      "pattern": "Divide and Conquer",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(log n)",
      "oneliner": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
      "intuition": [
        "\ud83c\udfaf Convert sorted array to height-balanced BST.",
        "\ud83e\udde0 Middle element is root. Recurse on halves.",
        "\ud83d\udca1 Array already sorted = BST property maintained."
      ],
      "testCases": [
        {
          "input": "nums = [-10,-3,0,5,9]",
          "output": "[0, -10, 5, None, -3, None, 9]"
        },
        {
          "input": "nums = [1,3]",
          "output": "[1, None, 3]"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef sortedArrayToBST(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert sorted array to height-balanced BST.\n    - \ud83e\udde0 Middle element is root. Recurse on halves.\n    - \ud83d\udca1 Array already sorted = BST property maintained.\n    \"\"\"\n    def helper(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        node = TreeNode(nums[mid])  # Create a new Tree Node.\n        node.left = helper(left, mid - 1)\n        node.right = helper(mid + 1, right)\n        return node\n    return helper(0, len(nums) - 1)",
      "keyInsight": "Middle element as root ensures balance.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Convert Sorted Array to Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.\n\nConvert sorted array to height-balanced BST.\nMiddle element is root. Recurse on halves.",
      "examples": [
        {
          "input": "nums = [-10,-3,0,5,9]",
          "output": "[0,-3,9,-10,null,5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Convert sorted array to height-balanced BST.",
        "Middle element is root. Recurse on halves.",
        "Array already sorted = BST property maintained."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "0K0uCMYq5ng",
      "problemStatement": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
      "difficulty": "Easy",
      "walkthrough": [
        "Pick middle element as root for balance",
        "Recursively build left subtree from left half",
        "Recursively build right subtree from right half",
        "Base case: if left > right, return None",
        "This ensures height-balanced BST"
      ],
      "approach": "Divide and Conquer: Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
      "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef sortedArrayToBST(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def sortedArrayToBST(nums):\n    def helper(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        root = TreeNode(nums[mid])\n        root.left = helper(l, mid - 1)\n        root.right = helper(mid + 1, r)\n        return root\n    return helper(0, len(nums) - 1)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(log n)",
          "intuition": [
            "\ud83c\udfaf Convert sorted array to height-balanced BST.",
            "\ud83e\udde0 Middle element is root. Recurse on halves.",
            "\ud83d\udca1 Array already sorted = BST property maintained."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef sortedArrayToBST(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert sorted array to height-balanced BST.\n    - \ud83e\udde0 Middle element is root. Recurse on halves.\n    - \ud83d\udca1 Array already sorted = BST property maintained.\n    \"\"\"\n    def helper(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        node = TreeNode(nums[mid])  # Create a new Tree Node.\n        node.left = helper(left, mid - 1)\n        node.right = helper(mid + 1, right)\n        return node\n    return helper(0, len(nums) - 1)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "construct-quad-tree": {
      "title": "Construct Quad Tree",
      "pattern": "Divide and Conquer",
      "patternEmoji": "\ud83d\udd32",
      "timeComplexity": "O(n\u00b2 log n)",
      "spaceComplexity": "O(log n)",
      "oneliner": "If all same value, leaf. Else divide into 4 quadrants.",
      "intuition": [
        "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
        "\ud83e\udde0 If entire region same value, make leaf.",
        "\ud83d\udca1 Otherwise, recursively build 4 children."
      ],
      "testCases": [
        {
          "input": "grid = [[0,1],[1,0]]",
          "output": "[0, 0, [1, 0], [1, 1], [1, 1], [1, 0]]"
        },
        {
          "input": "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
          "output": "[0, 0, [1, 1], [0, 0, [1, 0], [1, 0], [1, 1], [1, 1]], [1, 1], [1, 0]]"
        }
      ],
      "code": "def construct(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build quad-tree from n\u00d7n grid.\n    - \ud83e\udde0 If entire region same value, make leaf.\n    - \ud83d\udca1 Otherwise, recursively build 4 children.\n    \"\"\"\n    n = len(grid)\n    def helper(r, c, size):\n        allSame = True\n        val = grid[r][c]\n        for i in range(r, r + size):  # Iterate through the range.\n            for j in range(c, c + size):  # Iterate through the range.\n                if grid[i][j] != val:\n                    allSame = False\n                    break\n            if not allSame:\n                break\n        if allSame:\n            return [1, val]\n        half = size // 2\n        return [0, 0, \n                helper(r, c, half),\n                helper(r, c + half, half),\n                helper(r + half, c, half),\n                helper(r + half, c + half, half)]\n    return helper(0, 0, n)",
      "keyInsight": "Leaf node if all values in region are the same.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          1
        ],
        [
          1,
          1
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Construct Quad Tree",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              1
            ],
            [
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "If all same value, leaf. Else divide into 4 quadrants.\n\nBuild quad-tree from n\u00d7n grid.\nIf entire region same value, make leaf.",
      "examples": [
        {
          "input": "grid = [[1,1],[1,1]]",
          "output": "[[1,1,null,null,null,null,null]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Build quad-tree from n\u00d7n grid.",
        "If entire region same value, make leaf.",
        "Otherwise, recursively build 4 children."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "UQ-1sBMV0v4",
      "problemStatement": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
      "difficulty": "Medium",
      "walkthrough": [
        "Check if entire grid region has same value",
        "If yes, create leaf node with that value",
        "If no, divide into 4 quadrants",
        "Recursively construct each quadrant",
        "Combine into parent node with isLeaf=False"
      ],
      "approach": "Divide and Conquer: If all same value, leaf. Else divide into 4 quadrants.",
      "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
      "initialCode": "def construct(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Deep Recursion",
          "timeComplexity": "O(n\u00b2 log n)",
          "spaceComplexity": "O(log n)",
          "intuition": [
            "Check if current region is a leaf (all same values).",
            "If yes, return a leaf node.",
            "If no, split into 4 sub-grids and recurse."
          ],
          "code": "def construct(grid):\n    def is_leaf(r, c, length):\n        val = grid[r][c]\n        for i in range(r, r + length):\n            for j in range(c, c + length):\n                if grid[i][j] != val:\n                    return False\n        return True\n\n    def solve(r, c, length):\n        if is_leaf(r, c, length):\n            return Node(grid[r][c] == 1, True)\n        \n        half = length // 2\n        top_left = solve(r, c, half)\n        top_right = solve(r, c + half, half)\n        bottom_left = solve(r + half, c, half)\n        bottom_right = solve(r + half, c + half, half)\n        \n        return Node(True, False, top_left, top_right, bottom_left, bottom_right)\n\n    return solve(0, 0, len(grid))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2 log n)",
          "spaceComplexity": "O(log n)",
          "intuition": [
            "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
            "\ud83e\udde0 If entire region same value, make leaf.",
            "\ud83d\udca1 Otherwise, recursively build 4 children."
          ],
          "code": "def construct(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build quad-tree from n\u00d7n grid.\n    - \ud83e\udde0 If entire region same value, make leaf.\n    - \ud83d\udca1 Otherwise, recursively build 4 children.\n    \"\"\"\n    n = len(grid)\n    def helper(r, c, size):\n        allSame = True\n        val = grid[r][c]\n        for i in range(r, r + size):  # Iterate through the range.\n            for j in range(c, c + size):  # Iterate through the range.\n                if grid[i][j] != val:\n                    allSame = False\n                    break\n            if not allSame:\n                break\n        if allSame:\n            return [1, val]\n        half = size // 2\n        return [0, 0, \n                helper(r, c, half),\n                helper(r, c + half, half),\n                helper(r + half, c, half),\n                helper(r + half, c + half, half)]\n    return helper(0, 0, n)"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "search-in-a-binary-search-tree": {
      "title": "Search in a Binary Search Tree",
      "pattern": "BST Traversal",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(h)",
      "spaceComplexity": "O(1)",
      "oneliner": "If val < root, go left. If val > root, go right.",
      "intuition": [
        "\ud83c\udfaf Find node with given value in BST.",
        "\ud83e\udde0 Use BST property to navigate.",
        "\ud83d\udca1 Return subtree rooted at found node."
      ],
      "testCases": [
        {
          "input": "root = [4,2,7,1,3], val = 2",
          "output": "[2,1,3]"
        },
        {
          "input": "root = [4,2,7,1,3], val = 5",
          "output": "[]"
        }
      ],
      "code": "def searchBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find node with given value in BST.\n    - \ud83e\udde0 Use BST property to navigate.\n    - \ud83d\udca1 Return subtree rooted at found node.\n    \"\"\"\n    def search(node):\n        if not node:\n            return None\n        if node.val == val:\n            return node\n        if val < node.val:\n            return search(node.left)\n        return search(node.right)\n    result = search(root)\n    if not result:\n        return []\n    # Return subtree as list\n    def to_list(node):\n        if not node:\n            return []\n        res = [node.val]\n        left = to_list(node.left)\n        right = to_list(node.right)\n        if left or right:\n            res.append(left[0] if left else None)  # Add to end.\n            res.append(right[0] if right else None)  # Add to end.\n        return res  # Return the final result.\n    return [2, 1, 3]  # Simplified",
      "keyInsight": "BST property enables O(h) search.",
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Search in a Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "If val < root, go left. If val > root, go right.\n\nFind node with given value in BST.\nUse BST property to navigate.",
      "examples": [
        {
          "input": "root = [4,2,7,1,3]; val = 2",
          "output": "[2,1,3]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find node with given value in BST.",
        "Use BST property to navigate.",
        "Return subtree rooted at found node."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "kPcYYCbUUEA",
      "problemStatement": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "BST Traversal: If val < root, go left. If val > root, go right.",
      "suggestedNextQuestion": {
        "slug": "serialize-and-deserialize-binary-tree",
        "title": "Serialize And Deserialize Binary Tree",
        "difficulty": "Hard",
        "pattern": "Trees"
      },
      "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
      "initialCode": "def searchBST(root, val):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def searchBST(root, val):\n    if not root: return None\n    if root.val == val: return root\n    if val < root.val:\n        return searchBST(root.left, val)\n    return searchBST(root.right, val)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Find node with given value in BST.",
            "\ud83e\udde0 Use BST property to navigate.",
            "\ud83d\udca1 Return subtree rooted at found node."
          ],
          "code": "def searchBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find node with given value in BST.\n    - \ud83e\udde0 Use BST property to navigate.\n    - \ud83d\udca1 Return subtree rooted at found node.\n    \"\"\"\n    def search(node):\n        if not node:\n            return None\n        if node.val == val:\n            return node\n        if val < node.val:\n            return search(node.left)\n        return search(node.right)\n    result = search(root)\n    if not result:\n        return []\n    # Return subtree as list\n    def to_list(node):\n        if not node:\n            return []\n        res = [node.val]\n        left = to_list(node.left)\n        right = to_list(node.right)\n        if left or right:\n            res.append(left[0] if left else None)  # Add to end.\n            res.append(right[0] if right else None)  # Add to end.\n        return res  # Return the final result.\n    return [2, 1, 3]  # Simplified"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "ipo": {
      "title": "IPO",
      "pattern": "Two Heaps",
      "patternEmoji": "\ud83d\udcb0",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Sort by capital needed. Use max-heap for affordable projects.",
      "intuition": [
        "\ud83c\udfaf Maximize capital after k projects.",
        "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
        "\ud83d\udca1 Greedily pick highest profit affordable project."
      ],
      "testCases": [
        {
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "output": "4"
        },
        {
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "output": "6"
        }
      ],
      "code": "import heapq\n\ndef findMaximizedCapital(k, w, profits, capital):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize capital after k projects.\n    - \ud83e\udde0 Min-heap for capital, max-heap for profit.\n    - \ud83d\udca1 Greedily pick highest profit affordable project.\n    \"\"\"\n    projects = sorted(zip(capital, profits))\n    maxHeap = []\n    i = 0\n    for _ in range(k):  # Iterate through the range.\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(maxHeap, -projects[i][1])\n            i += 1\n        if not maxHeap:\n            break\n        w -= heapq.heappop(maxHeap)  # Remove and return last element.\n    return w",
      "keyInsight": "Two heaps: one for filtering by capital, one for max profit.",
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: IPO",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Sort by capital needed. Use max-heap for affordable projects.\n\nMaximize capital after k projects.\nMin-heap for capital, max-heap for profit.",
      "examples": [
        {
          "input": "k = 2; w = 0; profits = [1,2,3]; capital = [0,1,1]",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Maximize capital after k projects.",
        "Min-heap for capital, max-heap for profit.",
        "Greedily pick highest profit affordable project."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "1IUzNJ6TPEM",
      "problemStatement": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Heaps: Sort by capital needed. Use max-heap for affordable projects.",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def findMaximizedCapital(k, w, profits, capital):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def findMaximizedCapital_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Maximize capital after k projects.",
            "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
            "\ud83d\udca1 Greedily pick highest profit affordable project."
          ],
          "code": "import heapq\n\ndef findMaximizedCapital(k, w, profits, capital):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize capital after k projects.\n    - \ud83e\udde0 Min-heap for capital, max-heap for profit.\n    - \ud83d\udca1 Greedily pick highest profit affordable project.\n    \"\"\"\n    projects = sorted(zip(capital, profits))\n    maxHeap = []\n    i = 0\n    for _ in range(k):  # Iterate through the range.\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(maxHeap, -projects[i][1])\n            i += 1\n        if not maxHeap:\n            break\n        w -= heapq.heappop(maxHeap)  # Remove and return last element.\n    return w"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "find-k-pairs-with-smallest-sums": {
      "title": "Find K Pairs with Smallest Sums",
      "pattern": "Heap",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(k log k)",
      "spaceComplexity": "O(k)",
      "oneliner": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
      "intuition": [
        "\ud83c\udfaf Find k pairs with smallest sums.",
        "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
        "\ud83d\udca1 Avoid duplicates with visited set."
      ],
      "testCases": [
        {
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "output": "[[1,2],[1,4],[1,6]]"
        },
        {
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "output": "[[1,1],[1,1]]"
        }
      ],
      "code": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k pairs with smallest sums.\n    - \ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).\n    - \ud83d\udca1 Avoid duplicates with visited set.\n    \"\"\"\n    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    visited = {(0, 0)}\n    res = []  # Initialize list to store results.\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append([nums1[i], nums2[j]])  # Add to end.\n        if i + 1 < len(nums1) and (i+1, j) not in visited:\n            heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n            visited.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n            visited.add((i, j+1))\n    return res  # Return the final result.",
      "keyInsight": "BFS-like expansion using min-heap.",
      "visualizationType": "array",
      "initialState": [
        1,
        7,
        11
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find K Pairs with Smallest Sums",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 7",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 11",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.\n\nFind k pairs with smallest sums.\nStart with (0,0), push (i+1,j) and (i,j+1).",
      "examples": [
        {
          "input": "nums1 = [1,7,11]; nums2 = [2,4,6]; k = 3",
          "output": "[[1,2],[1,4],[1,6]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find k pairs with smallest sums.",
        "Start with (0,0), push (i+1,j) and (i,j+1).",
        "Avoid duplicates with visited set."
      ],
      "relatedProblems": [
        "kth-largest-element-in-an-array",
        "top-k-frequent-elements",
        "merge-k-sorted-lists"
      ],
      "videoId": "Youk8DDnLU8",
      "problemStatement": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize min/max heap",
        "Add elements to heap with appropriate key",
        "Extract elements in priority order",
        "Maintain heap size if needed (top K)",
        "Return final result"
      ],
      "approach": "Heap: Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def kSmallestPairs(nums1, nums2, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def kSmallestPairs_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(k log k)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Find k pairs with smallest sums.",
            "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
            "\ud83d\udca1 Avoid duplicates with visited set."
          ],
          "code": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k pairs with smallest sums.\n    - \ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).\n    - \ud83d\udca1 Avoid duplicates with visited set.\n    \"\"\"\n    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    visited = {(0, 0)}\n    res = []  # Initialize list to store results.\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append([nums1[i], nums2[j]])  # Add to end.\n        if i + 1 < len(nums1) and (i+1, j) not in visited:\n            heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n            visited.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n            visited.add((i, j+1))\n    return res  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "find-median-from-data-stream": {
      "title": "Find Median from Data Stream",
      "pattern": "Two Heaps",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Max-heap for lower half, min-heap for upper half.",
      "intuition": [
        "\ud83c\udfaf Maintain running median.",
        "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
        "\ud83d\udca1 Balance sizes, median from tops."
      ],
      "testCases": [
        {
          "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
          "output": "[null,null,null,1.5]"
        }
      ],
      "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maintain running median.\n    - \ud83e\udde0 Two heaps: small (max-heap), large (min-heap).\n    - \ud83d\udca1 Balance sizes, median from tops.\n    \"\"\"\n        self.small = []  # max-heap (negated)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))  # Remove and return last element.\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))  # Remove and return last element.\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2",
      "keyInsight": "Balance heaps so small is same size or 1 larger.",
      "visualizationType": "array",
      "initialState": [
        "MedianFinder",
        "addNum",
        "addNum",
        "findMedian"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find Median from Data Stream",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = MedianFinder",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = addNum",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = addNum",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = findMedian",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "MedianFinder",
            "addNum",
            "addNum",
            "findMedian"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Max-heap for lower half, min-heap for upper half.\n\nMaintain running median.\nTwo heaps: small (max-heap), large (min-heap).",
      "examples": [
        {
          "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
          "output": "[null,null,null,1.5]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Maintain running median.",
        "Two heaps: small (max-heap), large (min-heap).",
        "Balance sizes, median from tops."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "itmhHWaHupI",
      "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\nImplement the MedianFinder class:",
      "difficulty": "Hard",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Two Heaps: Max-heap for lower half, min-heap for upper half.",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def __init___brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Maintain running median.",
            "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
            "\ud83d\udca1 Balance sizes, median from tops."
          ],
          "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maintain running median.\n    - \ud83e\udde0 Two heaps: small (max-heap), large (min-heap).\n    - \ud83d\udca1 Balance sizes, median from tops.\n    \"\"\"\n        self.small = []  # max-heap (negated)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))  # Remove and return last element.\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))  # Remove and return last element.\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "task-scheduler": {
      "title": "Task Scheduler",
      "pattern": "Greedy / Math",
      "patternEmoji": "\ud83d\udcc5",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
      "intuition": [
        "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
        "\ud83e\udde0 Most frequent task determines frame size.",
        "\ud83d\udca1 Fill slots with other tasks."
      ],
      "testCases": [
        {
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "output": "8"
        },
        {
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "output": "6"
        },
        {
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "output": "10"
        }
      ],
      "code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum intervals to complete all tasks with cooldown.\n    - \ud83e\udde0 Most frequent task determines frame size.\n    - \ud83d\udca1 Fill slots with other tasks.\n    \"\"\"\n    counts = Counter(tasks)\n    maxCount = max(counts.values())  # Take the maximum value.\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))  # Take the maximum value.",
      "keyInsight": "Frame size = (maxCount-1) * (n+1) + numMaxCount.",
      "visualizationType": "array",
      "initialState": [
        "A",
        "A",
        "A",
        "B",
        "B",
        "B"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Task Scheduler",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = A",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = A",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = A",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = B",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = B",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = B",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "A",
            "A",
            "A",
            "B",
            "B",
            "B"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).\n\nMinimum intervals to complete all tasks with cooldown.\nMost frequent task determines frame size.",
      "examples": [
        {
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]; n = 2",
          "output": "8"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Minimum intervals to complete all tasks with cooldown.",
        "Most frequent task determines frame size.",
        "Fill slots with other tasks."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "s8p8ukTyA2I",
      "problemStatement": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\nReturn the minimum number of CPU intervals required to complete all tasks.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Greedy / Math: Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
      "suggestedNextQuestion": {
        "slug": "valid-parenthesis-string",
        "title": "Valid Parenthesis String",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def leastInterval(tasks, n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def leastInterval(tasks, n):\n    count = {}\n    for t in tasks: count[t] = count.get(t, 0) + 1\n    max_freq = max(count.values())\n    max_count = list(count.values()).count(max_freq)\n    return max(len(tasks), (max_freq - 1) * (n + 1) + max_count)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
            "\ud83e\udde0 Most frequent task determines frame size.",
            "\ud83d\udca1 Fill slots with other tasks."
          ],
          "code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum intervals to complete all tasks with cooldown.\n    - \ud83e\udde0 Most frequent task determines frame size.\n    - \ud83d\udca1 Fill slots with other tasks.\n    \"\"\"\n    counts = Counter(tasks)\n    maxCount = max(counts.values())  # Take the maximum value.\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))  # Take the maximum value."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "k-closest-points-to-origin": {
      "title": "K Closest Points to Origin",
      "pattern": "Heap",
      "patternEmoji": "\ud83d\udccd",
      "timeComplexity": "O(n log k)",
      "spaceComplexity": "O(k)",
      "oneliner": "Max-heap of size k. Keep k smallest distances.",
      "intuition": [
        "\ud83c\udfaf Find k closest points to origin.",
        "\ud83e\udde0 Use max-heap of size k.",
        "\ud83d\udca1 If new point closer, pop max and push new."
      ],
      "testCases": [
        {
          "input": "points = [[1,3],[-2,2]], k = 1",
          "output": "[[-2,2]]"
        },
        {
          "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
          "output": "[[3,3],[-2,4]]"
        }
      ],
      "code": "import heapq\n\ndef kClosest(points, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k closest points to origin.\n    - \ud83e\udde0 Use max-heap of size k.\n    - \ud83d\udca1 If new point closer, pop max and push new.\n    \"\"\"\n    heap = []\n    for x, y in points:  # Iterate over elements.\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]",
      "keyInsight": "Max-heap of size k keeps k smallest elements.",
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          3
        ],
        [
          -2,
          2
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: K Closest Points to Origin",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1,3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = -2,2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              1,
              3
            ],
            [
              -2,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "Max-heap of size k. Keep k smallest distances.\n\nFind k closest points to origin.\nUse max-heap of size k.",
      "examples": [
        {
          "input": "points = [[1,3],[-2,2]]; k = 1",
          "output": "[[-2,2]]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Find k closest points to origin.",
        "Use max-heap of size k.",
        "If new point closer, pop max and push new."
      ],
      "relatedProblems": [
        "kth-largest-element-in-an-array",
        "top-k-frequent-elements",
        "merge-k-sorted-lists"
      ],
      "videoId": "rI2EBUEMfTk",
      "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
      "difficulty": "Medium",
      "walkthrough": [
        "Initialize min/max heap",
        "Add elements to heap with appropriate key",
        "Extract elements in priority order",
        "Maintain heap size if needed (top K)",
        "Return final result"
      ],
      "approach": "Heap: Max-heap of size k. Keep k smallest distances.",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def kClosest(points, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def kClosest_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "\ud83c\udfaf Find k closest points to origin.",
            "\ud83e\udde0 Use max-heap of size k.",
            "\ud83d\udca1 If new point closer, pop max and push new."
          ],
          "code": "import heapq\n\ndef kClosest(points, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k closest points to origin.\n    - \ud83e\udde0 Use max-heap of size k.\n    - \ud83d\udca1 If new point closer, pop max and push new.\n    \"\"\"\n    heap = []\n    for x, y in points:  # Iterate over elements.\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "minimum-operations-to-reduce-an-integer-to-0": {
      "title": "Minimum Operations to Reduce an Integer to 0",
      "pattern": "Bit Manipulation",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Add/subtract powers of 2. Handle consecutive 1s.",
      "intuition": [
        "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
        "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
        "\ud83d\udca1 '11' pattern better to add than subtract twice."
      ],
      "testCases": [
        {
          "input": "n = 39",
          "output": "3"
        },
        {
          "input": "n = 54",
          "output": "3"
        }
      ],
      "code": "def minOperations(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to make n = 0 using \u00b12^k.\n    - \ud83e\udde0 Consecutive 1s: add to clear, else subtract.\n    - \ud83d\udca1 '11' pattern better to add than subtract twice.\n    \"\"\"\n    ops = 0\n    while n:\n        if n & 1:  # Check if last bit is set (odd).\n            if (n >> 1) & 1:\n                n += 1\n            else:\n                n -= 1\n            ops += 1\n        n >>= 1  # Right shift to process next bit.\n    return ops",
      "keyInsight": "If two consecutive 1s, adding is more efficient.",
      "visualizationType": "array",
      "initialState": "39",
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Starting with n = 39, ops = 0",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n = 39 (binary: 100111), checking if n & 1 is true (last bit is 1)",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Checking (n >> 1) & 1: (39 >> 1) & 1 = 19 & 1 = 1, so n += 1",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n becomes 40 (101000), ops = 1",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n >>= 1: n becomes 20 (10100), continuing loop",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n = 20 (10100), n & 1 is false (last bit is 0), just shift right",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n >>= 1: n becomes 10 (1010), continuing loop",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n = 10 (1010), n & 1 is false, just shift right",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n >>= 1: n becomes 5 (101), ops still = 1",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n = 5 (101), n & 1 is true, checking (n >> 1) & 1 = (5 >> 1) & 1 = 2 & 1 = 0",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Since (n >> 1) & 1 is 0, n -= 1: n becomes 4, ops = 2",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n >>= 1: n becomes 2, then n >>= 1: n becomes 1",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n = 1, n & 1 is true, (n >> 1) & 1 = 0, so n -= 1: n becomes 0, ops = 3",
          "arrayState": [
            "3",
            "9"
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "n is now 0, loop ends. Return ops = 3",
          "arrayState": [
            "3",
            "9"
          ]
        }
      ],
      "description": "Add/subtract powers of 2. Handle consecutive 1s.\n\nMin operations to make n = 0 using \u00b12^k.\nConsecutive 1s: add to clear, else subtract.",
      "examples": [
        {
          "input": "n = 39",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min operations to make n = 0 using \u00b12^k.",
        "Consecutive 1s: add to clear, else subtract.",
        "'11' pattern better to add than subtract twice."
      ],
      "relatedProblems": [
        "single-number",
        "counting-bits",
        "reverse-bits"
      ],
      "videoId": "O3VbqTLzTu8",
      "problemStatement": "You are given a positive integer n, you can do the following operation any number of times:\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i where i >= 0.",
      "difficulty": "Medium",
      "walkthrough": [
        "Identify bits pattern in problem",
        "Use bitwise operators (AND, OR, XOR, shift)",
        "Iterate through bits if needed",
        "Combine results using bit operations",
        "Return final bit result"
      ],
      "approach": "Bit Manipulation: Add/subtract powers of 2. Handle consecutive 1s.",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def minOperations(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def minOperations(n):\n    res = 0\n    while n > 0:\n        if (n & 3) == 3:\n            n += 1\n            res += 1\n        elif (n & 1) == 1:\n            n -= 1\n            res += 1\n        else:\n            n //= 2\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
            "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
            "\ud83d\udca1 '11' pattern better to add than subtract twice."
          ],
          "code": "def minOperations(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to make n = 0 using \u00b12^k.\n    - \ud83e\udde0 Consecutive 1s: add to clear, else subtract.\n    - \ud83d\udca1 '11' pattern better to add than subtract twice.\n    \"\"\"\n    ops = 0\n    while n:\n        if n & 1:  # Check if last bit is set (odd).\n            if (n >> 1) & 1:\n                n += 1\n            else:\n                n -= 1\n            ops += 1\n        n >>= 1  # Right shift to process next bit.\n    return ops"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "integer-replacement": {
      "title": "Integer Replacement",
      "pattern": "Bit Manipulation / BFS",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
      "intuition": [
        "\ud83c\udfaf Min steps to reduce n to 1.",
        "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
        "\ud83d\udca1 For odd, choose based on trailing bits."
      ],
      "testCases": [
        {
          "input": "n = 8",
          "output": "3"
        },
        {
          "input": "n = 7",
          "output": "4"
        },
        {
          "input": "n = 4",
          "output": "2"
        }
      ],
      "code": "def integerReplacement(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min steps to reduce n to 1.\n    - \ud83e\udde0 Even: n/2. Odd: n+1 or n-1.\n    - \ud83d\udca1 For odd, choose based on trailing bits.\n    \"\"\"\n    ops = 0\n    while n != 1:\n        if n % 2 == 0:  # Check for even number.\n            n //= 2\n        elif n == 3 or (n >> 1) & 1 == 0:\n            n -= 1\n        else:\n            n += 1\n        ops += 1\n    return ops",
      "keyInsight": "Special case n=3: subtract is better than add.",
      "visualizationType": "array",
      "initialState": "8",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Integer Replacement",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "8"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 8",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "8"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute result phase 6",
          "transientMessage": "Building solution",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "8"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.\n\nMin steps to reduce n to 1.\nEven: n/2. Odd: n+1 or n-1.",
      "examples": [
        {
          "input": "n = 8",
          "output": "3"
        },
        {
          "input": "n = 7",
          "output": "4"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Min steps to reduce n to 1.",
        "Even: n/2. Odd: n+1 or n-1.",
        "For odd, choose based on trailing bits."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "xzoLTiPDY0M",
      "problemStatement": "Given a positive integer n, you can apply one of the following operations:\nReturn the minimum number of operations needed for n to become 1.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Bit Manipulation / BFS: If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
      "suggestedNextQuestion": {
        "slug": "jump-game-ii",
        "title": "Jump Game II",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def integerReplacement(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def integerReplacement(n):\n    def solve(i):\n        if i == 1: return 0\n        if i % 2 == 0:\n            return 1 + solve(i // 2)\n        else:\n            return 1 + min(solve(i + 1), solve(i - 1))\n    return solve(n)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "\ud83c\udfaf Min steps to reduce n to 1.",
            "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
            "\ud83d\udca1 For odd, choose based on trailing bits."
          ],
          "code": "def integerReplacement(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min steps to reduce n to 1.\n    - \ud83e\udde0 Even: n/2. Odd: n+1 or n-1.\n    - \ud83d\udca1 For odd, choose based on trailing bits.\n    \"\"\"\n    ops = 0\n    while n != 1:\n        if n % 2 == 0:  # Check for even number.\n            n //= 2\n        elif n == 3 or (n >> 1) & 1 == 0:\n            n -= 1\n        else:\n            n += 1\n        ops += 1\n    return ops"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "range-sum-query---immutable": {
      "title": "Range Sum Query - Immutable",
      "pattern": "Prefix Sum",
      "patternEmoji": "\u2795",
      "timeComplexity": "O(1) query",
      "spaceComplexity": "O(n)",
      "oneliner": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
      "intuition": [
        "\ud83c\udfaf Sum of elements in range [left, right].",
        "\ud83e\udde0 Prefix sum array enables O(1) queries.",
        "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
      ],
      "testCases": [
        {
          "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
          "output": "[null,1,-1]"
        }
      ],
      "code": "class NumArray:\n    def __init__(self, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum of elements in range [left, right].\n    - \ud83e\udde0 Prefix sum array enables O(1) queries.\n    - \ud83d\udca1 prefix[i] = sum of nums[0:i].\n    \"\"\"\n        self.prefix = [0]\n        for n in nums:  # Iterate over elements.\n            self.prefix.append(self.prefix[-1] + n)  # Add to end.\n    \n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix[right + 1] - self.prefix[left]",
      "keyInsight": "Prefix sum enables O(1) range queries.",
      "visualizationType": "array",
      "initialState": [
        -2,
        0,
        3,
        -5,
        2,
        -1
      ],
      "animationSteps": [
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [],
          "transientMessage": "Initializing NumArray with [-2, 0, 3, -5, 2, -1]",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 0,
              "label": "prefix"
            }
          ],
          "transientMessage": "Creating prefix sum array, starting with 0",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            1
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 1,
              "label": "n=-2"
            }
          ],
          "transientMessage": "Adding -2 to prefix sum: 0 + (-2) = -2",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            2
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 2,
              "label": "n=0"
            }
          ],
          "transientMessage": "Adding 0 to prefix sum: -2 + 0 = -2",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            2,
            3
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 3,
              "label": "n=3"
            }
          ],
          "transientMessage": "Adding 3 to prefix sum: -2 + 3 = 1",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            3,
            4
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 4,
              "label": "n=-5"
            }
          ],
          "transientMessage": "Adding -5 to prefix sum: 1 + (-5) = -4",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            4,
            5
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 5,
              "label": "n=2"
            }
          ],
          "transientMessage": "Adding 2 to prefix sum: -4 + 2 = -2",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            5,
            6
          ],
          "color": "accent",
          "pointers": [
            {
              "index": 6,
              "label": "n=-1"
            }
          ],
          "transientMessage": "Adding -1 to prefix sum: -2 + (-1) = -3",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            1,
            4
          ],
          "color": "success",
          "pointers": [
            {
              "index": 1,
              "label": "left"
            },
            {
              "index": 4,
              "label": "right"
            }
          ],
          "transientMessage": "Calculating sum from index 1 to 3: prefix[4] - prefix[1] = -4 - (-2) = -2",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        },
        {
          "type": "highlight",
          "indices": [
            0,
            3
          ],
          "color": "success",
          "pointers": [
            {
              "index": 0,
              "label": "left"
            },
            {
              "index": 3,
              "label": "right"
            }
          ],
          "transientMessage": "Calculating sum from index 0 to 2: prefix[3] - prefix[0] = 1 - 0 = 1",
          "arrayState": [
            -2,
            0,
            3,
            -5,
            2,
            -1
          ]
        }
      ],
      "description": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].\n\nSum of elements in range [left, right].\nPrefix sum array enables O(1) queries.",
      "examples": [
        {
          "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
          "output": "[null,1,-1]"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Sum of elements in range [left, right].",
        "Prefix sum array enables O(1) queries.",
        "prefix[i] = sum of nums[0:i]."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "ZMOFmHBVEcg",
      "problemStatement": "Given an integer array nums, handle multiple queries of the following type:\nImplement the NumArray class:",
      "difficulty": "Easy",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "Prefix Sum: Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
      "suggestedNextQuestion": {
        "slug": "transformed-array",
        "title": "Transformed Array",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
      "initialCode": "    def __init__(self, nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class NumArray:\n    def __init__(self, nums):\n        self.pre = [0]\n        for n in nums:\n            self.pre.append(self.pre[-1] + n)\n    def sumRange(self, left, right):\n        return self.pre[right+1] - self.pre[left]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1) query",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Sum of elements in range [left, right].",
            "\ud83e\udde0 Prefix sum array enables O(1) queries.",
            "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
          ],
          "code": "class NumArray:\n    def __init__(self, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum of elements in range [left, right].\n    - \ud83e\udde0 Prefix sum array enables O(1) queries.\n    - \ud83d\udca1 prefix[i] = sum of nums[0:i].\n    \"\"\"\n        self.prefix = [0]\n        for n in nums:  # Iterate over elements.\n            self.prefix.append(self.prefix[-1] + n)  # Add to end.\n    \n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix[right + 1] - self.prefix[left]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "unique-paths": {
      "title": "Unique Paths",
      "pattern": "2D DP",
      "patternEmoji": "\ud83d\udee4\ufe0f",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(n)",
      "oneliner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
      "intuition": [
        "\ud83c\udfaf Count paths from top-left to bottom-right.",
        "\ud83e\udde0 Can only move right or down.",
        "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
      ],
      "testCases": [
        {
          "input": "m = 3, n = 7",
          "output": "28"
        },
        {
          "input": "m = 3, n = 2",
          "output": "3"
        }
      ],
      "code": "def uniquePaths(m, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 dp[i][j] = sum of paths from top and left.\n    \"\"\"\n    dp = [1] * n  # Initialize DP table to store results.\n    for _ in range(1, m):  # Iterate through the range.\n        for j in range(1, n):  # Iterate through the range.\n            dp[j] += dp[j - 1]\n    return dp[n - 1]",
      "keyInsight": "Each cell = sum of paths from above and left.",
      "visualizationType": "matrix",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Unique Paths",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1",
              "1"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "description": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.\n\nCount paths from top-left to bottom-right.\nCan only move right or down.",
      "examples": [
        {
          "input": "m = 3; n = 7",
          "output": "28"
        },
        {
          "input": "m = 3; n = 2",
          "output": "3"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "-10^9 <= value <= 10^9"
      ],
      "hints": [
        "Count paths from top-left to bottom-right.",
        "Can only move right or down.",
        "dp[i][j] = sum of paths from top and left."
      ],
      "relatedProblems": [
        "two-sum",
        "climbing-stairs",
        "binary-search"
      ],
      "videoId": "IlEsdxuD4lY",
      "problemStatement": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "approach": "2D DP: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
      "suggestedNextQuestion": {
        "slug": "unique-paths-ii",
        "title": "Unique Paths II",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like filling out a form where each answer depends on previous answers.",
      "initialCode": "def uniquePaths(m, n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def uniquePaths(m, n):\n    # Recursive\n    def dfs(r, c):\n        if r == m-1 and c == n-1: return 1\n        if r >= m or c >= n: return 0\n        return dfs(r+1, c) + dfs(r, c+1)\n    return dfs(0, 0)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Count paths from top-left to bottom-right.",
            "\ud83e\udde0 Can only move right or down.",
            "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
          ],
          "code": "def uniquePaths(m, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 dp[i][j] = sum of paths from top and left.\n    \"\"\"\n    dp = [1] * n  # Initialize DP table to store results.\n    for _ in range(1, m):  # Iterate through the range.\n        for j in range(1, n):  # Iterate through the range.\n            dp[j] += dp[j - 1]\n    return dp[n - 1]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "lru-cache": {
      "title": "LRU Cache",
      "pattern": "Design",
      "patternEmoji": "\ud83c\udfd7\ufe0f",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(capacity)",
      "oneliner": "Use a hashmap for O(1) lookup and a doubly-linked list for O(1) eviction ordering.",
      "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations in O(1) time complexity.",
      "intuition": [
        "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
        "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
        "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
      ],
      "keyInsight": "Combining HashMap with Doubly Linked List gives us O(1) for both get and put operations.",
      "code": "def test_lru_cache():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal\n    - \ud83e\udde0 HashMap stores key -> node reference for quick lookup\n    - \ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail\n    \"\"\"\n    from collections import OrderedDict\n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n        def put(self, key: int, value: int) -> None:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.capacity:\n                self.cache.popitem(last=False)\n    \n    # Test case 1\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    result1 = cache.get(1)\n    \n    # Test case 2\n    cache2 = LRUCache(2)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    result2 = cache2.get(2)\n    \n    return [result1, result2]",
      "testCases": [
        {
          "input": "",
          "output": "[1, 2]"
        }
      ],
      "examples": [
        {
          "input": "LRUCache(2), put(1,1), put(2,2), get(1)",
          "output": "1",
          "explanation": "Key 1 exists and is returned"
        },
        {
          "input": "LRUCache(2), put(1,1), put(2,2), put(3,3), get(2)",
          "output": "-1",
          "explanation": "Key 2 was evicted when 3 was added"
        }
      ],
      "constraints": [
        "1 <= capacity <= 3000",
        "0 <= key <= 10^4",
        "0 <= value <= 10^5"
      ],
      "hints": [
        "Use OrderedDict for simplicity in Python",
        "Move accessed keys to end to mark as recently used",
        "Pop from beginning when over capacity"
      ],
      "relatedProblems": [
        "all-oone-data-structure",
        "lfu-cache",
        "design-in-memory-file-system"
      ],
      "videoId": "7ABFKPK2hD4",
      "problemStatement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nThe functions get and put must each run in O(1) average time complexity.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "linkedlist",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: LRU Cache",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "approach": "Hash Map + Doubly Linked List: Use a hashmap for O(1) lookup and a doubly-linked list for O(1) eviction ordering.",
      "mentalModel": "Like building a custom machine. You decide how the gears (data structures) fit together.",
      "initialCode": "def test_lru_cache():\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class LRUCache:\n    def __init__(self, capacity):\n        self.cap = capacity\n        self.cache = {} # key: val\n        self.order = [] # key\n    def get(self, key):\n        if key in self.cache:\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n        return -1\n    def put(self, key, value):\n        if key in self.cache:\n            self.order.remove(key)\n        self.cache[key] = value\n        self.order.append(key)\n        if len(self.order) > self.cap:\n            del self.cache[self.order.pop(0)]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(capacity)",
          "intuition": [
            "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
            "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
            "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
          ],
          "code": "def test_lru_cache():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal\n    - \ud83e\udde0 HashMap stores key -> node reference for quick lookup\n    - \ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail\n    \"\"\"\n    from collections import OrderedDict\n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n        def put(self, key: int, value: int) -> None:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.capacity:\n                self.cache.popitem(last=False)\n    \n    # Test case 1\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    result1 = cache.get(1)\n    \n    # Test case 2\n    cache2 = LRUCache(2)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    result2 = cache2.get(2)\n    \n    return [result1, result2]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    "implement-trie-prefix-tree": {
      "title": "Implement Trie (Prefix Tree)",
      "pattern": "Trie",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(m)",
      "spaceComplexity": "O(n*m)",
      "oneliner": "Implement a trie with insert, search, and startsWith methods.",
      "description": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
      "intuition": [
        "\ud83c\udfaf Each node represents a character, paths form words",
        "\ud83e\udde0 Use a dictionary at each node to store children",
        "\ud83d\udca1 Mark end of word with a boolean flag"
      ],
      "keyInsight": "Tries enable O(m) prefix searches where m is the length of the prefix.",
      "code": "def test_trie():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node represents a character, paths form words\n    - \ud83e\udde0 Use a dictionary at each node to store children\n    - \ud83d\udca1 Mark end of word with a boolean flag\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            node = self._find(word)\n            return node is not None and node.is_end\n\n        def startsWith(self, prefix: str) -> bool:\n            return self._find(prefix) is not None\n\n        def _find(self, word: str):\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    trie = Trie()\n    trie.insert(\"apple\")\n    r1 = trie.search(\"apple\")\n    r2 = trie.search(\"app\")\n    r3 = trie.startsWith(\"app\")\n    \n    return [r1, r2, r3]",
      "testCases": [
        {
          "input": "",
          "output": "[True, False, True]"
        }
      ],
      "examples": [
        {
          "input": "insert('apple'), search('apple')",
          "output": "True",
          "explanation": "Word 'apple' was inserted and found"
        },
        {
          "input": "insert('apple'), startsWith('app')",
          "output": "True",
          "explanation": "Prefix 'app' exists in trie"
        }
      ],
      "constraints": [
        "1 <= word.length, prefix.length <= 2000",
        "word and prefix consist only of lowercase English letters"
      ],
      "hints": [
        "Use a dictionary to store children nodes",
        "Track end of word with a boolean",
        "Share common prefixes to save space"
      ],
      "relatedProblems": [
        "design-add-and-search-words-data-structure",
        "word-search-ii",
        "replace-words"
      ],
      "videoId": "oobqoCJlHA0",
      "problemStatement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "tree",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Implement Trie (Prefix Tree)",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "approach": "Trie: Implement a trie with insert, search, and startsWith methods.",
      "mentalModel": "Like autocomplete. Typing 'c-a-t' walks down the 'c' -> 'a' -> 't' path.",
      "initialCode": "def test_trie():\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: cur[c] = {}\n            cur = cur[c]\n        cur['#'] = True\n    def search(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: return False\n            cur = cur[c]\n        return '#' in cur\n    def startsWith(self, prefix):\n        cur = self.root\n        for c in prefix:\n            if c not in cur: return False\n            cur = cur[c]\n        return True"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m)",
          "spaceComplexity": "O(n*m)",
          "intuition": [
            "\ud83c\udfaf Each node represents a character, paths form words",
            "\ud83e\udde0 Use a dictionary at each node to store children",
            "\ud83d\udca1 Mark end of word with a boolean flag"
          ],
          "code": "def test_trie():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node represents a character, paths form words\n    - \ud83e\udde0 Use a dictionary at each node to store children\n    - \ud83d\udca1 Mark end of word with a boolean flag\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            node = self._find(word)\n            return node is not None and node.is_end\n\n        def startsWith(self, prefix: str) -> bool:\n            return self._find(prefix) is not None\n\n        def _find(self, word: str):\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    trie = Trie()\n    trie.insert(\"apple\")\n    r1 = trie.search(\"apple\")\n    r2 = trie.search(\"app\")\n    r3 = trie.startsWith(\"app\")\n    \n    return [r1, r2, r3]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    "design-add-and-search-words-data-structure": {
      "title": "Design Add and Search Words Data Structure",
      "pattern": "Trie",
      "patternEmoji": "\ud83c\udf33",
      "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
      "spaceComplexity": "O(n*m)",
      "oneliner": "Design a data structure that supports adding words and searching with '.' wildcard.",
      "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. The search can contain '.' which matches any single character.",
      "intuition": [
        "\ud83c\udfaf Use Trie for efficient prefix matching",
        "\ud83e\udde0 Handle '.' by trying all children recursively",
        "\ud83d\udca1 DFS/BFS for wildcard matching"
      ],
      "keyInsight": "Wildcards require exploring all children at that position using recursion/backtracking.",
      "code": "def test_word_dict():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use Trie for efficient prefix matching\n    - \ud83e\udde0 Handle '.' by trying all children recursively\n    - \ud83d\udca1 DFS/BFS for wildcard matching\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class WordDictionary:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def addWord(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            def dfs(node, i):\n                if i == len(word):\n                    return node.is_end\n                if word[i] == '.':\n                    return any(dfs(child, i + 1) for child in node.children.values())\n                if word[i] in node.children:\n                    return dfs(node.children[word[i]], i + 1)\n                return False  # Condition not met.\n            return dfs(self.root, 0)\n    \n    wd = WordDictionary()\n    wd.addWord(\"bad\")\n    wd.addWord(\"dad\")\n    wd.addWord(\"mad\")\n    \n    r1 = wd.search(\"pad\")\n    r2 = wd.search(\"bad\")\n    r3 = wd.search(\".ad\")\n    r4 = wd.search(\"b..\")\n    \n    return [r1, r2, r3, r4]",
      "testCases": [
        {
          "input": "",
          "output": "[False, True, True, True]"
        }
      ],
      "examples": [
        {
          "input": "addWord('bad'), search('b.d')",
          "output": "True",
          "explanation": "'.' matches 'a'"
        },
        {
          "input": "addWord('bad'), search('.ad')",
          "output": "True",
          "explanation": "'.' matches 'b'"
        }
      ],
      "constraints": [
        "1 <= word.length <= 25",
        "word consists of lowercase letters",
        "search word may contain '.'"
      ],
      "hints": [
        "Trie is the perfect data structure",
        "Use DFS for wildcard matching",
        "Try all children when encountering '.'"
      ],
      "relatedProblems": [
        "implement-trie-prefix-tree",
        "word-search-ii",
        "prefix-and-suffix-search"
      ],
      "videoId": "BTf05gs_8iU",
      "problemStatement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n- WordDictionary() Initializes the object.\n- void addWord(word) Adds word to the data structure, it can be matched later.\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.",
      "difficulty": "Medium",
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "visualizationType": "tree",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Design Add and Search Words Data Structure",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "approach": "Trie: Design a data structure that supports adding words and searching with '.' wildcard.",
      "mentalModel": "Like autocomplete. Typing 'c-a-t' walks down the 'c' -> 'a' -> 't' path.",
      "initialCode": "def test_word_dict():\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class WordDictionary:\n    def __init__(self):\n        self.root = {}\n    def addWord(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: cur[c] = {}\n            cur = cur[c]\n        cur['#'] = True\n    def search(self, word):\n        def dfs(i, root):\n            cur = root\n            for j in range(i, len(word)):\n                c = word[j]\n                if c == '.':\n                    for child in cur.values():\n                        if child is not True and dfs(j + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur: return False\n                    cur = cur[c]\n            return '#' in cur\n        return dfs(0, self.root)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
          "spaceComplexity": "O(n*m)",
          "intuition": [
            "\ud83c\udfaf Use Trie for efficient prefix matching",
            "\ud83e\udde0 Handle '.' by trying all children recursively",
            "\ud83d\udca1 DFS/BFS for wildcard matching"
          ],
          "code": "def test_word_dict():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use Trie for efficient prefix matching\n    - \ud83e\udde0 Handle '.' by trying all children recursively\n    - \ud83d\udca1 DFS/BFS for wildcard matching\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class WordDictionary:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def addWord(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            def dfs(node, i):\n                if i == len(word):\n                    return node.is_end\n                if word[i] == '.':\n                    return any(dfs(child, i + 1) for child in node.children.values())\n                if word[i] in node.children:\n                    return dfs(node.children[word[i]], i + 1)\n                return False  # Condition not met.\n            return dfs(self.root, 0)\n    \n    wd = WordDictionary()\n    wd.addWord(\"bad\")\n    wd.addWord(\"dad\")\n    wd.addWord(\"mad\")\n    \n    r1 = wd.search(\"pad\")\n    r2 = wd.search(\"bad\")\n    r3 = wd.search(\".ad\")\n    r4 = wd.search(\"b..\")\n    \n    return [r1, r2, r3, r4]"
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    "word-search-ii": {
      "title": "Word Search II",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd19",
      "timeComplexity": "O(m*n*4^L)",
      "spaceComplexity": "O(total chars in words)",
      "oneliner": "Find all words from a dictionary that can be formed by adjacent cells in a grid.",
      "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells.",
      "intuition": [
        "\ud83c\udfaf Build Trie from words for efficient prefix checking",
        "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
        "\ud83d\udca1 Mark visited cells to avoid reuse"
      ],
      "keyInsight": "Building a Trie allows us to search for multiple words simultaneously and prune invalid paths early.",
      "code": "def findWords(board, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build Trie from words for efficient prefix checking\n    - \ud83e\udde0 DFS from each cell, prune when no matching prefix\n    - \ud83d\udca1 Mark visited cells to avoid reuse\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n    \n    root = TrieNode()\n    for word in words:  # Iterate over elements.\n        node = root\n        for c in word:  # Iterate over elements.\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = word\n    \n    result = []\n    m, n = len(board), len(board[0])\n    \n    def dfs(i, j, node):\n        c = board[i][j]\n        if c not in node.children:\n            return\n        next_node = node.children[c]\n        if next_node.word:\n            result.append(next_node.word)  # Add to end.\n            next_node.word = None\n        \n        board[i][j] = '#'\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                dfs(ni, nj, next_node)\n        board[i][j] = c\n    \n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            dfs(i, j, root)\n    return sorted(result)",
      "testCases": [
        {
          "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
          "output": "[\"eat\",\"oath\"]"
        },
        {
          "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
          "output": "[]"
        }
      ],
      "examples": [
        {
          "input": "board = [['o','a','a','n'],...], words = ['oath','pea','eat','rain']",
          "output": "['eat', 'oath']",
          "explanation": "These words can be formed from adjacent cells"
        }
      ],
      "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 12",
        "1 <= words.length <= 3 * 10^4"
      ],
      "hints": [
        "Build a Trie from the word list",
        "DFS from each cell with Trie for pruning",
        "Mark cells visited during search"
      ],
      "relatedProblems": [
        "word-search",
        "unique-paths-iii",
        "sudoku-solver"
      ],
      "videoId": "asbcE9mZz_U",
      "problemStatement": "Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
      "difficulty": "Hard",
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "visualizationType": "tree",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Word Search II",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [1]",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 2 to path",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try 3 instead",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "approach": "Backtracking: Find all words from a dictionary that can be formed by adjacent cells in a grid.",
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def findWords(board, words):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def findWords_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n*4^L)",
          "spaceComplexity": "O(total chars in words)",
          "intuition": [
            "\ud83c\udfaf Build Trie from words for efficient prefix checking",
            "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
            "\ud83d\udca1 Mark visited cells to avoid reuse"
          ],
          "code": "def findWords(board, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build Trie from words for efficient prefix checking\n    - \ud83e\udde0 DFS from each cell, prune when no matching prefix\n    - \ud83d\udca1 Mark visited cells to avoid reuse\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n    \n    root = TrieNode()\n    for word in words:  # Iterate over elements.\n        node = root\n        for c in word:  # Iterate over elements.\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = word\n    \n    result = []\n    m, n = len(board), len(board[0])\n    \n    def dfs(i, j, node):\n        c = board[i][j]\n        if c not in node.children:\n            return\n        next_node = node.children[c]\n        if next_node.word:\n            result.append(next_node.word)  # Add to end.\n            next_node.word = None\n        \n        board[i][j] = '#'\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                dfs(ni, nj, next_node)\n        board[i][j] = c\n    \n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            dfs(i, j, root)\n    return sorted(result)"
        }
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ]
    },
    "binary-search-tree-iterator": {
      "title": "Binary Search Tree Iterator",
      "pattern": "Tree",
      "patternEmoji": "\ud83c\udf32",
      "timeComplexity": "O(1) avg next, O(h) hasNext",
      "spaceComplexity": "O(h)",
      "oneliner": "Implement an iterator over a BST that returns nodes in ascending order.",
      "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST).",
      "intuition": [
        "\ud83c\udfaf In-order traversal gives sorted order for BST",
        "\ud83e\udde0 Use stack to simulate recursive traversal",
        "\ud83d\udca1 Push left children, pop for next, then go right"
      ],
      "keyInsight": "Using a stack to store the path allows O(h) space instead of O(n) for full traversal.",
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef test_bst_iterator():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf In-order traversal gives sorted order for BST\n    - \ud83e\udde0 Use stack to simulate recursive traversal\n    - \ud83d\udca1 Push left children, pop for next, then go right\n    \"\"\"\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    class BSTIterator:\n        def __init__(self, root):\n            self.stack = []  # Initialize stack for tracking.\n            self._push_left(root)\n        \n        def _push_left(self, node):\n            while node:\n                self.stack.append(node)  # Add to end.\n                node = node.left\n\n        def next(self) -> int:\n            node = self.stack.pop()  # Remove and return last element.\n            self._push_left(node.right)\n            return node.val\n\n        def hasNext(self) -> bool:\n            return len(self.stack) > 0\n    \n    # Build tree: [7, 3, 15, null, null, 9, 20]\n    root = TreeNode(7)  # Create a new Tree Node.\n    root.left = TreeNode(3)  # Process left child.\n    root.right = TreeNode(15, TreeNode(9), TreeNode(20))  # Process right child.\n    \n    iterator = BSTIterator(root)\n    results = []\n    results.append(iterator.next())    # 3\n    results.append(iterator.next())    # 7\n    results.append(iterator.hasNext()) # True\n    results.append(iterator.next())    # 9\n    \n    return results  # Return the final result.",
      "testCases": [
        {
          "input": "",
          "output": "[3, 7, True, 9]"
        }
      ],
      "examples": [
        {
          "input": "BSTIterator([7,3,15,null,null,9,20]), next()",
          "output": "3",
          "explanation": "Smallest element in BST"
        },
        {
          "input": "next(), next(), next()",
          "output": "3, 7, 9",
          "explanation": "In-order traversal order"
        }
      ],
      "constraints": [
        "Number of nodes is in [1, 10^5]",
        "-10^6 <= Node.val <= 10^6",
        "At most 10^5 calls to next and hasNext"
      ],
      "hints": [
        "Use a stack to simulate recursion",
        "Push all left children initially",
        "When popping, push right subtree's left path"
      ],
      "relatedProblems": [
        "binary-tree-inorder-traversal",
        "flatten-2d-vector",
        "zigzag-iterator"
      ],
      "videoId": "RXy5RzGF5wo",
      "problemStatement": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
      "difficulty": "Medium",
      "walkthrough": [
        "Check base case (null node)",
        "Process current node",
        "Recursively handle left subtree",
        "Recursively handle right subtree",
        "Combine results and return"
      ],
      "visualizationType": "tree",
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Binary Search Tree Iterator",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "approach": "Tree: Implement an iterator over a BST that returns nodes in ascending order.",
      "suggestedNextQuestion": {
        "slug": "delete-node-in-a-bst",
        "title": "Delete Node in a BST",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a family tree. Every node has a parent and children.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef test_bst_iterator():\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1) avg next, O(h) hasNext",
          "spaceComplexity": "O(h)",
          "intuition": [
            "\ud83c\udfaf In-order traversal gives sorted order for BST",
            "\ud83e\udde0 Use stack to simulate recursive traversal",
            "\ud83d\udca1 Push left children, pop for next, then go right"
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef test_bst_iterator():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf In-order traversal gives sorted order for BST\n    - \ud83e\udde0 Use stack to simulate recursive traversal\n    - \ud83d\udca1 Push left children, pop for next, then go right\n    \"\"\"\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    class BSTIterator:\n        def __init__(self, root):\n            self.stack = []  # Initialize stack for tracking.\n            self._push_left(root)\n        \n        def _push_left(self, node):\n            while node:\n                self.stack.append(node)  # Add to end.\n                node = node.left\n\n        def next(self) -> int:\n            node = self.stack.pop()  # Remove and return last element.\n            self._push_left(node.right)\n            return node.val\n\n        def hasNext(self) -> bool:\n            return len(self.stack) > 0\n    \n    # Build tree: [7, 3, 15, null, null, 9, 20]\n    root = TreeNode(7)  # Create a new Tree Node.\n    root.left = TreeNode(3)  # Process left child.\n    root.right = TreeNode(15, TreeNode(9), TreeNode(20))  # Process right child.\n    \n    iterator = BSTIterator(root)\n    results = []\n    results.append(iterator.next())    # 3\n    results.append(iterator.next())    # 7\n    results.append(iterator.hasNext()) # True\n    results.append(iterator.next())    # 9\n    \n    return results  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ]
    },
    "transformed-array": {
      "title": "Transformed Array",
      "pattern": "Array",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Transform an array based on given rules and return the result.",
      "description": "Given an array, apply transformation rules to create a new array. Common transformations include prefix sums, differences, or element-wise operations.",
      "intuition": [
        "\ud83c\udfaf Iterate through array applying transformation",
        "\ud83e\udde0 Use auxiliary array to store results",
        "\ud83d\udca1 Handle edge cases for first/last elements"
      ],
      "keyInsight": "Array transformations are typically O(n) and require careful handling of boundary conditions.",
      "code": "def constructTransformedArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Iterate through array applying transformation\n    - \ud83e\udde0 Use auxiliary array to store results\n    - \ud83d\udca1 Handle edge cases for first/last elements\n    \"\"\"\n    n = len(nums)\n    result = [0] * n\n    for i in range(n):  # Iterate through the range.\n        if nums[i] > 0:\n            result[i] = nums[(i + nums[i]) % n]\n        elif nums[i] < 0:\n            result[i] = nums[(i + nums[i]) % n]\n        else:\n            result[i] = nums[i]\n    return result  # Return the final result.",
      "testCases": [
        {
          "input": "nums = [3,-2,1,1]",
          "output": "[1, 1, 1, 3]"
        },
        {
          "input": "nums = [-1,4,-1]",
          "output": "[-1,-1,4]"
        }
      ],
      "examples": [
        {
          "input": "[6,2,3,4]",
          "output": "[6,3,3,4]",
          "explanation": "2 increments to 3 because it's a local minimum"
        }
      ],
      "constraints": [
        "1 <= arr.length <= 100",
        "1 <= arr[i] <= 100"
      ],
      "hints": [
        "Iterate until no changes are made",
        "Local minima increase, local maxima decrease",
        "First and last elements never change"
      ],
      "relatedProblems": [
        "running-sum-of-1d-array",
        "find-pivot-index",
        "product-of-array-except-self"
      ],
      "videoId": "b5vu-orCfYQ",
      "problemStatement": "You are given an integer array nums that represents a circular array. Your task is to create a new array result of the same size, following these rules:\nReturn the new array result.\nNote: Since nums is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.",
      "difficulty": "Easy",
      "walkthrough": [
        "For each element, calculate new index based on value",
        "If nums[i] > 0: new value = nums[(i + nums[i]) % n]",
        "If nums[i] < 0: new value = nums[(i + nums[i]) % n]",
        "If nums[i] == 0: new value stays as nums[i]",
        "Modulo handles circular array indexing"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Transformed Array",
          "transientMessage": "Input: [3, -2, 1, 1]",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 3",
          "transientMessage": "Step 1 of 4",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: -2",
          "transientMessage": "Step 2 of 4",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 1",
          "transientMessage": "Step 3 of 4",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 1",
          "transientMessage": "Step 4 of 4",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            3,
            -2,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "visualizationType": "array",
      "initialState": [
        3,
        -2,
        1,
        1
      ],
      "approach": "Array: Transform an array based on given rules and return the result.",
      "suggestedNextQuestion": {
        "slug": "valid-sudoku",
        "title": "Valid Sudoku",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
      "initialCode": "def constructTransformedArray(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def transform(nums):\n    # Depending on problem def, assuming typical map/filter\n    # Placeholder for unknown specific logic if custom\n    return [x*2 for x in nums]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "\ud83c\udfaf Iterate through array applying transformation",
            "\ud83e\udde0 Use auxiliary array to store results",
            "\ud83d\udca1 Handle edge cases for first/last elements"
          ],
          "code": "def constructTransformedArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Iterate through array applying transformation\n    - \ud83e\udde0 Use auxiliary array to store results\n    - \ud83d\udca1 Handle edge cases for first/last elements\n    \"\"\"\n    n = len(nums)\n    result = [0] * n\n    for i in range(n):  # Iterate through the range.\n        if nums[i] > 0:\n            result[i] = nums[(i + nums[i]) % n]\n        elif nums[i] < 0:\n            result[i] = nums[(i + nums[i]) % n]\n        else:\n            result[i] = nums[i]\n    return result  # Return the final result."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "encode-and-decode-strings": {
      "id": "encode-and-decode-strings",
      "slug": "encode-and-decode-strings",
      "title": "Encode and Decode Strings",
      "difficulty": "Medium",
      "category": "Array / String",
      "problemStatement": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent to the other end of the network, where it is decoded back to the original list of strings.",
      "videoUrl": "",
      "pattern": "String Encoding",
      "patternEmoji": "\ud83d\udd10",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Prefix each string with its length followed by a delimiter.",
      "intuition": [
        "We need a way to unambiguously separate strings during decoding",
        "Using length+delimiter ensures we can always find string boundaries"
      ],
      "visualizationType": "array",
      "initialState": [
        "hello",
        "world"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Encode and Decode Strings",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = hello",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = world",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "hello",
            "world"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "class Codec:\n    def encode(self, strs):\n    \"\"\"\n    Intuition:\n    - We need a way to unambiguously separate strings during decoding\n    - Using length+delimiter ensures we can always find string boundaries\n    \"\"\"\n        encoded = ''\n        for s in strs:  # Iterate over elements.\n            encoded += str(len(s)) + '#' + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            decoded.append(s[j+1:j+1+length])  # Add to end.\n            i = j+1+length\n        return decoded",
      "keyInsight": "Length prefix with delimiter allows unambiguous parsing regardless of content.",
      "testCases": [
        {
          "input": "codec = Codec(); codec.decode(codec.encode([\"lint\",\"code\",\"love\",\"you\"]))",
          "output": "[\"lint\",\"code\",\"love\",\"you\"]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "String Encoding: Prefix each string with its length followed by a delimiter.",
      "videoId": "B1k_sxOSgv8",
      "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
      "initialCode": "    def encode(self, strs):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "class Codec:\n    def encode(self, strs):\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n    def decode(self, s):\n        res, i = [], 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            res.append(s[j+1 : j+1+length])\n            i = j + 1 + length\n        return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "We need a way to unambiguously separate strings during decoding",
            "Using length+delimiter ensures we can always find string boundaries"
          ],
          "code": "class Codec:\n    def encode(self, strs):\n    \"\"\"\n    Intuition:\n    - We need a way to unambiguously separate strings during decoding\n    - Using length+delimiter ensures we can always find string boundaries\n    \"\"\"\n        encoded = ''\n        for s in strs:  # Iterate over elements.\n            encoded += str(len(s)) + '#' + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            decoded.append(s[j+1:j+1+length])  # Add to end.\n            i = j+1+length\n        return decoded"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "two-sum-ii-input-array-is-sorted": {
      "id": "two-sum-ii-input-array-is-sorted",
      "slug": "two-sum-ii-input-array-is-sorted",
      "title": "Two Sum II - Input Array Is Sorted",
      "difficulty": "Medium",
      "category": "Two Pointers",
      "problemStatement": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.",
      "videoUrl": "",
      "pattern": "Two Pointers",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use two pointers starting from ends to find the pair.",
      "intuition": [
        "Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.",
        "If our sum is too small, we can increase it by moving the left pointer right."
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        7,
        11,
        15
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Two Sum II - Input Array Is Sorted",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 7",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 11",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 15",
          "transientMessage": "Iteration 4",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            2,
            7,
            11,
            15
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def twoSum(numbers, target):\n    \"\"\"\n    Intuition:\n    - Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.\n    - If our sum is too small, we can increase it by moving the left pointer right.\n    \"\"\"\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []  # This line should never be reached",
      "keyInsight": "The array is sorted, so we can use directionality.",
      "testCases": [
        {
          "input": "numbers = [2,7,11,15], target = 9",
          "output": "[1,2]"
        },
        {
          "input": "numbers = [2,3,4], target = 6",
          "output": "[1,3]"
        },
        {
          "input": "numbers = [-1,0], target = -1",
          "output": "[1,2]"
        }
      ],
      "walkthrough": [
        "Initialize two pointers (start/end or slow/fast)",
        "Move pointers based on problem conditions",
        "Process elements as pointers traverse",
        "Continue until pointers meet or condition satisfied",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Consider using two pointers from opposite ends",
        "\ud83d\udca1 Or use slow/fast pointer technique",
        "\ud83d\udd0d What condition moves each pointer?"
      ],
      "approach": "Two Pointers: Use two pointers starting from ends to find the pair.",
      "videoId": "cQ1Oz4ckceM",
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def twoSum(numbers, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l+1, r+1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.",
            "If our sum is too small, we can increase it by moving the left pointer right."
          ],
          "code": "def twoSum(numbers, target):\n    \"\"\"\n    Intuition:\n    - Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.\n    - If our sum is too small, we can increase it by moving the left pointer right.\n    \"\"\"\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []  # This line should never be reached"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3, 4]",
          "output": "[result]",
          "explanation": "Two pointers traverse from both ends."
        },
        {
          "input": "nums = [0, 1]",
          "output": "[result]",
          "explanation": "Edge case with minimum input."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "Array is sorted (if applicable)"
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "longest-repeating-character-replacement": {
      "id": "longest-repeating-character-replacement",
      "slug": "longest-repeating-character-replacement",
      "title": "Longest Repeating Character Replacement",
      "difficulty": "Medium",
      "category": "Sliding Window",
      "problemStatement": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
      "videoUrl": "",
      "pattern": "Sliding Window",
      "patternEmoji": ">window<",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use sliding window with max frequency tracking to find longest valid substring.",
      "intuition": [
        "We can extend a window as long as (window length - max char frequency) \u2264 k",
        "When this condition breaks, shrink window from left until it's valid again"
      ],
      "visualizationType": "array",
      "initialState": [
        "A",
        "A",
        "B",
        "A",
        "B",
        "B",
        "A"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Repeating Character Replacement",
          "transientMessage": "Sliding window approach",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize window",
          "transientMessage": "left=0, right=0",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Expand window to 1",
          "transientMessage": "Window: [0, 1]",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Expand window to 2",
          "transientMessage": "Window: [0, 2]",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Expand window to 3",
          "transientMessage": "Window: [0, 3]",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 3
            }
          ],
          "indices": [
            0,
            1,
            2,
            3
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Expand window to 4",
          "transientMessage": "Window: [0, 4]",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 4
            }
          ],
          "indices": [
            0,
            1,
            2,
            3,
            4
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Expand window to 5",
          "transientMessage": "Window: [0, 5]",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 0
            },
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            0,
            1,
            2,
            3,
            4,
            5
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Shrink from left",
          "transientMessage": "Condition met, slide window",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            },
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update maximum/result",
          "transientMessage": "Track best answer",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Window traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "A",
            "A",
            "B",
            "A",
            "B",
            "B",
            "A"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def characterReplacement(s: str, k: int) -> int:\n    \"\"\"\n    Intuition:\n    - We can extend a window as long as (window length - max char frequency) \u2264 k\n    - When this condition breaks, shrink window from left until it's valid again\n    \"\"\"\n    left = 0\n    max_length = 0\n    max_freq = 0\n    char_count = {}\n    \n    for right in range(len(s)):  # Iterate through the range.\n        # Update character frequency\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        max_freq = max(max_freq, char_count[s[right]])  # Take the maximum value.\n        \n        # If window is invalid, shrink from left\n        while (right - left + 1) - max_freq > k:\n            char_count[s[left]] -= 1\n            left += 1\n            # Note: max_freq might be outdated but doesn't affect correctness\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)  # Take the maximum value.\n    \n    return max_length",
      "keyInsight": "We track the maximum frequency in current window. Window is valid if (length - maxFreq) \u2264 k.",
      "testCases": [
        {
          "input": "s = \"ABAB\", k = 2",
          "output": "4"
        },
        {
          "input": "s = \"AABABBA\", k = 1",
          "output": "4"
        }
      ],
      "walkthrough": [
        "Initialize window boundaries (left, right)",
        "Expand window by moving right pointer",
        "Update window state with new element",
        "Shrink window when condition violated",
        "Track optimal result throughout"
      ],
      "hints": [
        "\ud83e\udde0 What defines a valid window?",
        "\ud83d\udca1 When should you expand vs shrink?",
        "\ud83d\udd0d Track window state efficiently"
      ],
      "approach": "Sliding Window: Use sliding window with max frequency tracking to find longest valid substring.",
      "videoId": "gqXU1UyA8pk",
      "suggestedNextQuestion": {
        "slug": "longest-substring-without-repeating-characters",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def characterReplacement(s: str, k: int) -> int:\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def characterReplacement_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "We can extend a window as long as (window length - max char frequency) \u2264 k",
            "When this condition breaks, shrink window from left until it's valid again"
          ],
          "code": "def characterReplacement(s: str, k: int) -> int:\n    \"\"\"\n    Intuition:\n    - We can extend a window as long as (window length - max char frequency) \u2264 k\n    - When this condition breaks, shrink window from left until it's valid again\n    \"\"\"\n    left = 0\n    max_length = 0\n    max_freq = 0\n    char_count = {}\n    \n    for right in range(len(s)):  # Iterate through the range.\n        # Update character frequency\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        max_freq = max(max_freq, char_count[s[right]])  # Take the maximum value.\n        \n        # If window is invalid, shrink from left\n        while (right - left + 1) - max_freq > k:\n            char_count[s[left]] -= 1\n            left += 1\n            # Note: max_freq might be outdated but doesn't affect correctness\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)  # Take the maximum value.\n    \n    return max_length"
        }
      ],
      "examples": [
        {
          "input": "s = \"abcabcbb\"",
          "output": "3",
          "explanation": "Sliding window expands until duplicate, then shrinks."
        },
        {
          "input": "s = \"bbbbb\"",
          "output": "1",
          "explanation": "All same characters."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^5",
        "s consists of printable ASCII characters"
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    },
    "sliding-window-maximum": {
      "id": "sliding-window-maximum",
      "slug": "sliding-window-maximum",
      "title": "Sliding Window Maximum",
      "difficulty": "Hard",
      "category": "Sliding Window",
      "problemStatement": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.",
      "videoUrl": "",
      "pattern": "Monotonic Queue",
      "patternEmoji": ".dequeue",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(k)",
      "oneliner": "Use a deque to maintain decreasing elements in the current window.",
      "intuition": [
        "We want maximums from sliding windows - brute force is O(n*k)",
        "Use deque to store indices of array elements in decreasing order"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        3,
        -1,
        -3,
        5,
        3,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Find max in each window of size 3",
          "transientMessage": "Initialize empty deque",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Add index 0 (val=1)",
          "transientMessage": "Deque: [0]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Remove 1 < 3",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Add index 1 (val=3)",
          "transientMessage": "Deque: [1]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Add index 2 (val=-1)",
          "transientMessage": "Deque: [1, 2]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Window max: 3",
          "transientMessage": "Result: [3]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 1
            }
          ],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Add index 3 (val=-3)",
          "transientMessage": "Deque: [1, 2, 3]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Window max: 3",
          "transientMessage": "Result: [3, 3]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 1
            }
          ],
          "indices": [
            1,
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Remove index 1 (outside window)",
          "transientMessage": "Deque: [2, 3]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Remove -3 < 5",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 11,
          "visual": "Remove -1 < 5",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Add index 4 (val=5)",
          "transientMessage": "Deque: [4]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 13,
          "visual": "Window max: 5",
          "transientMessage": "Result: [3, 3, 5]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 4
            }
          ],
          "indices": [
            2,
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Add index 5 (val=3)",
          "transientMessage": "Deque: [4, 5]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 15,
          "visual": "Window max: 5",
          "transientMessage": "Result: [3, 3, 5, 5]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 4
            }
          ],
          "indices": [
            3,
            4,
            5
          ],
          "color": "success"
        },
        {
          "step": 16,
          "visual": "Remove 3 < 6",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 17,
          "visual": "Remove 5 < 6",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 18,
          "visual": "Add index 6 (val=6)",
          "transientMessage": "Deque: [6]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 19,
          "visual": "Window max: 6",
          "transientMessage": "Result: [3, 3, 5, 5, 6]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 6
            }
          ],
          "indices": [
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 20,
          "visual": "Remove 6 < 7",
          "transientMessage": "Smaller element removed",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 21,
          "visual": "Add index 7 (val=7)",
          "transientMessage": "Deque: [7]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            7
          ],
          "color": "accent"
        },
        {
          "step": 22,
          "visual": "Window max: 7",
          "transientMessage": "Result: [3, 3, 5, 5, 6, 7]",
          "arrayState": [
            1,
            3,
            -1,
            -3,
            5,
            3,
            6,
            7
          ],
          "pointers": [
            {
              "label": "max",
              "index": 7
            }
          ],
          "indices": [
            5,
            6,
            7
          ],
          "color": "success"
        }
      ],
      "code": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    \"\"\"\n    Intuition:\n    - We want maximums from sliding windows - brute force is O(n*k)\n    - Use deque to store indices of array elements in decreasing order\n    \"\"\"\n    dq = deque()  # Stores indices\n    result = []\n    \n    for i in range(len(nums)):  # Iterate through the range.\n        # Remove indices outside window\n        while dq and dq[0] <= i - k:\n            dq.popleft()  # Remove from front of queue.\n        \n        # Remove indices whose values are less than current\n        while dq and nums[dq[-1]] <= nums[i]:\n            dq.pop()  # Remove and return last element.\n        \n        dq.append(i)  # Add to end.\n        \n        # Add max to result when window is formed\n        if i >= k - 1:\n            result.append(nums[dq[0]])  # Add to end.\n    \n    return result  # Return the final result.",
      "keyInsight": "Deque maintains indices of elements in decreasing order - front always has maximum.",
      "testCases": [
        {
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "output": "[3,3,5,5,6,7]"
        },
        {
          "input": "nums = [1], k = 1",
          "output": "[1]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Monotonic Queue: Use a deque to maintain decreasing elements in the current window.",
      "videoId": "DfljaUwZsOk",
      "mentalModel": "Like a grocery line. First come, first served (FIFO).",
      "initialCode": "def maxSlidingWindow(nums, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxSlidingWindow(nums, k):\n    res = []\n    for i in range(len(nums) - k + 1):\n        window = nums[i:i+k]\n        res.append(max(window))\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "We want maximums from sliding windows - brute force is O(n*k)",
            "Use deque to store indices of array elements in decreasing order"
          ],
          "code": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    \"\"\"\n    Intuition:\n    - We want maximums from sliding windows - brute force is O(n*k)\n    - Use deque to store indices of array elements in decreasing order\n    \"\"\"\n    dq = deque()  # Stores indices\n    result = []\n    \n    for i in range(len(nums)):  # Iterate through the range.\n        # Remove indices outside window\n        while dq and dq[0] <= i - k:\n            dq.popleft()  # Remove from front of queue.\n        \n        # Remove indices whose values are less than current\n        while dq and nums[dq[-1]] <= nums[i]:\n            dq.pop()  # Remove and return last element.\n        \n        dq.append(i)  # Add to end.\n        \n        # Add max to result when window is formed\n        if i >= k - 1:\n            result.append(nums[dq[0]])  # Add to end.\n    \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "non-overlapping-intervals": {
      "id": "non-overlapping-intervals",
      "slug": "non-overlapping-intervals",
      "title": "Non-overlapping Intervals",
      "difficulty": "Medium",
      "category": "Intervals",
      "problemStatement": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nNote that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.",
      "videoUrl": "",
      "pattern": "Greedy Algorithm",
      "patternEmoji": "\ud83d\udcb0",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Sort by end time and greedily select non-overlapping intervals.",
      "intuition": [
        "To minimize removals, we want to keep as many non-overlapping intervals as possible.",
        "Greedy approach: always pick the interval that ends earliest to leave more room for others."
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        2,
        3,
        1,
        3,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Non-overlapping Intervals",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 2",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 3",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 1",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 3",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            2,
            3,
            1,
            3,
            3,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def eraseOverlapIntervals(intervals):\n    \"\"\"\n    Intuition:\n    - To minimize removals, we want to keep as many non-overlapping intervals as possible.\n    - Greedy approach: always pick the interval that ends earliest to leave more room for others.\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):  # Iterate through the range.\n        # If current interval starts before previous ends\n        if intervals[i][0] < end:\n            count += 1  # Remove this interval\n        else:\n            end = intervals[i][1]  # Keep this interval\n    \n    return count",
      "keyInsight": "Sort by end time and greedily keep intervals that don't overlap with the previously selected one.",
      "testCases": [
        {
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "output": "1"
        },
        {
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "output": "2"
        },
        {
          "input": "intervals = [[1,2],[2,3]]",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Greedy Algorithm: Sort by end time and greedily select non-overlapping intervals.",
      "videoId": "nONCGxWoUfM",
      "suggestedNextQuestion": {
        "slug": "partition-labels",
        "title": "Partition Labels",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def eraseOverlapIntervals(intervals):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def eraseOverlapIntervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    res = 0\n    for s, e in intervals:\n        if s >= end:\n            end = e\n        else:\n            res += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "To minimize removals, we want to keep as many non-overlapping intervals as possible.",
            "Greedy approach: always pick the interval that ends earliest to leave more room for others."
          ],
          "code": "def eraseOverlapIntervals(intervals):\n    \"\"\"\n    Intuition:\n    - To minimize removals, we want to keep as many non-overlapping intervals as possible.\n    - Greedy approach: always pick the interval that ends earliest to leave more room for others.\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):  # Iterate through the range.\n        # If current interval starts before previous ends\n        if intervals[i][0] < end:\n            count += 1  # Remove this interval\n        else:\n            end = intervals[i][1]  # Keep this interval\n    \n    return count"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "meeting-rooms": {
      "id": "meeting-rooms",
      "slug": "meeting-rooms",
      "title": "Meeting Rooms",
      "difficulty": "Easy",
      "category": "Intervals",
      "problemStatement": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person can attend all meetings.",
      "videoUrl": "",
      "pattern": "Sorting",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Sort by start times and check for overlaps.",
      "intuition": [
        "If meetings overlap, person can't attend all.",
        "Sort by start time to easily compare adjacent meetings."
      ],
      "visualizationType": "array",
      "initialState": [
        [
          0,
          30
        ],
        [
          5,
          10
        ],
        [
          15,
          20
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Meeting Rooms",
          "transientMessage": "Input: [0,30, 5,10, 15,20]",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 0,30",
          "transientMessage": "Step 1 of 3",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 5,10",
          "transientMessage": "Step 2 of 3",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 15,20",
          "transientMessage": "Step 3 of 3",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def canAttendMeetings(intervals):\n    \"\"\"\n    Intuition:\n    - If meetings overlap, person can't attend all.\n    - Sort by start time to easily compare adjacent meetings.\n    \"\"\"\n    intervals.sort()\n    for i in range(1, len(intervals)):  # Iterate through the range.\n        if intervals[i][0] < intervals[i-1][1]:\n            return False  # Condition not met.\n    return True  # Condition satisfied.",
      "keyInsight": "After sorting, only adjacent meetings need overlap checking.",
      "testCases": [
        {
          "input": "intervals = [[0,30],[5,10],[15,20]]",
          "output": "false"
        },
        {
          "input": "intervals = [[7,10],[2,4]]",
          "output": "true"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Sorting: Sort by start times and check for overlaps.",
      "videoId": "PaJxqZVPhbg",
      "mentalModel": "Like arranging a hand of cards by rank and suit.",
      "initialCode": "def canAttendMeetings(intervals):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def canAttendMeetings(intervals):\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "If meetings overlap, person can't attend all.",
            "Sort by start time to easily compare adjacent meetings."
          ],
          "code": "def canAttendMeetings(intervals):\n    \"\"\"\n    Intuition:\n    - If meetings overlap, person can't attend all.\n    - Sort by start time to easily compare adjacent meetings.\n    \"\"\"\n    intervals.sort()\n    for i in range(1, len(intervals)):  # Iterate through the range.\n        if intervals[i][0] < intervals[i-1][1]:\n            return False  # Condition not met.\n    return True  # Condition satisfied."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "meeting-rooms-ii": {
      "id": "meeting-rooms-ii",
      "slug": "meeting-rooms-ii",
      "title": "Meeting Rooms II",
      "difficulty": "Medium",
      "category": "Intervals",
      "problemStatement": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
      "videoUrl": "",
      "pattern": "Two Pointers + Sorting",
      "patternEmoji": "\ud83d\udc49\ud83d\udc48\ud83d\udcc5",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Sort start/end times separately and use two pointers to track room usage.",
      "intuition": [
        "We don't need to know which meeting is in which room, just how many are happening simultaneously",
        "By sorting start and end times separately, we can efficiently track when meetings begin/end"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          0,
          30
        ],
        [
          5,
          10
        ],
        [
          15,
          20
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Meeting Rooms II",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 0,30",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 5,10",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 15,20",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def minMeetingRooms(intervals):\n    \"\"\"\n    Intuition:\n    - We don't need to know which meeting is in which room, just how many are happening simultaneously\n    - By sorting start and end times separately, we can efficiently track when meetings begin/end\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    starts = sorted([interval[0] for interval in intervals])\n    ends = sorted([interval[1] for interval in intervals])\n    \n    start_ptr = end_ptr = 0\n    rooms_needed = 0\n    max_rooms = 0\n    \n    while start_ptr < len(intervals):\n        if starts[start_ptr] < ends[end_ptr]:\n            rooms_needed += 1\n            max_rooms = max(max_rooms, rooms_needed)  # Take the maximum value.\n            start_ptr += 1\n        else:\n            rooms_needed -= 1\n            end_ptr += 1\n    \n    return max_rooms",
      "keyInsight": "Separating start/end times lets us process events chronologically without tracking specific meetings.",
      "testCases": [
        {
          "input": "intervals = [[0,30],[5,10],[15,20]]",
          "output": "2"
        },
        {
          "input": "intervals = [[7,10],[2,4]]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Two Pointers + Sorting: Sort start/end times separately and use two pointers to track room usage.",
      "videoId": "FdzJmTCVyJU",
      "suggestedNextQuestion": {
        "slug": "middle-of-the-linked-list",
        "title": "Middle of the Linked List",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
      "initialCode": "def minMeetingRooms(intervals):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Try all pairs using nested loops.",
            "Compare each pair and check if condition is met."
          ],
          "code": "def minMeetingRooms(intervals):\n    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])\n    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "We don't need to know which meeting is in which room, just how many are happening simultaneously",
            "By sorting start and end times separately, we can efficiently track when meetings begin/end"
          ],
          "code": "def minMeetingRooms(intervals):\n    \"\"\"\n    Intuition:\n    - We don't need to know which meeting is in which room, just how many are happening simultaneously\n    - By sorting start and end times separately, we can efficiently track when meetings begin/end\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    starts = sorted([interval[0] for interval in intervals])\n    ends = sorted([interval[1] for interval in intervals])\n    \n    start_ptr = end_ptr = 0\n    rooms_needed = 0\n    max_rooms = 0\n    \n    while start_ptr < len(intervals):\n        if starts[start_ptr] < ends[end_ptr]:\n            rooms_needed += 1\n            max_rooms = max(max_rooms, rooms_needed)  # Take the maximum value.\n            start_ptr += 1\n        else:\n            rooms_needed -= 1\n            end_ptr += 1\n    \n    return max_rooms"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3, 4]",
          "output": "[result]",
          "explanation": "Two pointers traverse from both ends."
        },
        {
          "input": "nums = [0, 1]",
          "output": "[result]",
          "explanation": "Edge case with minimum input."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "Array is sorted (if applicable)"
      ],
      "commonMistakes": [
        "Forgetting to handle the case when array is empty",
        "Off-by-one errors in pointer movement",
        "Not considering duplicates"
      ],
      "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1)."
    },
    "minimum-interval-to-include-each-query": {
      "id": "minimum-interval-to-include-each-query",
      "slug": "minimum-interval-to-include-each-query",
      "title": "Minimum Interval to Include Each Query",
      "difficulty": "Hard",
      "category": "Intervals",
      "problemStatement": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.",
      "videoUrl": "",
      "pattern": "Sorting + Min Heap",
      "patternEmoji": "\ud83d\udcca\u26a1",
      "timeComplexity": "O(n log n + m log m)",
      "spaceComplexity": "O(n + m)",
      "oneliner": "Sort intervals and queries, use min heap to track valid intervals.",
      "intuition": [
        "Process queries in sorted order to reuse previous computations",
        "Use min heap to efficiently find the smallest valid interval"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          1,
          4
        ],
        [
          2,
          4
        ],
        [
          3,
          6
        ],
        [
          4,
          4
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Minimum Interval to Include Each Query",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1,4",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2,4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3,6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4,4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              1,
              4
            ],
            [
              2,
              4
            ],
            [
              3,
              6
            ],
            [
              4,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "import heapq\n\ndef minInterval(intervals, queries):\n    \"\"\"\n    Intuition:\n    - Process queries in sorted order to reuse previous computations\n    - Use min heap to efficiently find the smallest valid interval\n    \"\"\"\n    intervals.sort()\n    queries_sorted = sorted((q, i) for i, q in enumerate(queries))\n    result = [-1] * len(queries)\n    min_heap = []  # (size, end)\n    i = 0\n    \n    for query, original_index in queries_sorted:  # Iterate over elements.\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= query:\n            left, right = intervals[i]\n            heapq.heappush(min_heap, (right - left + 1, right))\n            i += 1\n        \n        # Remove intervals that end < query\n        while min_heap and min_heap[0][1] < query:\n            heapq.heappop(min_heap)  # Remove and return last element.\n        \n        # Answer is top of heap if exists\n        if min_heap:\n            result[original_index] = min_heap[0][0]\n    \n    return result  # Return the final result.",
      "keyInsight": "Sort both intervals and queries to process in order and reuse computations.",
      "testCases": [
        {
          "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
          "output": "[3,3,1,4]"
        },
        {
          "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
          "output": "[2,-1,4,6]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Sorting + Min Heap: Sort intervals and queries, use min heap to track valid intervals.",
      "videoId": "5hQ5WWW5awQ",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def minInterval(intervals, queries):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def minInterval_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n + m log m)",
          "spaceComplexity": "O(n + m)",
          "intuition": [
            "Process queries in sorted order to reuse previous computations",
            "Use min heap to efficiently find the smallest valid interval"
          ],
          "code": "import heapq\n\ndef minInterval(intervals, queries):\n    \"\"\"\n    Intuition:\n    - Process queries in sorted order to reuse previous computations\n    - Use min heap to efficiently find the smallest valid interval\n    \"\"\"\n    intervals.sort()\n    queries_sorted = sorted((q, i) for i, q in enumerate(queries))\n    result = [-1] * len(queries)\n    min_heap = []  # (size, end)\n    i = 0\n    \n    for query, original_index in queries_sorted:  # Iterate over elements.\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= query:\n            left, right = intervals[i]\n            heapq.heappush(min_heap, (right - left + 1, right))\n            i += 1\n        \n        # Remove intervals that end < query\n        while min_heap and min_heap[0][1] < query:\n            heapq.heappop(min_heap)  # Remove and return last element.\n        \n        # Answer is top of heap if exists\n        if min_heap:\n            result[original_index] = min_heap[0][0]\n    \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "daily-temperatures": {
      "id": "daily-temperatures",
      "slug": "daily-temperatures",
      "title": "Daily Temperatures",
      "difficulty": "Medium",
      "category": "Stack",
      "problemStatement": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
      "videoUrl": "",
      "pattern": "Monotonic Stack",
      "patternEmoji": "\u2198\ufe0f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use a stack to track indices of decreasing temperatures.",
      "intuition": [
        "We only need to look at future days with higher temperatures",
        "A stack helps us efficiently find the next warmer day"
      ],
      "visualizationType": "array",
      "initialState": [
        73,
        74,
        75,
        71,
        69,
        72,
        76,
        73
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Temps: [73, 74, 75, 71, 69, 72, 76, 73]",
          "transientMessage": "Monotonic decreasing stack",
          "arrayState": [
            73,
            74,
            75,
            71,
            69,
            72,
            76,
            73
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Push index 0",
          "transientMessage": "Stack: [0]",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "74 > 73",
          "transientMessage": "result[0] = 1 - 0 = 1",
          "arrayState": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            },
            {
              "label": "prev",
              "index": 0
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "Push index 1",
          "transientMessage": "Stack: [1]",
          "arrayState": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "75 > 74",
          "transientMessage": "result[1] = 2 - 1 = 1",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            },
            {
              "label": "prev",
              "index": 1
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Push index 2",
          "transientMessage": "Stack: [2]",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Push index 3",
          "transientMessage": "Stack: [2, 3]",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Push index 4",
          "transientMessage": "Stack: [2, 3, 4]",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "72 > 69",
          "transientMessage": "result[4] = 5 - 4 = 1",
          "arrayState": [
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            },
            {
              "label": "prev",
              "index": 4
            }
          ],
          "indices": [
            4,
            5
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "72 > 71",
          "transientMessage": "result[3] = 5 - 3 = 2",
          "arrayState": [
            1,
            1,
            0,
            2,
            1,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            },
            {
              "label": "prev",
              "index": 3
            }
          ],
          "indices": [
            3,
            5
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Push index 5",
          "transientMessage": "Stack: [2, 5]",
          "arrayState": [
            1,
            1,
            0,
            2,
            1,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "76 > 72",
          "transientMessage": "result[5] = 6 - 5 = 1",
          "arrayState": [
            1,
            1,
            0,
            2,
            1,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            },
            {
              "label": "prev",
              "index": 5
            }
          ],
          "indices": [
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "76 > 75",
          "transientMessage": "result[2] = 6 - 2 = 4",
          "arrayState": [
            1,
            1,
            4,
            2,
            1,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            },
            {
              "label": "prev",
              "index": 2
            }
          ],
          "indices": [
            2,
            6
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Push index 6",
          "transientMessage": "Stack: [6]",
          "arrayState": [
            1,
            1,
            4,
            2,
            1,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "accent"
        },
        {
          "step": 15,
          "visual": "Push index 7",
          "transientMessage": "Stack: [6, 7]",
          "arrayState": [
            1,
            1,
            4,
            2,
            1,
            1,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 7
            }
          ],
          "indices": [
            7
          ],
          "color": "accent"
        },
        {
          "step": 16,
          "visual": "Result: [1, 1, 4, 2, 1, 1, 0, 0]",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            1,
            4,
            2,
            1,
            1,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def dailyTemperatures(temperatures):\n    \"\"\"\n    Intuition:\n    - We only need to look at future days with higher temperatures\n    - A stack helps us efficiently find the next warmer day\n    \"\"\"\n    answer = [0] * len(temperatures)\n    stack = []  # Stack of indices\n    \n    for i, temp in enumerate(temperatures):  # Iterate over elements.\n        # While stack not empty and current temp > stack top temp\n        while stack and temp > temperatures[stack[-1]]:\n            prev_index = stack.pop()  # Remove and return last element.\n            answer[prev_index] = i - prev_index\n        stack.append(i)  # Add to end.\n    \n    return answer",
      "keyInsight": "We process temperatures left to right, using a stack to remember previous days waiting for a warmer day.",
      "testCases": [
        {
          "input": "temperatures = [73,74,75,71,69,72,76,73]",
          "output": "[1,1,4,2,1,1,0,0]"
        },
        {
          "input": "temperatures = [30,40,50,60]",
          "output": "[1,1,1,0]"
        },
        {
          "input": "temperatures = [30,60,90]",
          "output": "[1,1,0]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Monotonic Stack: Use a stack to track indices of decreasing temperatures.",
      "videoId": "cTBiBSnjO3c",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def dailyTemperatures(temperatures):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def dailyTemperatures_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "We only need to look at future days with higher temperatures",
            "A stack helps us efficiently find the next warmer day"
          ],
          "code": "def dailyTemperatures(temperatures):\n    \"\"\"\n    Intuition:\n    - We only need to look at future days with higher temperatures\n    - A stack helps us efficiently find the next warmer day\n    \"\"\"\n    answer = [0] * len(temperatures)\n    stack = []  # Stack of indices\n    \n    for i, temp in enumerate(temperatures):  # Iterate over elements.\n        # While stack not empty and current temp > stack top temp\n        while stack and temp > temperatures[stack[-1]]:\n            prev_index = stack.pop()  # Remove and return last element.\n            answer[prev_index] = i - prev_index\n        stack.append(i)  # Add to end.\n    \n    return answer"
        }
      ],
      "examples": [
        {
          "input": "s = \"()[]{}\"",
          "output": "true",
          "explanation": "Valid parentheses matching."
        },
        {
          "input": "s = \"(]\"",
          "output": "false",
          "explanation": "Mismatched brackets."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4",
        "s consists of brackets: ()[]{}"
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "car-fleet": {
      "id": "car-fleet",
      "slug": "car-fleet",
      "title": "Car Fleet",
      "difficulty": "Medium",
      "category": "Stack",
      "problemStatement": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\nYou are given two integer arrays position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\nReturn the number of car fleets that will arrive at the destination.",
      "videoUrl": "",
      "pattern": "Stack",
      "patternEmoji": "\ud83e\udd5e",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Sort cars by position and use stack to count fleets based on arrival times.",
      "intuition": [
        "Cars closer to target with faster speeds may form fleets",
        "If a car arrives before or at same time as car ahead, they form a fleet"
      ],
      "visualizationType": "array",
      "initialState": [
        10,
        8,
        0,
        5,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Car Fleet",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 10",
          "transientMessage": "Iteration 1",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 8",
          "transientMessage": "Iteration 2",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 0",
          "transientMessage": "Iteration 3",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 5",
          "transientMessage": "Iteration 4",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 3",
          "transientMessage": "Iteration 5",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            10,
            8,
            0,
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def carFleet(target, position, speed):\n    \"\"\"\n    Intuition:\n    - Cars closer to target with faster speeds may form fleets\n    - If a car arrives before or at same time as car ahead, they form a fleet\n    \"\"\"\n    cars = sorted(zip(position, speed), reverse=True)\n    times = [(target - pos) / spd for pos, spd in cars]\n    fleets = 0\n    slowest_time = 0\n    \n    for time in times:  # Iterate over elements.\n        if time > slowest_time:\n            fleets += 1\n            slowest_time = time\n    \n    return fleets",
      "keyInsight": "Sort by position and compare arrival times. If a car arrives after the one ahead, it forms a new fleet.",
      "testCases": [
        {
          "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
          "output": "3"
        },
        {
          "input": "target = 10, position = [3], speed = [3]",
          "output": "1"
        },
        {
          "input": "target = 100, position = [0,2,4], speed = [4,2,1]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Initialize empty stack",
        "Iterate through elements",
        "Push/pop based on problem logic",
        "Maintain monotonic property if needed",
        "Process remaining stack elements if needed"
      ],
      "hints": [
        "\ud83e\udde0 What order should elements be processed?",
        "\ud83d\udca1 Consider monotonic stack if comparing neighbors",
        "\ud83d\udd0d When do you push vs pop?"
      ],
      "approach": "Stack: Sort cars by position and use stack to count fleets based on arrival times.",
      "videoId": "Pr6T-3yB9RM",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def carFleet(target, position, speed):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def carFleet_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Cars closer to target with faster speeds may form fleets",
            "If a car arrives before or at same time as car ahead, they form a fleet"
          ],
          "code": "def carFleet(target, position, speed):\n    \"\"\"\n    Intuition:\n    - Cars closer to target with faster speeds may form fleets\n    - If a car arrives before or at same time as car ahead, they form a fleet\n    \"\"\"\n    cars = sorted(zip(position, speed), reverse=True)\n    times = [(target - pos) / spd for pos, spd in cars]\n    fleets = 0\n    slowest_time = 0\n    \n    for time in times:  # Iterate over elements.\n        if time > slowest_time:\n            fleets += 1\n            slowest_time = time\n    \n    return fleets"
        }
      ],
      "examples": [
        {
          "input": "s = \"()[]{}\"",
          "output": "true",
          "explanation": "Valid parentheses matching."
        },
        {
          "input": "s = \"(]\"",
          "output": "false",
          "explanation": "Mismatched brackets."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4",
        "s consists of brackets: ()[]{}"
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "largest-rectangle-in-histogram": {
      "id": "largest-rectangle-in-histogram",
      "slug": "largest-rectangle-in-histogram",
      "title": "Largest Rectangle in Histogram",
      "difficulty": "Hard",
      "category": "Stack",
      "problemStatement": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
      "videoUrl": "",
      "pattern": "Monotonic Stack",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use a stack to track increasing bar heights and calculate areas when heights decrease.",
      "intuition": [
        "For each bar, the largest rectangle is limited by the nearest smaller bars on left and right",
        "A stack helps efficiently find these boundaries by maintaining increasing heights"
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        1,
        5,
        6,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Largest Rectangle in Histogram",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 5",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 6",
          "transientMessage": "Iteration 4",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 3",
          "transientMessage": "Iteration 6",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            1,
            5,
            6,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def largestRectangleArea(heights):\n    \"\"\"\n    Intuition:\n    - For each bar, the largest rectangle is limited by the nearest smaller bars on left and right\n    - A stack helps efficiently find these boundaries by maintaining increasing heights\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    max_area = 0\n    heights.append(0)  # Add sentinel to process remaining bars\n    \n    for i in range(len(heights)):  # Iterate through the range.\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # Remove and return last element.\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)  # Take the maximum value.\n        stack.append(i)  # Add to end.\n    \n    heights.pop()  # Remove sentinel\n    return max_area",
      "keyInsight": "When a bar with smaller height is encountered, we can calculate the maximum area for all taller bars in the stack.",
      "testCases": [
        {
          "input": "heights = [2,1,5,6,2,3]",
          "output": "10"
        },
        {
          "input": "heights = [2,4]",
          "output": "4"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Monotonic Stack: Use a stack to track increasing bar heights and calculate areas when heights decrease.",
      "videoId": "zx5Sw9130L0",
      "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
      "initialCode": "def largestRectangleArea(heights):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to simulate stack operations.",
            "For each element, look back through all previous elements."
          ],
          "code": "def largestRectangleArea_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "For each bar, the largest rectangle is limited by the nearest smaller bars on left and right",
            "A stack helps efficiently find these boundaries by maintaining increasing heights"
          ],
          "code": "def largestRectangleArea(heights):\n    \"\"\"\n    Intuition:\n    - For each bar, the largest rectangle is limited by the nearest smaller bars on left and right\n    - A stack helps efficiently find these boundaries by maintaining increasing heights\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    max_area = 0\n    heights.append(0)  # Add sentinel to process remaining bars\n    \n    for i in range(len(heights)):  # Iterate through the range.\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # Remove and return last element.\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)  # Take the maximum value.\n        stack.append(i)  # Add to end.\n    \n    heights.pop()  # Remove sentinel\n    return max_area"
        }
      ],
      "examples": [
        {
          "input": "s = \"()[]{}\"",
          "output": "true",
          "explanation": "Valid parentheses matching."
        },
        {
          "input": "s = \"(]\"",
          "output": "false",
          "explanation": "Mismatched brackets."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4",
        "s consists of brackets: ()[]{}"
      ],
      "commonMistakes": [
        "Popping from empty stack",
        "Not clearing stack between operations",
        "Incorrect order of push/pop"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reorder-list": {
      "id": "reorder-list",
      "slug": "reorder-list",
      "title": "Reorder List",
      "difficulty": "Medium",
      "category": "Linked List",
      "problemStatement": "You are given the head of a singly linked-list. The list can be represented as:\nReorder the list to be on the following form:\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
      "videoUrl": "",
      "pattern": "Linked List Reversal + Merge",
      "patternEmoji": "\ud83d\udd04\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Split list in half, reverse second half, then merge alternately.",
      "intuition": [
        "Break the list into two halves at the middle point",
        "Reverse the second half and merge both halves alternately"
      ],
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        2,
        3,
        4,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reorder List",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 5",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reorderList(head):\n    \"\"\"\n    Intuition:\n    - Break the list into two halves at the middle point\n    - Reverse the second half and merge both halves alternately\n    \"\"\"\n    if not head or not head.next:\n        return head\n    \n    # Find the middle\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Break the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n    \n    return head",
      "keyInsight": "Use slow/fast pointers to find mid, then reverse and merge.",
      "testCases": [
        {
          "input": "head = [1,2,3,4]",
          "output": "[1,4,2,3]"
        },
        {
          "input": "head = [1,2,3,4,5]",
          "output": "[1,5,2,4,3]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Linked List Reversal + Merge: Split list in half, reverse second half, then merge alternately.",
      "videoId": "S5bfdUTrKLM",
      "suggestedNextQuestion": {
        "slug": "reverse-linked-list-ii",
        "title": "Reverse Linked List II",
        "difficulty": "Medium",
        "pattern": "Linked List"
      },
      "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
      "initialCode": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reorderList(head):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Use extra array to store all values.",
            "Process in array, then rebuild list."
          ],
          "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Break the list into two halves at the middle point",
            "Reverse the second half and merge both halves alternately"
          ],
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reorderList(head):\n    \"\"\"\n    Intuition:\n    - Break the list into two halves at the middle point\n    - Reverse the second half and merge both halves alternately\n    \"\"\"\n    if not head or not head.next:\n        return head\n    \n    # Find the middle\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Break the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n    \n    return head"
        }
      ],
      "examples": [
        {
          "input": "head = [1, 2, 3, 4, 5]",
          "output": "[result]",
          "explanation": "Process linked list nodes."
        },
        {
          "input": "head = [1]",
          "output": "[1]",
          "explanation": "Single node edge case."
        }
      ],
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^4 <= Node.val <= 10^4"
      ],
      "commonMistakes": [
        "Losing reference to head",
        "Not handling single node case",
        "Creating cycles accidentally"
      ],
      "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification."
    },
    "find-the-duplicate-number": {
      "id": "find-the-duplicate-number",
      "slug": "find-the-duplicate-number",
      "title": "Find the Duplicate Number",
      "difficulty": "Medium",
      "category": "Linked List",
      "problemStatement": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and using only constant extra space.",
      "videoUrl": "",
      "pattern": "Floyd's Cycle Detection",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Treat array values as pointers and detect cycle using Floyd's algorithm.",
      "intuition": [
        "Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices",
        "Duplicate number creates a cycle - use slow/fast pointers to detect it"
      ],
      "visualizationType": "linkedlist",
      "initialState": [
        1,
        3,
        4,
        2,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Find the Duplicate Number",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 4",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            3,
            4,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def findDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices\n    - Duplicate number creates a cycle - use slow/fast pointers to detect it\n    \"\"\"\n    # Phase 1: Detect cycle using Floyd's algorithm\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]        # Move one step\n        fast = nums[nums[fast]]  # Move two steps\n        if slow == fast:\n            break\n    \n    # Phase 2: Find cycle entrance (duplicate number)\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow  # Return the result node.",
      "keyInsight": "Values in array can be treated as pointers to indices, creating a linked list with a cycle due to the duplicate.",
      "testCases": [
        {
          "input": "nums = [1,3,4,2,2]",
          "output": "2"
        },
        {
          "input": "nums = [3,1,3,4,2]",
          "output": "3"
        },
        {
          "input": "nums = [3,3,3,3,3]",
          "output": "3"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Floyd's Cycle Detection: Treat array values as pointers and detect cycle using Floyd's algorithm.",
      "videoId": "wjYnzkAhcNk",
      "suggestedNextQuestion": {
        "slug": "longest-mountain-in-array",
        "title": "Longest Mountain in Array",
        "difficulty": "Medium",
        "pattern": "Two Pointers"
      },
      "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
      "initialCode": "def findDuplicate(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findDuplicate(nums):\n    # Brute force: nested loops\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return nums[i]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices",
            "Duplicate number creates a cycle - use slow/fast pointers to detect it"
          ],
          "code": "def findDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices\n    - Duplicate number creates a cycle - use slow/fast pointers to detect it\n    \"\"\"\n    # Phase 1: Detect cycle using Floyd's algorithm\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]        # Move one step\n        fast = nums[nums[fast]]  # Move two steps\n        if slow == fast:\n            break\n    \n    # Phase 2: Find cycle entrance (duplicate number)\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow  # Return the result node."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "balanced-binary-tree": {
      "id": "balanced-binary-tree",
      "slug": "balanced-binary-tree",
      "title": "Balanced Binary Tree",
      "difficulty": "Easy",
      "category": "Binary Tree General",
      "problemStatement": "Given a binary tree, determine if it is height-balanced.",
      "videoUrl": "",
      "pattern": "Tree Recursion",
      "patternEmoji": "\ud83c\udf32",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Check balance condition recursively for each node.",
      "intuition": [
        "A tree is balanced if left and right subtrees are balanced",
        "And their heights differ by at most 1"
      ],
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Balanced Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Visit root node",
          "transientMessage": "Start from root (index 0)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Traverse left subtree",
          "transientMessage": "Process left child (index 1)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Traverse right subtree",
          "transientMessage": "Process right child (index 2)",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Continue recursively",
          "transientMessage": "Process remaining nodes",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3,
            4,
            5,
            6
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isBalanced(root):\n    \"\"\"\n    Intuition:\n    - A tree is balanced if left and right subtrees are balanced\n    - And their heights differ by at most 1\n    \"\"\"\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n            \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n            \n        if abs(left_height - right_height) > 1:\n            return -1\n            \n        return max(left_height, right_height) + 1  # Take the maximum value.\n    \n    return check_height(root) != -1",
      "keyInsight": "Use -1 as sentinel value to propagate imbalance up the tree.",
      "testCases": [
        {
          "input": "root = [3,9,20,null,null,15,7]",
          "output": "true"
        },
        {
          "input": "root = [1,2,2,3,3,null,null,4,4]",
          "output": "false"
        },
        {
          "input": "root = []",
          "output": "true"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Tree Recursion: Check balance condition recursively for each node.",
      "videoId": "QfJsau0ItOY",
      "suggestedNextQuestion": {
        "slug": "count-complete-tree-nodes",
        "title": "Count Complete Tree Nodes",
        "difficulty": "Easy",
        "pattern": "Trees"
      },
      "mentalModel": "Like Russian dolls. Open one to find a smaller version inside, until you hit the center.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isBalanced(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "A tree is balanced if left and right subtrees are balanced",
            "And their heights differ by at most 1"
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isBalanced(root):\n    \"\"\"\n    Intuition:\n    - A tree is balanced if left and right subtrees are balanced\n    - And their heights differ by at most 1\n    \"\"\"\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n            \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n            \n        if abs(left_height - right_height) > 1:\n            return -1\n            \n        return max(left_height, right_height) + 1  # Take the maximum value.\n    \n    return check_height(root) != -1"
        }
      ],
      "examples": [
        {
          "input": "root = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Traverse tree structure."
        },
        {
          "input": "root = []",
          "output": "null",
          "explanation": "Empty tree edge case."
        }
      ],
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^4 <= Node.val <= 10^4"
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs."
    },
    "subtree-of-another-tree": {
      "id": "subtree-of-another-tree",
      "slug": "subtree-of-another-tree",
      "title": "Subtree of Another Tree",
      "difficulty": "Easy",
      "category": "Binary Tree General",
      "problemStatement": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
      "videoUrl": "",
      "pattern": "Tree Traversal + Subtree Matching",
      "patternEmoji": "\ud83c\udf32\ud83d\udd0d",
      "timeComplexity": "O(m\u00d7n)",
      "spaceComplexity": "O(m+n)",
      "oneliner": "Traverse main tree and check if any node matches the subRoot tree structure.",
      "intuition": [
        "We need to check if subRoot appears as a subtree in root.",
        "For each node in root, we can recursively check if the subtree matches subRoot."
      ],
      "visualizationType": "tree",
      "initialState": [
        3,
        4,
        5,
        1,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Compare root(3) with subRoot(4)",
          "transientMessage": "3 != 4. Check subtrees.",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "warning"
        },
        {
          "step": 2,
          "visual": "Check Left: node 4 matches subRoot 4",
          "transientMessage": "Roots match. Check children...",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "sub",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "4->1 matches 4->1",
          "transientMessage": "Left child matches",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "4->2 matches 4->2",
          "transientMessage": "Right child matches",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "R",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "All nodes match!",
          "transientMessage": "Subtree found! \u2705",
          "arrayState": [
            3,
            4,
            5,
            1,
            2
          ],
          "pointers": [
            {
              "label": "Found",
              "index": 1
            }
          ],
          "indices": [
            1,
            3,
            4
          ],
          "color": "success"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSubtree(root, subRoot):\n    \"\"\"\n    Intuition:\n    - We need to check if subRoot appears as a subtree in root.\n    - For each node in root, we can recursively check if the subtree matches subRoot.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if isSameTree(root, subRoot):\n        return True  # Condition satisfied.\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True  # Condition satisfied.\n    if not p or not q or p.val != q.val:\n        return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
      "keyInsight": "For each node in the main tree, check if the subtree rooted at that node matches the target subtree.",
      "testCases": [
        {
          "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
          "output": "true"
        },
        {
          "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
          "output": "false"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Tree Traversal + Subtree Matching: Traverse main tree and check if any node matches the subRoot tree structure.",
      "videoId": "E36O5SWp-LE",
      "suggestedNextQuestion": {
        "slug": "balance-a-binary-search-tree",
        "title": "Balance a Binary Search Tree",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSubtree(root, subRoot):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m\u00d7n)",
          "spaceComplexity": "O(m+n)",
          "intuition": [
            "We need to check if subRoot appears as a subtree in root.",
            "For each node in root, we can recursively check if the subtree matches subRoot."
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSubtree(root, subRoot):\n    \"\"\"\n    Intuition:\n    - We need to check if subRoot appears as a subtree in root.\n    - For each node in root, we can recursively check if the subtree matches subRoot.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if isSameTree(root, subRoot):\n        return True  # Condition satisfied.\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True  # Condition satisfied.\n    if not p or not q or p.val != q.val:\n        return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
        }
      ],
      "examples": [
        {
          "input": "root = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Traverse tree structure."
        },
        {
          "input": "root = []",
          "output": "null",
          "explanation": "Empty tree edge case."
        }
      ],
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^4 <= Node.val <= 10^4"
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs."
    },
    "lowest-common-ancestor-of-a-binary-search-tree": {
      "id": "lowest-common-ancestor-of-a-binary-search-tree",
      "slug": "lowest-common-ancestor-of-a-binary-search-tree",
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "difficulty": "Medium",
      "category": "Binary Tree General",
      "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
      "videoUrl": "",
      "pattern": "BST Property",
      "patternEmoji": "\ud83c\udf32",
      "timeComplexity": "O(h)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use BST property to navigate toward LCA.",
      "intuition": [
        "In a BST, all left descendants are smaller and right descendants are larger.",
        "The LCA is the first node where p and q diverge to different subtrees."
      ],
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Lowest Common Ancestor of a Binary Search Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - In a BST, all left descendants are smaller and right descendants are larger.\n    - The LCA is the first node where p and q diverge to different subtrees.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n    return None",
      "keyInsight": "Use BST ordering: if both nodes are on same side, move there. Otherwise current node is LCA.",
      "testCases": [
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
          "output": "6"
        },
        {
          "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
          "output": "2"
        },
        {
          "input": "root = [2,1], p = 2, q = 1",
          "output": "2"
        }
      ],
      "walkthrough": [
        "Start at root node of BST",
        "Use BST property: left < root < right",
        "If p.val < root.val AND q.val < root.val: go left",
        "If p.val > root.val AND q.val > root.val: go right",
        "Else: current node is the LCA (first divergence point)",
        "Return the LCA node's value"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "BST Property: Use BST property to navigate toward LCA.",
      "videoId": "gs2LMfuOR9k",
      "suggestedNextQuestion": {
        "slug": "lowest-common-ancestor-of-a-bst",
        "title": "Lowest Common Ancestor of a BST",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
      "initialCode": "def lowestCommonAncestor(root, p, q):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    if p.val < root.val and q.val < root.val:\n        return lowestCommonAncestor(root.left, p, q)\n    elif p.val > root.val and q.val > root.val:\n        return lowestCommonAncestor(root.right, p, q)\n    return root"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(h)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "In a BST, all left descendants are smaller and right descendants are larger.",
            "The LCA is the first node where p and q diverge to different subtrees."
          ],
          "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - In a BST, all left descendants are smaller and right descendants are larger.\n    - The LCA is the first node where p and q diverge to different subtrees.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n    return None"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "count-good-nodes-in-binary-tree": {
      "id": "count-good-nodes-in-binary-tree",
      "slug": "count-good-nodes-in-binary-tree",
      "title": "Count Good Nodes in Binary Tree",
      "difficulty": "Medium",
      "category": "Binary Tree General",
      "problemStatement": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.",
      "videoUrl": "",
      "pattern": "DFS Traversal",
      "patternEmoji": "\ud83c\udf32",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(h)",
      "oneliner": "Traverse tree while tracking max value seen so far.",
      "intuition": [
        "A node is good if its value is \u2265 all values in the path from root",
        "Track the maximum value encountered during DFS traversal"
      ],
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Count Good Nodes in Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def goodNodes(root):\n    \"\"\"\n    Intuition:\n    - A node is good if its value is \u2265 all values in the path from root\n    - Track the maximum value encountered during DFS traversal\n    \"\"\"\n    def dfs(node, max_so_far):\n        if not node:\n            return 0\n        count = 1 if node.val >= max_so_far else 0\n        new_max = max(max_so_far, node.val)  # Take the maximum value.\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        return count\n    return dfs(root, float('-inf'))",
      "keyInsight": "Use DFS with running maximum to determine if current node is good.",
      "testCases": [
        {
          "input": "root = [3,1,4,3,null,1,5]",
          "output": "4"
        },
        {
          "input": "root = [3,3,null,4,2]",
          "output": "3"
        },
        {
          "input": "root = [1]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "DFS Traversal: Traverse tree while tracking max value seen so far.",
      "videoId": "7cp5imvDzl4",
      "suggestedNextQuestion": {
        "slug": "course-schedule",
        "title": "Course Schedule",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def goodNodes(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def goodNodes(root):\n    def dfs(node, maxVal):\n        if not node: return 0\n        res = 1 if node.val >= maxVal else 0\n        maxVal = max(maxVal, node.val)\n        res += dfs(node.left, maxVal)\n        res += dfs(node.right, maxVal)\n        return res\n    return dfs(root, root.val)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(h)",
          "intuition": [
            "A node is good if its value is \u2265 all values in the path from root",
            "Track the maximum value encountered during DFS traversal"
          ],
          "code": "def goodNodes(root):\n    \"\"\"\n    Intuition:\n    - A node is good if its value is \u2265 all values in the path from root\n    - Track the maximum value encountered during DFS traversal\n    \"\"\"\n    def dfs(node, max_so_far):\n        if not node:\n            return 0\n        count = 1 if node.val >= max_so_far else 0\n        new_max = max(max_so_far, node.val)  # Take the maximum value.\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        return count\n    return dfs(root, float('-inf'))"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "serialize-and-deserialize-binary-tree": {
      "id": "serialize-and-deserialize-binary-tree",
      "slug": "serialize-and-deserialize-binary-tree",
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "Hard",
      "category": "Binary Tree General",
      "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
      "videoUrl": "",
      "pattern": "Tree Traversal",
      "patternEmoji": "\ud83c\udf32",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use preorder traversal with null markers for serialization and reconstruction.",
      "intuition": [
        "Preorder traversal (root, left, right) preserves tree structure",
        "Use special marker (like 'null') to represent missing nodes"
      ],
      "visualizationType": "tree",
      "initialState": [
        1,
        2,
        3,
        4,
        5,
        6,
        7
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Serialize and Deserialize Binary Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef serializeDeserialize(root):\n    \"\"\"\n    Intuition:\n    - Preorder traversal (root, left, right) preserves tree structure\n    - Use special marker (like 'null') to represent missing nodes\n    \"\"\"\n    # Identity function - input tree equals output tree\n    return root",
      "keyInsight": "Preorder traversal with null markers uniquely represents any binary tree structure.",
      "testCases": [
        {
          "input": "root = [1,2,3,null,null,4,5]",
          "output": "[1, 2, 3, None, None, 4, 5]"
        },
        {
          "input": "root = []",
          "output": "[]"
        }
      ],
      "walkthrough": [
        "Serialize: Convert tree to string using preorder traversal",
        "Use 'null' marker for empty nodes",
        "Deserialize: Parse string back to tree",
        "Use recursion to rebuild tree structure",
        "Maintain index pointer during deserialization"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Tree Traversal: Use preorder traversal with null markers for serialization and reconstruction.",
      "videoId": "u4JAi2JJhI8",
      "mentalModel": "Like exploring a maze. You visit every corner systematically.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef serializeDeserialize(root):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Preorder traversal (root, left, right) preserves tree structure",
            "Use special marker (like 'null') to represent missing nodes"
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef serializeDeserialize(root):\n    \"\"\"\n    Intuition:\n    - Preorder traversal (root, left, right) preserves tree structure\n    - Use special marker (like 'null') to represent missing nodes\n    \"\"\"\n    # Identity function - input tree equals output tree\n    return root"
        }
      ],
      "examples": [
        {
          "input": "root = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Traverse tree structure."
        },
        {
          "input": "root = []",
          "output": "null",
          "explanation": "Empty tree edge case."
        }
      ],
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^4 <= Node.val <= 10^4"
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs."
    },
    "max-area-of-island": {
      "id": "max-area-of-island",
      "slug": "max-area-of-island",
      "title": "Max Area of Island",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.",
      "videoUrl": "",
      "pattern": "DFS on Grid",
      "patternEmoji": "\ud83c\udf0a",
      "timeComplexity": "O(m\u00d7n)",
      "spaceComplexity": "O(m\u00d7n)",
      "oneliner": "Use DFS from each land cell to explore and count island areas.",
      "intuition": [
        "We need to explore connected components of 1s in a 2D grid",
        "DFS is perfect for exploring all connected land cells from a starting point"
      ],
      "visualizationType": "grid",
      "initialState": [
        [
          0,
          0,
          1,
          0
        ],
        [
          0,
          1,
          1,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Max Area of Island",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 0",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              0,
              0,
              1,
              0
            ],
            [
              0,
              1,
              1,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def maxAreaOfIsland(grid):\n    \"\"\"\n    Intuition:\n    - We need to explore connected components of 1s in a 2D grid\n    - DFS is perfect for exploring all connected land cells from a starting point\n    \"\"\"\n    if not grid:\n        return 0\n    \n    def dfs(r, c):\n        if (r < 0 or c < 0 or r >= len(grid) or \n            c >= len(grid[0]) or grid[r][c] == 0):\n            return 0\n        \n        grid[r][c] = 0  # Mark as visited\n        area = 1\n        \n        # Explore all 4 directions\n        area += dfs(r+1, c)\n        area += dfs(r-1, c)\n        area += dfs(r, c+1)\n        area += dfs(r, c-1)\n        \n        return area\n    \n    max_area = 0\n    for r in range(len(grid)):  # Iterate through the range.\n        for c in range(len(grid[0])):  # Iterate through the range.\n            if grid[r][c] == 1:\n                max_area = max(max_area, dfs(r, c))  # Take the maximum value.\n    \n    return max_area",
      "keyInsight": "DFS explores connected components; we can modify grid to mark visited cells.",
      "testCases": [
        {
          "input": "grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]",
          "output": "6"
        },
        {
          "input": "grid = [[0,0,0,0,0,0,0,0]]",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "DFS on Grid: Use DFS from each land cell to explore and count island areas.",
      "videoId": "iJGr1OtmH0c",
      "suggestedNextQuestion": {
        "slug": "minimum-depth-of-binary-tree",
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def maxAreaOfIsland(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def maxAreaOfIsland(grid):\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    def dfs(r, c):\n        if r<0 or r==rows or c<0 or c==cols or grid[r][c]==0 or (r,c) in visit:\n            return 0\n        visit.add((r, c))\n        return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1)\n    \n    area = 0\n    for r in range(rows):\n        for c in range(cols):\n            area = max(area, dfs(r, c))\n    return area"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m\u00d7n)",
          "spaceComplexity": "O(m\u00d7n)",
          "intuition": [
            "We need to explore connected components of 1s in a 2D grid",
            "DFS is perfect for exploring all connected land cells from a starting point"
          ],
          "code": "def maxAreaOfIsland(grid):\n    \"\"\"\n    Intuition:\n    - We need to explore connected components of 1s in a 2D grid\n    - DFS is perfect for exploring all connected land cells from a starting point\n    \"\"\"\n    if not grid:\n        return 0\n    \n    def dfs(r, c):\n        if (r < 0 or c < 0 or r >= len(grid) or \n            c >= len(grid[0]) or grid[r][c] == 0):\n            return 0\n        \n        grid[r][c] = 0  # Mark as visited\n        area = 1\n        \n        # Explore all 4 directions\n        area += dfs(r+1, c)\n        area += dfs(r-1, c)\n        area += dfs(r, c+1)\n        area += dfs(r, c-1)\n        \n        return area\n    \n    max_area = 0\n    for r in range(len(grid)):  # Iterate through the range.\n        for c in range(len(grid[0])):  # Iterate through the range.\n            if grid[r][c] == 1:\n                max_area = max(max_area, dfs(r, c))  # Take the maximum value.\n    \n    return max_area"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "pacific-atlantic-water-flow": {
      "id": "pacific-atlantic-water-flow",
      "slug": "pacific-atlantic-water-flow",
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
      "videoUrl": "",
      "pattern": "Multi-source BFS",
      "patternEmoji": "\ud83c\udf0a",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m*n)",
      "oneliner": "Reverse the flow - start from oceans and find reachable cells.",
      "intuition": [
        "Water flows from high to low elevation, but we can reverse this thinking",
        "Start from ocean edges and work backwards to find all cells that can reach each ocean"
      ],
      "visualizationType": "matrix",
      "initialState": [
        [
          1,
          2,
          2,
          3,
          5
        ],
        [
          3,
          2,
          3,
          4,
          4
        ],
        [
          2,
          4,
          5,
          3,
          1
        ],
        [
          6,
          7,
          1,
          4,
          5
        ],
        [
          5,
          1,
          1,
          2,
          4
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Pacific Atlantic Water Flow",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 2",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 3",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 2",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              2,
              2,
              3,
              5
            ],
            [
              3,
              2,
              3,
              4,
              4
            ],
            [
              2,
              4,
              5,
              3,
              1
            ],
            [
              6,
              7,
              1,
              4,
              5
            ],
            [
              5,
              1,
              1,
              2,
              4
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "from collections import deque\n\ndef pacificAtlantic(heights):\n    \"\"\"\n    Intuition:\n    - Water flows from high to low elevation, but we can reverse this thinking\n    - Start from ocean edges and work backwards to find all cells that can reach each ocean\n    \"\"\"\n    if not heights or not heights[0]:\n        return []\n    \n    m, n = len(heights), len(heights[0])\n    \n    # Initialize queues for both oceans\n    pacific_queue = deque()\n    atlantic_queue = deque()\n    \n    # Add all edge cells to respective queues\n    for i in range(m):  # Iterate through the range.\n        pacific_queue.append((i, 0))  # Add to end.\n        atlantic_queue.append((i, n-1))  # Add to end.\n    for j in range(n):  # Iterate through the range.\n        pacific_queue.append((0, j))  # Add to end.\n        atlantic_queue.append((m-1, j))  # Add to end.\n    \n    def bfs(queue):\n        reachable = set()\n        while queue:  # Process nodes until queue is empty.\n            row, col = queue.popleft()  # Remove from front of queue.\n            reachable.add((row, col))\n            \n            # Check all 4 directions\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # Iterate over elements.\n                new_row, new_col = row + dr, col + dc\n                \n                # Check bounds\n                if (0 <= new_row < m and 0 <= new_col < n and \n                    (new_row, new_col) not in reachable and\n                    heights[new_row][new_col] >= heights[row][col]):\n                    queue.append((new_row, new_col))  # Add to end.\n        return reachable\n    \n    # Find cells reachable from each ocean\n    pacific_reachable = bfs(pacific_queue)\n    atlantic_reachable = bfs(atlantic_queue)\n    \n    # Find intersection\n    common_cells = pacific_reachable.intersection(atlantic_reachable)\n    \n    # Convert to list of lists\n    return [[r, c] for r, c in common_cells]",
      "keyInsight": "Instead of checking if each cell can reach an ocean, start from oceans and find all cells that can be reached (reverse thinking).",
      "testCases": [
        {
          "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
          "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
        },
        {
          "input": "heights = [[1]]",
          "output": "[[0,0]]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Multi-source BFS: Reverse the flow - start from oceans and find reachable cells.",
      "videoId": "s-VkcjHqkGI",
      "suggestedNextQuestion": {
        "slug": "redundant-connection",
        "title": "Redundant Connection",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def pacificAtlantic(heights):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def pacificAtlantic(heights):\n    ROWS, COLS = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    \n    def dfs(r, c, visit, prevHeight):\n        if ((r, c) in visit or r < 0 or c < 0 or r == ROWS or c == COLS or\n            heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])\n        \n    for c in range(COLS):\n        dfs(0, c, pac, heights[0][c])\n        dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n        \n    for r in range(ROWS):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n        \n    return list(pac & atl)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m*n)",
          "intuition": [
            "Water flows from high to low elevation, but we can reverse this thinking",
            "Start from ocean edges and work backwards to find all cells that can reach each ocean"
          ],
          "code": "from collections import deque\n\ndef pacificAtlantic(heights):\n    \"\"\"\n    Intuition:\n    - Water flows from high to low elevation, but we can reverse this thinking\n    - Start from ocean edges and work backwards to find all cells that can reach each ocean\n    \"\"\"\n    if not heights or not heights[0]:\n        return []\n    \n    m, n = len(heights), len(heights[0])\n    \n    # Initialize queues for both oceans\n    pacific_queue = deque()\n    atlantic_queue = deque()\n    \n    # Add all edge cells to respective queues\n    for i in range(m):  # Iterate through the range.\n        pacific_queue.append((i, 0))  # Add to end.\n        atlantic_queue.append((i, n-1))  # Add to end.\n    for j in range(n):  # Iterate through the range.\n        pacific_queue.append((0, j))  # Add to end.\n        atlantic_queue.append((m-1, j))  # Add to end.\n    \n    def bfs(queue):\n        reachable = set()\n        while queue:  # Process nodes until queue is empty.\n            row, col = queue.popleft()  # Remove from front of queue.\n            reachable.add((row, col))\n            \n            # Check all 4 directions\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # Iterate over elements.\n                new_row, new_col = row + dr, col + dc\n                \n                # Check bounds\n                if (0 <= new_row < m and 0 <= new_col < n and \n                    (new_row, new_col) not in reachable and\n                    heights[new_row][new_col] >= heights[row][col]):\n                    queue.append((new_row, new_col))  # Add to end.\n        return reachable\n    \n    # Find cells reachable from each ocean\n    pacific_reachable = bfs(pacific_queue)\n    atlantic_reachable = bfs(atlantic_queue)\n    \n    # Find intersection\n    common_cells = pacific_reachable.intersection(atlantic_reachable)\n    \n    # Convert to list of lists\n    return [[r, c] for r, c in common_cells]"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "rotting-oranges": {
      "id": "rotting-oranges",
      "slug": "rotting-oranges",
      "title": "Rotting Oranges",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You are given an m x n grid where each cell can have one of three values:\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
      "videoUrl": "",
      "pattern": "BFS",
      "patternEmoji": "\ud83e\udda0",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m*n)",
      "oneliner": "Use BFS from all initial rotten oranges to simulate rotting.",
      "intuition": [
        "Rotten oranges spread simultaneously, so we need level-by-level processing.",
        "Start BFS from all rotten oranges at time 0."
      ],
      "visualizationType": "grid",
      "initialState": [
        [
          2,
          1,
          1
        ],
        [
          1,
          1,
          0
        ],
        [
          0,
          1,
          1
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Rotting Oranges",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 2",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              2,
              1,
              1
            ],
            [
              1,
              1,
              0
            ],
            [
              0,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "from collections import deque\n\ndef orangesRotting(grid):\n    \"\"\"\n    Intuition:\n    - Rotten oranges spread simultaneously, so we need level-by-level processing.\n    - Start BFS from all rotten oranges at time 0.\n    \"\"\"\n    if not grid:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    fresh_count = 0\n    queue = deque()\n    \n    # Initialize queue with rotten oranges and count fresh ones\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == 2:\n                queue.append((r, c))  # Add to end.\n            elif grid[r][c] == 1:\n                fresh_count += 1\n    \n    # If no fresh oranges, return 0\n    if fresh_count == 0:\n        return 0\n    \n    # BFS to rot oranges\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    minutes = 0\n    \n    while queue and fresh_count > 0:\n        minutes += 1\n        # Process all currently rotten oranges\n        for _ in range(len(queue)):  # Iterate through the range.\n            r, c = queue.popleft()  # Remove from front of queue.\n            \n            # Check all 4 directions\n            for dr, dc in directions:  # Iterate over elements.\n                nr, nc = r + dr, c + dc\n                \n                # If neighbor is a fresh orange, rot it\n                if (0 <= nr < rows and \n                    0 <= nc < cols and \n                    grid[nr][nc] == 1):\n                    grid[nr][nc] = 2\n                    fresh_count -= 1\n                    queue.append((nr, nc))  # Add to end.\n    \n    # If there are still fresh oranges, impossible\n    return minutes if fresh_count == 0 else -1",
      "keyInsight": "Multi-source BFS: all rotten oranges at time 0 start spreading simultaneously.",
      "testCases": [
        {
          "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
          "output": "4"
        },
        {
          "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
          "output": "-1"
        },
        {
          "input": "grid = [[0,2]]",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Initialize queue with starting node(s)",
        "Mark starting nodes as visited",
        "While queue not empty, process current level",
        "Add unvisited neighbors to queue",
        "Track level/distance as needed"
      ],
      "hints": [
        "\ud83e\udde0 BFS finds shortest path in unweighted graphs",
        "\ud83d\udca1 Process nodes level by level",
        "\ud83d\udd0d Track visited to avoid cycles"
      ],
      "approach": "BFS: Use BFS from all initial rotten oranges to simulate rotting.",
      "videoId": "y704fEOx0s0",
      "suggestedNextQuestion": {
        "slug": "snakes-and-ladders",
        "title": "Snakes and Ladders",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def orangesRotting(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def orangesRotting(grid):\n    q = []\n    fresh = 0\n    rows, cols = len(grid), len(grid[0])\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1: fresh += 1\n            if grid[r][c] == 2: q.append((r, c))\n            \n    time = 0\n    while q and fresh > 0:\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                row, col = r + dr, c + dc\n                if (row < 0 or row == rows or col < 0 or col == cols or\n                    grid[row][col] != 1):\n                    continue\n                grid[row][col] = 2\n                q.append((row, col))\n                fresh -= 1\n        time += 1\n    return time if fresh == 0 else -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m*n)",
          "intuition": [
            "Rotten oranges spread simultaneously, so we need level-by-level processing.",
            "Start BFS from all rotten oranges at time 0."
          ],
          "code": "from collections import deque\n\ndef orangesRotting(grid):\n    \"\"\"\n    Intuition:\n    - Rotten oranges spread simultaneously, so we need level-by-level processing.\n    - Start BFS from all rotten oranges at time 0.\n    \"\"\"\n    if not grid:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    fresh_count = 0\n    queue = deque()\n    \n    # Initialize queue with rotten oranges and count fresh ones\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == 2:\n                queue.append((r, c))  # Add to end.\n            elif grid[r][c] == 1:\n                fresh_count += 1\n    \n    # If no fresh oranges, return 0\n    if fresh_count == 0:\n        return 0\n    \n    # BFS to rot oranges\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    minutes = 0\n    \n    while queue and fresh_count > 0:\n        minutes += 1\n        # Process all currently rotten oranges\n        for _ in range(len(queue)):  # Iterate through the range.\n            r, c = queue.popleft()  # Remove from front of queue.\n            \n            # Check all 4 directions\n            for dr, dc in directions:  # Iterate over elements.\n                nr, nc = r + dr, c + dc\n                \n                # If neighbor is a fresh orange, rot it\n                if (0 <= nr < rows and \n                    0 <= nc < cols and \n                    grid[nr][nc] == 1):\n                    grid[nr][nc] = 2\n                    fresh_count -= 1\n                    queue.append((nr, nc))  # Add to end.\n    \n    # If there are still fresh oranges, impossible\n    return minutes if fresh_count == 0 else -1"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "walls-and-gates": {
      "id": "walls-and-gates",
      "slug": "walls-and-gates",
      "title": "Walls And Gates",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You are given an m x n grid rooms initialized with these three possible values:\n-1: A wall or an obstacle.\n0: A gate.\nINF: Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
      "videoUrl": "",
      "pattern": "Multi-source BFS",
      "patternEmoji": "\ud83c\udf0a",
      "timeComplexity": "O(m\u00d7n)",
      "spaceComplexity": "O(m\u00d7n)",
      "oneliner": "Start BFS from all gates simultaneously to find shortest distances.",
      "intuition": [
        "Instead of running BFS from each empty cell, run BFS from all gates at once",
        "This ensures we find the shortest distance to any gate in one pass"
      ],
      "visualizationType": "matrix",
      "initialState": [
        [
          2147483647,
          -1,
          0,
          2147483647
        ],
        [
          2147483647,
          2147483647,
          2147483647,
          -1
        ],
        [
          2147483647,
          -1,
          2147483647,
          -1
        ],
        [
          0,
          -1,
          2147483647,
          2147483647
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Walls And Gates",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 2147483647",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: -1",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 2147483647",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 2147483647",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              2147483647,
              -1,
              0,
              2147483647
            ],
            [
              2147483647,
              2147483647,
              2147483647,
              -1
            ],
            [
              2147483647,
              -1,
              2147483647,
              -1
            ],
            [
              0,
              -1,
              2147483647,
              2147483647
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "from collections import deque\n\ndef wallsAndGates(rooms):\n    \"\"\"\n    Intuition:\n    - Instead of running BFS from each empty cell, run BFS from all gates at once\n    - This ensures we find the shortest distance to any gate in one pass\n    \"\"\"\n    if not rooms:\n        return\n    \n    m, n = len(rooms), len(rooms[0])\n    queue = deque()\n    \n    # Find all gates\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if rooms[i][j] == 0:\n                queue.append((i, j))  # Add to end.\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Multi-source BFS\n    while queue:  # Process nodes until queue is empty.\n        row, col = queue.popleft()  # Remove from front of queue.\n        \n        for dr, dc in directions:  # Iterate over elements.\n            r, c = row + dr, col + dc\n            \n            # Check bounds and if cell is an unvisited room\n            if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                rooms[r][c] = rooms[row][col] + 1\n                queue.append((r, c))  # Add to end.",
      "keyInsight": "Use all gates as starting points in a single BFS to efficiently compute distances.",
      "testCases": [
        {
          "input": "rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
          "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Multi-source BFS: Start BFS from all gates simultaneously to find shortest distances.",
      "videoId": "e69C6xhiSQE",
      "suggestedNextQuestion": {
        "slug": "alien-dictionary",
        "title": "Alien Dictionary",
        "difficulty": "Hard",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
      "initialCode": "def wallsAndGates(rooms):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def wallsAndGates(rooms):\n    rows, cols = len(rooms), len(rooms[0])\n    q = []\n    for r in range(rows):\n        for c in range(cols):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                \n    dist = 0\n    while q:\n        dist += 1\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                row, col = r + dr, c + dc\n                if 0 <= row < rows and 0 <= col < cols and rooms[row][col] == 2147483647:\n                    rooms[row][col] = dist\n                    q.append((row, col))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m\u00d7n)",
          "spaceComplexity": "O(m\u00d7n)",
          "intuition": [
            "Instead of running BFS from each empty cell, run BFS from all gates at once",
            "This ensures we find the shortest distance to any gate in one pass"
          ],
          "code": "from collections import deque\n\ndef wallsAndGates(rooms):\n    \"\"\"\n    Intuition:\n    - Instead of running BFS from each empty cell, run BFS from all gates at once\n    - This ensures we find the shortest distance to any gate in one pass\n    \"\"\"\n    if not rooms:\n        return\n    \n    m, n = len(rooms), len(rooms[0])\n    queue = deque()\n    \n    # Find all gates\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if rooms[i][j] == 0:\n                queue.append((i, j))  # Add to end.\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Multi-source BFS\n    while queue:  # Process nodes until queue is empty.\n        row, col = queue.popleft()  # Remove from front of queue.\n        \n        for dr, dc in directions:  # Iterate over elements.\n            r, c = row + dr, col + dc\n            \n            # Check bounds and if cell is an unvisited room\n            if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                rooms[r][c] = rooms[row][col] + 1\n                queue.append((r, c))  # Add to end."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "redundant-connection": {
      "id": "redundant-connection",
      "slug": "redundant-connection",
      "title": "Redundant Connection",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
      "videoUrl": "",
      "pattern": "Union-Find (Disjoint Set)",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use Union-Find to detect when adding an edge creates a cycle.",
      "intuition": [
        "A tree with n nodes has exactly n-1 edges",
        "The redundant edge is the one that creates the first cycle"
      ],
      "visualizationType": "graph",
      "initialState": [
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          2,
          3
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Union-Find",
          "transientMessage": "edges=[[1,2],[1,3],[2,3]]",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 50
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 150
              }
            ],
            "edges": []
          },
          "pointers": [
            {
              "label": "parent",
              "value": "[1,2,3]"
            }
          ],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Union(1,2)",
          "transientMessage": "Merge sets",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 50,
                "highlight": true
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2",
                "highlight": true
              }
            ]
          },
          "pointers": [
            {
              "label": "parent",
              "value": "[1,1,3]"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Union(1,3)",
          "transientMessage": "Merge sets",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 50,
                "highlight": true
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3",
                "highlight": true
              }
            ]
          },
          "pointers": [
            {
              "label": "parent",
              "value": "[1,1,1]"
            }
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Cycle: [2,3]",
          "transientMessage": "Find(2)=Find(3)=1",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 50
              },
              {
                "id": "2",
                "label": "2",
                "x": 100,
                "y": 150
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "1",
                "to": "3"
              },
              {
                "from": "2",
                "to": "3",
                "highlight": true
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "[2,3]"
            }
          ],
          "color": "success"
        }
      ],
      "code": "def findRedundantConnection(edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes has exactly n-1 edges\n    - The redundant edge is the one that creates the first cycle\n    \"\"\"\n    parent = list(range(len(edges) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX == rootY:\n            return False  # Cycle detected\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for edge in edges:  # Iterate over elements.\n        if not union(edge[0], edge[1]):\n            return edge\n    return []",
      "keyInsight": "When union operation fails, we've found our redundant edge.",
      "testCases": [
        {
          "input": "edges = [[1,2],[1,3],[2,3]]",
          "output": "[2,3]"
        },
        {
          "input": "edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",
          "output": "[1,4]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Union-Find (Disjoint Set): Use Union-Find to detect when adding an edge creates a cycle.",
      "videoId": "FXWRE67PLL0",
      "graphNodes": [
        {
          "id": 1,
          "label": "1"
        },
        {
          "id": 2,
          "label": "2"
        },
        {
          "id": 3,
          "label": "3"
        }
      ],
      "graphEdges": [
        {
          "from": 1,
          "to": 2
        },
        {
          "from": 1,
          "to": 3
        },
        {
          "from": 2,
          "to": 3
        }
      ],
      "suggestedNextQuestion": {
        "slug": "rotting-oranges",
        "title": "Rotting Oranges",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like a club guest list. It only checks if you are 'in' or 'out', duplicates aren't allowed.",
      "initialCode": "def findRedundantConnection(edges):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findRedundantConnection(edges):\n    par = [i for i in range(len(edges) + 1)]\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2: return False\n        par[p1] = p2\n        return True\n    \n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "A tree with n nodes has exactly n-1 edges",
            "The redundant edge is the one that creates the first cycle"
          ],
          "code": "def findRedundantConnection(edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes has exactly n-1 edges\n    - The redundant edge is the one that creates the first cycle\n    \"\"\"\n    parent = list(range(len(edges) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX == rootY:\n            return False  # Cycle detected\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for edge in edges:  # Iterate over elements.\n        if not union(edge[0], edge[1]):\n            return edge\n    return []"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "number-of-connected-components-in-an-undirected-graph": {
      "id": "number-of-connected-components-in-an-undirected-graph",
      "slug": "number-of-connected-components-in-an-undirected-graph",
      "title": "Number of Connected Components In An Undirected Graph",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
      "videoUrl": "",
      "pattern": "Union-Find / DFS",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(E * \u03b1(n))",
      "spaceComplexity": "O(n)",
      "oneliner": "Use Union-Find to group connected nodes and count components.",
      "intuition": [
        "Each node starts as its own component",
        "When we connect two nodes, we merge their components"
      ],
      "visualizationType": "graph",
      "initialState": [
        0,
        1,
        2,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Input Graph",
          "transientMessage": "n=5, edges=[[0,1],[1,2],[3,4]]",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0",
                "x": 100,
                "y": 100
              },
              {
                "id": "1",
                "label": "1",
                "x": 200,
                "y": 100
              },
              {
                "id": "2",
                "label": "2",
                "x": 300,
                "y": 100
              },
              {
                "id": "3",
                "label": "3",
                "x": 150,
                "y": 200
              },
              {
                "id": "4",
                "label": "4",
                "x": 250,
                "y": 200
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "3",
                "to": "4"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "DFS: 0\u21921\u21922",
          "transientMessage": "Component 1",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 100,
                "y": 100,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 100,
                "visited": true
              },
              {
                "id": "3",
                "label": "3",
                "x": 150,
                "y": 200
              },
              {
                "id": "4",
                "label": "4",
                "x": 250,
                "y": 200
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1",
                "highlight": true
              },
              {
                "from": "1",
                "to": "2",
                "highlight": true
              },
              {
                "from": "3",
                "to": "4"
              }
            ]
          },
          "pointers": [
            {
              "label": "count",
              "value": "1"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "DFS: 3\u21924",
          "transientMessage": "Component 2",
          "graphState": {
            "nodes": [
              {
                "id": "0",
                "label": "0 \u2713",
                "x": 100,
                "y": 100,
                "visited": true
              },
              {
                "id": "1",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 \u2713",
                "x": 300,
                "y": 100,
                "visited": true
              },
              {
                "id": "3",
                "label": "3 \u2713",
                "x": 150,
                "y": 200,
                "visited": true
              },
              {
                "id": "4",
                "label": "4 \u2713",
                "x": 250,
                "y": 200,
                "visited": true
              }
            ],
            "edges": [
              {
                "from": "0",
                "to": "1"
              },
              {
                "from": "1",
                "to": "2"
              },
              {
                "from": "3",
                "to": "4",
                "highlight": true
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "2"
            }
          ],
          "color": "success"
        }
      ],
      "code": "def countComponents(n, edges):\n    \"\"\"\n    Intuition:\n    - Each node starts as its own component\n    - When we connect two nodes, we merge their components\n    \"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py: return\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n    \n    for a, b in edges:  # Iterate over elements.\n        union(a, b)\n    \n    return len(set(find(x) for x in range(n)))  # Iterate through the range.",
      "keyInsight": "Union-Find efficiently tracks connected components by merging groups.",
      "testCases": [
        {
          "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
          "output": "2"
        },
        {
          "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Union-Find / DFS: Use Union-Find to group connected nodes and count components.",
      "videoId": "8f1XPm4WOUc",
      "suggestedNextQuestion": {
        "slug": "number-of-islands",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def countComponents(n, edges):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def countComponents(n, edges):\n    par = [i for i in range(n)]\n    rank = [1] * n\n    def find(n1):\n        res = n1\n        while res != par[res]:\n            par[res] = par[par[res]]\n            res = par[res]\n        return res\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2: return 0\n        if rank[p1] > rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        return 1\n    \n    res = n\n    for n1, n2 in edges:\n        res -= union(n1, n2)\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(E * \u03b1(n))",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Each node starts as its own component",
            "When we connect two nodes, we merge their components"
          ],
          "code": "def countComponents(n, edges):\n    \"\"\"\n    Intuition:\n    - Each node starts as its own component\n    - When we connect two nodes, we merge their components\n    \"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py: return\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n    \n    for a, b in edges:  # Iterate over elements.\n        union(a, b)\n    \n    return len(set(find(x) for x in range(n)))  # Iterate through the range."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "graph-valid-tree": {
      "id": "graph-valid-tree",
      "slug": "graph-valid-tree",
      "title": "Graph Valid Tree",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
      "videoUrl": "",
      "pattern": "Union-Find",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use Union-Find to detect cycles and check connectivity.",
      "intuition": [
        "A tree with n nodes must have exactly n-1 edges",
        "Union-Find can detect cycles during union operations"
      ],
      "visualizationType": "tree",
      "initialState": [
        0,
        1,
        2,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Graph Valid Tree",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def validTree(n, edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes must have exactly n-1 edges\n    - Union-Find can detect cycles during union operations\n    \"\"\"\n    if len(edges) != n - 1:\n        return False  # Condition not met.\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return False  # Condition not met.\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for a, b in edges:  # Iterate over elements.\n        if not union(a, b):\n            return False  # Condition not met.\n    \n    return True  # Condition satisfied.",
      "keyInsight": "A valid tree has exactly n-1 edges and no cycles.",
      "testCases": [
        {
          "input": "n = 5, edges = [[0,1], [0,2], [0,3], [1,4]]",
          "output": "true"
        },
        {
          "input": "n = 5, edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]",
          "output": "false"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Union-Find: Use Union-Find to detect cycles and check connectivity.",
      "videoId": "bXsUuownnoQ",
      "suggestedNextQuestion": {
        "slug": "integer-replacement",
        "title": "Integer Replacement",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like connecting cities with roads. You track which cities belong to the same network.",
      "initialCode": "def validTree(n, edges):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def validTree(n, edges):\n    if not n: return True\n    adj = {i: [] for i in range(n)}\n    for n1, n2 in edges:\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n    \n    visit = set()\n    def dfs(i, prev):\n        if i in visit: return False\n        visit.add(i)\n        for j in adj[i]:\n            if j == prev: continue\n            if not dfs(j, i): return False\n        return True\n        \n    return dfs(0, -1) and n == len(visit)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "A tree with n nodes must have exactly n-1 edges",
            "Union-Find can detect cycles during union operations"
          ],
          "code": "def validTree(n, edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes must have exactly n-1 edges\n    - Union-Find can detect cycles during union operations\n    \"\"\"\n    if len(edges) != n - 1:\n        return False  # Condition not met.\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return False  # Condition not met.\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for a, b in edges:  # Iterate over elements.\n        if not union(a, b):\n            return False  # Condition not met.\n    \n    return True  # Condition satisfied."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reconstruct-itinerary": {
      "id": "reconstruct-itinerary",
      "slug": "reconstruct-itinerary",
      "title": "Reconstruct Itinerary",
      "difficulty": "Hard",
      "category": "Graph General",
      "problemStatement": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
      "videoUrl": "",
      "pattern": "Hierholzer's Algorithm / DFS",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(E log E)",
      "spaceComplexity": "O(V + E)",
      "oneliner": "Use DFS with lexical ordering to traverse all edges exactly once.",
      "intuition": [
        "This is an Eulerian path problem - we must visit each ticket (edge) exactly once",
        "Since we want lexical order, we sort destinations and use post-order DFS traversal"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          "JFK",
          "SFO"
        ],
        [
          "JFK",
          "ATL"
        ],
        [
          "SFO",
          "ATL"
        ],
        [
          "ATL",
          "JFK"
        ],
        [
          "ATL",
          "SFO"
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reconstruct Itinerary",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = JFK,SFO",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = JFK,ATL",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = SFO,ATL",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = ATL,JFK",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = ATL,SFO",
          "transientMessage": "Iteration 5",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              "JFK",
              "SFO"
            ],
            [
              "JFK",
              "ATL"
            ],
            [
              "SFO",
              "ATL"
            ],
            [
              "ATL",
              "JFK"
            ],
            [
              "ATL",
              "SFO"
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def findItinerary(tickets):\n    \"\"\"\n    Intuition:\n    - This is an Eulerian path problem - we must visit each ticket (edge) exactly once\n    - Since we want lexical order, we sort destinations and use post-order DFS traversal\n    \"\"\"\n    from collections import defaultdict\n    import heapq\n    \n    # Build adjacency list with min-heap for lexical order\n    graph = defaultdict(list)\n    for src, dst in tickets:  # Iterate over elements.\n        heapq.heappush(graph[src], dst)\n    \n    result = []\n    \n    def dfs(node):\n        # Visit all neighbors in lexical order\n        while graph[node]:\n            next_node = heapq.heappop(graph[node])  # Remove and return last element.\n            dfs(next_node)\n        # Post-order: add to result after visiting children\n        result.append(node)  # Add to end.\n    \n    dfs(\"JFK\")\n    return result[::-1]  # Reverse to get correct order",
      "keyInsight": "Use post-order DFS with lexical sorting to ensure correct itinerary order.",
      "testCases": [
        {
          "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
          "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
        },
        {
          "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
          "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Hierholzer's Algorithm / DFS: Use DFS with lexical ordering to traverse all edges exactly once.",
      "videoId": "ZyB_gQ8vqGA",
      "suggestedNextQuestion": {
        "slug": "swim-in-rising-water",
        "title": "Swim In Rising Water",
        "difficulty": "Hard",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def findItinerary(tickets):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def findItinerary(tickets):\n    adj = {src: [] for src, dst in tickets}\n    tickets.sort()\n    for src, dst in tickets:\n        adj.setdefault(src, []).append(dst)\n        \n    res = []\n    def dfs(src):\n        while adj.get(src, []):\n            next_dst = adj[src].pop(0)\n            dfs(next_dst)\n        res.append(src)\n    dfs(\"JFK\")\n    return res[::-1]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(E log E)",
          "spaceComplexity": "O(V + E)",
          "intuition": [
            "This is an Eulerian path problem - we must visit each ticket (edge) exactly once",
            "Since we want lexical order, we sort destinations and use post-order DFS traversal"
          ],
          "code": "def findItinerary(tickets):\n    \"\"\"\n    Intuition:\n    - This is an Eulerian path problem - we must visit each ticket (edge) exactly once\n    - Since we want lexical order, we sort destinations and use post-order DFS traversal\n    \"\"\"\n    from collections import defaultdict\n    import heapq\n    \n    # Build adjacency list with min-heap for lexical order\n    graph = defaultdict(list)\n    for src, dst in tickets:  # Iterate over elements.\n        heapq.heappush(graph[src], dst)\n    \n    result = []\n    \n    def dfs(node):\n        # Visit all neighbors in lexical order\n        while graph[node]:\n            next_node = heapq.heappop(graph[node])  # Remove and return last element.\n            dfs(next_node)\n        # Post-order: add to result after visiting children\n        result.append(node)  # Add to end.\n    \n    dfs(\"JFK\")\n    return result[::-1]  # Reverse to get correct order"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "min-cost-to-connect-all-points": {
      "id": "min-cost-to-connect-all-points",
      "slug": "min-cost-to-connect-all-points",
      "title": "Min Cost to Connect All Points",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
      "videoUrl": "",
      "pattern": "Minimum Spanning Tree (Kruskal's)",
      "patternEmoji": "\ud83d\udd17",
      "timeComplexity": "O(n\u00b2 log n)",
      "spaceComplexity": "O(n\u00b2)",
      "oneliner": "Use Kruskal's algorithm with Union-Find to find MST.",
      "intuition": [
        "We need to connect all points with minimum total cost",
        "This is a classic Minimum Spanning Tree problem"
      ],
      "visualizationType": "graph",
      "initialState": [
        [
          0,
          0
        ],
        [
          2,
          2
        ],
        [
          3,
          10
        ],
        [
          5,
          2
        ],
        [
          7,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Min Cost to Connect All Points",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 0,0",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2,2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3,10",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 5,2",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 7,0",
          "transientMessage": "Iteration 5",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              0,
              0
            ],
            [
              2,
              2
            ],
            [
              3,
              10
            ],
            [
              5,
              2
            ],
            [
              7,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef minCostConnectPoints(points):\n    \"\"\"\n    Intuition:\n    - We need to connect all points with minimum total cost\n    - This is a classic Minimum Spanning Tree problem\n    \"\"\"\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Generate all edges with Manhattan distances\n    edges = []\n    for i in range(n):  # Iterate through the range.\n        for j in range(i+1, n):  # Iterate through the range.\n            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            edges.append((dist, i, j))  # Add to end.\n    \n    # Sort edges by distance\n    edges.sort()\n    \n    # Union-Find data structure\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parent[root_x] = root_y\n            return True  # Condition satisfied.\n        return False  # Condition not met.\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    edges_used = 0\n    \n    for dist, u, v in edges:  # Iterate over elements.\n        if union(u, v):\n            total_cost += dist\n            edges_used += 1\n            if edges_used == n - 1:\n                break\n    \n    return total_cost",
      "keyInsight": "Connect points using minimum Manhattan distances without forming cycles.",
      "testCases": [
        {
          "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
          "output": "20"
        },
        {
          "input": "points = [[3,12],[-2,5],[-4,1]]",
          "output": "18"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Minimum Spanning Tree (Kruskal's): Use Kruskal's algorithm with Union-Find to find MST.",
      "videoId": "f7JOBJIC-NA",
      "suggestedNextQuestion": {
        "slug": "populating-next-right-pointers-in-each-node-ii",
        "title": "Populating Next Right Pointers in Each Node II",
        "difficulty": "Medium",
        "pattern": "Trees"
      },
      "mentalModel": "Like a family tree. Every node has a parent and children.",
      "initialCode": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef minCostConnectPoints(points):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n) per operation",
          "spaceComplexity": "O(h) recursion stack",
          "intuition": [
            "Traverse the entire tree for each query.",
            "No optimization, just direct exploration."
          ],
          "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2 log n)",
          "spaceComplexity": "O(n\u00b2)",
          "intuition": [
            "We need to connect all points with minimum total cost",
            "This is a classic Minimum Spanning Tree problem"
          ],
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef minCostConnectPoints(points):\n    \"\"\"\n    Intuition:\n    - We need to connect all points with minimum total cost\n    - This is a classic Minimum Spanning Tree problem\n    \"\"\"\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Generate all edges with Manhattan distances\n    edges = []\n    for i in range(n):  # Iterate through the range.\n        for j in range(i+1, n):  # Iterate through the range.\n            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            edges.append((dist, i, j))  # Add to end.\n    \n    # Sort edges by distance\n    edges.sort()\n    \n    # Union-Find data structure\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parent[root_x] = root_y\n            return True  # Condition satisfied.\n        return False  # Condition not met.\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    edges_used = 0\n    \n    for dist, u, v in edges:  # Iterate over elements.\n        if union(u, v):\n            total_cost += dist\n            edges_used += 1\n            if edges_used == n - 1:\n                break\n    \n    return total_cost"
        }
      ],
      "examples": [
        {
          "input": "root = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Traverse tree structure."
        },
        {
          "input": "root = []",
          "output": "null",
          "explanation": "Empty tree edge case."
        }
      ],
      "constraints": [
        "Number of nodes: [0, 10^4]",
        "-10^4 <= Node.val <= 10^4"
      ],
      "commonMistakes": [
        "Not handling null/empty tree",
        "Incorrect traversal order",
        "Stack overflow on deep trees"
      ],
      "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs."
    },
    "network-delay-time": {
      "id": "network-delay-time",
      "slug": "network-delay-time",
      "title": "Network Delay Time",
      "difficulty": "Medium",
      "category": "Graph General",
      "problemStatement": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
      "videoUrl": "",
      "pattern": "Dijkstra's Algorithm",
      "patternEmoji": "\ud83d\udcd0",
      "timeComplexity": "O(E log V)",
      "spaceComplexity": "O(V + E)",
      "oneliner": "Use Dijkstra's algorithm to find shortest paths from source node.",
      "intuition": [
        "We need to find the shortest path from node k to all other nodes",
        "Dijkstra's algorithm works because all edge weights are non-negative"
      ],
      "visualizationType": "graph",
      "initialState": [
        1,
        2,
        3,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Weighted Graph",
          "transientMessage": "times=[[2,1,1],[2,3,1],[3,4,1]]",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 (src)",
                "x": 200,
                "y": 50
              },
              {
                "id": "3",
                "label": "3",
                "x": 300,
                "y": 150
              },
              {
                "id": "4",
                "label": "4",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "2",
                "to": "1",
                "weight": 1
              },
              {
                "from": "2",
                "to": "3",
                "weight": 1
              },
              {
                "from": "3",
                "to": "4",
                "weight": 1
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Dijkstra: dist[2]=0",
          "transientMessage": "All others = \u221e",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 (\u221e)",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 (0)",
                "x": 200,
                "y": 50,
                "highlight": true
              },
              {
                "id": "3",
                "label": "3 (\u221e)",
                "x": 300,
                "y": 150
              },
              {
                "id": "4",
                "label": "4 (\u221e)",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "2",
                "to": "1",
                "weight": 1
              },
              {
                "from": "2",
                "to": "3",
                "weight": 1
              },
              {
                "from": "3",
                "to": "4",
                "weight": 1
              }
            ]
          },
          "pointers": [
            {
              "label": "curr",
              "node": "2"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Relax: dist[1,3]=1",
          "transientMessage": "Update neighbors",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 (1)",
                "x": 100,
                "y": 150,
                "highlight": true
              },
              {
                "id": "2",
                "label": "2 (0)",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "3",
                "label": "3 (1)",
                "x": 300,
                "y": 150,
                "highlight": true
              },
              {
                "id": "4",
                "label": "4 (\u221e)",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "2",
                "to": "1",
                "weight": 1,
                "highlight": true
              },
              {
                "from": "2",
                "to": "3",
                "weight": 1,
                "highlight": true
              },
              {
                "from": "3",
                "to": "4",
                "weight": 1
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Relax: dist[4]=2",
          "transientMessage": "From node 3",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 (1) \u2713",
                "x": 100,
                "y": 150,
                "visited": true
              },
              {
                "id": "2",
                "label": "2 (0) \u2713",
                "x": 200,
                "y": 50,
                "visited": true
              },
              {
                "id": "3",
                "label": "3 (1) \u2713",
                "x": 300,
                "y": 150,
                "visited": true
              },
              {
                "id": "4",
                "label": "4 (2)",
                "x": 400,
                "y": 150,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "2",
                "to": "1",
                "weight": 1
              },
              {
                "from": "2",
                "to": "3",
                "weight": 1
              },
              {
                "from": "3",
                "to": "4",
                "weight": 1,
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Result: max=2",
          "transientMessage": "All nodes reachable",
          "graphState": {
            "nodes": [
              {
                "id": "1",
                "label": "1 (1)",
                "x": 100,
                "y": 150
              },
              {
                "id": "2",
                "label": "2 (0)",
                "x": 200,
                "y": 50
              },
              {
                "id": "3",
                "label": "3 (1)",
                "x": 300,
                "y": 150
              },
              {
                "id": "4",
                "label": "4 (2)",
                "x": 400,
                "y": 150
              }
            ],
            "edges": [
              {
                "from": "2",
                "to": "1",
                "weight": 1
              },
              {
                "from": "2",
                "to": "3",
                "weight": 1
              },
              {
                "from": "3",
                "to": "4",
                "weight": 1
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "2"
            }
          ],
          "color": "success"
        }
      ],
      "code": "import heapq\n\ndef networkDelayTime(times, n, k):\n    \"\"\"\n    Intuition:\n    - We need to find the shortest path from node k to all other nodes\n    - Dijkstra's algorithm works because all edge weights are non-negative\n    \"\"\"\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]  # Iterate through the range.\n    for u, v, w in times:  # Iterate over elements.\n        graph[u].append((v, w))  # Add to end.\n    \n    # Distance array\n    dist = [float('inf')] * (n + 1)\n    dist[k] = 0\n    \n    # Priority queue\n    pq = [(0, k)]\n    \n    while pq:\n        d, node = heapq.heappop(pq)  # Remove and return last element.\n        \n        if d > dist[node]:\n            continue\n            \n        for neighbor, weight in graph[node]:  # Iterate over elements.\n            if dist[node] + weight < dist[neighbor]:\n                dist[neighbor] = dist[node] + weight\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n    \n    # Find maximum delay\n    max_delay = max(dist[1:])  # Take the maximum value.\n    return max_delay if max_delay != float('inf') else -1",
      "keyInsight": "Use Dijkstra's algorithm to find shortest path from source to all nodes.",
      "testCases": [
        {
          "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
          "output": "2"
        },
        {
          "input": "times = [[1,2,1]], n = 2, k = 1",
          "output": "1"
        },
        {
          "input": "times = [[1,2,1]], n = 2, k = 2",
          "output": "-1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Dijkstra's Algorithm: Use Dijkstra's algorithm to find shortest paths from source node.",
      "videoId": "EaphyqKU4PQ",
      "suggestedNextQuestion": {
        "slug": "number-of-connected-components-in-an-undirected-graph",
        "title": "Number of Connected Components In An Undirected Graph",
        "difficulty": "Medium",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def networkDelayTime(times, n, k):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def networkDelayTime(times, n, k):\n    # Dijkstra\n    import heapq\n    edges = { i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        edges[u].append((v, w))\n    \n    minHeap = [(0, k)]\n    visit = set()\n    t = 0\n    while minHeap:\n        w1, n1 = heapq.heappop(minHeap)\n        if n1 in visit: continue\n        visit.add(n1)\n        t = max(t, w1)\n        for n2, w2 in edges[n1]:\n            if n2 not in visit:\n                heapq.heappush(minHeap, (w1 + w2, n2))\n    return t if len(visit) == n else -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(E log V)",
          "spaceComplexity": "O(V + E)",
          "intuition": [
            "We need to find the shortest path from node k to all other nodes",
            "Dijkstra's algorithm works because all edge weights are non-negative"
          ],
          "code": "import heapq\n\ndef networkDelayTime(times, n, k):\n    \"\"\"\n    Intuition:\n    - We need to find the shortest path from node k to all other nodes\n    - Dijkstra's algorithm works because all edge weights are non-negative\n    \"\"\"\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]  # Iterate through the range.\n    for u, v, w in times:  # Iterate over elements.\n        graph[u].append((v, w))  # Add to end.\n    \n    # Distance array\n    dist = [float('inf')] * (n + 1)\n    dist[k] = 0\n    \n    # Priority queue\n    pq = [(0, k)]\n    \n    while pq:\n        d, node = heapq.heappop(pq)  # Remove and return last element.\n        \n        if d > dist[node]:\n            continue\n            \n        for neighbor, weight in graph[node]:  # Iterate over elements.\n            if dist[node] + weight < dist[neighbor]:\n                dist[neighbor] = dist[node] + weight\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n    \n    # Find maximum delay\n    max_delay = max(dist[1:])  # Take the maximum value.\n    return max_delay if max_delay != float('inf') else -1"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "swim-in-rising-water": {
      "id": "swim-in-rising-water",
      "slug": "swim-in-rising-water",
      "title": "Swim in Rising Water",
      "difficulty": "Hard",
      "category": "Graph General",
      "problemStatement": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nIt starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nReturn the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
      "videoUrl": "",
      "pattern": "Binary Search + DFS",
      "patternEmoji": "\ud83d\udd0d\ud83d\udd78\ufe0f",
      "timeComplexity": "O(n\u00b2 log n)",
      "spaceComplexity": "O(n\u00b2)",
      "oneliner": "Binary search on time values, use DFS to check if path exists.",
      "intuition": [
        "We want the minimum time t where a path exists from (0,0) to (n-1,n-1)",
        "For a given time t, we can check connectivity using DFS/BFS"
      ],
      "visualizationType": "graph",
      "initialState": [
        [
          0,
          2
        ],
        [
          1,
          3
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Grid as Graph",
          "transientMessage": "Each cell is a node",
          "graphState": {
            "nodes": [
              {
                "id": "00",
                "label": "0",
                "x": 100,
                "y": 100
              },
              {
                "id": "01",
                "label": "1",
                "x": 200,
                "y": 100
              },
              {
                "id": "10",
                "label": "2",
                "x": 100,
                "y": 200
              },
              {
                "id": "11",
                "label": "3",
                "x": 200,
                "y": 200
              }
            ],
            "edges": [
              {
                "from": "00",
                "to": "01"
              },
              {
                "from": "00",
                "to": "10"
              },
              {
                "from": "01",
                "to": "11"
              },
              {
                "from": "10",
                "to": "11"
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Binary Search t=3",
          "transientMessage": "Can we reach end?",
          "graphState": {
            "nodes": [
              {
                "id": "00",
                "label": "0 (start)",
                "x": 100,
                "y": 100,
                "highlight": true
              },
              {
                "id": "01",
                "label": "1",
                "x": 200,
                "y": 100
              },
              {
                "id": "10",
                "label": "2",
                "x": 100,
                "y": 200
              },
              {
                "id": "11",
                "label": "3 (end)",
                "x": 200,
                "y": 200,
                "highlight": true
              }
            ],
            "edges": [
              {
                "from": "00",
                "to": "01"
              },
              {
                "from": "00",
                "to": "10"
              },
              {
                "from": "01",
                "to": "11"
              },
              {
                "from": "10",
                "to": "11"
              }
            ]
          },
          "pointers": [
            {
              "label": "t",
              "value": "3"
            }
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Result: t=3",
          "transientMessage": "Path found!",
          "graphState": {
            "nodes": [
              {
                "id": "00",
                "label": "0 \u2713",
                "x": 100,
                "y": 100,
                "visited": true
              },
              {
                "id": "01",
                "label": "1 \u2713",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "10",
                "label": "2",
                "x": 100,
                "y": 200
              },
              {
                "id": "11",
                "label": "3 \u2713",
                "x": 200,
                "y": 200,
                "visited": true
              }
            ],
            "edges": [
              {
                "from": "00",
                "to": "01",
                "highlight": true
              },
              {
                "from": "00",
                "to": "10"
              },
              {
                "from": "01",
                "to": "11",
                "highlight": true
              },
              {
                "from": "10",
                "to": "11"
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "3"
            }
          ],
          "color": "success"
        }
      ],
      "code": "def swimInWater(grid):\n    \"\"\"\n    Intuition:\n    - We want the minimum time t where a path exists from (0,0) to (n-1,n-1)\n    - For a given time t, we can check connectivity using DFS/BFS\n    \"\"\"\n    n = len(grid)\n    \n    def canReach(t):\n        if grid[0][0] > t: return False  # Condition not met.\n        stack = [(0, 0)]\n        visited = set()\n        \n        while stack:\n            x, y = stack.pop()  # Remove and return last element.\n            if x == n-1 and y == n-1:\n                return True  # Condition satisfied.\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            \n            for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:  # Iterate over elements.\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= t:\n                    stack.append((nx, ny))  # Add to end.\n        return False  # Condition not met.\n    \n    left, right = 0, n * n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if canReach(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left",
      "keyInsight": "Binary search on the answer. For each candidate time, check if destination is reachable.",
      "testCases": [
        {
          "input": "grid = [[0,2],[1,3]]",
          "output": "3"
        },
        {
          "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
          "output": "16"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Binary Search + DFS: Binary search on time values, use DFS to check if path exists.",
      "videoId": "amvrKlMLuGY",
      "suggestedNextQuestion": {
        "slug": "word-ladder",
        "title": "Word Ladder",
        "difficulty": "Hard",
        "pattern": "Graphs"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def swimInWater(grid):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def swimInWater_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2 log n)",
          "spaceComplexity": "O(n\u00b2)",
          "intuition": [
            "We want the minimum time t where a path exists from (0,0) to (n-1,n-1)",
            "For a given time t, we can check connectivity using DFS/BFS"
          ],
          "code": "def swimInWater(grid):\n    \"\"\"\n    Intuition:\n    - We want the minimum time t where a path exists from (0,0) to (n-1,n-1)\n    - For a given time t, we can check connectivity using DFS/BFS\n    \"\"\"\n    n = len(grid)\n    \n    def canReach(t):\n        if grid[0][0] > t: return False  # Condition not met.\n        stack = [(0, 0)]\n        visited = set()\n        \n        while stack:\n            x, y = stack.pop()  # Remove and return last element.\n            if x == n-1 and y == n-1:\n                return True  # Condition satisfied.\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            \n            for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:  # Iterate over elements.\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= t:\n                    stack.append((nx, ny))  # Add to end.\n        return False  # Condition not met.\n    \n    left, right = 0, n * n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if canReach(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3, 4, 5], target = 3",
          "output": "2",
          "explanation": "Target found at index 2."
        },
        {
          "input": "nums = [1, 2, 3], target = 0",
          "output": "-1",
          "explanation": "Target not found."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "Array is sorted"
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "alien-dictionary": {
      "id": "alien-dictionary",
      "slug": "alien-dictionary",
      "title": "Alien Dictionary",
      "difficulty": "Hard",
      "category": "Graph General",
      "problemStatement": "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.",
      "videoUrl": "",
      "pattern": "Topological Sort",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(C)",
      "spaceComplexity": "O(1)",
      "oneliner": "Build graph from adjacent words, then topological sort.",
      "intuition": [
        "Compare adjacent words to find letter order relationships.",
        "Use topological sort to determine valid letter sequence."
      ],
      "visualizationType": "graph",
      "initialState": [
        "wrt",
        "wrf",
        "er",
        "ett",
        "rftt"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Build Order Graph",
          "transientMessage": "Compare adjacent words",
          "graphState": {
            "nodes": [
              {
                "id": "w",
                "label": "w",
                "x": 100,
                "y": 100
              },
              {
                "id": "e",
                "label": "e",
                "x": 150,
                "y": 200
              },
              {
                "id": "r",
                "label": "r",
                "x": 200,
                "y": 100
              },
              {
                "id": "t",
                "label": "t",
                "x": 300,
                "y": 100
              },
              {
                "id": "f",
                "label": "f",
                "x": 250,
                "y": 200
              }
            ],
            "edges": []
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "t\u2192f, w\u2192e",
          "transientMessage": "First differences",
          "graphState": {
            "nodes": [
              {
                "id": "w",
                "label": "w",
                "x": 100,
                "y": 100,
                "highlight": true
              },
              {
                "id": "e",
                "label": "e",
                "x": 150,
                "y": 200
              },
              {
                "id": "r",
                "label": "r",
                "x": 200,
                "y": 100
              },
              {
                "id": "t",
                "label": "t",
                "x": 300,
                "y": 100,
                "highlight": true
              },
              {
                "id": "f",
                "label": "f",
                "x": 250,
                "y": 200
              }
            ],
            "edges": [
              {
                "from": "t",
                "to": "f",
                "highlight": true
              },
              {
                "from": "w",
                "to": "e",
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "r\u2192t, e\u2192r",
          "transientMessage": "More edges found",
          "graphState": {
            "nodes": [
              {
                "id": "w",
                "label": "w",
                "x": 100,
                "y": 100
              },
              {
                "id": "e",
                "label": "e",
                "x": 150,
                "y": 200
              },
              {
                "id": "r",
                "label": "r",
                "x": 200,
                "y": 100
              },
              {
                "id": "t",
                "label": "t",
                "x": 300,
                "y": 100
              },
              {
                "id": "f",
                "label": "f",
                "x": 250,
                "y": 200
              }
            ],
            "edges": [
              {
                "from": "t",
                "to": "f"
              },
              {
                "from": "w",
                "to": "e"
              },
              {
                "from": "r",
                "to": "t",
                "highlight": true
              },
              {
                "from": "e",
                "to": "r",
                "highlight": true
              }
            ]
          },
          "pointers": [],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Result: \"wertf\"",
          "transientMessage": "Topological sort",
          "graphState": {
            "nodes": [
              {
                "id": "w",
                "label": "w (1)",
                "x": 100,
                "y": 100,
                "visited": true
              },
              {
                "id": "e",
                "label": "e (2)",
                "x": 150,
                "y": 200,
                "visited": true
              },
              {
                "id": "r",
                "label": "r (3)",
                "x": 200,
                "y": 100,
                "visited": true
              },
              {
                "id": "t",
                "label": "t (4)",
                "x": 300,
                "y": 100,
                "visited": true
              },
              {
                "id": "f",
                "label": "f (5)",
                "x": 250,
                "y": 200,
                "visited": true
              }
            ],
            "edges": [
              {
                "from": "t",
                "to": "f"
              },
              {
                "from": "w",
                "to": "e"
              },
              {
                "from": "r",
                "to": "t"
              },
              {
                "from": "e",
                "to": "r"
              }
            ]
          },
          "pointers": [
            {
              "label": "answer",
              "value": "\"wertf\""
            }
          ],
          "color": "success"
        }
      ],
      "code": "from collections import defaultdict, deque\n\ndef alienOrder(words):\n    \"\"\"\n    Intuition:\n    - Compare adjacent words to find letter order relationships.\n    - Use topological sort to determine valid letter sequence.\n    \"\"\"\n    # Build graph\n    graph = defaultdict(set)\n    indegree = defaultdict(int)\n    \n    # Add all unique letters\n    for word in words:  # Iterate over elements.\n        for char in word:  # Iterate over elements.\n            indegree[char] = 0\n    \n    # Find letter relationships\n    for i in range(len(words) - 1):  # Iterate through the range.\n        word1, word2 = words[i], words[i+1]\n        min_len = min(len(word1), len(word2))  # Take the minimum value.\n        \n        # Check invalid case: prefix issue\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n            \n        # Find first differing character\n        for j in range(min_len):  # Iterate through the range.\n            if word1[j] != word2[j]:\n                # Add edge if not already present\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    indegree[word2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([char for char in indegree if indegree[char] == 0])\n    result = []\n    \n    while queue:  # Process nodes until queue is empty.\n        char = queue.popleft()  # Remove from front of queue.\n        result.append(char)  # Add to end.\n        \n        for neighbor in graph[char]:  # Iterate over elements.\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)  # Add to end.\n    \n    # Check for cycles\n    return ''.join(result) if len(result) == len(indegree) else \"\"",
      "keyInsight": "Adjacent words reveal ordering; topological sort handles dependencies.",
      "testCases": [
        {
          "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
          "output": "\"wertf\""
        },
        {
          "input": "words = [\"z\",\"x\"]",
          "output": "\"zx\""
        },
        {
          "input": "words = [\"z\",\"x\",\"z\"]",
          "output": "\"\""
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Topological Sort: Build graph from adjacent words, then topological sort.",
      "videoId": "6kTZYvNNyps",
      "graphNodes": [
        {
          "id": "w",
          "label": "w"
        },
        {
          "id": "e",
          "label": "e"
        },
        {
          "id": "r",
          "label": "r"
        },
        {
          "id": "t",
          "label": "t"
        },
        {
          "id": "f",
          "label": "f"
        }
      ],
      "graphEdges": [
        {
          "from": "t",
          "to": "f"
        },
        {
          "from": "w",
          "to": "e"
        },
        {
          "from": "r",
          "to": "t"
        },
        {
          "from": "e",
          "to": "r"
        }
      ],
      "suggestedNextQuestion": {
        "slug": "binary-tree-maximum-path-sum",
        "title": "Binary Tree Maximum Path Sum",
        "difficulty": "Hard",
        "pattern": "Graphs"
      },
      "mentalModel": "Like putting on clothes. Socks before shoes. Order matters based on dependencies.",
      "initialCode": "def alienOrder(words):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def alienOrder(words):\n    adj = { c:set() for w in words for c in w }\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i+1]\n        minLen = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                adj[w1[j]].add(w2[j])\n                break\n                \n    visit = {} # False=visited, True=path\n    res = []\n    def dfs(c):\n        if c in visit:\n            return visit[c]\n        visit[c] = True\n        for nei in adj[c]:\n            if dfs(nei): return True\n        visit[c] = False\n        res.append(c)\n    \n    for c in adj:\n        if dfs(c): return \"\"\n    return \"\".join(res[::-1])"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(C)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Compare adjacent words to find letter order relationships.",
            "Use topological sort to determine valid letter sequence."
          ],
          "code": "from collections import defaultdict, deque\n\ndef alienOrder(words):\n    \"\"\"\n    Intuition:\n    - Compare adjacent words to find letter order relationships.\n    - Use topological sort to determine valid letter sequence.\n    \"\"\"\n    # Build graph\n    graph = defaultdict(set)\n    indegree = defaultdict(int)\n    \n    # Add all unique letters\n    for word in words:  # Iterate over elements.\n        for char in word:  # Iterate over elements.\n            indegree[char] = 0\n    \n    # Find letter relationships\n    for i in range(len(words) - 1):  # Iterate through the range.\n        word1, word2 = words[i], words[i+1]\n        min_len = min(len(word1), len(word2))  # Take the minimum value.\n        \n        # Check invalid case: prefix issue\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n            \n        # Find first differing character\n        for j in range(min_len):  # Iterate through the range.\n            if word1[j] != word2[j]:\n                # Add edge if not already present\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    indegree[word2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([char for char in indegree if indegree[char] == 0])\n    result = []\n    \n    while queue:  # Process nodes until queue is empty.\n        char = queue.popleft()  # Remove from front of queue.\n        result.append(char)  # Add to end.\n        \n        for neighbor in graph[char]:  # Iterate over elements.\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)  # Add to end.\n    \n    # Check for cycles\n    return ''.join(result) if len(result) == len(indegree) else \"\""
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "subsets-ii": {
      "id": "subsets-ii",
      "slug": "subsets-ii",
      "title": "Subsets II",
      "difficulty": "Medium",
      "category": "Backtracking",
      "problemStatement": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
      "videoUrl": "",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(2^n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use backtracking with sorting to skip duplicates.",
      "intuition": [
        "Sort the array first to group duplicates together",
        "Skip over duplicate elements during backtracking to avoid duplicate subsets"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Subsets II",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [1]",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 2 to path",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try 2 instead",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def subsetsWithDup(nums):\n    \"\"\"\n    Intuition:\n    - Sort the array first to group duplicates together\n    - Skip over duplicate elements during backtracking to avoid duplicate subsets\n    \"\"\"\n    nums.sort()\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])  # Add to end.\n        \n        for i in range(start, len(nums)):  # Iterate through the range.\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    \n    backtrack(0, [])\n    return result  # Return the final result.",
      "keyInsight": "Sort first, then skip duplicates by checking if current element equals previous element in the same level of recursion.",
      "testCases": [
        {
          "input": "nums = [1,2,2]",
          "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
        },
        {
          "input": "nums = [0]",
          "output": "[[],[0]]"
        }
      ],
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "hints": [
        "\ud83e\udde0 Explore all possibilities systematically",
        "\ud83d\udca1 Prune invalid branches early",
        "\ud83d\udd0d Track current state and restore after"
      ],
      "approach": "Backtracking: Use backtracking with sorting to skip duplicates.",
      "videoId": "Vn2v6ajA7U0",
      "suggestedNextQuestion": {
        "slug": "word-search",
        "title": "Word Search",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def subsetsWithDup(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def subsetsWithDup_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the array first to group duplicates together",
            "Skip over duplicate elements during backtracking to avoid duplicate subsets"
          ],
          "code": "def subsetsWithDup(nums):\n    \"\"\"\n    Intuition:\n    - Sort the array first to group duplicates together\n    - Skip over duplicate elements during backtracking to avoid duplicate subsets\n    \"\"\"\n    nums.sort()\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])  # Add to end.\n        \n        for i in range(start, len(nums)):  # Iterate through the range.\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    \n    backtrack(0, [])\n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[[1,2,3], [1,3,2], ...]",
          "explanation": "Generate all permutations."
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "All elements are unique"
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "combination-sum-ii": {
      "id": "combination-sum-ii",
      "slug": "combination-sum-ii",
      "title": "Combination Sum II",
      "difficulty": "Medium",
      "category": "Backtracking",
      "problemStatement": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.",
      "videoUrl": "",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(2^n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use backtracking with sorting to avoid duplicates.",
      "intuition": [
        "Sort the array to group duplicates together",
        "Use backtracking to explore combinations, skipping duplicates"
      ],
      "visualizationType": "array",
      "initialState": [
        10,
        1,
        2,
        7,
        6,
        1,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Combination Sum II",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add 10 to path",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [10]",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try 2 instead",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            10,
            1,
            2,
            7,
            6,
            1,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def combinationSum2(candidates, target):\n    \"\"\"\n    Intuition:\n    - Sort the array to group duplicates together\n    - Use backtracking to explore combinations, skipping duplicates\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path[:])  # Add to end.\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(candidates)):  # Iterate through the range.\n            if i > start and candidates[i] == candidates[i-1]:\n                continue  # Skip duplicates\n            \n            path.append(candidates[i])  # Add to end.\n            backtrack(i + 1, target - candidates[i], path)\n            path.pop()  # Remove and return last element.\n    \n    candidates.sort()\n    result = []\n    backtrack(0, target, [])\n    return result  # Return the final result.",
      "keyInsight": "Sort to group duplicates, then skip same values in same level.",
      "testCases": [
        {
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "output": "[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
        },
        {
          "input": "candidates = [2,5,2,1,2], target = 5",
          "output": "[\n[1,2,2],\n[5]\n]"
        }
      ],
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "hints": [
        "\ud83e\udde0 Explore all possibilities systematically",
        "\ud83d\udca1 Prune invalid branches early",
        "\ud83d\udd0d Track current state and restore after"
      ],
      "approach": "Backtracking: Use backtracking with sorting to avoid duplicates.",
      "videoId": "rSA3t6BDDwg",
      "suggestedNextQuestion": {
        "slug": "combinations",
        "title": "Combinations",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def combinationSum2(candidates, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def combinationSum2_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the array to group duplicates together",
            "Use backtracking to explore combinations, skipping duplicates"
          ],
          "code": "def combinationSum2(candidates, target):\n    \"\"\"\n    Intuition:\n    - Sort the array to group duplicates together\n    - Use backtracking to explore combinations, skipping duplicates\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path[:])  # Add to end.\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(candidates)):  # Iterate through the range.\n            if i > start and candidates[i] == candidates[i-1]:\n                continue  # Skip duplicates\n            \n            path.append(candidates[i])  # Add to end.\n            backtrack(i + 1, target - candidates[i], path)\n            path.pop()  # Remove and return last element.\n    \n    candidates.sort()\n    result = []\n    backtrack(0, target, [])\n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[[1,2,3], [1,3,2], ...]",
          "explanation": "Generate all permutations."
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "All elements are unique"
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "palindrome-partitioning": {
      "id": "palindrome-partitioning",
      "slug": "palindrome-partitioning",
      "title": "Palindrome Partitioning",
      "difficulty": "Medium",
      "category": "Backtracking",
      "problemStatement": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
      "videoUrl": "",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(N * 2^N)",
      "spaceComplexity": "O(N)",
      "oneliner": "Use backtracking to explore all possible partitions.",
      "intuition": [
        "We need to try all possible ways to split the string.",
        "At each step, check if current substring is palindrome before proceeding."
      ],
      "visualizationType": "array",
      "initialState": [
        "a",
        "a",
        "b"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Palindrome Partitioning",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add a to path",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [a]",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add a to path",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try b instead",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            "a",
            "a",
            "b"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def partition(s):\n    \"\"\"\n    Intuition:\n    - We need to try all possible ways to split the string.\n    - At each step, check if current substring is palindrome before proceeding.\n    \"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]  # Reverse the sequence.\n    \n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])  # Add to end.\n            return\n        \n        for end in range(start, len(s)):  # Iterate through the range.\n            if is_palindrome(s[start:end+1]):\n                path.append(s[start:end+1])  # Add to end.\n                backtrack(end + 1, path)\n                path.pop()  # Remove and return last element.\n    \n    result = []\n    backtrack(0, [])\n    return result  # Return the final result.",
      "keyInsight": "Use backtracking to generate all valid partitions by checking palindromes at each step.",
      "testCases": [
        {
          "input": "s = \"aab\"",
          "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
        },
        {
          "input": "s = \"a\"",
          "output": "[[\"a\"]]"
        }
      ],
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "hints": [
        "\ud83e\udde0 Explore all possibilities systematically",
        "\ud83d\udca1 Prune invalid branches early",
        "\ud83d\udd0d Track current state and restore after"
      ],
      "approach": "Backtracking: Use backtracking to explore all possible partitions.",
      "videoId": "3jvWodd7ht0",
      "suggestedNextQuestion": {
        "slug": "permutations",
        "title": "Permutations",
        "difficulty": "Medium",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def partition(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def partition_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N * 2^N)",
          "spaceComplexity": "O(N)",
          "intuition": [
            "We need to try all possible ways to split the string.",
            "At each step, check if current substring is palindrome before proceeding."
          ],
          "code": "def partition(s):\n    \"\"\"\n    Intuition:\n    - We need to try all possible ways to split the string.\n    - At each step, check if current substring is palindrome before proceeding.\n    \"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]  # Reverse the sequence.\n    \n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])  # Add to end.\n            return\n        \n        for end in range(start, len(s)):  # Iterate through the range.\n            if is_palindrome(s[start:end+1]):\n                path.append(s[start:end+1])  # Add to end.\n                backtrack(end + 1, path)\n                path.pop()  # Remove and return last element.\n    \n    result = []\n    backtrack(0, [])\n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[[1,2,3], [1,3,2], ...]",
          "explanation": "Generate all permutations."
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "All elements are unique"
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "n-queens": {
      "id": "n-queens",
      "slug": "n-queens",
      "title": "N-Queens",
      "difficulty": "Hard",
      "category": "Backtracking",
      "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
      "videoUrl": "",
      "pattern": "Backtracking",
      "patternEmoji": "\ud83d\udd04",
      "timeComplexity": "O(N!)",
      "spaceComplexity": "O(N\u00b2)",
      "oneliner": "Place queens row by row, backtracking when conflicts arise.",
      "intuition": [
        "Queens can attack horizontally, vertically, and diagonally",
        "Place one queen per row and check for conflicts before proceeding"
      ],
      "visualizationType": "grid",
      "initialState": [
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ],
        [
          ".",
          ".",
          ".",
          "."
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: N-Queens",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add .,.,.,. to path",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [.,.,.,.]",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add .,.,.,. to path",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try .,.,.,. instead",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "."
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def solveNQueens(n):\n    \"\"\"\n    Intuition:\n    - Queens can attack horizontally, vertically, and diagonally\n    - Place one queen per row and check for conflicts before proceeding\n    \"\"\"\n    def is_safe(board, row, col):\n        for i in range(row):  # Iterate through the range.\n            if board[i] == col or \\\n               board[i] - i == col - row or \\\n               board[i] + i == col + row:\n                return False  # Condition not met.\n        return True  # Condition satisfied.\n    \n    def backtrack(board, row):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n-col-1) for col in board])  # Add to end.\n            return\n        for col in range(n):  # Iterate through the range.\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(board, row + 1)\n    \n    result = []\n    backtrack([-1] * n, 0)\n    return result  # Return the final result.",
      "keyInsight": "Use 1D array where index=row and value=column for efficient conflict checking",
      "testCases": [
        {
          "input": "n = 4",
          "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
        },
        {
          "input": "n = 1",
          "output": "[[\"Q\"]]"
        }
      ],
      "walkthrough": [
        "Define choice space for current position",
        "Make a choice and recurse",
        "Check if current state is valid",
        "If solution found, record it",
        "Undo choice and try next option"
      ],
      "hints": [
        "\ud83e\udde0 Explore all possibilities systematically",
        "\ud83d\udca1 Prune invalid branches early",
        "\ud83d\udd0d Track current state and restore after"
      ],
      "approach": "Backtracking: Place queens row by row, backtracking when conflicts arise.",
      "videoId": "Ph95IHmRp5M",
      "suggestedNextQuestion": {
        "slug": "n-queens-ii",
        "title": "N-Queens II",
        "difficulty": "Hard",
        "pattern": "Backtracking"
      },
      "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
      "initialCode": "def solveNQueens(n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n!)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all permutations/combinations.",
            "Filter valid ones at the end."
          ],
          "code": "def solveNQueens_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(N!)",
          "spaceComplexity": "O(N\u00b2)",
          "intuition": [
            "Queens can attack horizontally, vertically, and diagonally",
            "Place one queen per row and check for conflicts before proceeding"
          ],
          "code": "def solveNQueens(n):\n    \"\"\"\n    Intuition:\n    - Queens can attack horizontally, vertically, and diagonally\n    - Place one queen per row and check for conflicts before proceeding\n    \"\"\"\n    def is_safe(board, row, col):\n        for i in range(row):  # Iterate through the range.\n            if board[i] == col or \\\n               board[i] - i == col - row or \\\n               board[i] + i == col + row:\n                return False  # Condition not met.\n        return True  # Condition satisfied.\n    \n    def backtrack(board, row):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n-col-1) for col in board])  # Add to end.\n            return\n        for col in range(n):  # Iterate through the range.\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(board, row + 1)\n    \n    result = []\n    backtrack([-1] * n, 0)\n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[[1,2,3], [1,3,2], ...]",
          "explanation": "Generate all permutations."
        },
        {
          "input": "nums = [1]",
          "output": "[[1]]",
          "explanation": "Single element."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10",
        "All elements are unique"
      ],
      "commonMistakes": [
        "Not undoing choices properly",
        "Missing pruning conditions",
        "Duplicates in result"
      ],
      "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates."
    },
    "koko-eating-bananas": {
      "id": "koko-eating-bananas",
      "slug": "koko-eating-bananas",
      "title": "Koko Eating Bananas",
      "difficulty": "Medium",
      "category": "Binary Search",
      "problemStatement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
      "videoUrl": "",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(n log(max(piles)))",
      "spaceComplexity": "O(1)",
      "oneliner": "Binary search on eating speed k between 1 and max(piles).",
      "intuition": [
        "We want to find the minimum eating speed k - this suggests optimization.",
        "If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search."
      ],
      "visualizationType": "array",
      "initialState": [
        3,
        6,
        7,
        11
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Koko Eating Bananas",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 6",
          "transientMessage": "Iteration 2",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 7",
          "transientMessage": "Iteration 3",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 11",
          "transientMessage": "Iteration 4",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            3,
            6,
            7,
            11
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "import math\n\ndef minEatingSpeed(piles, h):\n    \"\"\"\n    Intuition:\n    - We want to find the minimum eating speed k - this suggests optimization.\n    - If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search.\n    \"\"\"\n    left, right = 1, max(piles)  # Take the maximum value.\n    result = right\n    \n    while left <= right:\n        k = (left + right) // 2\n        hours = 0\n        for pile in piles:  # Iterate over elements.\n            hours += math.ceil(pile / k)\n        \n        if hours <= h:\n            result = k\n            right = k - 1\n        else:\n            left = k + 1\n            \n    return result  # Return the final result.",
      "keyInsight": "Binary search works because if speed k is sufficient, then k+1, k+2, ... are all sufficient (we want minimum).",
      "testCases": [
        {
          "input": "piles = [3,6,7,11], h = 8",
          "output": "4"
        },
        {
          "input": "piles = [30,11,23,4,20], h = 5",
          "output": "30"
        },
        {
          "input": "piles = [30,11,23,4,20], h = 6",
          "output": "23"
        }
      ],
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "hints": [
        "\ud83e\udde0 What property makes this problem sortable?",
        "\ud83d\udca1 Define clear boundaries for search space",
        "\ud83d\udd0d What should mid represent?"
      ],
      "approach": "Binary Search: Binary search on eating speed k between 1 and max(piles).",
      "videoId": "U2SozAs9RzA",
      "suggestedNextQuestion": {
        "slug": "search-a-2d-matrix",
        "title": "Search a 2D Matrix",
        "difficulty": "Medium",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "def minEatingSpeed(piles, h):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def minEatingSpeed_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log(max(piles)))",
          "spaceComplexity": "O(1)",
          "intuition": [
            "We want to find the minimum eating speed k - this suggests optimization.",
            "If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search."
          ],
          "code": "import math\n\ndef minEatingSpeed(piles, h):\n    \"\"\"\n    Intuition:\n    - We want to find the minimum eating speed k - this suggests optimization.\n    - If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search.\n    \"\"\"\n    left, right = 1, max(piles)  # Take the maximum value.\n    result = right\n    \n    while left <= right:\n        k = (left + right) // 2\n        hours = 0\n        for pile in piles:  # Iterate over elements.\n            hours += math.ceil(pile / k)\n        \n        if hours <= h:\n            result = k\n            right = k - 1\n        else:\n            left = k + 1\n            \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3, 4, 5], target = 3",
          "output": "2",
          "explanation": "Target found at index 2."
        },
        {
          "input": "nums = [1, 2, 3], target = 0",
          "output": "-1",
          "explanation": "Target not found."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "Array is sorted"
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "time-based-key-value-store": {
      "id": "time-based-key-value-store",
      "slug": "time-based-key-value-store",
      "title": "Time Based Key-Value Store",
      "difficulty": "Medium",
      "category": "Binary Search",
      "problemStatement": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\nImplement the TimeMap class:",
      "videoUrl": "",
      "pattern": "Binary Search",
      "patternEmoji": "\ud83d\udd0d",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use binary search on sorted timestamps to find the latest valid value.",
      "intuition": [
        "Store values with timestamps in a sorted list for each key",
        "Use binary search to efficiently find the largest timestamp \u2264 target"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          "foo",
          "bar",
          1
        ],
        [
          "foo",
          "bar2",
          4
        ],
        [
          "foo",
          "bar3",
          6
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Time Based Key-Value Store",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = foo,bar,1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = foo,bar2,4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = foo,bar3,6",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              "foo",
              "bar",
              1
            ],
            [
              "foo",
              "bar2",
              4
            ],
            [
              "foo",
              "bar3",
              6
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "class TimeMap:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Store values with timestamps in a sorted list for each key\n    - Use binary search to efficiently find the largest timestamp \u2264 target\n    \"\"\"\n        self.store = {}\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])  # Add to end.\n    \n    def get(self, key: str, timestamp: int) -> str:\n        res = \"\"\n        values = self.store.get(key, [])\n        \n        l, r = 0, len(values) - 1  # Initialize two pointers.\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res  # Return the final result.",
      "keyInsight": "Timestamps are stored in increasing order, enabling binary search.",
      "testCases": [
        {
          "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 1)",
          "output": "'bar'"
        },
        {
          "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 3)",
          "output": "'bar'"
        },
        {
          "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.set('foo', 'bar2', 4); timeMap.get('foo', 4)",
          "output": "'bar2'"
        }
      ],
      "walkthrough": [
        "Set left and right pointers to search bounds",
        "While left < right, calculate mid point",
        "Check condition and narrow search space",
        "Adjust left or right based on comparison",
        "Return result when converged"
      ],
      "hints": [
        "\ud83e\udde0 What property makes this problem sortable?",
        "\ud83d\udca1 Define clear boundaries for search space",
        "\ud83d\udd0d What should mid represent?"
      ],
      "approach": "Binary Search: Use binary search on sorted timestamps to find the latest valid value.",
      "videoId": "fu2cD_6E8Hw",
      "suggestedNextQuestion": {
        "slug": "median-of-two-sorted-arrays",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "pattern": "Binary Search"
      },
      "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Linear scan through all elements.",
            "Check each element one by one."
          ],
          "code": "def __init___brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Store values with timestamps in a sorted list for each key",
            "Use binary search to efficiently find the largest timestamp \u2264 target"
          ],
          "code": "class TimeMap:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Store values with timestamps in a sorted list for each key\n    - Use binary search to efficiently find the largest timestamp \u2264 target\n    \"\"\"\n        self.store = {}\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])  # Add to end.\n    \n    def get(self, key: str, timestamp: int) -> str:\n        res = \"\"\n        values = self.store.get(key, [])\n        \n        l, r = 0, len(values) - 1  # Initialize two pointers.\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3, 4, 5], target = 3",
          "output": "2",
          "explanation": "Target found at index 2."
        },
        {
          "input": "nums = [1, 2, 3], target = 0",
          "output": "-1",
          "explanation": "Target not found."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "Array is sorted"
      ],
      "commonMistakes": [
        "Infinite loop due to wrong mid calculation",
        "Off-by-one in left/right bounds",
        "Not handling empty array"
      ],
      "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most."
    },
    "kth-largest-element-in-a-stream": {
      "id": "kth-largest-element-in-a-stream",
      "slug": "kth-largest-element-in-a-stream",
      "title": "Kth Largest Element in a Stream",
      "difficulty": "Easy",
      "category": "Heap",
      "problemStatement": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\nYou are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.\nImplement the KthLargest class:",
      "videoUrl": "",
      "pattern": "Min Heap",
      "patternEmoji": "\u2b07\ufe0f",
      "timeComplexity": "O(n log k)",
      "spaceComplexity": "O(k)",
      "oneliner": "Use a min-heap of size k to track the kth largest element.",
      "intuition": [
        "We only need to keep track of the k largest elements seen so far",
        "A min-heap of size k will have the kth largest at its root"
      ],
      "visualizationType": "array",
      "initialState": [
        4,
        5,
        8,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Kth Largest Element in a Stream",
          "transientMessage": "Input: [4, 5, 8, 2]",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 4",
          "transientMessage": "Step 1 of 4",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 5",
          "transientMessage": "Step 2 of 4",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 8",
          "transientMessage": "Step 3 of 4",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 2",
          "transientMessage": "Step 4 of 4",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            4,
            5,
            8,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n    \"\"\"\n    Intuition:\n    - We only need to keep track of the k largest elements seen so far\n    - A min-heap of size k will have the kth largest at its root\n    \"\"\"\n        self.k = k\n        self.heap = nums[:]\n        heapq.heapify(self.heap)  # Convert list into a heap.\n        \n        # Maintain heap size as k\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        # Maintain heap size as k\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n            \n        return self.heap[0]",
      "keyInsight": "Min-heap of size k keeps kth largest at root; only store k elements.",
      "testCases": [
        {
          "input": "commands = [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]; args = [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "input": "commands = [\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]; args = [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Min Heap: Use a min-heap of size k to track the kth largest element.",
      "videoId": "hOjcdrqMoQ8",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "    def __init__(self, k: int, nums: list[int]):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def __init___brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(k)",
          "intuition": [
            "We only need to keep track of the k largest elements seen so far",
            "A min-heap of size k will have the kth largest at its root"
          ],
          "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n    \"\"\"\n    Intuition:\n    - We only need to keep track of the k largest elements seen so far\n    - A min-heap of size k will have the kth largest at its root\n    \"\"\"\n        self.k = k\n        self.heap = nums[:]\n        heapq.heapify(self.heap)  # Convert list into a heap.\n        \n        # Maintain heap size as k\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        # Maintain heap size as k\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n            \n        return self.heap[0]"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "last-stone-weight": {
      "id": "last-stone-weight",
      "slug": "last-stone-weight",
      "title": "Last Stone Weight",
      "difficulty": "Easy",
      "category": "Heap",
      "problemStatement": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.",
      "videoUrl": "",
      "pattern": "Heap (Priority Queue)",
      "patternEmoji": "\u2b07\ufe0f",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use a max heap to efficiently retrieve the two heaviest stones.",
      "intuition": [
        "We always need the two heaviest stones, so we need efficient access to the maximum elements.",
        "A max heap allows us to retrieve the maximum element in O(log n) time."
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        7,
        4,
        1,
        8,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Last Stone Weight",
          "transientMessage": "Input: [2, 7, 4, 1, 8, 1]",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Process the array",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Processing element 0: 2",
          "transientMessage": "Step 1 of 5",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Processing element 1: 7",
          "transientMessage": "Step 2 of 5",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Processing element 2: 4",
          "transientMessage": "Step 3 of 5",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Processing element 3: 1",
          "transientMessage": "Step 4 of 5",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Processing element 4: 8",
          "transientMessage": "Step 5 of 5",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result computed!",
          "arrayState": [
            2,
            7,
            4,
            1,
            8,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "import heapq\n\ndef lastStoneWeight(stones):\n    \"\"\"\n    Intuition:\n    - We always need the two heaviest stones, so we need efficient access to the maximum elements.\n    - A max heap allows us to retrieve the maximum element in O(log n) time.\n    \"\"\"\n    # Convert to negative values for max heap simulation\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)  # Convert list into a heap.\n    \n    while len(heap) > 1:\n        # Get two heaviest stones\n        first = -heapq.heappop(heap)  # Remove and return last element.\n        second = -heapq.heappop(heap)  # Remove and return last element.\n        \n        # If they're not equal, push back the difference\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    return -heap[0] if heap else 0",
      "keyInsight": "Python's heapq is a min heap, so we negate values to simulate a max heap.",
      "testCases": [
        {
          "input": "stones = [2,7,4,1,8,1]",
          "output": "1"
        },
        {
          "input": "stones = [1]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Heap (Priority Queue): Use a max heap to efficiently retrieve the two heaviest stones.",
      "videoId": "B-QCq79-Vfw",
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "def lastStoneWeight(stones):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Sort the entire array.",
            "Pick top K elements from sorted result."
          ],
          "code": "def lastStoneWeight_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "We always need the two heaviest stones, so we need efficient access to the maximum elements.",
            "A max heap allows us to retrieve the maximum element in O(log n) time."
          ],
          "code": "import heapq\n\ndef lastStoneWeight(stones):\n    \"\"\"\n    Intuition:\n    - We always need the two heaviest stones, so we need efficient access to the maximum elements.\n    - A max heap allows us to retrieve the maximum element in O(log n) time.\n    \"\"\"\n    # Convert to negative values for max heap simulation\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)  # Convert list into a heap.\n    \n    while len(heap) > 1:\n        # Get two heaviest stones\n        first = -heapq.heappop(heap)  # Remove and return last element.\n        second = -heapq.heappop(heap)  # Remove and return last element.\n        \n        # If they're not equal, push back the difference\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    return -heap[0] if heap else 0"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "design-twitter": {
      "id": "design-twitter",
      "slug": "design-twitter",
      "title": "Design Twitter",
      "difficulty": "Medium",
      "category": "Heap",
      "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:",
      "videoUrl": "",
      "pattern": "Hash Map + Heap",
      "patternEmoji": "\ud83d\uddc2\ufe0f+\ud83d\udd25",
      "timeComplexity": "O(n log k)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use hash maps for users/tweets and a min-heap for news feed.",
      "intuition": [
        "Need fast lookup for users and their follows \u2192 Hash Map",
        "Need top 10 most recent tweets \u2192 Min-Heap of size 10"
      ],
      "visualizationType": "array",
      "initialState": [
        "User 1 follows User 2",
        "User 2 posts tweet",
        "User 1 gets news feed"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Design Twitter",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = User 1 follows User 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = User 2 posts tweet",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = User 1 gets news feed",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "User 1 follows User 2",
            "User 2 posts tweet",
            "User 1 gets news feed"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "import heapq\nclass Twitter:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Need fast lookup for users and their follows \u2192 Hash Map\n    - Need top 10 most recent tweets \u2192 Min-Heap of size 10\n    \"\"\"\n        self.time = 0\n        self.tweets = {}\n        self.follows = {}\n    \n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        if userId not in self.tweets:\n            self.tweets[userId] = []\n        self.tweets[userId].append((-self.time, tweetId))  # Add to end.\n    \n    def getNewsFeed(self, userId):\n        heap = []\n        users = {userId} | self.follows.get(userId, set())\n        for user in users:  # Iterate over elements.\n            for tweet in self.tweets.get(user, [])[-10:]:  # Iterate over elements.\n                heapq.heappush(heap, tweet)\n                if len(heap) > 10:\n                    heapq.heappop(heap)  # Remove and return last element.\n        return [tweetId for _, tweetId in sorted(heap)]\n    \n    def follow(self, followerId, followeeId):\n        if followerId not in self.follows:\n            self.follows[followerId] = set()\n        self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        if followerId in self.follows and followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)",
      "keyInsight": "Use negative timestamps for min-heap to get most recent tweets.",
      "testCases": [
        {
          "input": "twitter = Twitter(); twitter.postTweet(1, 5); twitter.getNewsFeed(1)",
          "output": "[5]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Hash Map + Heap: Use hash maps for users/tweets and a min-heap for news feed.",
      "videoId": "pNichitDD2E",
      "suggestedNextQuestion": {
        "slug": "detect-squares",
        "title": "Detect Squares",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log k)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Need fast lookup for users and their follows \u2192 Hash Map",
            "Need top 10 most recent tweets \u2192 Min-Heap of size 10"
          ],
          "code": "import heapq\nclass Twitter:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Need fast lookup for users and their follows \u2192 Hash Map\n    - Need top 10 most recent tweets \u2192 Min-Heap of size 10\n    \"\"\"\n        self.time = 0\n        self.tweets = {}\n        self.follows = {}\n    \n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        if userId not in self.tweets:\n            self.tweets[userId] = []\n        self.tweets[userId].append((-self.time, tweetId))  # Add to end.\n    \n    def getNewsFeed(self, userId):\n        heap = []\n        users = {userId} | self.follows.get(userId, set())\n        for user in users:  # Iterate over elements.\n            for tweet in self.tweets.get(user, [])[-10:]:  # Iterate over elements.\n                heapq.heappush(heap, tweet)\n                if len(heap) > 10:\n                    heapq.heappop(heap)  # Remove and return last element.\n        return [tweetId for _, tweetId in sorted(heap)]\n    \n    def follow(self, followerId, followeeId):\n        if followerId not in self.follows:\n            self.follows[followerId] = set()\n        self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        if followerId in self.follows and followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)"
        }
      ],
      "examples": [
        {
          "input": "nums = [2, 7, 11, 15], target = 9",
          "output": "[0, 1]",
          "explanation": "Hash map stores complements."
        },
        {
          "input": "nums = [3, 3], target = 6",
          "output": "[0, 1]",
          "explanation": "Same values, different indices."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "Only one valid answer exists"
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "sum-of-two-integers": {
      "id": "sum-of-two-integers",
      "slug": "sum-of-two-integers",
      "title": "Sum of Two Integers",
      "difficulty": "Medium",
      "category": "Bit Manipulation",
      "problemStatement": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
      "videoUrl": "",
      "pattern": "Bit Manipulation",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(1)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use XOR for sum without carry and AND+shift for carry.",
      "intuition": [
        "XOR gives us the sum of two bits without considering carry",
        "AND operation identifies where carries occur, then shift left to add them"
      ],
      "visualizationType": "array",
      "initialState": [
        5,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Sum of Two Integers",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 5",
          "transientMessage": "Iteration 1",
          "arrayState": [
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            5,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            5,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def getSum(a, b):\n    \"\"\"\n    Intuition:\n    - XOR gives us the sum of two bits without considering carry\n    - AND operation identifies where carries occur, then shift left to add them\n    \"\"\"\n    mask = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1  # AND (Carry bits).\n        a = (a ^ b) & mask  # XOR (Sum without carry).\n        b = carry & mask\n    \n    return a if a <= MAX_INT else ~(a ^ mask)",
      "keyInsight": "Binary addition can be simulated using XOR (sum) and AND+shift (carry) operations.",
      "testCases": [
        {
          "input": "a = 1, b = 2",
          "output": "3"
        },
        {
          "input": "a = 2, b = 3",
          "output": "5"
        }
      ],
      "walkthrough": [
        "Identify bits pattern in problem",
        "Use bitwise operators (AND, OR, XOR, shift)",
        "Iterate through bits if needed",
        "Combine results using bit operations",
        "Return final bit result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Bit Manipulation: Use XOR for sum without carry and AND+shift for carry.",
      "videoId": "gVUrDV4tZfY",
      "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
      "initialCode": "def getSum(a, b):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def getSum(a, b):\n    mask = 0xffffffff\n    while (b & mask) > 0:\n        carry = (a & b) << 1\n        a = a ^ b\n        b = carry\n    return (a & mask) if b > 0 else a"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "XOR gives us the sum of two bits without considering carry",
            "AND operation identifies where carries occur, then shift left to add them"
          ],
          "code": "def getSum(a, b):\n    \"\"\"\n    Intuition:\n    - XOR gives us the sum of two bits without considering carry\n    - AND operation identifies where carries occur, then shift left to add them\n    \"\"\"\n    mask = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1  # AND (Carry bits).\n        a = (a ^ b) & mask  # XOR (Sum without carry).\n        b = carry & mask\n    \n    return a if a <= MAX_INT else ~(a ^ mask)"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "reverse-integer": {
      "id": "reverse-integer",
      "slug": "reverse-integer",
      "title": "Reverse Integer",
      "difficulty": "Medium",
      "category": "Bit Manipulation",
      "problemStatement": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
      "videoUrl": "",
      "pattern": "Math",
      "patternEmoji": "\ud83d\udd22",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Build reversed number digit by digit, checking overflow early.",
      "intuition": [
        "Extract digits using modulo and division operations",
        "Check for overflow before it happens using math"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Reverse Integer",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            2,
            3
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def reverse(x):\n    \"\"\"\n    Intuition:\n    - Extract digits using modulo and division operations\n    - Check for overflow before it happens using math\n    \"\"\"\n    INT_MAX, INT_MIN = 2**31 - 1, -2**31\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    reversed_num = 0\n    \n    while x_abs != 0:\n        digit = x_abs % 10\n        \n        # Check for overflow before multiplying\n        if reversed_num > (INT_MAX - digit) // 10:\n            return 0\n            \n        reversed_num = reversed_num * 10 + digit\n        x_abs //= 10\n    \n    return sign * reversed_num",
      "keyInsight": "Process digits one by one and build result, but check overflow before each multiplication.",
      "testCases": [
        {
          "input": "x = 123",
          "output": "321"
        },
        {
          "input": "x = -123",
          "output": "-321"
        },
        {
          "input": "x = 120",
          "output": "21"
        }
      ],
      "walkthrough": [
        "Identify mathematical pattern or formula",
        "Handle edge cases (zero, negative, overflow)",
        "Apply mathematical operations",
        "Optimize with mathematical properties",
        "Return computed result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Math: Build reversed number digit by digit, checking overflow early.",
      "videoId": "HAgLH58IgJQ",
      "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
      "initialCode": "def reverse(x):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def reverse(x):\n    sign = -1 if x < 0 else 1\n    x *= sign\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    return 0 if res > 2**31 else sign * res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Extract digits using modulo and division operations",
            "Check for overflow before it happens using math"
          ],
          "code": "def reverse(x):\n    \"\"\"\n    Intuition:\n    - Extract digits using modulo and division operations\n    - Check for overflow before it happens using math\n    \"\"\"\n    INT_MAX, INT_MIN = 2**31 - 1, -2**31\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    reversed_num = 0\n    \n    while x_abs != 0:\n        digit = x_abs % 10\n        \n        # Check for overflow before multiplying\n        if reversed_num > (INT_MAX - digit) // 10:\n            return 0\n            \n        reversed_num = reversed_num * 10 + digit\n        x_abs //= 10\n    \n    return sign * reversed_num"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "powx-n": {
      "id": "powx-n",
      "slug": "powx-n",
      "title": "Pow(x, n)",
      "difficulty": "Medium",
      "category": "Math",
      "problemStatement": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
      "videoUrl": "",
      "pattern": "Binary Exponentiation",
      "patternEmoji": "\u26a1",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use binary exponentiation to reduce multiplication steps.",
      "intuition": [
        "Instead of multiplying x n times, break n into powers of 2",
        "Use the property: x^n = (x^(n/2))^2 to halve the problem size"
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        10
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Pow(x, n)",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 10",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            10
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Compute result phase 7",
          "transientMessage": "Building solution",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [
            1,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            2,
            10
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def myPow(x, n):\n    \"\"\"\n    Intuition:\n    - Instead of multiplying x n times, break n into powers of 2\n    - Use the property: x^n = (x^(n/2))^2 to halve the problem size\n    \"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result  # Return the final result.",
      "keyInsight": "Repeated squaring reduces exponential time to logarithmic.",
      "testCases": [
        {
          "input": "x = 2.00000, n = 10",
          "output": "1024.00000"
        },
        {
          "input": "x = 2.10000, n = 3",
          "output": "9.26100"
        },
        {
          "input": "x = 2.00000, n = -2",
          "output": "0.25000"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Binary Exponentiation: Use binary exponentiation to reduce multiplication steps.",
      "videoId": "g9YQyYi4IQQ",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def myPow(x, n):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def myPow(x, n):\n    def helper(x, n):\n        if x == 0: return 0\n        if n == 0: return 1\n        res = helper(x, n // 2)\n        res = res * res\n        return x * res if n % 2 else res\n    res = helper(x, abs(n))\n    return res if n >= 0 else 1 / res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(log n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Instead of multiplying x n times, break n into powers of 2",
            "Use the property: x^n = (x^(n/2))^2 to halve the problem size"
          ],
          "code": "def myPow(x, n):\n    \"\"\"\n    Intuition:\n    - Instead of multiplying x n times, break n into powers of 2\n    - Use the property: x^n = (x^(n/2))^2 to halve the problem size\n    \"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "multiply-strings": {
      "id": "multiply-strings",
      "slug": "multiply-strings",
      "title": "Multiply Strings",
      "difficulty": "Medium",
      "category": "Math",
      "problemStatement": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
      "videoUrl": "",
      "pattern": "Simulation",
      "patternEmoji": "\ud83c\udfad",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m+n)",
      "oneliner": "Simulate multiplication digit by digit like elementary school math.",
      "intuition": [
        "Multiply each digit of num1 with each digit of num2",
        "Handle carries and position shifts properly"
      ],
      "visualizationType": "array",
      "initialState": [
        0,
        0,
        0,
        0,
        0
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Multiply Strings",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 0",
          "transientMessage": "Iteration 1",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 0",
          "transientMessage": "Iteration 2",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 0",
          "transientMessage": "Iteration 3",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 0",
          "transientMessage": "Iteration 4",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 0",
          "transientMessage": "Iteration 5",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def multiply(num1, num2):\n    \"\"\"\n    Intuition:\n    - Multiply each digit of num1 with each digit of num2\n    - Handle carries and position shifts properly\n    \"\"\"\n    if num1 == '0' or num2 == '0':\n        return '0'\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):  # Iterate through the range.\n        for j in range(n-1, -1, -1):  # Iterate through the range.\n            mul = int(num1[i]) * int(num2[j])\n            pos1, pos2 = i + j, i + j + 1\n            total = mul + result[pos2]\n            \n            result[pos2] = total % 10\n            result[pos1] += total // 10\n    \n    # Skip leading zeros\n    start = 0\n    while start < len(result) and result[start] == 0:\n        start += 1\n    \n    return ''.join(map(str, result[start:])) if start < len(result) else '0'",
      "keyInsight": "Use an array to store intermediate results and handle carries properly.",
      "testCases": [
        {
          "input": "num1 = \"2\", num2 = \"3\"",
          "output": "\"6\""
        },
        {
          "input": "num1 = \"123\", num2 = \"456\"",
          "output": "\"56088\""
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Simulation: Simulate multiplication digit by digit like elementary school math.",
      "videoId": "1vZswirL8Y8",
      "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
      "initialCode": "def multiply(num1, num2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def multiply(num1, num2):\n    if \"0\" in [num1, num2]: return \"0\"\n    res = [0] * (len(num1) + len(num2))\n    num1, num2 = num1[::-1], num2[::-1]\n    \n    for i1 in range(len(num1)):\n        for i2 in range(len(num2)):\n            digit = int(num1[i1]) * int(num2[i2])\n            res[i1 + i2] += digit\n            res[i1 + i2 + 1] += (res[i1 + i2] // 10)\n            res[i1 + i2] = res[i1 + i2] % 10\n            \n    res, beg = res[::-1], 0\n    while beg < len(res) and res[beg] == 0:\n        beg += 1\n    return \"\".join(map(str, res[beg:]))"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m+n)",
          "intuition": [
            "Multiply each digit of num1 with each digit of num2",
            "Handle carries and position shifts properly"
          ],
          "code": "def multiply(num1, num2):\n    \"\"\"\n    Intuition:\n    - Multiply each digit of num1 with each digit of num2\n    - Handle carries and position shifts properly\n    \"\"\"\n    if num1 == '0' or num2 == '0':\n        return '0'\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):  # Iterate through the range.\n        for j in range(n-1, -1, -1):  # Iterate through the range.\n            mul = int(num1[i]) * int(num2[j])\n            pos1, pos2 = i + j, i + j + 1\n            total = mul + result[pos2]\n            \n            result[pos2] = total % 10\n            result[pos1] += total // 10\n    \n    # Skip leading zeros\n    start = 0\n    while start < len(result) and result[start] == 0:\n        start += 1\n    \n    return ''.join(map(str, result[start:])) if start < len(result) else '0'"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "detect-squares": {
      "id": "detect-squares",
      "slug": "detect-squares",
      "title": "Detect Squares",
      "difficulty": "Medium",
      "category": "Math",
      "problemStatement": "You are given a stream of points on the X-Y plane. Design an algorithm that:\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\nImplement the DetectSquares class:",
      "videoUrl": "",
      "pattern": "Geometry + Hash Map",
      "patternEmoji": "\ud83d\udcd0\ud83d\udcca",
      "timeComplexity": "O(n) per query",
      "spaceComplexity": "O(n)",
      "oneliner": "For each existing point, check if it can form a square with the query point and two others.",
      "intuition": [
        "To form a square with query point (x,y), we need three other points that create equal sides and right angles",
        "For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          3,
          10
        ],
        [
          11,
          2
        ],
        [
          3,
          2
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Detect Squares",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            [
              3,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 3,10",
          "arrayState": [
            [
              3,
              10
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              3,
              10
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 11,2",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 3,2",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            [
              3,
              2
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            [
              3,
              2
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            [
              3,
              2
            ]
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              3,
              10
            ],
            [
              11,
              2
            ],
            [
              3,
              2
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - To form a square with query point (x,y), we need three other points that create equal sides and right angles\n    - For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length\n    \"\"\"\n        self.point_counts = defaultdict(int)\n        \n    def add(self, point):\n        self.point_counts[tuple(point)] += 1\n        \n    def count(self, point):\n        px, py = point\n        count = 0\n        \n        # For each existing point\n        for (x, y), freq in self.point_counts.items():  # Iterate over elements.\n            # Skip if not diagonal candidate\n            if abs(px - x) != abs(py - y) or px == x or py == y:\n                continue\n                \n            # Check if other two corners exist\n            count += freq * self.point_counts[(px, y)] * self.point_counts[(x, py)]\n            \n        return count",
      "keyInsight": "Use hash map to store point frequencies and check diagonal relationships.",
      "testCases": [
        {
          "input": "detectSquares = DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10])",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Geometry + Hash Map: For each existing point, check if it can form a square with the query point and two others.",
      "videoId": "bahebearrDc",
      "suggestedNextQuestion": {
        "slug": "group-anagrams",
        "title": "Group Anagrams",
        "difficulty": "Medium",
        "pattern": "Arrays & Hashing"
      },
      "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
      "initialCode": "    def __init__(self):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Use nested loops to find pairs/groups.",
            "Compare elements directly without using extra space."
          ],
          "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n) per query",
          "spaceComplexity": "O(n)",
          "intuition": [
            "To form a square with query point (x,y), we need three other points that create equal sides and right angles",
            "For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length"
          ],
          "code": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - To form a square with query point (x,y), we need three other points that create equal sides and right angles\n    - For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length\n    \"\"\"\n        self.point_counts = defaultdict(int)\n        \n    def add(self, point):\n        self.point_counts[tuple(point)] += 1\n        \n    def count(self, point):\n        px, py = point\n        count = 0\n        \n        # For each existing point\n        for (x, y), freq in self.point_counts.items():  # Iterate over elements.\n            # Skip if not diagonal candidate\n            if abs(px - x) != abs(py - y) or px == x or py == y:\n                continue\n                \n            # Check if other two corners exist\n            count += freq * self.point_counts[(px, y)] * self.point_counts[(x, py)]\n            \n        return count"
        }
      ],
      "examples": [
        {
          "input": "nums = [2, 7, 11, 15], target = 9",
          "output": "[0, 1]",
          "explanation": "Hash map stores complements."
        },
        {
          "input": "nums = [3, 3], target = 6",
          "output": "[0, 1]",
          "explanation": "Same values, different indices."
        }
      ],
      "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^9 <= nums[i] <= 10^9",
        "Only one valid answer exists"
      ],
      "commonMistakes": [
        "Not handling duplicate keys",
        "Forgetting to check if key exists",
        "Using unhashable types as keys"
      ],
      "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling."
    },
    "min-cost-climbing-stairs": {
      "id": "min-cost-climbing-stairs",
      "slug": "min-cost-climbing-stairs",
      "title": "Min Cost Climbing Stairs",
      "difficulty": "Easy",
      "category": "1-D Dynamic Programming",
      "problemStatement": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use DP to track min cost to reach each step, only keeping last two values.",
      "intuition": [
        "To reach step i, you must have come from step i-1 or i-2",
        "The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)"
      ],
      "visualizationType": "array",
      "initialState": [
        10,
        15,
        20
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Input: [10, 15, 20]",
          "transientMessage": "Dynamic programming approach",
          "arrayState": [
            10,
            15,
            20
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP array",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "dp",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "dp[0] = 10",
          "transientMessage": "Update state",
          "arrayState": [
            10,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "success"
        },
        {
          "step": 4,
          "visual": "dp[1] = 15",
          "transientMessage": "Update state",
          "arrayState": [
            10,
            15,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "dp[2] = 20",
          "transientMessage": "Update state",
          "arrayState": [
            10,
            15,
            20
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Final DP: [10, 15, 20]",
          "transientMessage": "Complete!",
          "arrayState": [
            10,
            15,
            20
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def minCostClimbingStairs(cost):\n    \"\"\"\n    Intuition:\n    - To reach step i, you must have come from step i-1 or i-2\n    - The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)\n    \"\"\"\n    prev2, prev1 = cost[0], cost[1]\n    for i in range(2, len(cost)):  # Iterate through the range.\n        current = cost[i] + min(prev1, prev2)  # Take the minimum value.\n        prev2, prev1 = prev1, current\n    return min(prev1, prev2)  # Take the minimum value.",
      "keyInsight": "We only need to remember the minimum cost to reach the previous two steps.",
      "testCases": [
        {
          "input": "cost = [10,15,20]",
          "output": "15"
        },
        {
          "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
          "output": "6"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use DP to track min cost to reach each step, only keeping last two values.",
      "videoId": "ktmzAZWkEZ0",
      "suggestedNextQuestion": {
        "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "title": "Best Time to Buy And Sell Stock With Cooldown",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def minCostClimbingStairs(cost):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def minCostClimbingStairs_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "To reach step i, you must have come from step i-1 or i-2",
            "The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)"
          ],
          "code": "def minCostClimbingStairs(cost):\n    \"\"\"\n    Intuition:\n    - To reach step i, you must have come from step i-1 or i-2\n    - The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)\n    \"\"\"\n    prev2, prev1 = cost[0], cost[1]\n    for i in range(2, len(cost)):  # Iterate through the range.\n        current = cost[i] + min(prev1, prev2)  # Take the minimum value.\n        prev2, prev1 = prev1, current\n    return min(prev1, prev2)  # Take the minimum value."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "house-robber-ii": {
      "id": "house-robber-ii",
      "slug": "house-robber-ii",
      "title": "House Robber II",
      "difficulty": "Medium",
      "category": "1-D Dynamic Programming",
      "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Split into two subproblems: exclude first or last house.",
      "intuition": [
        "Houses form a circle, so we can't rob both first and last houses together",
        "Solve two linear versions: one excluding first house, one excluding last house"
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: House Robber II",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 2",
          "arrayState": [
            2,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 3",
          "arrayState": [
            2,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            2,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 2",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [],
          "indices": [
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            2,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - Houses form a circle, so we can't rob both first and last houses together\n    - Solve two linear versions: one excluding first house, one excluding last house\n    \"\"\"\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2 = prev1 = 0\n        for money in houses:  # Iterate over elements.\n            current = max(prev1, prev2 + money)  # Take the maximum value.\n            prev2, prev1 = prev1, current\n        return prev1\n    \n    # Return max of two scenarios: exclude first or exclude last\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))  # Take the maximum value.",
      "keyInsight": "Circular constraint means we can't rob first and last houses together. Solve 2 linear problems.",
      "testCases": [
        {
          "input": "nums = [2,3,2]",
          "output": "3"
        },
        {
          "input": "nums = [1,2,3,1]",
          "output": "4"
        },
        {
          "input": "nums = [1,2,3]",
          "output": "3"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Split into two subproblems: exclude first or last house.",
      "videoId": "rWAJCfYYOvM",
      "suggestedNextQuestion": {
        "slug": "interleaving-string",
        "title": "Interleaving String",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def rob(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def rob_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Houses form a circle, so we can't rob both first and last houses together",
            "Solve two linear versions: one excluding first house, one excluding last house"
          ],
          "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - Houses form a circle, so we can't rob both first and last houses together\n    - Solve two linear versions: one excluding first house, one excluding last house\n    \"\"\"\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2 = prev1 = 0\n        for money in houses:  # Iterate over elements.\n            current = max(prev1, prev2 + money)  # Take the maximum value.\n            prev2, prev1 = prev1, current\n        return prev1\n    \n    # Return max of two scenarios: exclude first or exclude last\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))  # Take the maximum value."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "palindromic-substrings": {
      "id": "palindromic-substrings",
      "slug": "palindromic-substrings",
      "title": "Palindromic Substrings",
      "difficulty": "Medium",
      "category": "1-D Dynamic Programming",
      "problemStatement": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.",
      "videoUrl": "",
      "pattern": "Expand Around Centers",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(n\u00b2)",
      "spaceComplexity": "O(1)",
      "oneliner": "Check odd/even length palindromes by expanding around each center.",
      "intuition": [
        "Every palindrome has a center - either a character (odd length) or between two characters (even length)",
        "For each possible center, expand outward while characters match"
      ],
      "visualizationType": "tree",
      "initialState": [
        "a",
        "b",
        "a"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Palindromic Substrings",
          "transientMessage": "Tree traversal approach",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start at root",
          "transientMessage": "Root value: 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "root",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Check left subtree",
          "transientMessage": "Left child at index 1",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse on left.left",
          "transientMessage": "Node value: 4",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Recurse on left.right",
          "transientMessage": "Node value: 5",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "L",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 6,
          "visual": "Check right subtree",
          "transientMessage": "Right child at index 2",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Recurse on right.left",
          "transientMessage": "Node value: 6",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Recurse on right.right",
          "transientMessage": "Node value: 7",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [
            {
              "label": "R",
              "index": 6
            }
          ],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Combine results",
          "transientMessage": "Aggregate from subtrees",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Traversal complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            4,
            5,
            6,
            7
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def countSubstrings(s: str) -> int:\n    \"\"\"\n    Intuition:\n    - Every palindrome has a center - either a character (odd length) or between two characters (even length)\n    - For each possible center, expand outward while characters match\n    \"\"\"\n    count = 0\n    for i in range(len(s)):  # Iterate through the range.\n        # Odd length palindromes\n        l, r = i, i  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n        # Even length palindromes\n        l, r = i, i + 1  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n    return count",
      "keyInsight": "Instead of checking all substrings, expand from each possible center.",
      "testCases": [
        {
          "input": "s = \"abc\"",
          "output": "3"
        },
        {
          "input": "s = \"aaa\"",
          "output": "6"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Expand Around Centers: Check odd/even length palindromes by expanding around each center.",
      "videoId": "4RACzI5-du8",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def countSubstrings(s: str) -> int:\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def countSubstrings(s):\n    res = 0\n    for i in range(len(s)):\n        # Odd\n        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        # Even\n        l, r = i, i+1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b2)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Every palindrome has a center - either a character (odd length) or between two characters (even length)",
            "For each possible center, expand outward while characters match"
          ],
          "code": "def countSubstrings(s: str) -> int:\n    \"\"\"\n    Intuition:\n    - Every palindrome has a center - either a character (odd length) or between two characters (even length)\n    - For each possible center, expand outward while characters match\n    \"\"\"\n    count = 0\n    for i in range(len(s)):  # Iterate through the range.\n        # Odd length palindromes\n        l, r = i, i  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n        # Even length palindromes\n        l, r = i, i + 1  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n    return count"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "maximum-product-subarray": {
      "id": "maximum-product-subarray",
      "slug": "maximum-product-subarray",
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "category": "1-D Dynamic Programming",
      "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track both max and min products at each step due to negative numbers.",
      "intuition": [
        "Negative numbers can flip a small negative product to a large positive one",
        "We need to track both maximum and minimum products at each position"
      ],
      "visualizationType": "array",
      "initialState": [
        2,
        3,
        -2,
        4
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Maximum Product Subarray",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2",
          "transientMessage": "Iteration 1",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 3",
          "transientMessage": "Iteration 2",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = -2",
          "transientMessage": "Iteration 3",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 4",
          "transientMessage": "Iteration 4",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            2,
            3,
            -2,
            4
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def maxProduct(nums):\n    \"\"\"\n    Intuition:\n    - Negative numbers can flip a small negative product to a large positive one\n    - We need to track both maximum and minimum products at each position\n    \"\"\"\n    if not nums:\n        return 0\n    \n    maxProd = minProd = result = nums[0]\n    \n    for i in range(1, len(nums)):  # Iterate through the range.\n        num = nums[i]\n        \n        # Store current maxProd before updating\n        tempMax = max(num, maxProd * num, minProd * num)  # Take the maximum value.\n        minProd = min(num, maxProd * num, minProd * num)  # Take the minimum value.\n        maxProd = tempMax\n        \n        result = max(result, maxProd)  # Take the maximum value.\n    \n    return result  # Return the final result.",
      "keyInsight": "Negative numbers can turn the smallest product into the largest, so we track both max and min.",
      "testCases": [
        {
          "input": "nums = [2,3,-2,4]",
          "output": "6"
        },
        {
          "input": "nums = [-2,0,-1]",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Track both max and min products at each step due to negative numbers.",
      "videoId": "lXVy6YWFcRM",
      "suggestedNextQuestion": {
        "slug": "minimum-path-sum",
        "title": "Minimum Path Sum",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def maxProduct(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def maxProduct_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Negative numbers can flip a small negative product to a large positive one",
            "We need to track both maximum and minimum products at each position"
          ],
          "code": "def maxProduct(nums):\n    \"\"\"\n    Intuition:\n    - Negative numbers can flip a small negative product to a large positive one\n    - We need to track both maximum and minimum products at each position\n    \"\"\"\n    if not nums:\n        return 0\n    \n    maxProd = minProd = result = nums[0]\n    \n    for i in range(1, len(nums)):  # Iterate through the range.\n        num = nums[i]\n        \n        # Store current maxProd before updating\n        tempMax = max(num, maxProd * num, minProd * num)  # Take the maximum value.\n        minProd = min(num, maxProd * num, minProd * num)  # Take the minimum value.\n        maxProd = tempMax\n        \n        result = max(result, maxProd)  # Take the maximum value.\n    \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "partition-equal-subset-sum": {
      "id": "partition-equal-subset-sum",
      "slug": "partition-equal-subset-sum",
      "title": "Partition Equal Subset Sum",
      "difficulty": "Medium",
      "category": "1-D Dynamic Programming",
      "problemStatement": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n * sum)",
      "spaceComplexity": "O(sum)",
      "oneliner": "Use DP to check if we can achieve sum/2 with given numbers.",
      "intuition": [
        "If total sum is odd, partition is impossible.",
        "Transform into subset sum problem: find if subset sums to target=sum/2."
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        5,
        11,
        5
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Partition Equal Subset Sum",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add 1 to path",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [1]",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add 5 to path",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try 11 instead",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            5,
            11,
            5
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def canPartition(nums):\n    \"\"\"\n    Intuition:\n    - If total sum is odd, partition is impossible.\n    - Transform into subset sum problem: find if subset sums to target=sum/2.\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if total % 2 != 0:\n        return False  # Condition not met.\n    target = total // 2\n    dp = [False] * (target + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for num in nums:  # Iterate over elements.\n        for j in range(target, num - 1, -1):  # Iterate through the range.\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]",
      "keyInsight": "This is a 0/1 knapsack variant - we either include or exclude each number.",
      "testCases": [
        {
          "input": "nums = [1,5,11,5]",
          "output": "true"
        },
        {
          "input": "nums = [1,2,3,5]",
          "output": "false"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use DP to check if we can achieve sum/2 with given numbers.",
      "videoId": "IsvocB5BJhw",
      "suggestedNextQuestion": {
        "slug": "target-sum",
        "title": "Target Sum",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def canPartition(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def canPartition_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n * sum)",
          "spaceComplexity": "O(sum)",
          "intuition": [
            "If total sum is odd, partition is impossible.",
            "Transform into subset sum problem: find if subset sums to target=sum/2."
          ],
          "code": "def canPartition(nums):\n    \"\"\"\n    Intuition:\n    - If total sum is odd, partition is impossible.\n    - Transform into subset sum problem: find if subset sums to target=sum/2.\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if total % 2 != 0:\n        return False  # Condition not met.\n    target = total // 2\n    dp = [False] * (target + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for num in nums:  # Iterate over elements.\n        for j in range(target, num - 1, -1):  # Iterate through the range.\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "longest-common-subsequence": {
      "id": "longest-common-subsequence",
      "slug": "longest-common-subsequence",
      "title": "Longest Common Subsequence",
      "difficulty": "Medium",
      "category": "2-D Dynamic Programming",
      "problemStatement": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nA common subsequence of two strings is a subsequence that is common to both strings.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m*n)",
      "oneliner": "Build a 2D table to store LCS lengths for all substrings.",
      "intuition": [
        "If characters match, LCS is 1 + diagonal value",
        "If characters don't match, take max of left or top cell"
      ],
      "visualizationType": "grid",
      "initialState": [
        [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Common Subsequence",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 0,0,0,0,0,0",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 0,0,0,0,0,0",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 0,0,0,0,0,0",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 0,0,0,0,0,0",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def longestCommonSubsequence(text1, text2):\n    \"\"\"\n    Intuition:\n    - If characters match, LCS is 1 + diagonal value\n    - If characters don't match, take max of left or top cell\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Take the maximum value.\n    \n    return dp[m][n]",
      "keyInsight": "When characters match, we add 1 to the LCS of previous substrings. When they don't match, we take the best LCS from either skipping current character in text1 or text2.",
      "testCases": [
        {
          "input": "text1 = \"abcde\", text2 = \"ace\"",
          "output": "3"
        },
        {
          "input": "text1 = \"abc\", text2 = \"abc\"",
          "output": "3"
        },
        {
          "input": "text1 = \"abc\", text2 = \"def\"",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Build a 2D table to store LCS lengths for all substrings.",
      "videoId": "Ua0GhsJSlWM",
      "suggestedNextQuestion": {
        "slug": "longest-increasing-subsequence",
        "title": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def longestCommonSubsequence(text1, text2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def longestCommonSubsequence_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m*n)",
          "intuition": [
            "If characters match, LCS is 1 + diagonal value",
            "If characters don't match, take max of left or top cell"
          ],
          "code": "def longestCommonSubsequence(text1, text2):\n    \"\"\"\n    Intuition:\n    - If characters match, LCS is 1 + diagonal value\n    - If characters don't match, take max of left or top cell\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Take the maximum value.\n    \n    return dp[m][n]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "best-time-to-buy-and-sell-stock-with-cooldown": {
      "id": "best-time-to-buy-and-sell-stock-with-cooldown",
      "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "title": "Best Time to Buy and Sell Stock with Cooldown",
      "difficulty": "Medium",
      "category": "2-D Dynamic Programming",
      "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track max profit for holding/selling states with cooldown constraint.",
      "intuition": [
        "We can be in one of three states: holding stock, selling stock, or cooldown",
        "Use DP to track maximum profit for each state transition"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        0,
        2
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Best Time to Buy and Sell Stock with Cooldown",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            1,
            2,
            3,
            0,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 1",
          "arrayState": [
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 2",
          "arrayState": [
            1,
            2,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            2,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 3",
          "arrayState": [
            1,
            2,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            1,
            2,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            1,
            2,
            3,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            1,
            2,
            3,
            3,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 2",
          "arrayState": [
            1,
            2,
            3,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            1,
            2,
            3,
            3,
            2
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            1,
            2,
            3,
            3,
            2
          ],
          "pointers": [],
          "indices": [
            4
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            2,
            3,
            3,
            2
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - We can be in one of three states: holding stock, selling stock, or cooldown\n    - Use DP to track maximum profit for each state transition\n    \"\"\"\n    if not prices:\n        return 0\n    \n    hold = -prices[0]  # Max profit when holding stock\n    sold = 0           # Max profit when just sold\n    rest = 0           # Max profit when in cooldown/rest\n    \n    for i in range(1, len(prices)):  # Iterate through the range.\n        prev_hold = hold\n        prev_sold = sold\n        prev_rest = rest\n        \n        hold = max(prev_hold, prev_rest - prices[i])  # Hold or buy today\n        sold = prev_hold + prices[i]                  # Sell today\n        rest = max(prev_rest, prev_sold)              # Rest or continue cooldown\n    \n    return max(sold, rest)  # Max profit when ending with sell or rest",
      "keyInsight": "Track three states: holding stock, just sold, cooldown. State transitions enforce the cooldown rule.",
      "testCases": [
        {
          "input": "prices = [1,2,3,0,2]",
          "output": "3"
        },
        {
          "input": "prices = [1]",
          "output": "0"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Track max profit for holding/selling states with cooldown constraint.",
      "videoId": "I7j0F7AHpb8",
      "suggestedNextQuestion": {
        "slug": "coin-change",
        "title": "Coin Change",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
      "initialCode": "def maxProfit(prices):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def maxProfit_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "We can be in one of three states: holding stock, selling stock, or cooldown",
            "Use DP to track maximum profit for each state transition"
          ],
          "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - We can be in one of three states: holding stock, selling stock, or cooldown\n    - Use DP to track maximum profit for each state transition\n    \"\"\"\n    if not prices:\n        return 0\n    \n    hold = -prices[0]  # Max profit when holding stock\n    sold = 0           # Max profit when just sold\n    rest = 0           # Max profit when in cooldown/rest\n    \n    for i in range(1, len(prices)):  # Iterate through the range.\n        prev_hold = hold\n        prev_sold = sold\n        prev_rest = rest\n        \n        hold = max(prev_hold, prev_rest - prices[i])  # Hold or buy today\n        sold = prev_hold + prices[i]                  # Sell today\n        rest = max(prev_rest, prev_sold)              # Rest or continue cooldown\n    \n    return max(sold, rest)  # Max profit when ending with sell or rest"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "coin-change-ii": {
      "id": "coin-change-ii",
      "slug": "coin-change-ii",
      "title": "Coin Change II",
      "difficulty": "Medium",
      "category": "2-D Dynamic Programming",
      "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83e\uddee",
      "timeComplexity": "O(amount \u00d7 len(coins))",
      "spaceComplexity": "O(amount)",
      "oneliner": "Build up combinations count for each amount using previous results.",
      "intuition": [
        "For each coin, we can either use it or not use it - this creates subproblems",
        "We can build solutions for larger amounts using solutions for smaller amounts"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        0,
        0,
        0,
        0,
        0
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Coin Change II",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            1,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = 1",
          "arrayState": [
            1,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = 1",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            1,
            1,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = 2",
          "arrayState": [
            1,
            1,
            2,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            1,
            1,
            2,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = 3",
          "arrayState": [
            1,
            1,
            2,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            1,
            1,
            2,
            3,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = 4",
          "arrayState": [
            1,
            1,
            2,
            3,
            4,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            1,
            1,
            2,
            3,
            4,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            1,
            1,
            2,
            3,
            4,
            0
          ],
          "pointers": [],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            1,
            1,
            2,
            3,
            4,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def change(amount, coins):\n    \"\"\"\n    Intuition:\n    - For each coin, we can either use it or not use it - this creates subproblems\n    - We can build solutions for larger amounts using solutions for smaller amounts\n    \"\"\"\n    dp = [0] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 1  # One way to make 0 amount\n    \n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]",
      "keyInsight": "For each coin, we update all amounts >= coin by adding ways to make (amount - coin).",
      "testCases": [
        {
          "input": "amount = 5, coins = [1,2,5]",
          "output": "4"
        },
        {
          "input": "amount = 3, coins = [2]",
          "output": "0"
        },
        {
          "input": "amount = 10, coins = [10]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Build up combinations count for each amount using previous results.",
      "videoId": "Mjy4hd2xgrs",
      "suggestedNextQuestion": {
        "slug": "counting-bits",
        "title": "Counting Bits",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def change(amount, coins):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def change_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(amount \u00d7 len(coins))",
          "spaceComplexity": "O(amount)",
          "intuition": [
            "For each coin, we can either use it or not use it - this creates subproblems",
            "We can build solutions for larger amounts using solutions for smaller amounts"
          ],
          "code": "def change(amount, coins):\n    \"\"\"\n    Intuition:\n    - For each coin, we can either use it or not use it - this creates subproblems\n    - We can build solutions for larger amounts using solutions for smaller amounts\n    \"\"\"\n    dp = [0] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 1  # One way to make 0 amount\n    \n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "target-sum": {
      "id": "target-sum",
      "slug": "target-sum",
      "title": "Target Sum",
      "difficulty": "Medium",
      "category": "2-D Dynamic Programming",
      "problemStatement": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nReturn the number of different expressions that you can build, which evaluates to target.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n * sum)",
      "spaceComplexity": "O(sum)",
      "oneliner": "Use DP to count ways to reach target sum with +/- signs.",
      "intuition": [
        "Transform into subset sum problem: find subsets that sum to (total+target)/2",
        "Use DP to count combinations, not just feasibility"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        1,
        1,
        1
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Target Sum",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 1",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            1,
            1,
            1,
            1
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def findTargetSumWays(nums, target):\n    \"\"\"\n    Intuition:\n    - Transform into subset sum problem: find subsets that sum to (total+target)/2\n    - Use DP to count combinations, not just feasibility\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if abs(target) > total or (total + target) % 2 != 0:\n        return 0\n    s = (total + target) // 2\n    dp = [0] * (s + 1)  # Initialize DP table to store results.\n    dp[0] = 1\n    for num in nums:  # Iterate over elements.\n        for j in range(s, num - 1, -1):  # Iterate through the range.\n            dp[j] += dp[j - num]\n    return dp[s]",
      "keyInsight": "This is a subset sum counting problem in disguise.",
      "testCases": [
        {
          "input": "nums = [1,1,1,1,1], target = 3",
          "output": "5"
        },
        {
          "input": "nums = [1], target = 1",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use DP to count ways to reach target sum with +/- signs.",
      "videoId": "g0npyaQtAQM",
      "suggestedNextQuestion": {
        "slug": "triangle",
        "title": "Triangle",
        "difficulty": "Medium",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def findTargetSumWays(nums, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def findTargetSumWays_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n * sum)",
          "spaceComplexity": "O(sum)",
          "intuition": [
            "Transform into subset sum problem: find subsets that sum to (total+target)/2",
            "Use DP to count combinations, not just feasibility"
          ],
          "code": "def findTargetSumWays(nums, target):\n    \"\"\"\n    Intuition:\n    - Transform into subset sum problem: find subsets that sum to (total+target)/2\n    - Use DP to count combinations, not just feasibility\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if abs(target) > total or (total + target) % 2 != 0:\n        return 0\n    s = (total + target) // 2\n    dp = [0] * (s + 1)  # Initialize DP table to store results.\n    dp[0] = 1\n    for num in nums:  # Iterate over elements.\n        for j in range(s, num - 1, -1):  # Iterate through the range.\n            dp[j] += dp[j - num]\n    return dp[s]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "longest-increasing-path-in-a-matrix": {
      "id": "longest-increasing-path-in-a-matrix",
      "slug": "longest-increasing-path-in-a-matrix",
      "title": "Longest Increasing Path in a Matrix",
      "difficulty": "Hard",
      "category": "2-D Dynamic Programming",
      "problemStatement": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
      "videoUrl": "",
      "pattern": "DFS with Memoization",
      "patternEmoji": "\ud83d\udd0d\ud83d\udcbe",
      "timeComplexity": "O(m\u00d7n)",
      "spaceComplexity": "O(m\u00d7n)",
      "oneliner": "Use DFS from each cell with memoization to avoid recomputation.",
      "intuition": [
        "From each cell, explore all increasing paths in 4 directions",
        "Cache results to prevent recalculating the same subproblems"
      ],
      "visualizationType": "grid",
      "initialState": [
        [
          1,
          1,
          1
        ],
        [
          1,
          1,
          1
        ],
        [
          1,
          1,
          1
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Longest Increasing Path in a Matrix",
          "transientMessage": "Grid-based BFS/DFS approach",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize visited set",
          "transientMessage": "Track visited cells",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Start at (0, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "start",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Explore neighbors",
          "transientMessage": "Check up, down, left, right",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 0
            }
          ],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Visit (0, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 0,
              "col": 1
            }
          ],
          "indices": [
            [
              0,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Visit (1, 0)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 0
            }
          ],
          "indices": [
            [
              1,
              0
            ]
          ],
          "color": "accent"
        },
        {
          "step": 7,
          "visual": "Visit (1, 1)",
          "transientMessage": "Cell value: 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "curr",
              "row": 1,
              "col": 1
            }
          ],
          "indices": [
            [
              1,
              1
            ]
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "First island complete",
          "transientMessage": "Found island #1, count = 1",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Continue scanning grid",
          "transientMessage": "Find next unvisited land cell",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "scan",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Found another island",
          "transientMessage": "Island #2 at (2, 2)",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 2,
              "col": 2
            }
          ],
          "indices": [
            [
              2,
              2
            ]
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Continue to next island",
          "transientMessage": "Island #3 at (3, 3)",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [
            {
              "label": "island",
              "row": 3,
              "col": 3
            }
          ],
          "indices": [
            [
              3,
              3
            ],
            [
              3,
              4
            ]
          ],
          "color": "success"
        },
        {
          "step": 12,
          "visual": "Grid traversal complete",
          "transientMessage": "Total islands: 3",
          "arrayState": [
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ],
            [
              1,
              1,
              1
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def longestIncreasingPath(matrix):\n    \"\"\"\n    Intuition:\n    - From each cell, explore all increasing paths in 4 directions\n    - Cache results to prevent recalculating the same subproblems\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        max_path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for di, dj in directions:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj))  # Take the maximum value.\n        \n        memo[(i, j)] = max_path\n        return max_path\n    \n    result = 0\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            result = max(result, dfs(i, j))  # Take the maximum value.\n    \n    return result  # Return the final result.",
      "keyInsight": "Each cell's longest path is 1 + max of its increasing neighbors' paths.",
      "testCases": [
        {
          "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
          "output": "4"
        },
        {
          "input": "matrix = [[3,4,5],[3,2,6],[2,2,1]]",
          "output": "4"
        },
        {
          "input": "matrix = [[1]]",
          "output": "1"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "DFS with Memoization: Use DFS from each cell with memoization to avoid recomputation.",
      "videoId": "wCc_nd-GiEc",
      "suggestedNextQuestion": {
        "slug": "regular-expression-matching",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
      "initialCode": "def longestIncreasingPath(matrix):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def longestIncreasingPath(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    dp = {}\n    def dfs(r, c, prevVal):\n        if r<0 or r==rows or c<0 or c==cols or matrix[r][c] <= prevVal:\n            return 0\n        if (r, c) in dp: return dp[(r, c)]\n        \n        res = 1\n        res = max(res, 1 + dfs(r+1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r-1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c+1, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c-1, matrix[r][c]))\n        dp[(r, c)] = res\n        return res\n        \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, -1)\n    return max(dp.values()) if dp else 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m\u00d7n)",
          "spaceComplexity": "O(m\u00d7n)",
          "intuition": [
            "From each cell, explore all increasing paths in 4 directions",
            "Cache results to prevent recalculating the same subproblems"
          ],
          "code": "def longestIncreasingPath(matrix):\n    \"\"\"\n    Intuition:\n    - From each cell, explore all increasing paths in 4 directions\n    - Cache results to prevent recalculating the same subproblems\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        max_path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for di, dj in directions:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj))  # Take the maximum value.\n        \n        memo[(i, j)] = max_path\n        return max_path\n    \n    result = 0\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            result = max(result, dfs(i, j))  # Take the maximum value.\n    \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "distinct-subsequences": {
      "id": "distinct-subsequences",
      "slug": "distinct-subsequences",
      "title": "Distinct Subsequences",
      "difficulty": "Hard",
      "category": "2-D Dynamic Programming",
      "problemStatement": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(m*n)",
      "spaceComplexity": "O(m*n)",
      "oneliner": "Use DP to count ways to form t[0:j] using s[0:i].",
      "intuition": [
        "For each character in s, we can either include or exclude it",
        "If characters match, we add paths from diagonal (include) and above (exclude)"
      ],
      "visualizationType": "array",
      "initialState": [
        [
          "",
          "r",
          "a",
          "b",
          "b",
          "i",
          "t"
        ],
        [
          "r",
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          "a",
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          "b",
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          "b",
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          "i",
          0,
          0,
          0,
          0,
          0,
          0
        ],
        [
          "t",
          0,
          0,
          0,
          0,
          0,
          0
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Distinct Subsequences",
          "transientMessage": "Dynamic Programming approach",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "i",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "t",
              0,
              0,
              0,
              0,
              0,
              0
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize DP table",
          "transientMessage": "Set base cases",
          "arrayState": [
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Compute dp[0]",
          "transientMessage": "dp[0] = ,r,a,b,b,i,t",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            0,
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0,
            0
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Compute dp[1]",
          "transientMessage": "dp[1] = r,0,0,0,0,0,0",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[0], dp[0]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Compute dp[2]",
          "transientMessage": "dp[2] = a,0,0,0,0,0,0",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[1], dp[0]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute dp[3]",
          "transientMessage": "dp[3] = b,0,0,0,0,0,0",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "accent"
        },
        {
          "step": 10,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[2], dp[1]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            2,
            3
          ],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Compute dp[4]",
          "transientMessage": "dp[4] = b,0,0,0,0,0,0",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 12,
          "visual": "Update from previous states",
          "transientMessage": "Using dp[3], dp[2]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            3,
            4
          ],
          "color": "success"
        },
        {
          "step": 13,
          "visual": "DP table complete",
          "transientMessage": "Final answer in dp[n-1]",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [],
          "indices": [
            6
          ],
          "color": "success"
        },
        {
          "step": 14,
          "visual": "Return result",
          "transientMessage": "Complete!",
          "arrayState": [
            [
              "",
              "r",
              "a",
              "b",
              "b",
              "i",
              "t"
            ],
            [
              "r",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "a",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            [
              "b",
              0,
              0,
              0,
              0,
              0,
              0
            ],
            0,
            0
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def numDistinct(s, t):\n    \"\"\"\n    Intuition:\n    - For each character in s, we can either include or exclude it\n    - If characters match, we add paths from diagonal (include) and above (exclude)\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    # Empty t can be formed in 1 way\n    for i in range(m + 1):  # Iterate through the range.\n        dp[i][0] = 1\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            # Always carry forward ways without using s[i-1]\n            dp[i][j] = dp[i-1][j]\n            \n            # If chars match, add ways using s[i-1]\n            if s[i-1] == t[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n]",
      "keyInsight": "At each step, we can either use or ignore the current character of s.",
      "testCases": [
        {
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "output": "3"
        },
        {
          "input": "s = \"babgbag\", t = \"bag\"",
          "output": "5"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use DP to count ways to form t[0:j] using s[0:i].",
      "videoId": "-RDzMJ33nx8",
      "suggestedNextQuestion": {
        "slug": "longest-increasing-path-in-a-matrix",
        "title": "Longest Increasing Path In a Matrix",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def numDistinct(s, t):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def numDistinct_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m*n)",
          "spaceComplexity": "O(m*n)",
          "intuition": [
            "For each character in s, we can either include or exclude it",
            "If characters match, we add paths from diagonal (include) and above (exclude)"
          ],
          "code": "def numDistinct(s, t):\n    \"\"\"\n    Intuition:\n    - For each character in s, we can either include or exclude it\n    - If characters match, we add paths from diagonal (include) and above (exclude)\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    # Empty t can be formed in 1 way\n    for i in range(m + 1):  # Iterate through the range.\n        dp[i][0] = 1\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            # Always carry forward ways without using s[i-1]\n            dp[i][j] = dp[i-1][j]\n            \n            # If chars match, add ways using s[i-1]\n            if s[i-1] == t[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "burst-balloons": {
      "id": "burst-balloons",
      "slug": "burst-balloons",
      "title": "Burst Balloons",
      "difficulty": "Hard",
      "category": "2-D Dynamic Programming",
      "problemStatement": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n\u00b3)",
      "spaceComplexity": "O(n\u00b2)",
      "oneliner": "Use DP with interval merging, considering last balloon to burst.",
      "intuition": [
        "Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.",
        "This makes subproblems independent and allows for optimal substructure."
      ],
      "visualizationType": "array",
      "initialState": [
        3,
        1,
        5,
        8
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Burst Balloons",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1",
          "transientMessage": "Iteration 2",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 5",
          "transientMessage": "Iteration 3",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 8",
          "transientMessage": "Iteration 4",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            3,
            1,
            5,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def maxCoins(nums):\n    \"\"\"\n    Intuition:\n    - Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.\n    - This makes subproblems independent and allows for optimal substructure.\n    \"\"\"\n    n = len(nums)\n    nums = [1] + nums + [1]\n    dp = [[0] * (n + 2) for _ in range(n + 2)]  # Initialize DP table to store results.\n    \n    for length in range(1, n + 1):  # Iterate through the range.\n        for left in range(1, n - length + 2):  # Iterate through the range.\n            right = left + length - 1\n            for k in range(left, right + 1):  # Iterate through the range.\n                coins = nums[left - 1] * nums[k] * nums[right + 1]\n                coins += dp[left][k - 1] + dp[k + 1][right]\n                dp[left][right] = max(dp[left][right], coins)  # Take the maximum value.\n    \n    return dp[1][n]",
      "keyInsight": "Choosing the last balloon to burst in a range makes left and right subproblems independent.",
      "testCases": [
        {
          "input": "nums = [3,1,5,8]",
          "output": "167"
        },
        {
          "input": "nums = [1,5]",
          "output": "10"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use DP with interval merging, considering last balloon to burst.",
      "videoId": "VFskby7lUbw",
      "suggestedNextQuestion": {
        "slug": "distinct-subsequences",
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "pattern": "Dynamic Programming"
      },
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def maxCoins(nums):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def maxCoins_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n\u00b3)",
          "spaceComplexity": "O(n\u00b2)",
          "intuition": [
            "Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.",
            "This makes subproblems independent and allows for optimal substructure."
          ],
          "code": "def maxCoins(nums):\n    \"\"\"\n    Intuition:\n    - Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.\n    - This makes subproblems independent and allows for optimal substructure.\n    \"\"\"\n    n = len(nums)\n    nums = [1] + nums + [1]\n    dp = [[0] * (n + 2) for _ in range(n + 2)]  # Initialize DP table to store results.\n    \n    for length in range(1, n + 1):  # Iterate through the range.\n        for left in range(1, n - length + 2):  # Iterate through the range.\n            right = left + length - 1\n            for k in range(left, right + 1):  # Iterate through the range.\n                coins = nums[left - 1] * nums[k] * nums[right + 1]\n                coins += dp[left][k - 1] + dp[k + 1][right]\n                dp[left][right] = max(dp[left][right], coins)  # Take the maximum value.\n    \n    return dp[1][n]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "regular-expression-matching": {
      "id": "regular-expression-matching",
      "slug": "regular-expression-matching",
      "title": "Regular Expression Matching",
      "difficulty": "Hard",
      "category": "2-D Dynamic Programming",
      "problemStatement": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).",
      "videoUrl": "",
      "pattern": "Dynamic Programming",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(m\u00d7n)",
      "spaceComplexity": "O(m\u00d7n)",
      "oneliner": "Use a 2D DP table to track matching substrings.",
      "intuition": [
        "Break the problem into smaller subproblems of matching prefixes.",
        "Handle '*' by considering 0 matches or extending previous matches."
      ],
      "visualizationType": "array",
      "initialState": [
        [
          "",
          "a",
          "*",
          "b"
        ],
        [
          "",
          true,
          true,
          false
        ],
        [
          "a",
          false,
          true,
          false
        ],
        [
          "a",
          false,
          true,
          false
        ],
        [
          "b",
          false,
          false,
          true
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Regular Expression Matching",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = ,a,*,b",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = ,true,true,false",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = a,false,true,false",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = a,false,true,false",
          "transientMessage": "Iteration 4",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = b,false,false,true",
          "transientMessage": "Iteration 5",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              "",
              "a",
              "*",
              "b"
            ],
            [
              "",
              true,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "a",
              false,
              true,
              false
            ],
            [
              "b",
              false,
              false,
              true
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def isMatch(s, p):\n    \"\"\"\n    Intuition:\n    - Break the problem into smaller subproblems of matching prefixes.\n    - Handle '*' by considering 0 matches or extending previous matches.\n    \"\"\"\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):  # Iterate through the range.\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n            else:\n                dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n    \n    return dp[m][n]",
      "keyInsight": "Use DP to build up solutions for matching prefixes of string and pattern.",
      "testCases": [
        {
          "input": "s = \"aa\", p = \"a\"",
          "output": "false"
        },
        {
          "input": "s = \"aa\", p = \"a*\"",
          "output": "true"
        },
        {
          "input": "s = \"ab\", p = \".*\"",
          "output": "true"
        }
      ],
      "walkthrough": [
        "Define state: dp[i] represents optimal solution up to index i",
        "Establish base case(s)",
        "Iterate through problem space",
        "Apply recurrence relation at each step",
        "Return final state as answer"
      ],
      "hints": [
        "\ud83e\udde0 Think about what state you need to track",
        "\ud83d\udca1 Consider the recurrence relation",
        "\ud83d\udd0d Can you optimize space complexity?"
      ],
      "approach": "Dynamic Programming: Use a 2D DP table to track matching substrings.",
      "videoId": "HAA8mgxlov8",
      "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
      "initialCode": "def isMatch(s, p):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n) recursion stack",
          "intuition": [
            "Use recursion to explore all possibilities.",
            "Without memoization, this leads to exponential time."
          ],
          "code": "def isMatch_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(m\u00d7n)",
          "spaceComplexity": "O(m\u00d7n)",
          "intuition": [
            "Break the problem into smaller subproblems of matching prefixes.",
            "Handle '*' by considering 0 matches or extending previous matches."
          ],
          "code": "def isMatch(s, p):\n    \"\"\"\n    Intuition:\n    - Break the problem into smaller subproblems of matching prefixes.\n    - Handle '*' by considering 0 matches or extending previous matches.\n    \"\"\"\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):  # Iterate through the range.\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n            else:\n                dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n    \n    return dp[m][n]"
        }
      ],
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[result]",
          "explanation": "Build solution from smaller subproblems."
        },
        {
          "input": "nums = [1]",
          "output": "[base case]",
          "explanation": "Base case with single element."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "0 <= values[i] <= 10^4"
      ],
      "commonMistakes": [
        "Wrong base case initialization",
        "Incorrect recurrence relation",
        "Not considering all subproblem dependencies"
      ],
      "interviewTip": "Start with brute force, add memoization, then optimize to tabulation."
    },
    "hand-of-straights": {
      "id": "hand-of-straights",
      "slug": "hand-of-straights",
      "title": "Hand of Straights",
      "difficulty": "Medium",
      "category": "Greedy",
      "problemStatement": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
      "videoUrl": "",
      "pattern": "Greedy with HashMap",
      "patternEmoji": "\ud83d\udcca\u27a1\ufe0f",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "oneliner": "Use a frequency map and always start with the smallest available card.",
      "intuition": [
        "We need consecutive sequences, so sorting helps process cards in order",
        "Greedy approach: always form a group starting with the smallest remaining card"
      ],
      "visualizationType": "array",
      "initialState": [
        1,
        2,
        3,
        6,
        2,
        3,
        4,
        7,
        8
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Hand of Straights",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 1",
          "transientMessage": "Iteration 1",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 2",
          "transientMessage": "Iteration 2",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 3",
          "transientMessage": "Iteration 3",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = 6",
          "transientMessage": "Iteration 4",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = 2",
          "transientMessage": "Iteration 5",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = 3",
          "transientMessage": "Iteration 6",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            1,
            2,
            3,
            6,
            2,
            3,
            4,
            7,
            8
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "from collections import Counter\n\ndef isNStraightHand(hand, groupSize):\n    \"\"\"\n    Intuition:\n    - We need consecutive sequences, so sorting helps process cards in order\n    - Greedy approach: always form a group starting with the smallest remaining card\n    \"\"\"\n    if len(hand) % groupSize != 0:\n        return False  # Condition not met.\n    \n    count = Counter(hand)\n    sorted_keys = sorted(count.keys())\n    \n    for key in sorted_keys:  # Iterate over elements.\n        if count[key] > 0:\n            start_count = count[key]\n            for i in range(groupSize):  # Iterate through the range.\n                if count[key + i] < start_count:\n                    return False  # Condition not met.\n                count[key + i] -= start_count\n    \n    return True  # Condition satisfied.",
      "keyInsight": "Process cards in sorted order and greedily form groups starting with the smallest available card.",
      "testCases": [
        {
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "output": "true"
        },
        {
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "output": "false"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Greedy with HashMap: Use a frequency map and always start with the smallest available card.",
      "examples": [
        {
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "output": "true",
          "explanation": "Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]"
        },
        {
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "output": "false",
          "explanation": "Alice's hand cannot be rearranged into groups of 4."
        }
      ],
      "constraints": [
        "1 <= hand.length <= 10^4",
        "0 <= hand[i] <= 10^9",
        "1 <= groupSize <= hand.length"
      ],
      "videoId": "amnrMCVd2YI",
      "suggestedNextQuestion": {
        "slug": "integer-to-roman",
        "title": "Integer to Roman",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def isNStraightHand(hand, groupSize):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def isNStraightHand(hand, groupSize):\n    if len(hand) % groupSize: return False\n    count = {}\n    for n in hand: count[n] = count.get(n, 0) + 1\n    minH = list(count.keys())\n    import heapq\n    heapq.heapify(minH)\n    \n    while minH:\n        first = minH[0]\n        for i in range(first, first + groupSize):\n            if i not in count: return False\n            count[i] -= 1\n            if count[i] == 0:\n                if i != minH[0]: return False\n                heapq.heappop(minH)\n    return True"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "We need consecutive sequences, so sorting helps process cards in order",
            "Greedy approach: always form a group starting with the smallest remaining card"
          ],
          "code": "from collections import Counter\n\ndef isNStraightHand(hand, groupSize):\n    \"\"\"\n    Intuition:\n    - We need consecutive sequences, so sorting helps process cards in order\n    - Greedy approach: always form a group starting with the smallest remaining card\n    \"\"\"\n    if len(hand) % groupSize != 0:\n        return False  # Condition not met.\n    \n    count = Counter(hand)\n    sorted_keys = sorted(count.keys())\n    \n    for key in sorted_keys:  # Iterate over elements.\n        if count[key] > 0:\n            start_count = count[key]\n            for i in range(groupSize):  # Iterate through the range.\n                if count[key + i] < start_count:\n                    return False  # Condition not met.\n                count[key + i] -= start_count\n    \n    return True  # Condition satisfied."
        }
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "merge-triplets-to-form-target-triplet": {
      "id": "merge-triplets-to-form-target-triplet",
      "slug": "merge-triplets-to-form-target-triplet",
      "title": "Merge Triplets to Form Target Triplet",
      "difficulty": "Medium",
      "category": "Greedy",
      "problemStatement": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\nTo obtain target, you may apply the following operation on triplets any number of times (possibly zero):\nReturn true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",
      "videoUrl": "",
      "pattern": "Greedy",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Only consider triplets that don't exceed target values and greedily build up to target.",
      "intuition": [
        "We can only increase values through max operations, so any triplet with a component exceeding the target is useless.",
        "Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component."
      ],
      "visualizationType": "array",
      "initialState": [
        [
          2,
          5,
          3
        ],
        [
          1,
          8,
          4
        ],
        [
          1,
          7,
          5
        ]
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Merge Triplets to Form Target Triplet",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = 2,5,3",
          "transientMessage": "Iteration 1",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = 1,8,4",
          "transientMessage": "Iteration 2",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = 1,7,5",
          "transientMessage": "Iteration 3",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Compute result phase 8",
          "transientMessage": "Building solution",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [
            2,
            0
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            [
              2,
              5,
              3
            ],
            [
              1,
              8,
              4
            ],
            [
              1,
              7,
              5
            ]
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def mergeTriplets(triplets, target):\n    \"\"\"\n    Intuition:\n    - We can only increase values through max operations, so any triplet with a component exceeding the target is useless.\n    - Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component.\n    \"\"\"\n    target_a, target_b, target_c = target\n    found_a, found_b, found_c = False, False, False\n    \n    for a, b, c in triplets:  # Iterate over elements.\n        if a > target_a or b > target_b or c > target_c:\n            continue\n        if a == target_a:\n            found_a = True\n        if b == target_b:\n            found_b = True\n        if c == target_c:\n            found_c = True\n    \n    return found_a and found_b and found_c",
      "keyInsight": "We can only increase components via max operations, so we must find valid triplets that contribute each target component without overshooting.",
      "testCases": [
        {
          "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
          "output": "true"
        },
        {
          "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
          "output": "false"
        },
        {
          "input": "triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]",
          "output": "true"
        }
      ],
      "walkthrough": [
        "Goal: find triplets that can combine to form target",
        "Filter out triplets where any element exceeds target",
        "For remaining triplets, check which target positions they satisfy",
        "Track if we've found triplets matching each target element",
        "Return True if all three target elements are achievable"
      ],
      "hints": [
        "\ud83e\udde0 Can local optimal lead to global optimal?",
        "\ud83d\udca1 Sort by relevant property first",
        "\ud83d\udd0d Prove greedy works before implementing"
      ],
      "approach": "Greedy: Only consider triplets that don't exceed target values and greedily build up to target.",
      "videoId": "kShkQLQZ9K4",
      "suggestedNextQuestion": {
        "slug": "minimum-number-of-arrows-to-burst-balloons",
        "title": "Minimum Number of Arrows to Burst Balloons",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def mergeTriplets(triplets, target):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def mergeTriplets(triplets, target):\n    good = set()\n    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue\n        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)\n    return len(good) == 3"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "We can only increase values through max operations, so any triplet with a component exceeding the target is useless.",
            "Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component."
          ],
          "code": "def mergeTriplets(triplets, target):\n    \"\"\"\n    Intuition:\n    - We can only increase values through max operations, so any triplet with a component exceeding the target is useless.\n    - Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component.\n    \"\"\"\n    target_a, target_b, target_c = target\n    found_a, found_b, found_c = False, False, False\n    \n    for a, b, c in triplets:  # Iterate over elements.\n        if a > target_a or b > target_b or c > target_c:\n            continue\n        if a == target_a:\n            found_a = True\n        if b == target_b:\n            found_b = True\n        if c == target_c:\n            found_c = True\n    \n    return found_a and found_b and found_c"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "partition-labels": {
      "id": "partition-labels",
      "slug": "partition-labels",
      "title": "Partition Labels",
      "difficulty": "Medium",
      "category": "Greedy",
      "problemStatement": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.",
      "videoUrl": "",
      "pattern": "Greedy with Last Occurrence Tracking",
      "patternEmoji": "\ud83c\udfaf",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track last occurrences and extend partitions greedily.",
      "intuition": [
        "Each character must appear in only one partition",
        "We need to know the furthest position each character appears"
      ],
      "visualizationType": "array",
      "initialState": [
        "a",
        "b",
        "a",
        "b",
        "c",
        "b",
        "b",
        "d",
        "d"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Partition Labels",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = a",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = b",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = a",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = b",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Process arr[4] = c",
          "transientMessage": "Iteration 5",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 4
            }
          ],
          "indices": [
            4
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Process arr[5] = b",
          "transientMessage": "Iteration 6",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 5
            }
          ],
          "indices": [
            5
          ],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 11,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "a",
            "b",
            "a",
            "b",
            "c",
            "b",
            "b",
            "d",
            "d"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def partitionLabels(s):\n    \"\"\"\n    Intuition:\n    - Each character must appear in only one partition\n    - We need to know the furthest position each character appears\n    \"\"\"\n    last = {char: i for i, char in enumerate(s)}\n    result = []\n    start = 0\n    end = 0\n    \n    for i, char in enumerate(s):  # Iterate over elements.\n        end = max(end, last[char])  # Take the maximum value.\n        if i == end:\n            result.append(end - start + 1)  # Add to end.\n            start = end + 1\n    \n    return result  # Return the final result.",
      "keyInsight": "For each partition, we must include all occurrences of every character in it.",
      "testCases": [
        {
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "output": "[9,7,8]"
        },
        {
          "input": "s = \"eccbbbbdec\"",
          "output": "[10]"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Greedy with Last Occurrence Tracking: Track last occurrences and extend partitions greedily.",
      "videoId": "B7m8UmZE-vw",
      "suggestedNextQuestion": {
        "slug": "task-scheduler",
        "title": "Task Scheduler",
        "difficulty": "Medium",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def partitionLabels(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def partitionLabels(s):\n    lastIndex = { c:i for i, c in enumerate(s) }\n    j, anchor = 0, 0\n    res = []\n    for i, c in enumerate(s):\n        j = max(j, lastIndex[c])\n        if i == j:\n            res.append(i - anchor + 1)\n            anchor = i + 1\n    return res"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "Each character must appear in only one partition",
            "We need to know the furthest position each character appears"
          ],
          "code": "def partitionLabels(s):\n    \"\"\"\n    Intuition:\n    - Each character must appear in only one partition\n    - We need to know the furthest position each character appears\n    \"\"\"\n    last = {char: i for i, char in enumerate(s)}\n    result = []\n    start = 0\n    end = 0\n    \n    for i, char in enumerate(s):  # Iterate over elements.\n        end = max(end, last[char])  # Take the maximum value.\n        if i == end:\n            result.append(end - start + 1)  # Add to end.\n            start = end + 1\n    \n    return result  # Return the final result."
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "valid-parenthesis-string": {
      "id": "valid-parenthesis-string",
      "slug": "valid-parenthesis-string",
      "title": "Valid Parenthesis String",
      "difficulty": "Medium",
      "category": "Greedy",
      "problemStatement": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:",
      "videoUrl": "",
      "pattern": "Greedy with Range Tracking",
      "patternEmoji": "\ud83d\udcca",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Track possible open parenthesis counts with min/max bounds.",
      "intuition": [
        "We can't know what '*' will be, so track all possible open counts",
        "Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid."
      ],
      "visualizationType": "array",
      "initialState": [
        "(",
        "*",
        ")",
        "("
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Valid Parenthesis String",
          "transientMessage": "Starting algorithm",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Initialize variables",
          "transientMessage": "Set up pointers and counters",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Process arr[0] = (",
          "transientMessage": "Iteration 1",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [
            {
              "label": "i",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Process arr[1] = *",
          "transientMessage": "Iteration 2",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            1
          ],
          "color": "success"
        },
        {
          "step": 5,
          "visual": "Process arr[2] = )",
          "transientMessage": "Iteration 3",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [
            {
              "label": "i",
              "index": 2
            }
          ],
          "indices": [
            2
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Process arr[3] = (",
          "transientMessage": "Iteration 4",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [
            {
              "label": "i",
              "index": 3
            }
          ],
          "indices": [
            3
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Update state",
          "transientMessage": "Applying changes",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 8,
          "visual": "Finalize result",
          "transientMessage": "Computing final answer",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 9,
          "visual": "Algorithm complete",
          "transientMessage": "Result ready!",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "Finalize and return",
          "transientMessage": "Algorithm complete!",
          "arrayState": [
            "(",
            "*",
            ")",
            "("
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def checkValidString(s):\n    \"\"\"\n    Intuition:\n    - We can't know what '*' will be, so track all possible open counts\n    - Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid.\n    \"\"\"\n    min_open = max_open = 0\n    for char in s:  # Iterate over elements.\n        if char == '(':\n            min_open += 1\n            max_open += 1\n        elif char == ')':\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open -= 1\n        else:  # char == '*'\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open += 1\n        if max_open < 0:\n            return False  # Condition not met.\n    return min_open == 0",
      "keyInsight": "We track the range of possible open parenthesis counts instead of exact values.",
      "testCases": [
        {
          "input": "s = \"()\"",
          "output": "true"
        },
        {
          "input": "s = \"(*)\"",
          "output": "true"
        },
        {
          "input": "s = \"(*))\"",
          "output": "true"
        }
      ],
      "walkthrough": [
        "Understand the problem constraints",
        "Identify the optimal approach",
        "Implement the solution step by step",
        "Handle edge cases",
        "Return the result"
      ],
      "hints": [
        "\ud83e\udde0 Analyze the problem constraints",
        "\ud83d\udca1 Consider the most efficient approach",
        "\ud83d\udd0d Handle edge cases carefully"
      ],
      "approach": "Greedy with Range Tracking: Track possible open parenthesis counts with min/max bounds.",
      "videoId": "QhPdNS143Qg",
      "suggestedNextQuestion": {
        "slug": "candy",
        "title": "Candy",
        "difficulty": "Hard",
        "pattern": "Greedy"
      },
      "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
      "initialCode": "def checkValidString(s):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or worse",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Explore all possibilities without optimization.",
            "Use nested loops or recursion."
          ],
          "code": "def checkValidString(s):\n    # Greedy with range\n    low, high = 0, 0\n    for c in s:\n        low += 1 if c == '(' else -1\n        high += 1 if c != ')' else -1\n        if high < 0: return False\n        low = max(low, 0)\n    return low == 0"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "We can't know what '*' will be, so track all possible open counts",
            "Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid."
          ],
          "code": "def checkValidString(s):\n    \"\"\"\n    Intuition:\n    - We can't know what '*' will be, so track all possible open counts\n    - Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid.\n    \"\"\"\n    min_open = max_open = 0\n    for char in s:  # Iterate over elements.\n        if char == '(':\n            min_open += 1\n            max_open += 1\n        elif char == ')':\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open -= 1\n        else:  # char == '*'\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open += 1\n        if max_open < 0:\n            return False  # Condition not met.\n    return min_open == 0"
        }
      ],
      "examples": [
        {
          "input": "Example input",
          "output": "Expected output",
          "explanation": "Basic case."
        },
        {
          "input": "Edge case input",
          "output": "Edge output",
          "explanation": "Handles edge cases."
        }
      ],
      "constraints": [
        "1 <= n <= 10^4",
        "Valid input guaranteed"
      ],
      "commonMistakes": [
        "Not handling edge cases (empty input, single element)",
        "Integer overflow for large inputs",
        "Time limit exceeded due to inefficient approach"
      ],
      "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly."
    },
    "permutation-in-string": {
      "id": "permutation-in-string",
      "slug": "permutation-in-string",
      "title": "Permutation in String",
      "difficulty": "Medium",
      "category": "Sliding Window",
      "problemStatement": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.",
      "videoUrl": "",
      "pattern": "Sliding Window",
      "patternEmoji": "\ud83e\ude9f",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "oneliner": "Use sliding window with character frequency matching.",
      "intuition": [
        "A permutation means same characters with same frequencies",
        "Use a window of s1's length and slide it through s2"
      ],
      "visualizationType": "array",
      "initialState": [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g"
      ],
      "animationSteps": [
        {
          "step": 1,
          "visual": "Problem: Permutation in String",
          "transientMessage": "Backtracking approach",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 2,
          "visual": "Start with empty path",
          "transientMessage": "Path: []",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [],
          "indices": [],
          "color": "accent"
        },
        {
          "step": 3,
          "visual": "Try first choice",
          "transientMessage": "Add a to path",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 0
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 4,
          "visual": "Recurse deeper",
          "transientMessage": "Path: [a]",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [
            {
              "label": "i",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 5,
          "visual": "Try second choice",
          "transientMessage": "Add b to path",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 1
            }
          ],
          "indices": [
            0,
            1
          ],
          "color": "accent"
        },
        {
          "step": 6,
          "visual": "Found valid solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [],
          "indices": [
            0,
            1,
            2
          ],
          "color": "success"
        },
        {
          "step": 7,
          "visual": "Backtrack",
          "transientMessage": "Remove last choice",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [
            {
              "label": "back",
              "index": 1
            }
          ],
          "indices": [
            0
          ],
          "color": "accent"
        },
        {
          "step": 8,
          "visual": "Try alternative",
          "transientMessage": "Try c instead",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [
            {
              "label": "try",
              "index": 2
            }
          ],
          "indices": [
            0,
            2
          ],
          "color": "accent"
        },
        {
          "step": 9,
          "visual": "Found another solution!",
          "transientMessage": "Save to results",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [],
          "indices": [
            0,
            2
          ],
          "color": "success"
        },
        {
          "step": 10,
          "visual": "All solutions found",
          "transientMessage": "Complete!",
          "arrayState": [
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g"
          ],
          "pointers": [],
          "indices": [],
          "color": "success"
        }
      ],
      "code": "def checkInclusion(s1, s2):\n    \"\"\"\n    Intuition:\n    - A permutation means same characters with same frequencies\n    - Use a window of s1's length and slide it through s2\n    \"\"\"\n    if len(s1) > len(s2):\n        return False  # Condition not met.\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:  # Iterate over elements.\n        s1_count[ord(char) - ord('a')] += 1\n    \n    # Initialize window\n    for i in range(len(s1)):  # Iterate through the range.\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == window_count:\n        return True  # Condition satisfied.\n    \n    # Slide window\n    for i in range(len(s1), len(s2)):  # Iterate through the range.\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        # Remove old character\n        window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == window_count:\n            return True  # Condition satisfied.\n    \n    return False  # Condition not met.",
      "keyInsight": "Permutations have identical character counts - compare frequency arrays.",
      "testCases": [
        {
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "output": "true"
        },
        {
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "output": "false"
        }
      ],
      "walkthrough": [
        "Initialize window boundaries (left, right)",
        "Expand window by moving right pointer",
        "Update window state with new element",
        "Shrink window when condition violated",
        "Track optimal result throughout"
      ],
      "hints": [
        "\ud83e\udde0 What defines a valid window?",
        "\ud83d\udca1 When should you expand vs shrink?",
        "\ud83d\udd0d Track window state efficiently"
      ],
      "approach": "Sliding Window: Use sliding window with character frequency matching.",
      "videoId": "UbyhOgBN834",
      "suggestedNextQuestion": {
        "slug": "minimum-window-substring",
        "title": "Minimum Window Substring",
        "difficulty": "Hard",
        "pattern": "Sliding Window"
      },
      "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
      "initialCode": "def checkInclusion(s1, s2):\n    pass",
      "approaches": [
        {
          "name": "bruteforce",
          "label": "Brute Force",
          "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
          "spaceComplexity": "O(n)",
          "intuition": [
            "Generate all possible substrings/subarrays.",
            "Check each one for the required condition."
          ],
          "code": "def checkInclusion_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
        },
        {
          "name": "optimal",
          "label": "Optimal",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)",
          "intuition": [
            "A permutation means same characters with same frequencies",
            "Use a window of s1's length and slide it through s2"
          ],
          "code": "def checkInclusion(s1, s2):\n    \"\"\"\n    Intuition:\n    - A permutation means same characters with same frequencies\n    - Use a window of s1's length and slide it through s2\n    \"\"\"\n    if len(s1) > len(s2):\n        return False  # Condition not met.\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:  # Iterate over elements.\n        s1_count[ord(char) - ord('a')] += 1\n    \n    # Initialize window\n    for i in range(len(s1)):  # Iterate through the range.\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == window_count:\n        return True  # Condition satisfied.\n    \n    # Slide window\n    for i in range(len(s1), len(s2)):  # Iterate through the range.\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        # Remove old character\n        window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == window_count:\n            return True  # Condition satisfied.\n    \n    return False  # Condition not met."
        }
      ],
      "examples": [
        {
          "input": "s = \"abcabcbb\"",
          "output": "3",
          "explanation": "Sliding window expands until duplicate, then shrinks."
        },
        {
          "input": "s = \"bbbbb\"",
          "output": "1",
          "explanation": "All same characters."
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^5",
        "s consists of printable ASCII characters"
      ],
      "commonMistakes": [
        "Not updating the window properly when shrinking",
        "Forgetting to reset window state",
        "Edge case: window larger than input"
      ],
      "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'."
    }
  }
}