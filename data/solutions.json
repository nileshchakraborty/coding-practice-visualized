{
    "solutions": {
        "triangle": {
            "title": "Triangle",
            "pattern": "Dynamic Programming",
            "patternEmoji": "ğŸ“‰",
            "timeComplexity": "O(n^2)",
            "spaceComplexity": "O(n)",
            "oneliner": "Compute min path sum from bottom to top to avoid greedy traps!",
            "intuition": [
                "ğŸ”º Greedy doesn't work! Local min â‰  Global min",
                "ğŸ§  Subproblem: Min path from cell (i, j) to bottom",
                "ğŸ’¡ dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
            ],
            "testCases": [
                {
                    "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11"
                },
                {
                    "input": "triangle = [[-10]]",
                    "output": "-10"
                }
            ],
            "code": "def minimumTotal(triangle):\n    dp = triangle[-1][:]\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(i + 1):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n    return dp[0]",
            "keyInsight": "Bottom-up DP simplifies boundary conditions and reuses space."
        },
        "best-time-to-buy-and-sell-stock": {
            "title": "Best Time to Buy and Sell Stock",
            "pattern": "Track Minimum",
            "patternEmoji": "ğŸ“ˆ",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track the minimum price seen so far, maximize profit at each step!",
            "intuition": [
                "ğŸ¯ Buy LOW, Sell HIGH",
                "ğŸ§  Keep track of the cheapest day to buy",
                "ğŸ’¡ At each day, calculate: what if I sold today?"
            ],
            "testCases": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "5"
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize Trackers",
                    "visual": "min_price = âˆ\nmax_profit = 0",
                    "explanation": "Start with infinity as min (first price will always be lower)"
                },
                {
                    "step": 2,
                    "title": "Walk Through Prices",
                    "visual": "prices: [7, 1, 5, 3, 6, 4]\n         â†‘\n       Day 1: price = 7",
                    "explanation": "Visit each day's price"
                },
                {
                    "step": 3,
                    "title": "Update Minimum",
                    "visual": "Day 1: min = min(âˆ, 7) = 7\nDay 2: min = min(7, 1) = 1 â­ NEW LOW!",
                    "explanation": "Always track the best buying opportunity"
                },
                {
                    "step": 4,
                    "title": "Calculate Profit",
                    "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 ğŸ’°\n        max_profit = 5",
                    "explanation": "At each step: profit = today - min_so_far"
                }
            ],
            "code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit",
            "keyInsight": "One pass solution - no need to compare every pair!"
        },
        "valid-palindrome": {
            "title": "Valid Palindrome",
            "pattern": "Two Pointers",
            "patternEmoji": "ğŸ‘†",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers from both ends, skip non-alphanumeric!",
            "intuition": [
                "ğŸ¯ Palindrome reads same forwards & backwards",
                "ğŸ§  Compare characters from outside â†’ inside",
                "ğŸ’¡ Skip spaces and punctuation!"
            ],
            "testCases": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "True"
                },
                {
                    "input": "s = \"race a car\"",
                    "output": "False"
                },
                {
                    "input": "s = \" \"",
                    "output": "True"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up Pointers",
                    "visual": "\"A man, a plan, a canal: Panama\"\n â†‘                              â†‘\nleft                          right",
                    "explanation": "Start from both ends of the string"
                },
                {
                    "step": 2,
                    "title": "Skip Non-Letters",
                    "visual": "\"...canal: Panama\"\n         â†‘      â†‘\n     skip ':'  'a'",
                    "explanation": "Move pointer if not alphanumeric"
                },
                {
                    "step": 3,
                    "title": "Compare (Case-Insensitive)",
                    "visual": "'A' == 'a' âœ… (lowercase both)\n'M' == 'm' âœ…\n'N' == 'n' âœ…",
                    "explanation": "Convert to lowercase and compare"
                },
                {
                    "step": 4,
                    "title": "Move Inward",
                    "visual": "left â†’ â†     â†’ â† right\n      Meet in middle = VALID!",
                    "explanation": "Continue until pointers cross"
                }
            ],
            "code": "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True",
            "keyInsight": "Two pointers = no extra space needed for reversed string!"
        },
        "merge-sorted-array": {
            "title": "Merge Sorted Array",
            "pattern": "Three Pointers (Reverse)",
            "patternEmoji": "ğŸ”€",
            "timeComplexity": "O(m + n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Fill from the END to avoid overwriting!",
            "intuition": [
                "ğŸ¯ Can't start from front - would overwrite nums1!",
                "ğŸ§  Start from back - empty space is there for us!",
                "ğŸ’¡ Three pointers: end of nums1, end of nums2, write position"
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                    "output": "[1, 2, 2, 3, 5, 6]"
                },
                {
                    "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                    "output": "[1]"
                },
                {
                    "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
                    "output": "[1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up 3 Pointers",
                    "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            â†‘     â†‘              â†‘\n           p1    write           p2",
                    "explanation": "p1 at last real element, p2 at end of nums2, write at end"
                },
                {
                    "step": 2,
                    "title": "Compare & Place Larger",
                    "visual": "3 vs 6 â†’ 6 wins!\n[1,2,3,0,0,6] â† place 6",
                    "explanation": "Bigger goes to write position"
                },
                {
                    "step": 3,
                    "title": "Move Pointers",
                    "visual": "[1,2,3,0,0,6]\n            â†‘ â†‘\n           p1 write\n           â† moved left",
                    "explanation": "Decrement write and the pointer that was used"
                },
                {
                    "step": 4,
                    "title": "Continue Until Done",
                    "visual": "Result: [1,2,2,3,5,6] âœ…",
                    "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
                }
            ],
            "code": "def merge(nums1, m, nums2, n):\n    p1, p2 = m - 1, n - 1\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1",
            "keyInsight": "Reverse iteration = in-place without overwriting!"
        },
        "valid-parentheses": {
            "title": "Valid Parentheses",
            "pattern": "Stack",
            "patternEmoji": "ğŸ“š",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push opening brackets, pop and match for closing!",
            "intuition": [
                "ğŸ¯ Every opening needs matching closing in correct order",
                "ğŸ§  Most recent open must close first = LIFO = Stack!",
                "ğŸ’¡ Opening â†’ push, Closing â†’ pop & check match"
            ],
            "testCases": [
                {
                    "input": "s = \"()\"",
                    "output": "True"
                },
                {
                    "input": "s = \"()[]{}\"",
                    "output": "True"
                },
                {
                    "input": "s = \"(]\"",
                    "output": "False"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Create Stack + Mapping",
                    "visual": "stack = []\nmapping = { ')':'(', '}':'{', ']':'[' }",
                    "explanation": "Map each closing bracket to its opening pair"
                },
                {
                    "step": 2,
                    "title": "Process Opening Bracket",
                    "visual": "\"([)]\"\n â†‘\n'(' â†’ push â†’ stack: ['(']",
                    "explanation": "Opening brackets go on the stack"
                },
                {
                    "step": 3,
                    "title": "Process Closing Bracket",
                    "visual": "\"([)]\"\n   â†‘\n')' â†’ pop â†’ got '[' âŒ Expected '('",
                    "explanation": "Pop and check if it matches!"
                },
                {
                    "step": 4,
                    "title": "Final Check",
                    "visual": "Valid: stack empty âœ…\nInvalid: stack has leftovers âŒ",
                    "explanation": "All brackets matched = empty stack"
                }
            ],
            "code": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:  # closing bracket\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:  # opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0",
            "keyInsight": "Stack naturally handles nested matching - LIFO property!"
        },
        "maximum-subarray": {
            "title": "Maximum Subarray",
            "pattern": "Kadane's Algorithm",
            "patternEmoji": "ğŸ“ˆ",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Extend current sum OR start fresh - pick the better option!",
            "intuition": [
                "ğŸ¯ At each position: should I continue or restart?",
                "ğŸ§  If current_sum < 0, better to start fresh!",
                "ğŸ’¡ Track both current sum and overall maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6"
                },
                {
                    "input": "nums = [1]",
                    "output": "1"
                },
                {
                    "input": "nums = [5,4,-1,7,8]",
                    "output": "23"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
                    "explanation": "Start with first element as both"
                },
                {
                    "step": 2,
                    "title": "The Key Decision",
                    "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         â†‘\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 â† WINNER!",
                    "explanation": "current_sum = max(num, current_sum + num)"
                },
                {
                    "step": 3,
                    "title": "Update Maximum",
                    "visual": "current: 1 â†’ -2 â†’ 4 â†’ 3 â†’ 5 â†’ 6 â†’ 1 â†’ 5\n                   â†‘           â†‘\n                 reset       max=6!",
                    "explanation": "max_sum = max(max_sum, current_sum)"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "[4,-1,2,1] = 6 âœ…\n â†‘ max subarray",
                    "explanation": "Return max_sum"
                }
            ],
            "code": "def maxSubArray(nums):\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
            "keyInsight": "The magic: negative prefix sum is never worth keeping!"
        },
        "climbing-stairs": {
            "title": "Climbing Stairs",
            "pattern": "Dynamic Programming (Fibonacci)",
            "patternEmoji": "ğŸ“",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Ways to reach step n = ways to reach (n-1) + ways to reach (n-2)!",
            "intuition": [
                "ğŸ¯ From step n, you either came from n-1 or n-2",
                "ğŸ§  This is just Fibonacci in disguise!",
                "ğŸ’¡ Only need to track last 2 values"
            ],
            "testCases": [
                {
                    "input": "n = 2",
                    "output": "2"
                },
                {
                    "input": "n = 3",
                    "output": "3"
                },
                {
                    "input": "n = 4",
                    "output": "5"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Base Cases",
                    "visual": "Step 1: 1 way [1]\nStep 2: 2 ways [1+1] or [2]",
                    "explanation": "Starting points for our pattern"
                },
                {
                    "step": 2,
                    "title": "See The Pattern",
                    "visual": "     Step 1  Step 2  Step 3  Step 4\nWays:   1      2       3       5\n                     â†— â†—    â†— â†—\n                    1+2    2+3",
                    "explanation": "Each = sum of previous two!"
                },
                {
                    "step": 3,
                    "title": "Build Up",
                    "visual": "a, b = 1, 2\nStep 3: a, b = 2, 3  (1+2)\nStep 4: a, b = 3, 5  (2+3)",
                    "explanation": "Slide the window forward"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "n=5: [1,2,3,5,8] â†’ 8 ways!",
                    "explanation": "Return b (or a depending on implementation)"
                }
            ],
            "code": "def climbStairs(n):\n    if n <= 2:\n        return n\n    \n    a, b = 1, 2  # ways for step 1 and 2\n    \n    for i in range(3, n + 1):\n        a, b = b, a + b\n    \n    return b",
            "keyInsight": "Recognizing Fibonacci pattern = O(1) space solution!"
        },
        "linked-list-cycle": {
            "title": "Linked List Cycle",
            "pattern": "Floyd's Tortoise & Hare",
            "patternEmoji": "ğŸ¢ğŸ‡",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Slow moves 1 step, fast moves 2 - if they meet, there's a cycle!",
            "intuition": [
                "ğŸ¯ If there's a loop, fast will catch up to slow",
                "ğŸ¢ Slow: 1 step at a time",
                "ğŸ‡ Fast: 2 steps at a time â†’ WILL lap slow if cycle exists!"
            ],
            "testCases": [
                {
                    "input": "head = [3,2,0,-4], pos = 1",
                    "output": "True"
                },
                {
                    "input": "head = [1,2], pos = 0",
                    "output": "True"
                },
                {
                    "input": "head = [1], pos = -1",
                    "output": "False"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize Runners",
                    "visual": "1 â†’ 2 â†’ 3 â†’ 4 â†’ 2 (cycle!)\nâ†‘       \nS,F start here",
                    "explanation": "Both start at head"
                },
                {
                    "step": 2,
                    "title": "Move At Different Speeds",
                    "visual": "After 1 round:\n1 â†’ 2 â†’ 3 â†’ 4\n    S       F",
                    "explanation": "Slow += 1, Fast += 2"
                },
                {
                    "step": 3,
                    "title": "In A Cycle...",
                    "visual": "  â†’ 2 â†’ 3\n  â†‘     â†“\n  4 â† â† â”˜\n  SF meet! âœ…",
                    "explanation": "Fast catches up in the cycle"
                },
                {
                    "step": 4,
                    "title": "No Cycle?",
                    "visual": "1 â†’ 2 â†’ 3 â†’ None\n            F hits None âŒ",
                    "explanation": "Fast reaches null = no cycle"
                }
            ],
            "code": "def hasCycle(head):\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next        # 1 step\n        fast = fast.next.next   # 2 steps\n        \n        if slow == fast:\n            return True\n    \n    return False",
            "keyInsight": "No extra space needed - just two pointers at different speeds!"
        },
        "binary-search": {
            "title": "Binary Search",
            "pattern": "Divide & Conquer",
            "patternEmoji": "ğŸ¯",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Half the search space each time by checking the middle!",
            "intuition": [
                "ğŸ¯ Array is SORTED - exploit this!",
                "ğŸ§  Check middle: too big? go left. Too small? go right.",
                "ğŸ’¡ Halving = logâ‚‚(n) steps maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 9",
                    "output": "4"
                },
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 2",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Boundaries",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n â†‘                    â†‘\nleft                right",
                    "explanation": "Start with full array range"
                },
                {
                    "step": 2,
                    "title": "Find Middle",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n          â†‘\n         mid (index 3, value 7)",
                    "explanation": "mid = (left + right) // 2"
                },
                {
                    "step": 3,
                    "title": "Compare & Narrow",
                    "visual": "target = 11\n7 < 11 â†’ search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             â†‘       â†‘\n           left    right",
                    "explanation": "Eliminate half the options!"
                },
                {
                    "step": 4,
                    "title": "Repeat Until Found",
                    "visual": "mid = 11 âœ… FOUND!\nOR left > right = Not found",
                    "explanation": "Continue halving until match or exhausted"
                }
            ],
            "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1",
            "keyInsight": "Each step eliminates HALF - that's why it's O(log n)!"
        },
        "number-of-islands": {
            "title": "Number of Islands",
            "pattern": "DFS/BFS Flood Fill",
            "patternEmoji": "ğŸï¸",
            "timeComplexity": "O(m Ã— n)",
            "spaceComplexity": "O(m Ã— n)",
            "oneliner": "Find a '1', flood-fill/sink the whole island, count it!",
            "intuition": [
                "ğŸ¯ Each connected group of 1s = one island",
                "ğŸ§  When you find land, explore ALL connected land",
                "ğŸ’¡ Mark visited cells to avoid counting twice"
            ],
            "testCases": [
                {
                    "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                    "output": "1"
                },
                {
                    "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan Grid",
                    "visual": "1 1 0 0 0\n1 1 0 0 0\n0 0 1 0 0\n0 0 0 1 1\nâ†‘ Found '1'!",
                    "explanation": "Look for unvisited land"
                },
                {
                    "step": 2,
                    "title": "Flood Fill (DFS/BFS)",
                    "visual": "X X 0 0 0\nX X 0 0 0\n0 0 1 0 0\n0 0 0 1 1\nMark all connected as 'X'",
                    "explanation": "Visit all 4 directions, mark as visited"
                },
                {
                    "step": 3,
                    "title": "Count It!",
                    "visual": "count = 1 âœ…",
                    "explanation": "One complete flood fill = one island"
                },
                {
                    "step": 4,
                    "title": "Continue Scanning",
                    "visual": "X X 0 0 0\nX X 0 0 0\n0 0 X 0 0  â† island 2\n0 0 0 X X  â† island 3\nTotal: 3 islands",
                    "explanation": "Find next '1', repeat until done"
                }
            ],
            "code": "def numIslands(grid):\n    if not grid:\n        return 0\n    \n    count = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return\n        if grid[i][j] != '1':\n            return\n        \n        grid[i][j] = '0'  # mark visited\n        dfs(i+1, j)  # down\n        dfs(i-1, j)  # up\n        dfs(i, j+1)  # right\n        dfs(i, j-1)  # left\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j)\n                count += 1\n    \n    return count",
            "keyInsight": "Flood fill groups connected components - used everywhere in graphs!"
        },
        "reverse-linked-list": {
            "title": "Reverse Linked List",
            "pattern": "Iterative Pointer Swap",
            "patternEmoji": "ğŸ”„",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Change each node's pointer to point backwards!",
            "intuition": [
                "ğŸ¯ Each node.next should point to previous node",
                "ğŸ§  Need to save 'next' before changing pointer",
                "ğŸ’¡ Use 3 pointers: prev, current, next"
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]"
                },
                {
                    "input": "head = [1,2]",
                    "output": "[2,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "None â† 1 â†’ 2 â†’ 3 â†’ None\n â†‘    â†‘\nprev  curr",
                    "explanation": "prev starts at None (new tail)"
                },
                {
                    "step": 2,
                    "title": "Save Next",
                    "visual": "1 â†’ 2 â†’ 3\n    â†‘\n   next_node (save before we lose it!)",
                    "explanation": "Must save before changing pointer"
                },
                {
                    "step": 3,
                    "title": "Reverse Pointer",
                    "visual": "None â† 1   2 â†’ 3\n â†‘    â†‘   â†‘\nprev curr next",
                    "explanation": "curr.next = prev"
                },
                {
                    "step": 4,
                    "title": "Move Forward",
                    "visual": "None â† 1 â† 2 â† 3\n               â†‘\n              prev (new head!)",
                    "explanation": "Shift all pointers right, repeat"
                }
            ],
            "code": "def reverseList(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head",
            "keyInsight": "Three-pointer technique is fundamental for linked list operations!"
        },
        "contains-duplicate": {
            "title": "Contains Duplicate",
            "pattern": "Hash Set",
            "patternEmoji": "ğŸ—‚ï¸",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Put numbers in a set - sets don't allow duplicates!",
            "intuition": [
                "ğŸ¯ Need to check if any number appears twice",
                "ğŸ§  Set = O(1) lookup + only unique values",
                "ğŸ’¡ If set size < array size â†’ duplicates exist!"
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "True"
                },
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "False"
                },
                {
                    "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                    "output": "True"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "The Insight",
                    "visual": "[1, 2, 3, 1]\n     â†“\n{1, 2, 3} â† only 3 unique!\n4 â‰  3 â†’ HAS DUPLICATES",
                    "explanation": "Set removes duplicates automatically"
                },
                {
                    "step": 2,
                    "title": "One-Liner!",
                    "visual": "len(set(nums)) < len(nums)",
                    "explanation": "Compare sizes"
                },
                {
                    "step": 3,
                    "title": "Alternative: Check While Adding",
                    "visual": "for num in nums:\n  if num in seen: return True\n  seen.add(num)",
                    "explanation": "Early exit if duplicate found"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "[1,2,3,4] â†’ False\n[1,2,3,1] â†’ True",
                    "explanation": "Simple!"
                }
            ],
            "code": "def containsDuplicate(nums):\n    # One-liner:\n    return len(set(nums)) < len(nums)\n    \n    # Or with early exit:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False",
            "keyInsight": "Sets are your best friend for duplicate detection!",
            "videoId": "3OamzN90kPg",
            "neetcodeLink": "https://neetcode.io/problems/contains-duplicate"
        },
        "invert-binary-tree": {
            "title": "Invert Binary Tree",
            "pattern": "Tree Recursion",
            "patternEmoji": "ğŸŒ³",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Swap left and right children at every node!",
            "intuition": [
                "ğŸ¯ Mirror the tree: every left becomes right",
                "ğŸ§  Recursively swap children at each node",
                "ğŸ’¡ Base case: null node needs no swap"
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]"
                },
                {
                    "input": "root = [2,1,3]",
                    "output": "[2,3,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Visualize",
                    "visual": "    4          4\n   / \\   â†’   / \\\n  2   7     7   2\n / \\ / \\   / \\ / \\\n1  3 6  9 9  6 3  1",
                    "explanation": "Mirror image of the tree"
                },
                {
                    "step": 2,
                    "title": "At Each Node",
                    "visual": "  4\n / \\\n2   7  â† swap these!\n\n  4\n / \\\n7   2  âœ…",
                    "explanation": "Swap left and right children"
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "Then invert(7) and invert(2)\n  â†“           â†“\nswap 6,9   swap 1,3",
                    "explanation": "Do the same for all subtrees"
                },
                {
                    "step": 4,
                    "title": "Base Case",
                    "visual": "if node is None:\n    return None\n    \n(Leaf's children are None - nothing to swap)",
                    "explanation": "Stop at null nodes"
                }
            ],
            "code": "def invertTree(root):\n    if root is None:\n        return None\n    \n    # Swap children\n    root.left, root.right = root.right, root.left\n    \n    # Recurse on subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root",
            "keyInsight": "The famous interview question Max Howell couldn't solve! Now you can ğŸ˜„"
        },
        "coin-change": {
            "title": "Coin Change",
            "pattern": "Dynamic Programming",
            "patternEmoji": "ğŸª™",
            "timeComplexity": "O(amount Ã— coins)",
            "spaceComplexity": "O(amount)",
            "oneliner": "Build up from amount 0, using each coin to reach new amounts!",
            "intuition": [
                "ğŸ¯ For each amount: what's minimum coins needed?",
                "ğŸ§  dp[i] = min coins to make amount i",
                "ğŸ’¡ For each coin: dp[i] = min(dp[i], dp[i-coin] + 1)"
            ],
            "testCases": [
                {
                    "input": "coins = [1,2,5], amount = 11",
                    "output": "3"
                },
                {
                    "input": "coins = [2], amount = 3",
                    "output": "-1"
                },
                {
                    "input": "coins = [1], amount = 0",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize DP Array",
                    "visual": "coins = [1,2,5], amount = 11\n\ndp = [0, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ, âˆ]\n      â†‘\n   0 coins for amount 0",
                    "explanation": "dp[0] = 0, everything else = infinity"
                },
                {
                    "step": 2,
                    "title": "Fill Using Each Coin",
                    "visual": "For coin = 1:\ndp[1] = dp[0] + 1 = 1\ndp[2] = dp[1] + 1 = 2\n...",
                    "explanation": "If we can reach amount i-coin, we can reach i!"
                },
                {
                    "step": 3,
                    "title": "Update With Better Options",
                    "visual": "For coin = 2:\ndp[2] = min(2, dp[0]+1) = 1 âœ… better!\n\nFor coin = 5:\ndp[5] = min(5, dp[0]+1) = 1 âœ… much better!",
                    "explanation": "Take the minimum across all coin choices"
                },
                {
                    "step": 4,
                    "title": "Final Answer",
                    "visual": "dp[11] = 3 (5+5+1)\n\n[0,1,1,2,2,1,2,2,3,3,2,3]\n                        â†‘",
                    "explanation": "dp[amount] is the answer!"
                }
            ],
            "code": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1",
            "keyInsight": "Classic unbounded knapsack - build solutions from smaller subproblems!"
        },
        "two-sum": {
            "title": "Two Sum",
            "pattern": "Hashmap",
            "patternEmoji": "ğŸ—ºï¸",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a hashmap to store seen complements.",
            "intuition": [
                "Map value -> index for O(1) lookups.",
                "Check if target - current exists in map.",
                "If yes, return indices. If no, add current."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking 2. Complement = 7."
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "default",
                    "pointers": [],
                    "transientMessage": "7 not in map. Store 2:0."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking 7. Complement = 2."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "2 is in map! Found pair."
                }
            ],
            "code": "def twoSum(nums, target):\\n    seen = {}\\n    for i, num in enumerate(nums):\\n        complement = target - num\\n        if complement in seen:\\n            return [seen[complement], i]\\n        seen[num] = i\\n    return []",
            "keyInsight": "Trading space for speed: Hashmap gives O(1) lookup.",
            "testCases": [
                {
                    "input": "numbers = [2,7,11,15], target = 9",
                    "output": "[1, 2]"
                }
            ],
            "videoId": "KLlXCFG5TnA",
            "takeuforwardLink": "https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/"
        },
        "remove-element": {
            "title": "Remove Element",
            "pattern": "Two Pointers",
            "patternEmoji": "âœŒï¸",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use a read pointer and a write pointer to filter in-place.",
            "intuition": [
                "ğŸ¯ We need to remove all instances of val in-place",
                "ğŸ§  Maintain a 'k' pointer that tracks the position of valid elements",
                "ğŸ’¡ If current element != val, put it at k and increment k"
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,2,3], val = 3",
                    "output": "2, nums = [2,2,_,_]"
                },
                {
                    "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                    "output": "5, nums = [0,1,4,0,3,_,_,_]"
                }
            ],
            "code": "def removeElement(nums, val):\n    k = 0\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k",
            "keyInsight": "Overwrite values we don't want with the ones we keep!"
        },
        "majority-element": {
            "title": "Majority Element",
            "pattern": "Boyer-Moore Voting",
            "patternEmoji": "ğŸ—³ï¸",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Cancel out different elements; the majority always survives!",
            "intuition": [
                "ğŸ¯ Majority element appears > n/2 times",
                "ğŸ§  Think of it as a war: mixed pair die, majority wins",
                "ğŸ’¡ Count +, Count -. If count 0, pick new candidate."
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3"
                },
                {
                    "input": "nums = [2,2,1,1,1,2,2]",
                    "output": "2"
                }
            ],
            "code": "def majorityElement(nums):\n    count = 0\n    candidate = None\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate",
            "keyInsight": "If >50% of people vote Red, even if everyone else pairs up against them, Red wins!"
        },
        "ransom-note": {
            "title": "Ransom Note",
            "pattern": "Frequency Count",
            "patternEmoji": "ğŸ“Š",
            "timeComplexity": "O(n + m)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count available letters in magazine, subtract for note.",
            "intuition": [
                "ğŸ¯ Can we construct the note from magazine letters?",
                "ğŸ§  Need enough of EACH character type",
                "ğŸ’¡ Count occurrences. If any char count in note > magazine -> False"
            ],
            "testCases": [
                {
                    "input": "ransomNote = \"a\", magazine = \"b\"",
                    "output": "False"
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"ab\"",
                    "output": "False"
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"aab\"",
                    "output": "True"
                }
            ],
            "code": "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    counts = Counter(magazine)\n    \n    for char in ransomNote:\n        if counts[char] <= 0:\n            return False\n        counts[char] -= 1\n        \n    return True",
            "keyInsight": "Using a fixed-size array (26 chars) or hashmap makes this efficient!"
        },
        "valid-anagram": {
            "title": "Valid Anagram",
            "pattern": "Frequency Analysis",
            "patternEmoji": "âš–ï¸",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count characters - must match exactly!",
            "intuition": [
                "ğŸ¯ Anagram = same characters, same counts, different order",
                "ğŸ§  Sort? O(n log n). Count? O(n).",
                "ğŸ’¡ Increment for 's', decrement for 't'. All zero? True."
            ],
            "testCases": [
                {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "output": "True"
                },
                {
                    "input": "s = \"rat\", t = \"car\"",
                    "output": "False"
                }
            ],
            "code": "def isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n        \n    count = {}\n    \n    for char in s:\n        count[char] = count.get(char, 0) + 1\n        \n    for char in t:\n        if char not in count or count[char] == 0:\n            return False\n        count[char] -= 1\n        \n    return True",
            "keyInsight": "If lengths differ, instant False. Otherwise, cancel out counts."
        },
        "happy-number": {
            "title": "Happy Number",
            "pattern": "Cycle Detection",
            "patternEmoji": "ğŸ”„",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Detect if sum of squares enters a cycle or hits 1.",
            "intuition": [
                "ğŸ¯ Repeat process: replace n with sum of squared digits",
                "ğŸ§  It either reaches 1 (Happy) or cycles endlessly (Sad)",
                "ğŸ’¡ Use a Set to track seen numbers OR Floyd's cycle finding!"
            ],
            "testCases": [
                {
                    "input": "n = 19",
                    "output": "True"
                },
                {
                    "input": "n = 2",
                    "output": "False"
                }
            ],
            "code": "def isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(d) ** 2 for d in str(n))\n    return n == 1",
            "keyInsight": "Only two outcomes: 1 or cycle. Detect the cycle!"
        }
    }
}