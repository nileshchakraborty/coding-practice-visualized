{
  "triangle": {
    "title": "Triangle",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcc9",
    "timeComplexity": "O(n^2)",
    "spaceComplexity": "O(n)",
    "oneliner": "Compute min path sum from bottom to top to avoid greedy traps!",
    "intuition": [
      "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
      "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
      "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
    ],
    "testCases": [
      {
        "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
        "output": "11"
      },
      {
        "input": "triangle = [[-10]]",
        "output": "-10"
      }
    ],
    "code": "class Solution:\n    def minimumTotal(self, triangle):\n        \"\"\"\n        Intuition:\n        - \ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min\n        - \ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom\n        - \ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n        \"\"\"\n        dp = triangle[-1][:]  # Initialize DP table to store results.\n        for i in range(len(triangle) - 2, -1, -1):  # Iterate through the range.\n            for j in range(i + 1):  # Iterate through the range.\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])  # Take the minimum value.\n        return dp[0]",
    "keyInsight": "Bottom-up DP simplifies boundary conditions and reuses space.",
    "description": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
    "examples": [
      {
        "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
        "output": "11",
        "explanation": "Path 2 -> 3 -> 5 -> 1 = 11."
      },
      {
        "input": "triangle = [[-10]]",
        "output": "-10",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= triangle.length <= 200",
      "triangle[0].length == 1",
      "triangle[i].length == triangle[i - 1].length + 1",
      "-10^4 <= triangle[i][j] <= 10^4"
    ],
    "hints": [
      "Use DP from bottom to top.",
      "dp[i] = triangle[row][i] + min(dp[i], dp[i+1]).",
      "Space optimization: reuse same array."
    ],
    "relatedProblems": [
      "minimum-path-sum",
      "dungeon-game"
    ],
    "videoId": "OM1MTokvxs4",
    "problemStatement": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "visualizationType": "matrix",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Triangle",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          [
            4,
            1,
            8,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 2",
        "arrayState": [
          [
            2
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            2
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 3,4",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 6,5,7",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 4,1,8,3",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          [
            4,
            1,
            8,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          [
            4,
            1,
            8,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          [
            4,
            1,
            8,
            3
          ]
        ],
        "pointers": [],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            2
          ],
          [
            3,
            4
          ],
          [
            6,
            5,
            7
          ],
          [
            4,
            1,
            8,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "initialState": [
      [
        2
      ],
      [
        3,
        4
      ],
      [
        6,
        5,
        7
      ],
      [
        4,
        1,
        8,
        3
      ]
    ],
    "approach": "Dynamic Programming: Compute min path sum from bottom to top to avoid greedy traps!",
    "suggestedNextQuestion": {
      "slug": "unique-paths",
      "title": "Unique Paths",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def minimumTotal(self, triangle):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def minimumTotal_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
          "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
          "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
        ],
        "code": "def minimumTotal(triangle):\n    \"\"\"\n    Intuition:\n    - \ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min\n    - \ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom\n    - \ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n    \"\"\"\n    dp = triangle[-1][:]  # Initialize DP table to store results.\n    for i in range(len(triangle) - 2, -1, -1):  # Iterate through the range.\n        for j in range(i + 1):  # Iterate through the range.\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])  # Take the minimum value.\n    return dp[0]"
      }
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minimumTotal(triangle) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} triangle\n     * @return {any}\n     */\n    minimumTotal(triangle) {\n        for (let i = triangle.length - 2; i > -1; i--) {\n          for (let j = 0; j < triangle[i].length; j++) {\n            triangle[i][j] += Math.min( triangle[i + 1][j], triangle[i + 1][j + 1]);\n          }\n      }\n\n    return triangle[0][0];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        int[][] f = new int[n + 1][n + 1];\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = 0; j <= i; ++j) {\n                f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + triangle.get(i).get(j);\n            }\n        }\n        return f[0][0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minimumTotal(vector<vector<int>>& triangle) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n = triangle.size();\n        vector<vector<int>> f(n + 1, vector<int>(n + 1, 0));\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = 0; j <= i; ++j) {\n                f[i][j] = min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j];\n            }\n        }\n        return f[0][0];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minimumTotal(triangle [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minimumTotal(triangle [][]int) int {\n\tn := len(triangle)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tfor i := n - 1; i >= 0; i-- {\n\t\tfor j := 0; j <= i; j++ {\n\t\t\tf[i][j] = min(f[i+1][j], f[i+1][j+1]) + triangle[i][j]\n\t\t}\n\t}\n\treturn f[0][0]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn minimum_total(triangle: Vec<Vec<i32>>) -> i32 {\n        let n = triangle.len();\n        let mut f = vec![vec![0; n + 1]; n + 1];\n        for i in (0..n).rev() {\n            for j in 0..=i {\n                f[i][j] = f[i + 1][j].min(f[i + 1][j + 1]) + triangle[i][j];\n            }\n        }\n        f[0][0]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minimumTotal(self, triangle):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minimumTotal(triangle: number[][]): number  {\n    const n = triangle.length;\n    const f: number[][] = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 0; --i) {\n        for (let j = 0; j <= i; ++j) {\n            f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j];\n        }\n    }\n    return f[0][0];\n}\n}",
        "initialCode": "class Solution {\n    minimumTotal(triangle: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "best-time-to-buy-and-sell-stock": {
    "title": "Best Time to Buy and Sell Stock",
    "pattern": "Track Minimum",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track the minimum price seen so far, maximize profit at each step!",
    "intuition": [
      "\ud83c\udfaf Buy LOW, Sell HIGH",
      "\ud83e\udde0 Keep track of the cheapest day to buy",
      "\ud83d\udca1 At each day, calculate: what if I sold today?"
    ],
    "testCases": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5"
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Initialize Trackers",
        "visual": "min_price = \u221e\nmax_profit = 0",
        "explanation": "Start with infinity as min (first price will always be lower)"
      },
      {
        "step": 2,
        "title": "Walk Through Prices",
        "visual": "prices: [7, 1, 5, 3, 6, 4]\n         \u2191\n       Day 1: price = 7",
        "explanation": "Visit each day's price"
      },
      {
        "step": 3,
        "title": "Update Minimum",
        "visual": "Day 1: min = min(\u221e, 7) = 7\nDay 2: min = min(7, 1) = 1 \u2b50 NEW LOW!",
        "explanation": "Always track the best buying opportunity"
      },
      {
        "step": 4,
        "title": "Calculate Profit",
        "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 \ud83d\udcb0\n        max_profit = 5",
        "explanation": "At each step: profit = today - min_so_far"
      }
    ],
    "code": "class Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Buy LOW, Sell HIGH\n        - \ud83e\udde0 Keep track of the cheapest day to buy\n        - \ud83d\udca1 At each day, calculate: what if I sold today?\n\n        Algorithm:\n        1. Initialize Trackers - Start with infinity as min (first price will always be lower)\n        2. Walk Through Prices - Visit each day's price\n        3. Update Minimum - Always track the best buying opportunity\n        4. Calculate Profit - At each step: profit = today - min_so_far\n        \"\"\"\n        min_price = float('inf')\n        max_profit = 0\n\n        for price in prices:  # Iterate over elements.\n            min_price = min(min_price, price)  # Take the minimum value.\n            profit = price - min_price\n            max_profit = max(max_profit, profit)  # Take the maximum value.\n\n        return max_profit",
    "keyInsight": "One pass solution - no need to compare every pair!",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profitable transaction possible."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "hints": [
      "Track the minimum price seen so far.",
      "At each day, calculate potential profit if you sold today.",
      "Keep track of the maximum profit seen."
    ],
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-ii",
      "best-time-to-buy-and-sell-stock-iii",
      "maximum-subarray"
    ],
    "videoId": "1pkOgXD63yU",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Prices: [7, 1, 5, 3, 6, 4]",
        "transientMessage": "minPrice=7, maxProfit=0",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "buy",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Day 1: price 1 < minPrice",
        "transientMessage": "New minPrice = 1",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "buy",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Day 2: sell at 5, profit=4",
        "transientMessage": "New maxProfit = 4!",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "sell",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Day 3: sell at 3, profit=2",
        "transientMessage": "maxProfit still 4",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "sell",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Day 4: sell at 6, profit=5",
        "transientMessage": "New maxProfit = 5!",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "sell",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Day 5: sell at 4, profit=3",
        "transientMessage": "maxProfit still 5",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [
          {
            "label": "sell",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Max profit: 5",
        "transientMessage": "Complete!",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "array",
    "initialState": [
      7,
      1,
      5,
      3,
      6,
      4
    ],
    "approach": "Track Minimum: Track the minimum price seen so far, maximize profit at each step!",
    "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
    "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxProfit(prices):\n    max_p = 0\n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - prices[i]\n            if profit > max_p:\n                max_p = profit\n    return max_p"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Buy LOW, Sell HIGH",
          "\ud83e\udde0 Keep track of the cheapest day to buy",
          "\ud83d\udca1 At each day, calculate: what if I sold today?"
        ],
        "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Buy LOW, Sell HIGH\n    - \ud83e\udde0 Keep track of the cheapest day to buy\n    - \ud83d\udca1 At each day, calculate: what if I sold today?\n\n    Algorithm:\n    1. Initialize Trackers - Start with infinity as min (first price will always be lower)\n    2. Walk Through Prices - Visit each day's price\n    3. Update Minimum - Always track the best buying opportunity\n    4. Calculate Profit - At each step: profit = today - min_so_far\n    \"\"\"\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:  # Iterate over elements.\n        min_price = min(min_price, price)  # Take the minimum value.\n        profit = price - min_price\n        max_profit = max(max_profit, profit)  # Take the maximum value.\n    \n    return max_profit"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProfit(prices) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} prices\n     * @return {any}\n     */\n    maxProfit(prices) {\n        let ans = 0;\n        let mi = prices[0];\n        for (const v of prices) {\n            ans = Math.max(ans, v - mi);\n            mi = Math.min(mi, v);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int ans = 0, mi = prices[0];\n        for (int v : prices) {\n            ans = Math.max(ans, v - mi);\n            mi = Math.min(mi, v);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProfit(vector<int>& prices) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int ans = 0, mi = prices[0];\n        for (int& v : prices) {\n            ans = max(ans, v - mi);\n            mi = min(mi, v);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) (ans int) {\n\tmi := prices[0]\n\tfor _, v := range prices {\n\t\tans = max(ans, v-mi)\n\t\tmi = min(mi, v)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut ans = 0;\n        let mut mi = prices[0];\n        for &v in &prices {\n            ans = ans.max(v - mi);\n            mi = mi.min(v);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProfit(prices: number[]): number  {\n    let ans = 0;\n    let mi = prices[0];\n    for (const v of prices) {\n        ans = Math.max(ans, v - mi);\n        mi = Math.min(mi, v);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxProfit(prices: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "valid-parentheses",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "pattern": "Stack"
    }
  },
  "valid-palindrome": {
    "title": "Valid Palindrome",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc46",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use two pointers from both ends, skip non-alphanumeric!",
    "intuition": [
      "\ud83c\udfaf Palindrome reads same forwards & backwards",
      "\ud83e\udde0 Compare characters from outside \u2192 inside",
      "\ud83d\udca1 Skip spaces and punctuation!"
    ],
    "testCases": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true"
      },
      {
        "input": "s = \"race a car\"",
        "output": "false"
      },
      {
        "input": "s = \" \"",
        "output": "true"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Set Up Pointers",
        "visual": "\"A man, a plan, a canal: Panama\"\n \u2191                              \u2191\nleft                          right",
        "explanation": "Start from both ends of the string"
      },
      {
        "step": 2,
        "title": "Skip Non-Letters",
        "visual": "\"...canal: Panama\"\n         \u2191      \u2191\n     skip ':'  'a'",
        "explanation": "Move pointer if not alphanumeric"
      },
      {
        "step": 3,
        "title": "Compare (Case-Insensitive)",
        "visual": "'A' == 'a' \u2705 (lowercase both)\n'M' == 'm' \u2705\n'N' == 'n' \u2705",
        "explanation": "Convert to lowercase and compare"
      },
      {
        "step": 4,
        "title": "Move Inward",
        "visual": "left \u2192 \u2190     \u2192 \u2190 right\n      Meet in middle = VALID!",
        "explanation": "Continue until pointers cross"
      }
    ],
    "code": "class Solution:\n    def isPalindrome(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Palindrome reads same forwards & backwards\n        - \ud83e\udde0 Compare characters from outside \u2192 inside\n        - \ud83d\udca1 Skip spaces and punctuation!\n\n        Algorithm:\n        1. Set Up Pointers - Start from both ends of the string\n        2. Skip Non-Letters - Move pointer if not alphanumeric\n        3. Compare (Case-Insensitive) - Convert to lowercase and compare\n        4. Move Inward - Continue until pointers cross\n        \"\"\"\n        left, right = 0, len(s) - 1\n\n        while left < right:\n            while left < right and not s[left].isalnum():\n                left += 1\n            while left < right and not s[right].isalnum():\n                right -= 1\n\n            if s[left].lower() != s[right].lower():\n                return False  # Condition not met.\n\n            left += 1\n            right -= 1\n\n        return True  # Condition satisfied.",
    "keyInsight": "Two pointers = no extra space needed for reversed string!",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "After filtering: 'amanaplanacanalpanama' is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "After filtering: 'raceacar' is not a palindrome."
      }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters."
    ],
    "hints": [
      "Use two pointers from both ends.",
      "Skip non-alphanumeric characters.",
      "Compare characters (case-insensitive)."
    ],
    "relatedProblems": [
      "valid-palindrome-ii",
      "palindrome-linked-list",
      "longest-palindromic-substring"
    ],
    "videoId": "jJXJ16kPFWg",
    "animationSteps": [
      {
        "step": 1,
        "visual": "s = \"A man, a plan, a canal: Panama\"",
        "transientMessage": "Initialize left=0, right=29",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 29
          }
        ],
        "indices": [
          0,
          29
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Compare 'A' (idx 0) vs 'a' (idx 29)",
        "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 29
          }
        ],
        "indices": [
          0,
          29
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "Skip non-alphanumeric ' ' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 28
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Compare 'm' (idx 2) vs 'm' (idx 28)",
        "transientMessage": "'m' == 'm' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 28
          }
        ],
        "indices": [
          2,
          28
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compare 'a' (idx 3) vs 'a' (idx 27)",
        "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 27
          }
        ],
        "indices": [
          3,
          27
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Compare 'n' (idx 4) vs 'n' (idx 26)",
        "transientMessage": "'n' == 'n' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          },
          {
            "label": "R",
            "index": 26
          }
        ],
        "indices": [
          4,
          26
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Skip non-alphanumeric ',' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 6
          },
          {
            "label": "R",
            "index": 25
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Skip non-alphanumeric ' ' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 7
          },
          {
            "label": "R",
            "index": 25
          }
        ],
        "indices": [
          7
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Compare 'a' (idx 7) vs 'a' (idx 25)",
        "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 7
          },
          {
            "label": "R",
            "index": 25
          }
        ],
        "indices": [
          7,
          25
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Skip non-alphanumeric ' ' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 9
          },
          {
            "label": "R",
            "index": 24
          }
        ],
        "indices": [
          9
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Compare 'p' (idx 9) vs 'P' (idx 24)",
        "transientMessage": "'p' == 'p' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 9
          },
          {
            "label": "R",
            "index": 24
          }
        ],
        "indices": [
          9,
          24
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Skip non-alphanumeric ' ' on right",
        "transientMessage": "Right pointer moves left past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 10
          },
          {
            "label": "R",
            "index": 22
          }
        ],
        "indices": [
          22
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "Skip non-alphanumeric ':' on right",
        "transientMessage": "Right pointer moves left past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 10
          },
          {
            "label": "R",
            "index": 21
          }
        ],
        "indices": [
          21
        ],
        "color": "accent"
      },
      {
        "step": 14,
        "visual": "Compare 'l' (idx 10) vs 'l' (idx 21)",
        "transientMessage": "'l' == 'l' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 10
          },
          {
            "label": "R",
            "index": 21
          }
        ],
        "indices": [
          10,
          21
        ],
        "color": "success"
      },
      {
        "step": 15,
        "visual": "Compare 'a' (idx 11) vs 'a' (idx 20)",
        "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 11
          },
          {
            "label": "R",
            "index": 20
          }
        ],
        "indices": [
          11,
          20
        ],
        "color": "success"
      },
      {
        "step": 16,
        "visual": "Compare 'n' (idx 12) vs 'n' (idx 19)",
        "transientMessage": "'n' == 'n' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 12
          },
          {
            "label": "R",
            "index": 19
          }
        ],
        "indices": [
          12,
          19
        ],
        "color": "success"
      },
      {
        "step": 17,
        "visual": "Skip non-alphanumeric ',' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 14
          },
          {
            "label": "R",
            "index": 18
          }
        ],
        "indices": [
          14
        ],
        "color": "accent"
      },
      {
        "step": 18,
        "visual": "Skip non-alphanumeric ' ' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 15
          },
          {
            "label": "R",
            "index": 18
          }
        ],
        "indices": [
          15
        ],
        "color": "accent"
      },
      {
        "step": 19,
        "visual": "Compare 'a' (idx 15) vs 'a' (idx 18)",
        "transientMessage": "'a' == 'a' \u2713 Match! Move pointers inward",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 15
          },
          {
            "label": "R",
            "index": 18
          }
        ],
        "indices": [
          15,
          18
        ],
        "color": "success"
      },
      {
        "step": 20,
        "visual": "Skip non-alphanumeric ' ' on left",
        "transientMessage": "Left pointer moves right past non-alphanumeric",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 17
          },
          {
            "label": "R",
            "index": 17
          }
        ],
        "indices": [
          17
        ],
        "color": "accent"
      },
      {
        "step": 21,
        "visual": "Result: true",
        "transientMessage": "Pointers crossed - It's a palindrome! \u2705",
        "arrayState": [
          "A",
          " ",
          "m",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "p",
          "l",
          "a",
          "n",
          ",",
          " ",
          "a",
          " ",
          "c",
          "a",
          "n",
          "a",
          "l",
          ":",
          " ",
          "P",
          "a",
          "n",
          "a",
          "m",
          "a"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "problemStatement": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "visualizationType": "array",
    "initialState": [
      "A",
      " ",
      "m",
      "a",
      "n",
      ",",
      " ",
      "a",
      " ",
      "p",
      "l",
      "a",
      "n",
      ",",
      " ",
      "a",
      " ",
      "c",
      "a",
      "n",
      "a",
      "l",
      ":",
      " ",
      "P",
      "a",
      "n",
      "a",
      "m",
      "a"
    ],
    "approach": "Two Pointers: Use two pointers from both ends, skip non-alphanumeric!",
    "suggestedNextQuestion": {
      "slug": "3sum",
      "title": "3Sum",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def isPalindrome(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def isPalindrome(s):\n    # Filter non-alphanumeric chars\n    filtered = [c.lower() for c in s if c.isalnum()]\n    # Compare with reverse\n    return filtered == filtered[::-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Palindrome reads same forwards & backwards",
          "\ud83e\udde0 Compare characters from outside \u2192 inside",
          "\ud83d\udca1 Skip spaces and punctuation!"
        ],
        "code": "def isPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Palindrome reads same forwards & backwards\n    - \ud83e\udde0 Compare characters from outside \u2192 inside\n    - \ud83d\udca1 Skip spaces and punctuation!\n\n    Algorithm:\n    1. Set Up Pointers - Start from both ends of the string\n    2. Skip Non-Letters - Move pointer if not alphanumeric\n    3. Compare (Case-Insensitive) - Convert to lowercase and compare\n    4. Move Inward - Continue until pointers cross\n    \"\"\"\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False  # Condition not met.\n        \n        left += 1\n        right -= 1\n    \n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isPalindrome(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    isPalindrome(s) {\n        let i = 0;\n        let j = s.length - 1;\n        while (i < j) {\n            if (!/[a-zA-Z0-9]/.test(s[i])) {\n                ++i;\n            } else if (!/[a-zA-Z0-9]/.test(s[j])) {\n                --j;\n            } else if (s[i].toLowerCase() !== s[j].toLowerCase()) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n    }\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isPalindrome(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n        while (i < j) {\n            if (!Character.isLetterOrDigit(s.charAt(i))) {\n                ++i;\n            } else if (!Character.isLetterOrDigit(s.charAt(j))) {\n                --j;\n            } else if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isPalindrome(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int i = 0, j = s.size() - 1;\n        while (i < j) {\n            if (!isalnum(s[i])) {\n                ++i;\n            } else if (!isalnum(s[j])) {\n                --j;\n            } else if (tolower(s[i]) != tolower(s[j])) {\n                return false;\n            } else {\n                ++i;\n                --j;\n            }\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isPalindrome(s string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isPalindrome(s string) bool {\n\ti, j := 0, len(s)-1\n\tfor i < j {\n\t\tif !isalnum(s[i]) {\n\t\t\ti++\n\t\t} else if !isalnum(s[j]) {\n\t\t\tj--\n\t\t} else if tolower(s[i]) != tolower(s[j]) {\n\t\t\treturn false\n\t\t} else {\n\t\t\ti, j = i+1, j-1\n\t\t}\n\t}\n\treturn true\n}\n\nfunc isalnum(ch byte) bool {\n\treturn (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')\n}\n\nfunc tolower(ch byte) byte {\n\tif ch >= 'A' && ch <= 'Z' {\n\t\treturn ch + 32\n\t}\n\treturn ch\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_palindrome(s: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_palindrome(s: String) -> bool {\n        let s = s.to_lowercase();\n        let s = s.as_bytes();\n        let n = s.len();\n        let (mut l, mut r) = (0, n - 1);\n        while l < r {\n            while l < r && !s[l].is_ascii_alphanumeric() {\n                l += 1;\n            }\n            while l < r && !s[r].is_ascii_alphanumeric() {\n                r -= 1;\n            }\n            if s[l] != s[r] {\n                return false;\n            }\n            l += 1;\n            if r != 0 {\n                r -= 1;\n            }\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isPalindrome(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isPalindrome(s: string): boolean  {\n    let i = 0;\n    let j = s.length - 1;\n    while (i < j) {\n        if (!/[a-zA-Z0-9]/.test(s[i])) {\n            ++i;\n        } else if (!/[a-zA-Z0-9]/.test(s[j])) {\n            --j;\n        } else if (s[i].toLowerCase() !== s[j].toLowerCase()) {\n            return false;\n        } else {\n            ++i;\n            --j;\n        }\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    isPalindrome(s: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "merge-sorted-array": {
    "title": "Merge Sorted Array",
    "pattern": "Three Pointers (Reverse)",
    "patternEmoji": "\ud83d\udd00",
    "timeComplexity": "O(m + n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Fill from the END to avoid overwriting!",
    "intuition": [
      "\ud83c\udfaf Can't start from front - would overwrite nums1!",
      "\ud83e\udde0 Start from back - empty space is there for us!",
      "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
    ],
    "testCases": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]"
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]"
      },
      {
        "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
        "output": "[1]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Set Up 3 Pointers",
        "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            \u2191     \u2191              \u2191\n           p1    write           p2",
        "explanation": "p1 at last real element, p2 at end of nums2, write at end"
      },
      {
        "step": 2,
        "title": "Compare & Place Larger",
        "visual": "3 vs 6 \u2192 6 wins!\n[1,2,3,0,0,6] \u2190 place 6",
        "explanation": "Bigger goes to write position"
      },
      {
        "step": 3,
        "title": "Move Pointers",
        "visual": "[1,2,3,0,0,6]\n            \u2191 \u2191\n           p1 write\n           \u2190 moved left",
        "explanation": "Decrement write and the pointer that was used"
      },
      {
        "step": 4,
        "title": "Continue Until Done",
        "visual": "Result: [1,2,2,3,5,6] \u2705",
        "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
      }
    ],
    "code": "class Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Can't start from front - would overwrite nums1!\n        - \ud83e\udde0 Start from back - empty space is there for us!\n        - \ud83d\udca1 Three pointers: end of nums1, end of nums2, write position\n\n        Algorithm:\n        1. Set Up 3 Pointers - p1 at last real element, p2 at end of nums2, write at end\n        2. Compare & Place Larger - Bigger goes to write position\n        3. Move Pointers - Decrement write and the pointer that was used\n        4. Continue Until Done - If nums2 remaining, copy them. nums1 remaining? Already in place!\n        \"\"\"\n        p1, p2 = m - 1, n - 1  # Initialize pointers for merging.\n        write = m + n - 1\n\n        while p2 >= 0:\n            if p1 >= 0 and nums1[p1] > nums2[p2]:\n                nums1[write] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[write] = nums2[p2]\n                p2 -= 1\n            write -= 1\n        return nums1",
    "keyInsight": "Reverse iteration = in-place without overwriting!",
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]."
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": "No elements to merge from nums2."
      }
    ],
    "constraints": [
      "nums1.length == m + n",
      "nums2.length == n",
      "0 <= m, n <= 200",
      "1 <= m + n <= 200",
      "-10^9 <= nums1[i], nums2[j] <= 10^9"
    ],
    "hints": [
      "Start from the end of both arrays and work backwards.",
      "Compare elements from the end and place the larger one at the back of nums1.",
      "This avoids overwriting elements we haven't processed yet."
    ],
    "relatedProblems": [
      "merge-two-sorted-lists",
      "sort-an-array",
      "squares-of-a-sorted-array"
    ],
    "videoId": "P1Ic85RarKY",
    "animationSteps": [
      {
        "step": 1,
        "visual": "nums1: [1,2,3,0,0,0]    nums2: [2,5,6]",
        "transientMessage": "p1 at last real element, p2 at end of nums2, write at end",
        "arrayState": [
          1,
          2,
          3,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 5
          }
        ],
        "indices": [
          2,
          5
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Compare: nums1[p1]=3 vs nums2[p2]=6",
        "transientMessage": "6 > 3, so place 6 at write position",
        "arrayState": [
          1,
          2,
          3,
          0,
          0,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "Placed 6, move p2 and write left",
        "transientMessage": "p2-- \u2192 1, write-- \u2192 4",
        "arrayState": [
          1,
          2,
          3,
          0,
          0,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 4
          }
        ],
        "indices": [
          2,
          4
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Compare: nums1[p1]=3 vs nums2[p2]=5",
        "transientMessage": "5 > 3, so place 5 at write position",
        "arrayState": [
          1,
          2,
          3,
          0,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Placed 5, move p2 and write left",
        "transientMessage": "p2-- \u2192 0, write-- \u2192 3",
        "arrayState": [
          1,
          2,
          3,
          0,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Compare: nums1[p1]=3 vs nums2[p2]=2",
        "transientMessage": "3 > 2, so place 3 at write position",
        "arrayState": [
          1,
          2,
          3,
          3,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "write",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Placed 3, move p1 and write left",
        "transientMessage": "p1-- \u2192 1, write-- \u2192 2",
        "arrayState": [
          1,
          2,
          3,
          3,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 1
          },
          {
            "label": "write",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Compare: nums1[p1]=2 vs nums2[p2]=2",
        "transientMessage": "Equal! Place nums2[p2]=2 at write position",
        "arrayState": [
          1,
          2,
          2,
          3,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 1
          },
          {
            "label": "write",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Placed 2, p2 becomes -1 (exhausted)",
        "transientMessage": "nums2 exhausted! nums1 elements already in place \u2705",
        "arrayState": [
          1,
          2,
          2,
          3,
          5,
          6
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 1
          }
        ],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Final Result: [1,2,2,3,5,6]",
        "transientMessage": "Merge complete! All elements sorted in nums1",
        "arrayState": [
          1,
          2,
          2,
          3,
          5,
          6
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "color": "success"
      }
    ],
    "problemStatement": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      0,
      0,
      0
    ],
    "approach": "Three Pointers (Reverse): Fill from the END to avoid overwriting!",
    "mentalModel": "Like using your fingers to track two different positions in a book at once.",
    "initialCode": "class Solution:\n    def merge(self, nums1, m, nums2, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def merge(nums1, m, nums2, n):\n    # Copy nums2 into nums1's end\n    for i in range(n):\n        nums1[m + i] = nums2[i]\n    # Sort the entire array\n    nums1.sort()"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m + n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Can't start from front - would overwrite nums1!",
          "\ud83e\udde0 Start from back - empty space is there for us!",
          "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
        ],
        "code": "def merge(nums1, m, nums2, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can't start from front - would overwrite nums1!\n    - \ud83e\udde0 Start from back - empty space is there for us!\n    - \ud83d\udca1 Three pointers: end of nums1, end of nums2, write position\n\n    Algorithm:\n    1. Set Up 3 Pointers - p1 at last real element, p2 at end of nums2, write at end\n    2. Compare & Place Larger - Bigger goes to write position\n    3. Move Pointers - Decrement write and the pointer that was used\n    4. Continue Until Done - If nums2 remaining, copy them. nums1 remaining? Already in place!\n    \"\"\"\n    p1, p2 = m - 1, n - 1  # Initialize pointers for merging.\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    return nums1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    merge(nums1, m, nums2, n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nclass Solution {\n    /**\n     * @param {any} nums1, m, nums2, n\n     * @return {any}\n     */\n    merge(nums1, m, nums2, n) {\n        for (let i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\n            nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        for (int i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\n            nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for (int i = m - 1, j = n - 1, k = m + n - 1; ~j; --k) {\n            nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) merge(nums1 []int, m int, nums2 []int, n int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) merge(nums1 []int, m int, nums2 []int, n int) {\n\tfor i, j, k := m-1, n-1, m+n-1; j >= 0; k-- {\n\t\tif i >= 0 && nums1[i] > nums2[j] {\n\t\t\tnums1[k] = nums1[i]\n\t\t\ti--\n\t\t} else {\n\t\t\tnums1[k] = nums2[j]\n\t\t\tj--\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        let mut k = (m + n - 1) as usize;\n        let mut i = (m - 1) as isize;\n        let mut j = (n - 1) as isize;\n\n        while j >= 0 {\n            if i >= 0 && nums1[i as usize] > nums2[j as usize] {\n                nums1[k] = nums1[i as usize];\n                i -= 1;\n            } else {\n                nums1[k] = nums2[j as usize];\n                j -= 1;\n            }\n            k -= 1;\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def merge(self, nums1, m, nums2, n):\n        pass\n"
      },
      "typescript": {
        "code": "/**\n Do not return anything, modify nums1 in-place instead.\n */\nclass Solution {\n    merge(nums1: number[], m: number, nums2: number[], n: number): void  {\n    for (let i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\n        nums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n    }\n}\n}",
        "initialCode": "class Solution {\n    merge(nums1: number[], m: number, nums2: number[], n: number): void {\n        // Your code here\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "binary-search",
      "title": "Binary Search",
      "difficulty": "Easy",
      "pattern": "Divide & Conquer"
    }
  },
  "valid-parentheses": {
    "title": "Valid Parentheses",
    "pattern": "Stack",
    "patternEmoji": "(\ufe0f)\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Push open brackets; pop and match close brackets.",
    "intuition": [
      "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
      "\ud83e\udde0 Stack tracks open brackets.",
      "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
    ],
    "testCases": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      },
      {
        "input": "s = \"([])\"",
        "output": "true"
      },
      {
        "input": "s = \"([)]\"",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Open",
        "visual": "Push '(', '[', '{'.",
        "explanation": "Await closing."
      },
      {
        "step": 2,
        "title": "Close",
        "visual": "Pop top. Matches current? () [] {}",
        "explanation": "Verify pairing."
      },
      {
        "step": 3,
        "title": "End",
        "visual": "Stack empty? Valid.",
        "explanation": "No unclosed brackets left."
      }
    ],
    "code": "class Solution:\n    def isValid(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Last Opened must be First Closed (LIFO).\n        - \ud83e\udde0 Stack tracks open brackets.\n        - \ud83d\udca1 Mismatch or empty stack on close? Invalid.\n\n        Algorithm:\n        1. Open - Await closing.\n        2. Close - Verify pairing.\n        3. End - No unclosed brackets left.\n        \"\"\"\n        stack = []  # Initialize stack for tracking.\n        closeToOpen = {')': '(', ']': '[', '}': '{'}\n        for c in s:  # Iterate over elements.\n            if c in closeToOpen:\n                if stack and stack[-1] == closeToOpen[c]:\n                    stack.pop()  # Remove and return last element.\n                else:\n                    return False  # Condition not met.\n            else:\n                stack.append(c)  # Add to end.\n        return not stack",
    "keyInsight": "Map only the closing brackets allows clean logic: \"Is it a closer? Check stack. Else, it must be an opener.\"",
    "visualizationType": "array",
    "initialState": [
      "(",
      "{",
      "[",
      "]",
      "}",
      ")"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "String: \"({[]})\"",
        "transientMessage": "Use stack to match brackets",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Push '(' onto stack",
        "transientMessage": "Stack: [(]",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Push '{' onto stack",
        "transientMessage": "Stack: [(, {]",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Push '[' onto stack",
        "transientMessage": "Stack: [(, {, []",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Pop '[' for ']'",
        "transientMessage": "Match!",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Pop '{' for '}'",
        "transientMessage": "Match!",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Pop '(' for ')'",
        "transientMessage": "Match!",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Stack empty: true",
        "transientMessage": "Valid!",
        "arrayState": [
          "(",
          "{",
          "[",
          "]",
          "}",
          ")"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": "Simple pair of matching parentheses."
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "Multiple types of matching brackets."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched bracket types."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "hints": [
      "Use a stack to track opening brackets.",
      "When you see a closing bracket, check if it matches the top of the stack.",
      "At the end, the stack should be empty."
    ],
    "relatedProblems": [
      "generate-parentheses",
      "longest-valid-parentheses",
      "remove-invalid-parentheses"
    ],
    "videoId": "WTzjTskDFMg",
    "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize empty stack",
      "Iterate through elements",
      "Push/pop based on problem logic",
      "Maintain monotonic property if needed",
      "Process remaining stack elements if needed"
    ],
    "approach": "Stack: Push open brackets; pop and match close brackets.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def isValid(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def isValid_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
          "\ud83e\udde0 Stack tracks open brackets.",
          "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
        ],
        "code": "def isValid(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Last Opened must be First Closed (LIFO).\n    - \ud83e\udde0 Stack tracks open brackets.\n    - \ud83d\udca1 Mismatch or empty stack on close? Invalid.\n\n    Algorithm:\n    1. Open - Await closing.\n    2. Close - Verify pairing.\n    3. End - No unclosed brackets left.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    closeToOpen = {')': '(', ']': '[', '}': '{'}\n    for c in s:  # Iterate over elements.\n        if c in closeToOpen:\n            if stack and stack[-1] == closeToOpen[c]:\n                stack.pop()  # Remove and return last element.\n            else:\n                return False  # Condition not met.\n        else:\n            stack.append(c)  # Add to end.\n    return not stack"
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "    class Solution {\n    isValid(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    isValid(s) {\n        let stk = [];\n        for (const c of s) {\n            if (c == '(' || c == '{' || c == '[') {\n                stk.push(c);\n            } else if (stk.length == 0 || !match(stk[stk.length - 1], c)) {\n                return false;\n            } else {\n                stk.pop();\n            }\n        }\n        return stk.length == 0;\n    };\n\n    class Solution {\n        /**\n         * @param {any} l, r\n         * @return {any}\n         */\n        match(l, r) {\n        return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isValid(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean isValid(String s) {\n        Deque<Character> stk = new ArrayDeque<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '{' || c == '[') {\n                stk.push(c);\n            } else if (stk.isEmpty() || !match(stk.pop(), c)) {\n                return false;\n            }\n        }\n        return stk.isEmpty();\n    }\n\n    private boolean match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isValid(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        string stk;\n        for (char c : s) {\n            if (c == '(' || c == '{' || c == '[')\n                stk.push_back(c);\n            else if (stk.empty() || !match(stk.back(), c))\n                return false;\n            else\n                stk.pop_back();\n        }\n        return stk.empty();\n    }\n\n    bool match(char l, char r) {\n        return (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isValid(s string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isValid(s string) bool {\n\tstk := []rune{}\n\tfor _, c := range s {\n\t\tif c == '(' || c == '{' || c == '[' {\n\t\t\tstk = append(stk, c)\n\t\t} else if len(stk) == 0 || !match(stk[len(stk)-1], c) {\n\t\t\treturn false\n\t\t} else {\n\t\t\tstk = stk[:len(stk)-1]\n\t\t}\n\t}\n\treturn len(stk) == 0\n}\n\nfunc match(l, r rune) bool {\n\treturn (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}')\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_valid(s: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn is_valid(s: String) -> bool {\n        let mut map = HashMap::new();\n        map.insert('(', ')');\n        map.insert('[', ']');\n        map.insert('{', '}');\n        let mut stack = vec![];\n        for c in s.chars() {\n            if map.contains_key(&c) {\n                stack.push(map[&c]);\n            } else if stack.pop().unwrap_or(' ') != c {\n                return false;\n            }\n        }\n        stack.len() == 0\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isValid(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isValid(s: string): boolean {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    isValid(s: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "car-fleet",
      "title": "Car Fleet",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "maximum-subarray": {
    "title": "Maximum Subarray",
    "pattern": "Kadane's Algorithm",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Extend current sum OR start fresh - pick the better option!",
    "intuition": [
      "\ud83c\udfaf At each position: should I continue or restart?",
      "\ud83e\udde0 If current_sum < 0, better to start fresh!",
      "\ud83d\udca1 Track both current sum and overall maximum"
    ],
    "testCases": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Initialize",
        "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
        "explanation": "Start with first element as both"
      },
      {
        "step": 2,
        "title": "The Key Decision",
        "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         \u2191\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 \u2190 WINNER!",
        "explanation": "current_sum = max(num, current_sum + num)"
      },
      {
        "step": 3,
        "title": "Update Maximum",
        "visual": "current: 1 \u2192 -2 \u2192 4 \u2192 3 \u2192 5 \u2192 6 \u2192 1 \u2192 5\n                   \u2191           \u2191\n                 reset       max=6!",
        "explanation": "max_sum = max(max_sum, current_sum)"
      },
      {
        "step": 4,
        "title": "Result",
        "visual": "[4,-1,2,1] = 6 \u2705\n \u2191 max subarray",
        "explanation": "Return max_sum"
      }
    ],
    "code": "class Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf At each position: should I continue or restart?\n        - \ud83e\udde0 If current_sum < 0, better to start fresh!\n        - \ud83d\udca1 Track both current sum and overall maximum\n\n        Algorithm:\n        1. Initialize - Start with first element as both\n        2. The Key Decision - current_sum = max(num, current_sum + num)\n        3. Update Maximum - max_sum = max(max_sum, current_sum)\n        4. Result - Return max_sum\n        \"\"\"\n        current_sum = nums[0]\n        max_sum = nums[0]\n\n        for num in nums[1:]:  # Iterate over elements.\n            # Either extend current subarray or start new\n            current_sum = max(num, current_sum + num)  # Take the maximum value.\n            max_sum = max(max_sum, current_sum)  # Take the maximum value.\n\n        return max_sum",
    "keyInsight": "The magic: negative prefix sum is never worth keeping!",
    "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "Single element is the maximum."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The entire array has the largest sum."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "hints": [
      "Use Kadane's algorithm.",
      "At each position, decide: extend current subarray or start fresh.",
      "current_sum = max(nums[i], current_sum + nums[i])"
    ],
    "relatedProblems": [
      "maximum-product-subarray",
      "best-time-to-buy-and-sell-stock",
      "maximum-sum-circular-subarray"
    ],
    "videoId": "5WZl3MMT0Eg",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
        "transientMessage": "currentSum=-2, maxSum=-2",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "nums[1]=1: extend or start new?",
        "transientMessage": "currentSum=1, maxSum=1",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "nums[2]=-3: extend or start new?",
        "transientMessage": "currentSum=-2, maxSum=1",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "nums[3]=4: extend or start new?",
        "transientMessage": "currentSum=4, maxSum=4",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "nums[4]=-1: extend or start new?",
        "transientMessage": "currentSum=3, maxSum=4",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "nums[5]=2: extend or start new?",
        "transientMessage": "currentSum=5, maxSum=5",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "nums[6]=1: extend or start new?",
        "transientMessage": "currentSum=6, maxSum=6",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "nums[7]=-5: extend or start new?",
        "transientMessage": "currentSum=1, maxSum=6",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          7
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "nums[8]=4: extend or start new?",
        "transientMessage": "currentSum=5, maxSum=6",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 8
          }
        ],
        "indices": [
          8
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Maximum subarray sum: 6",
        "transientMessage": "Complete!",
        "arrayState": [
          -2,
          1,
          -3,
          4,
          -1,
          2,
          1,
          -5,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "array",
    "initialState": [
      -2,
      1,
      -3,
      4,
      -1,
      2,
      1,
      -5,
      4
    ],
    "approach": "Kadane's Algorithm: Extend current sum OR start fresh - pick the better option!",
    "mentalModel": "Like finding the sunniest part of the day. If the clouds (negative) get too heavy, you restart your streak.",
    "initialCode": "class Solution:\n    def maxSubArray(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxSubArray(nums):\n    max_sum = float('-inf')\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            if current_sum > max_sum:\n                max_sum = current_sum\n    return max_sum"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf At each position: should I continue or restart?",
          "\ud83e\udde0 If current_sum < 0, better to start fresh!",
          "\ud83d\udca1 Track both current sum and overall maximum"
        ],
        "code": "def maxSubArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf At each position: should I continue or restart?\n    - \ud83e\udde0 If current_sum < 0, better to start fresh!\n    - \ud83d\udca1 Track both current sum and overall maximum\n\n    Algorithm:\n    1. Initialize - Start with first element as both\n    2. The Key Decision - current_sum = max(num, current_sum + num)\n    3. Update Maximum - max_sum = max(max_sum, current_sum)\n    4. Result - Return max_sum\n    \"\"\"\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:  # Iterate over elements.\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)  # Take the maximum value.\n        max_sum = max(max_sum, current_sum)  # Take the maximum value.\n    \n    return max_sum"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxSubArray(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    maxSubArray(nums) {\n        let [ans, f] = [nums[0], nums[0]];\n        for (let i = 1; i < nums.length; ++i) {\n            f = Math.max(f, 0) + nums[i];\n            ans = Math.max(ans, f);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxSubArray(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int ans = nums[0];\n        for (int i = 1, f = nums[0]; i < nums.length; ++i) {\n            f = Math.max(f, 0) + nums[i];\n            ans = Math.max(ans, f);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxSubArray(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int ans = nums[0], f = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            f = max(f, 0) + nums[i];\n            ans = max(ans, f);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxSubArray(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxSubArray(nums []int) int {\n\tans, f := nums[0], nums[0]\n\tfor _, x := range nums[1:] {\n\t\tf = max(f, 0) + x\n\t\tans = max(ans, f)\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_sub_array(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut ans = nums[0];\n        let mut f = nums[0];\n        for i in 1..n {\n            f = f.max(0) + nums[i];\n            ans = ans.max(f);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxSubArray(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxSubArray(nums: number[]): number  {\n    let [ans, f] = [nums[0], nums[0]];\n    for (let i = 1; i < nums.length; ++i) {\n        f = Math.max(f, 0) + nums[i];\n        ans = Math.max(ans, f);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxSubArray(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    }
  },
  "climbing-stairs": {
    "title": "Climbing Stairs",
    "pattern": "DP (Fibonacci)",
    "patternEmoji": "\ud83e\uddb7",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)",
    "oneliner": "ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
    "intuition": [
      "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
      "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
      "\ud83d\udca1 Use two variables to store previous results."
    ],
    "testCases": [
      {
        "input": "n = 2",
        "output": "2"
      },
      {
        "input": "n = 3",
        "output": "3"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "one, two = 1, 1",
        "explanation": "Base cases."
      },
      {
        "step": 2,
        "title": "Loop",
        "visual": "temp=one. one=one+two. two=temp.",
        "explanation": "Shift."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "return one.",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.\n        - \ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).\n        - \ud83d\udca1 Use two variables to store previous results.\n\n        Algorithm:\n        1. Init - Base cases.\n        2. Loop - Shift.\n        3. Return - Result.\n        \"\"\"\n        one, two = 1, 1\n        for i in range(n - 1):  # Iterate through the range.\n            temp = one\n            one = one + two\n            two = temp\n        return one",
    "keyInsight": "Notice the subproblem structure overlap. Memorization or Iterative DP solves it efficiently.",
    "visualizationType": "array",
    "initialState": [
      1,
      1,
      0,
      0,
      0,
      0
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "n = 5, ways to climb stairs",
        "transientMessage": "dp[0] = 1, dp[1] = 1 (base cases)",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "dp[2] = dp[1] + dp[0] = 1 + 1",
        "transientMessage": "dp[2] = 2",
        "arrayState": [
          1,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "dp[3] = dp[2] + dp[1] = 2 + 1",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          1,
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          1,
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "dp[4] = dp[3] + dp[2] = 3 + 2",
        "transientMessage": "dp[4] = 5",
        "arrayState": [
          1,
          1,
          2,
          3,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          2,
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "dp[5] = dp[4] + dp[3] = 5 + 3",
        "transientMessage": "dp[5] = 8",
        "arrayState": [
          1,
          1,
          2,
          3,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          3,
          4,
          5
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Result: 8 ways",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          1,
          2,
          3,
          5,
          8
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      }
    ],
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "Two ways: (1+1) or (2)."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "Three ways: (1+1+1), (1+2), (2+1)."
      }
    ],
    "constraints": [
      "1 <= n <= 45"
    ],
    "hints": [
      "This is a classic dynamic programming problem.",
      "The number of ways to reach step n = ways to reach (n-1) + ways to reach (n-2).",
      "This is essentially the Fibonacci sequence!"
    ],
    "relatedProblems": [
      "min-cost-climbing-stairs",
      "house-robber",
      "fibonacci-number"
    ],
    "videoId": "Y0lT9Fck7qI",
    "problemStatement": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DP (Fibonacci): ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
    "suggestedNextQuestion": {
      "slug": "min-cost-climbing-stairs",
      "title": "Min Cost Climbing Stairs",
      "difficulty": "Easy",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like a Fibonacci sequence. Step N depends on N-1 and N-2.",
    "initialCode": "class Solution:\n    def climbStairs(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def climbStairs(n):\n    if n <= 2: return n\n    return climbStairs(n - 1) + climbStairs(n - 2)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
          "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
          "\ud83d\udca1 Use two variables to store previous results."
        ],
        "code": "def climbStairs(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.\n    - \ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).\n    - \ud83d\udca1 Use two variables to store previous results.\n\n    Algorithm:\n    1. Init - Base cases.\n    2. Loop - Shift.\n    3. Return - Result.\n    \"\"\"\n    one, two = 1, 1\n    for i in range(n - 1):  # Iterate through the range.\n        temp = one\n        one = one + two\n        two = temp\n    return one"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    climbStairs(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    climbStairs(n) {\n        let a = 0,\n            b = 1;\n        for (let i = 0; i < n; ++i) {\n            const c = a + b;\n            a = b;\n            b = c;\n    }\n    return b;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int climbStairs(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int climbStairs(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int climbStairs(int n) {\n        int a = 0, b = 1;\n        for (int i = 0; i < n; ++i) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) climbStairs(n int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) climbStairs(n int) int {\n\ta, b := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\ta, b = b, a+b\n\t}\n\treturn b\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn climb_stairs(n: i32) -> i32 {\n        let (mut p, mut q) = (1, 1);\n        for i in 1..n {\n            let t = p + q;\n            p = q;\n            q = t;\n        }\n        q\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def climbStairs(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    climbStairs(n: number): number  {\n    let p = 1;\n    let q = 1;\n    for (let i = 1; i < n; i++) {\n        [p, q] = [q, p + q];\n    }\n    return q;\n}\n}",
        "initialCode": "class Solution {\n    climbStairs(n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "linked-list-cycle": {
    "title": "Linked List Cycle",
    "pattern": "Fast & Slow Pointers",
    "patternEmoji": "\ud83d\udc07\ud83d\udc22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
    "intuition": [
      "\ud83c\udfaf Floyd's Tortoise and Hare.",
      "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
      "\ud83d\udca1 If Fast reaches null, no cycle."
    ],
    "testCases": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true"
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true"
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Run",
        "visual": "Slow=Head, Fast=Head. Loop.",
        "explanation": "Start race."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "Slow == Fast? Return True.",
        "explanation": "Collision!"
      },
      {
        "step": 3,
        "title": "End",
        "visual": "Fast is None? Return False.",
        "explanation": "Reached end."
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, x):\n    #         self.val = x\n    #         self.next = None\n    \n    def hasCycle(self, head):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Floyd's Tortoise and Hare.\n        - \ud83e\udde0 If cycle exists, Fast will eventually lap Slow.\n        - \ud83d\udca1 If Fast reaches null, no cycle.\n    \n        Algorithm:\n        1. Run - Start race.\n        2. Check - Collision!\n        3. End - Reached end.\n        \"\"\"\n        slow, fast = head, head  # Initialize slow and fast pointers.\n        while fast and fast.next:  # Traverse until end of list.\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True  # Condition satisfied.\n        return False  # Condition not met.",
    "keyInsight": "Fast pointer MUST check `fast.next` before jumping two steps to avoid AttributeError.",
    "visualizationType": "linkedlist",
    "initialState": [
      3,
      2,
      0,
      -4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "3 \u2192 2 \u2192 0 \u2192 -4 \u21a9 (cycle to 2)",
        "transientMessage": "slow=3, fast=3 (both at head)",
        "arrayState": [
          3,
          2,
          0,
          -4
        ],
        "pointers": [
          {
            "label": "slow",
            "index": 0
          },
          {
            "label": "fast",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Move: slow+1, fast+2",
        "transientMessage": "slow=2, fast=0",
        "arrayState": [
          3,
          2,
          0,
          -4
        ],
        "pointers": [
          {
            "label": "slow",
            "index": 1
          },
          {
            "label": "fast",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Move: slow+1, fast+2",
        "transientMessage": "slow=0, fast=2 (in cycle)",
        "arrayState": [
          3,
          2,
          0,
          -4
        ],
        "pointers": [
          {
            "label": "slow",
            "index": 2
          },
          {
            "label": "fast",
            "index": 1
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "slow catches up to fast!",
        "transientMessage": "They meet at node with value 2 \u2192 Cycle detected! \ud83c\udfaf",
        "arrayState": [
          3,
          2,
          0,
          -4
        ],
        "pointers": [
          {
            "label": "meet!",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Result: true",
        "transientMessage": "Cycle exists (Floyd's algorithm) \u2705",
        "arrayState": [
          3,
          2,
          0,
          -4
        ],
        "pointers": [],
        "indices": [
          1,
          2,
          3
        ],
        "color": "success"
      }
    ],
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "examples": [
      {
        "input": "head = [3,2,0,-4], pos = 1",
        "output": "true",
        "explanation": "There is a cycle where the tail connects to node at index 1."
      },
      {
        "input": "head = [1,2], pos = 0",
        "output": "true",
        "explanation": "Tail connects to node at index 0."
      },
      {
        "input": "head = [1], pos = -1",
        "output": "false",
        "explanation": "No cycle in the list."
      }
    ],
    "constraints": [
      "The number of nodes is in range [0, 10^4]",
      "-10^5 <= Node.val <= 10^5",
      "pos is -1 or a valid index."
    ],
    "hints": [
      "Use Floyd's Cycle Detection (Tortoise and Hare).",
      "Have a slow pointer move by 1 and fast pointer move by 2.",
      "If they meet, there's a cycle."
    ],
    "relatedProblems": [
      "linked-list-cycle-ii",
      "happy-number",
      "find-the-duplicate-number"
    ],
    "videoId": "gBTe7lFR3vc",
    "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Fast & Slow Pointers: Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
    "suggestedNextQuestion": {
      "slug": "merge-two-sorted-lists",
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like using your fingers to track two different positions in a book at once.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def hasCycle(head):\n    seen = set()\n    curr = head\n    while curr:\n        if curr in seen:\n            return True\n        seen.add(curr)\n        curr = curr.next\n    return False"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Floyd's Tortoise and Hare.",
          "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
          "\ud83d\udca1 If Fast reaches null, no cycle."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Floyd's Tortoise and Hare.\n    - \ud83e\udde0 If cycle exists, Fast will eventually lap Slow.\n    - \ud83d\udca1 If Fast reaches null, no cycle.\n\n    Algorithm:\n    1. Run - Start race.\n    2. Check - Collision!\n    3. End - Reached end.\n    \"\"\"\n    slow, fast = head, head  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True  # Condition satisfied.\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__(ListNode head) {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__(ListNode* head) {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) hasCycle(head *ListNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) hasCycle(head *ListNode) bool {\n\ts := map[*ListNode]bool{}\n\tfor ; head != nil; head = head.Next {\n\t\tif s[head] {\n\t\t\treturn true\n\t\t}\n\t\ts[head] = true\n\t}\n\treturn false\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn has_cycle(head: Option<Box<ListNode>>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn has_cycle(head: Option<Box<ListNode>>) -> bool {\n        // Rust specific: This usually requires unsafe or Rc/RefCell depending on definition.\n        // Assuming standard LeetCode Rust definition for singly-linked list which is Option<Box<ListNode>>.\n        // But cycle detection usually implies raw pointers or Rc.\n        // For visualizer purposes, we provide a standard iterative approach mock or strict logic.\n        false // Placeholder for complex linked list design in Rust\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "binary-search": {
    "title": "Binary Search",
    "pattern": "Divide & Conquer",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Half the search space each time by checking the middle!",
    "intuition": [
      "\ud83c\udfaf Array is SORTED - exploit this!",
      "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
      "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
    ],
    "testCases": [
      {
        "input": "nums = [-1,0,3,5,9,12], target = 9",
        "output": "4"
      },
      {
        "input": "nums = [-1,0,3,5,9,12], target = 2",
        "output": "-1"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Set Boundaries",
        "visual": "[1, 3, 5, 7, 9, 11, 13]\n \u2191                    \u2191\nleft                right",
        "explanation": "Start with full array range"
      },
      {
        "step": 2,
        "title": "Find Middle",
        "visual": "[1, 3, 5, 7, 9, 11, 13]\n          \u2191\n         mid (index 3, value 7)",
        "explanation": "mid = (left + right) // 2"
      },
      {
        "step": 3,
        "title": "Compare & Narrow",
        "visual": "target = 11\n7 < 11 \u2192 search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             \u2191       \u2191\n           left    right",
        "explanation": "Eliminate half the options!"
      },
      {
        "step": 4,
        "title": "Repeat Until Found",
        "visual": "mid = 11 \u2705 FOUND!\nOR left > right = Not found",
        "explanation": "Continue halving until match or exhausted"
      }
    ],
    "code": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Array is SORTED - exploit this!\n        - \ud83e\udde0 Check middle: too big? go left. Too small? go right.\n        - \ud83d\udca1 Halving = log\u2082(n) steps maximum\n\n        Algorithm:\n        1. Set Boundaries - Start with full array range\n        2. Find Middle - mid = (left + right) // 2\n        3. Compare & Narrow - Eliminate half the options!\n        4. Repeat Until Found - Continue halving until match or exhausted\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1   # search right\n            else:\n                right = mid - 1  # search left\n\n        return -1",
    "keyInsight": "Each step eliminates HALF - that's why it's O(log n)!",
    "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [-1,0,3,5,9,12], target = 9",
        "output": "4",
        "explanation": "9 exists in nums and its index is 4."
      },
      {
        "input": "nums = [-1,0,3,5,9,12], target = 2",
        "output": "-1",
        "explanation": "2 does not exist in nums."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 < nums[i], target < 10^4",
      "All the integers in nums are unique.",
      "nums is sorted in ascending order."
    ],
    "hints": [
      "Use two pointers: left and right.",
      "Calculate mid = (left + right) // 2.",
      "Compare nums[mid] with target and narrow the search range."
    ],
    "relatedProblems": [
      "search-insert-position",
      "search-in-rotated-sorted-array",
      "find-first-and-last-position-of-element-in-sorted-array"
    ],
    "videoId": "s4DPM8ct1pI",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Search for 9 in [-1, 0, 3, 5, 9, 12]",
        "transientMessage": "Initialize left=0, right=5",
        "arrayState": [
          -1,
          0,
          3,
          5,
          9,
          12
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          5
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "mid = (0 + 5) / 2 = 2",
        "transientMessage": "Check arr[2] = 3",
        "arrayState": [
          -1,
          0,
          3,
          5,
          9,
          12
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "M",
            "index": 2
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "3 < 9",
        "transientMessage": "Target is in right half, move left",
        "arrayState": [
          -1,
          0,
          3,
          5,
          9,
          12
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          3,
          5
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "mid = (3 + 5) / 2 = 4",
        "transientMessage": "Check arr[4] = 9",
        "arrayState": [
          -1,
          0,
          3,
          5,
          9,
          12
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "M",
            "index": 4
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "arr[4] = 9 \u2713",
        "transientMessage": "Found target at index 4!",
        "arrayState": [
          -1,
          0,
          3,
          5,
          9,
          12
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      }
    ],
    "problemStatement": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "array",
    "initialState": [
      -1,
      0,
      3,
      5,
      9,
      12
    ],
    "approach": "Divide & Conquer: Half the search space each time by checking the middle!",
    "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
    "initialCode": "class Solution:\n    def search(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def search(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Array is SORTED - exploit this!",
          "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
          "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
        ],
        "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Array is SORTED - exploit this!\n    - \ud83e\udde0 Check middle: too big? go left. Too small? go right.\n    - \ud83d\udca1 Halving = log\u2082(n) steps maximum\n\n    Algorithm:\n    1. Set Boundaries - Start with full array range\n    2. Find Middle - mid = (left + right) // 2\n    3. Compare & Narrow - Eliminate half the options!\n    4. Repeat Until Found - Continue halving until match or exhausted\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    search(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    search(nums, target) {\n        let [l, r] = [0, nums.length - 1];\n        while (l < r) {\n            const mid = (l + r) >> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n    }\n    return nums[l] === target ? l : -1;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int search(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return nums[l] == target ? l : -1;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int search(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return nums[l] == target ? l : -1;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) search(nums []int, target int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) search(nums []int, target int) int {\n\tl, r := 0, len(nums)-1\n\tfor l < r {\n\t\tmid := (l + r) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tr = mid\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\tif nums[l] == target {\n\t\treturn l\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        let mut l: usize = 0;\n        let mut r: usize = nums.len() - 1;\n        while l < r {\n            let mid = (l + r) >> 1;\n            if nums[mid] >= target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if nums[l] == target {\n            l as i32\n        } else {\n            -1\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def search(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    search(nums: number[], target: number): number  {\n    let [l, r] = [0, nums.length - 1];\n    while (l < r) {\n        const mid = (l + r) >> 1;\n        if (nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return nums[l] === target ? l : -1;\n}\n}",
        "initialCode": "class Solution {\n    search(nums: number[], target: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    }
  },
  "number-of-islands": {
    "title": "Number of Islands",
    "pattern": "Matrix DFS / BFS",
    "patternEmoji": "\ud83c\udfdd\ufe0f",
    "timeComplexity": "O(M*N)",
    "spaceComplexity": "O(M*N)",
    "oneliner": "Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
    "intuition": [
      "\ud83c\udfaf '1' is land. Connected '1's form one island.",
      "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
      "\ud83d\udca1 Flood fill."
    ],
    "testCases": [
      {
        "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
        "output": "1"
      },
      {
        "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
        "output": "3"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Scan",
        "visual": "Find '1' at (r, c). Count++.",
        "explanation": "Discovery."
      },
      {
        "step": 2,
        "title": "Sink",
        "visual": "DFS(r, c). Turn '1' to '0'. Recurse 4 dirs.",
        "explanation": "Erase."
      },
      {
        "step": 3,
        "title": "Repeat",
        "visual": "Continue scan till end.",
        "explanation": "Completion."
      }
    ],
    "code": "class Solution:\n    def numIslands(self, grid):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf '1' is land. Connected '1's form one island.\n        - \ud83e\udde0 When we find an island, destroy it so we don't count it again.\n        - \ud83d\udca1 Flood fill.\n\n        Algorithm:\n        1. Scan - Discovery.\n        2. Sink - Erase.\n        3. Repeat - Completion.\n        \"\"\"\n        if not grid: return 0\n        rows, cols = len(grid), len(grid[0])\n        visit = set()\n        islands = 0\n\n        def bfs(r, c):\n            q = []\n            q.append((r, c))  # Add to end.\n            visit.add((r,c))\n            while q:\n                row, col = q.pop(0)  # Remove and return last element.\n                directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n                for dr, dc in directions:  # Iterate over elements.\n                    r, c = row + dr, col + dc\n                    if (r in range(rows) and c in range(cols) and\n                        grid[r][c] == \"1\" and (r, c) not in visit):\n                        q.append((r, c))  # Add to end.\n                        visit.add((r, c))\n\n        for r in range(rows):  # Iterate through the range.\n            for c in range(cols):  # Iterate through the range.\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    bfs(r, c)\n                    islands += 1\n        return islands",
    "keyInsight": "You can modify the grid in-place (change '1' to '0') to save O(MN) space for the visited set.",
    "visualizationType": "grid",
    "initialState": [
      [
        "1",
        "1",
        "0"
      ],
      [
        "1",
        "1",
        "0"
      ],
      [
        "0",
        "0",
        "1"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Number of Islands",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "1",
            "1",
            "0"
          ],
          [
            "1",
            "1",
            "0"
          ],
          [
            "0",
            "0",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
      {
        "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
        "output": "1",
        "explanation": "One connected land mass."
      },
      {
        "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "output": "3",
        "explanation": "Three separate islands."
      }
    ],
    "constraints": [
      "m == grid.length",
      "n == grid[i].length",
      "1 <= m, n <= 300",
      "grid[i][j] is '0' or '1'."
    ],
    "hints": [
      "Use DFS or BFS to explore connected land.",
      "When you find a '1', increment count and mark all connected land as visited.",
      "Continue scanning the grid."
    ],
    "relatedProblems": [
      "surrounded-regions",
      "max-area-of-island",
      "number-of-enclaves"
    ],
    "videoId": "pV2kpPD66nE",
    "problemStatement": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Matrix DFS / BFS: Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
    "suggestedNextQuestion": {
      "slug": "pacific-atlantic-water-flow",
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def numIslands(self, grid):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def numIslands(grid):\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    count = 0\n    \n    def bfs(r, c):\n        q = [((r, c))]\n        while q:\n            row, col = q.pop(0)\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = row + dr, col + dc\n                if (0 <= nr < rows and 0 <= nc < cols and\n                    grid[nr][nc] == \"1\" and (nr, nc) not in visited):\n                    visited.add((nr, nc))\n                    q.append((nr, nc))\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\" and (r, c) not in visited:\n                count += 1\n                visited.add((r, c))\n                bfs(r, c)\n    return count"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(M*N)",
        "spaceComplexity": "O(M*N)",
        "intuition": [
          "\ud83c\udfaf '1' is land. Connected '1's form one island.",
          "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
          "\ud83d\udca1 Flood fill."
        ],
        "code": "def numIslands(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf '1' is land. Connected '1's form one island.\n    - \ud83e\udde0 When we find an island, destroy it so we don't count it again.\n    - \ud83d\udca1 Flood fill.\n\n    Algorithm:\n    1. Scan - Discovery.\n    2. Sink - Erase.\n    3. Repeat - Completion.\n    \"\"\"\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    islands = 0\n    \n    def bfs(r, c):\n        q = []\n        q.append((r, c))  # Add to end.\n        visit.add((r,c))\n        while q:\n            row, col = q.pop(0)  # Remove and return last element.\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:  # Iterate over elements.\n                r, c = row + dr, col + dc\n                if (r in range(rows) and c in range(cols) and\n                    grid[r][c] == \"1\" and (r, c) not in visit):\n                    q.append((r, c))  # Add to end.\n                    visit.add((r, c))\n\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == \"1\" and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1\n    return islands"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    numIslands(grid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} grid\n     * @return {any}\n     */\n    numIslands(grid) {\n        let count = 0;\n\n        for (let i = 0; i < grid.length; i++) {\n          for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === '1') {\n              count++;\n              dfs(i, j);\n            }\n          }\n        }\n\n        class Solution {\n          /**\n           * @param {any} i, j\n           * @return {any}\n           */\n          dfs(i, j) {\n          if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] === '0') {\n            return;\n          }\n\n          grid[i][j] = '0';\n\n          dfs(i + 1, j);\n          dfs(i - 1, j);\n          dfs(i, j + 1);\n          dfs(i, j - 1);\n      }\n\n    return count;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int numIslands(char[][] grid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private char[][] grid;\n    private int m;\n    private int n;\n\n    public int numIslands(char[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        this.grid = grid;\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n\n    private void dfs(int i, int j) {\n        grid[i][j] = '0';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k];\n            int y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1') {\n                dfs(x, y);\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int numIslands(vector<vector<char>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        int ans = 0;\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        auto dfs = [&](this auto&& dfs, int i, int j) -> void {\n            grid[i][j] = '0';\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == '1') {\n                    dfs(x, y);\n                }\n            }\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(i, j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) numIslands(grid [][]byte) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) numIslands(grid [][]byte) int {\n\tm, n := len(grid), len(grid[0])\n\tvar dfs func(i, j int)\n\tdfs = func(i, j int) {\n\t\tgrid[i][j] = '0'\n\t\tdirs := []int{-1, 0, 1, 0, -1}\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tx, y := i+dirs[k], j+dirs[k+1]\n\t\t\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == '1' {\n\t\t\t\tdfs(x, y)\n\t\t\t}\n\t\t}\n\t}\n\tans := 0\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif grid[i][j] == '1' {\n\t\t\t\tdfs(i, j)\n\t\t\t\tans++\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "const DIRS: [i32; 5] = [-1, 0, 1, 0, -1];\n\nimpl Solution {\n    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {\n        fn dfs(grid: &mut Vec<Vec<char>>, i: usize, j: usize) {\n            grid[i][j] = '0';\n            for k in 0..4 {\n                let x = (i as i32) + DIRS[k];\n                let y = (j as i32) + DIRS[k + 1];\n                if x >= 0\n                    && (x as usize) < grid.len()\n                    && y >= 0\n                    && (y as usize) < grid[0].len()\n                    && grid[x as usize][y as usize] == '1'\n                {\n                    dfs(grid, x as usize, y as usize);\n                }\n            }\n        }\n\n        let mut grid = grid;\n        let mut ans = 0;\n        for i in 0..grid.len() {\n            for j in 0..grid[0].len() {\n                if grid[i][j] == '1' {\n                    dfs(&mut grid, i, j);\n                    ans += 1;\n                }\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def numIslands(self, grid):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    numIslands(grid: string[][]): number  {\n    const m = grid.length;\n    const n = grid[0].length;\n    let ans = 0;\n    const dirs = [-1, 0, 1, 0, -1];\n\n    const dfs = (i: number, j: number) => {\n        grid[i][j] = '0';\n        for (let k = 0; k < 4; ++k) {\n            const x = i + dirs[k];\n            const y = j + dirs[k + 1];\n            if (grid[x]?.[y] === '1') {\n                dfs(x, y);\n            }\n        }\n    };\n\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] === '1') {\n                dfs(i, j);\n                ans++;\n            }\n        }\n    }\n\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    numIslands(grid: string[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "reverse-linked-list": {
    "title": "Reverse Linked List",
    "pattern": "Iterative Pointer Swap",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Change each node's pointer to point backwards!",
    "intuition": [
      "\ud83c\udfaf Each node.next should point to previous node",
      "\ud83e\udde0 Need to save 'next' before changing pointer",
      "\ud83d\udca1 Use 3 pointers: prev, current, next"
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]"
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]"
      },
      {
        "input": "head = []",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Initialize",
        "visual": "None \u2190 1 \u2192 2 \u2192 3 \u2192 None\n \u2191    \u2191\nprev  curr",
        "explanation": "prev starts at None (new tail)"
      },
      {
        "step": 2,
        "title": "Save Next",
        "visual": "1 \u2192 2 \u2192 3\n    \u2191\n   next_node (save before we lose it!)",
        "explanation": "Must save before changing pointer"
      },
      {
        "step": 3,
        "title": "Reverse Pointer",
        "visual": "None \u2190 1   2 \u2192 3\n \u2191    \u2191   \u2191\nprev curr next",
        "explanation": "curr.next = prev"
      },
      {
        "step": 4,
        "title": "Move Forward",
        "visual": "None \u2190 1 \u2190 2 \u2190 3\n               \u2191\n              prev (new head!)",
        "explanation": "Shift all pointers right, repeat"
      }
    ],
    "code": "class Solution:\n    def reverseList(self, head):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Each node.next should point to previous node\n        - \ud83e\udde0 Need to save 'next' before changing pointer\n        - \ud83d\udca1 Use 3 pointers: prev, current, next\n\n        Algorithm:\n        1. Initialize - prev starts at None (new tail)\n        2. Save Next - Must save before changing pointer\n        3. Reverse Pointer - curr.next = prev\n        4. Move Forward - Shift all pointers right, repeat\n        \"\"\"\n        prev = None\n        curr = head\n\n        while curr:\n            next_node = curr.next  # save next\n            curr.next = prev       # reverse pointer\n            prev = curr            # move prev forward\n            curr = next_node       # move curr forward\n\n        return prev  # prev is new head",
    "keyInsight": "Three-pointer technique is fundamental for linked list operations!",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The list is reversed."
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": "Two-element list reversed."
      },
      {
        "input": "head = []",
        "output": "[]",
        "explanation": "Empty list remains empty."
      }
    ],
    "constraints": [
      "The number of nodes in the list is the range [0, 5000].",
      "-5000 <= Node.val <= 5000"
    ],
    "hints": [
      "Use three pointers: prev, curr, next.",
      "At each step, reverse curr's pointer to prev.",
      "Move all pointers one step forward."
    ],
    "relatedProblems": [
      "reverse-linked-list-ii",
      "palindrome-linked-list",
      "reverse-nodes-in-k-group"
    ],
    "videoId": "G0_I-ZF0S38",
    "animationSteps": [
      {
        "step": 1,
        "visual": "1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 null",
        "transientMessage": "prev=null, curr=head(1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": -1
          },
          {
            "label": "curr",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Save next: next = 2",
        "transientMessage": "Reverse link: 1.next = null (prev)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": -1
          },
          {
            "label": "curr",
            "index": 0
          },
          {
            "label": "next",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "null \u2190 1    2 \u2192 3 \u2192 4 \u2192 5",
        "transientMessage": "Move: prev=1, curr=2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": 0
          },
          {
            "label": "curr",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "null \u2190 1 \u2190 2    3 \u2192 4 \u2192 5",
        "transientMessage": "Reverse link: 2.next = 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": 1
          },
          {
            "label": "curr",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "null \u2190 1 \u2190 2 \u2190 3    4 \u2192 5",
        "transientMessage": "Reverse link: 3.next = 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": 2
          },
          {
            "label": "curr",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "null \u2190 1 \u2190 2 \u2190 3 \u2190 4    5",
        "transientMessage": "Reverse link: 4.next = 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "prev",
            "index": 3
          },
          {
            "label": "curr",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "null \u2190 1 \u2190 2 \u2190 3 \u2190 4 \u2190 5",
        "transientMessage": "Reverse link: 5.next = 4, curr=null (done!)",
        "arrayState": [
          5,
          4,
          3,
          2,
          1
        ],
        "pointers": [
          {
            "label": "prev",
            "index": 0
          }
        ],
        "indices": [
          0,
          1,
          2,
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "5 \u2192 4 \u2192 3 \u2192 2 \u2192 1 \u2192 null",
        "transientMessage": "Return prev (new head = 5) \u2705",
        "arrayState": [
          5,
          4,
          3,
          2,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3,
          4
        ],
        "color": "success"
      }
    ],
    "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "approach": "Iterative Pointer Swap: Change each node's pointer to point backwards!",
    "mentalModel": "Like using your fingers to track two different positions in a book at once.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseList(self, head):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def reverseList(head):\n    # Convert to list, reverse, rebuild\n    if not head: return None\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    \n    vals.reverse()\n    dummy = ListNode(0)\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Each node.next should point to previous node",
          "\ud83e\udde0 Need to save 'next' before changing pointer",
          "\ud83d\udca1 Use 3 pointers: prev, current, next"
        ],
        "code": "def reverseList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node.next should point to previous node\n    - \ud83e\udde0 Need to save 'next' before changing pointer\n    - \ud83d\udca1 Use 3 pointers: prev, current, next\n\n    Algorithm:\n    1. Initialize - prev starts at None (new tail)\n    2. Save Next - Must save before changing pointer\n    3. Reverse Pointer - curr.next = prev\n    4. Move Forward - Shift all pointers right, repeat\n    \"\"\"\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode __init__(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode __init__(ListNode head) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* __init__(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* __init__(ListNode* head) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverseList(head *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) reverseList(head *ListNode) *ListNode {\n\tdummy := &ListNode{}\n\tcurr := head\n\tfor curr != nil {\n\t\tnext := curr.Next\n\t\tcurr.Next = dummy.Next\n\t\tdummy.Next = curr\n\t\tcurr = next\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut head = head;\n        let mut pre = None;\n        while let Some(mut node) = head {\n            head = node.next.take();\n            node.next = pre.take();\n            pre = Some(node);\n        }\n        pre\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseList(self, head):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null): ListNode | null {\n        return head;\n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null): ListNode | null {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "binary-search",
      "title": "Binary Search",
      "difficulty": "Easy",
      "pattern": "Divide & Conquer"
    }
  },
  "contains-duplicate": {
    "title": "Contains Duplicate",
    "pattern": "Hash Set",
    "patternEmoji": "\ud83d\udc6f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Add to set; if exists, return True.",
    "intuition": [
      "\ud83c\udfaf Any number appearing twice?",
      "\ud83e\udde0 Set stores unique elements.",
      "\ud83d\udca1 Check membership before adding."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false"
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Scan",
        "visual": "Iterate numbers.",
        "explanation": "Standard pass."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "In set? True.",
        "explanation": "Collision."
      },
      {
        "step": 3,
        "title": "Add",
        "visual": "Add to set.",
        "explanation": "Track seen."
      }
    ],
    "code": "class Solution:\n    def containsDuplicate(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Any number appearing twice?\n        - \ud83e\udde0 Set stores unique elements.\n        - \ud83d\udca1 Check membership before adding.\n\n        Algorithm:\n        1. Scan - Standard pass.\n        2. Check - Collision.\n        3. Add - Track seen.\n        \"\"\"\n        seen = set()  # Keep track of visited elements.\n        for n in nums:  # Iterate over elements.\n            if n in seen: return True  # Check if already visited.\n            seen.add(n)\n        return False  # Condition not met.",
    "keyInsight": "HashSet provides immediate collision detection.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [1, 2, 3, 1]",
        "transientMessage": "Check for duplicates using HashSet",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Add 1 to set",
        "transientMessage": "Set: {1}",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Add 2 to set",
        "transientMessage": "Set: {1, 2}",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Add 3 to set",
        "transientMessage": "Set: {1, 2, 3}",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "nums[3]=1 already in set!",
        "transientMessage": "Duplicate found! Return true",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "!",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": "1 appears twice."
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": "All elements are distinct."
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true",
        "explanation": "Multiple duplicates exist."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Use a hash set to track seen numbers.",
      "If you see a number already in the set, return true.",
      "Alternatively, sort the array and check adjacent elements."
    ],
    "relatedProblems": [
      "contains-duplicate-ii",
      "contains-duplicate-iii",
      "find-the-duplicate-number"
    ],
    "videoId": "3OamzN90kPg",
    "problemStatement": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Set: Add to set; if exists, return True.",
    "suggestedNextQuestion": {
      "slug": "copy-list-with-random-pointer",
      "title": "Copy List with Random Pointer",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def containsDuplicate(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def containsDuplicate(nums):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return True\n    return False"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Any number appearing twice?",
          "\ud83e\udde0 Set stores unique elements.",
          "\ud83d\udca1 Check membership before adding."
        ],
        "code": "def containsDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Any number appearing twice?\n    - \ud83e\udde0 Set stores unique elements.\n    - \ud83d\udca1 Check membership before adding.\n\n    Algorithm:\n    1. Scan - Standard pass.\n    2. Check - Collision.\n    3. Add - Track seen.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    for n in nums:  # Iterate over elements.\n        if n in seen: return True  # Check if already visited.\n        seen.add(n)\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    containsDuplicate(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    containsDuplicate(nums) {\n        return new Set(nums).size !== nums.length;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 1; ++i) {\n            if (nums[i] == nums[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool containsDuplicate(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            if (nums[i] == nums[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) containsDuplicate(nums []int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) containsDuplicate(nums []int) bool {\n\tsort.Ints(nums)\n\tfor i, v := range nums[1:] {\n\t\tif v == nums[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn contains_duplicate(mut nums: Vec<i32>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn contains_duplicate(mut nums: Vec<i32>) -> bool {\n        nums.sort();\n        let n = nums.len();\n        for i in 1..n {\n            if nums[i - 1] == nums[i] {\n                return true;\n            }\n        }\n        false\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def containsDuplicate(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    containsDuplicate(nums: number[]): boolean  {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    for (let i = 1; i < n; i++) {\n        if (nums[i - 1] === nums[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n}",
        "initialCode": "class Solution {\n    containsDuplicate(nums: number[]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "invert-binary-tree": {
    "title": "Invert Binary Tree",
    "pattern": "DFS (Recursion)",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Swap left and right children, then recurse.",
    "intuition": [
      "\ud83c\udfaf Mirror image.",
      "\ud83e\udde0 For every node, left becomes right.",
      "\ud83d\udca1 Post-order or Pre-order traversal works fine."
    ],
    "testCases": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]"
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,3,1]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Swap",
        "visual": "root.left, root.right = root.right, root.left.",
        "explanation": "Action."
      },
      {
        "step": 2,
        "title": "Recurse",
        "visual": "invert(left), invert(right).",
        "explanation": "Propagate."
      },
      {
        "step": 3,
        "title": "Base",
        "visual": "If null, return null.",
        "explanation": "Stop."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def invertTree(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Mirror image.\n        - \ud83e\udde0 For every node, left becomes right.\n        - \ud83d\udca1 Post-order or Pre-order traversal works fine.\n    \n        Algorithm:\n        1. Swap - Action.\n        2. Recurse - Propagate.\n        3. Base - Stop.\n        \"\"\"\n        if not root: return None  # Base case: Check if tree is empty.\n        root.left, root.right = root.right, root.left\n        invertTree(root.left)\n        invertTree(root.right)\n        return root",
    "keyInsight": "Max Howell famously got rejected by Google for not solving this on a whiteboard.",
    "visualizationType": "tree",
    "initialState": [
      4,
      2,
      7,
      1,
      3,
      6,
      9
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "    4\n   / \\\n  2   7\n / \\ / \\\n1  3 6  9",
        "transientMessage": "Recursively swap left and right children",
        "arrayState": [
          4,
          2,
          7,
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "At node 4: swap children",
        "transientMessage": "4.left \u2194 4.right \u2192 2 \u2194 7",
        "arrayState": [
          4,
          7,
          2,
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "swap",
            "index": 0
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "At node 7 (now left): swap children",
        "transientMessage": "7.left \u2194 7.right \u2192 6 \u2194 9",
        "arrayState": [
          4,
          7,
          2,
          9,
          6,
          3,
          1
        ],
        "pointers": [
          {
            "label": "swap",
            "index": 1
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "At node 2 (now right): swap children",
        "transientMessage": "2.left \u2194 2.right \u2192 1 \u2194 3",
        "arrayState": [
          4,
          7,
          2,
          9,
          6,
          3,
          1
        ],
        "pointers": [
          {
            "label": "swap",
            "index": 2
          }
        ],
        "indices": [
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "    4\n   / \\\n  7   2\n / \\ / \\\n9  6 3  1",
        "transientMessage": "Tree inverted! \u2705",
        "arrayState": [
          4,
          7,
          2,
          9,
          6,
          3,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "color": "success"
      }
    ],
    "description": "Given the root of a binary tree, invert the tree, and return its root.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]",
        "explanation": "Mirror the tree."
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,3,1]",
        "explanation": "Swap children."
      }
    ],
    "constraints": [
      "The number of nodes is in range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "Recursively swap left and right children.",
      "Base case: null node returns null.",
      "DFS or BFS both work."
    ],
    "relatedProblems": [
      "same-tree",
      "symmetric-tree"
    ],
    "videoId": "OnSn2XEQ4MY",
    "problemStatement": "Given the root of a binary tree, invert the tree, and return its root.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS (Recursion): Swap left and right children, then recurse.",
    "suggestedNextQuestion": {
      "slug": "maximum-depth-of-binary-tree",
      "title": "Maximum Depth of Binary Tree",
      "difficulty": "Easy",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def invertTree(root):\n    if not root:\n        return None\n    # Swap children\n    root.left, root.right = root.right, root.left\n    # Recurse\n    invertTree(root.left)\n    invertTree(root.right)\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Mirror image.",
          "\ud83e\udde0 For every node, left becomes right.",
          "\ud83d\udca1 Post-order or Pre-order traversal works fine."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef invertTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Mirror image.\n    - \ud83e\udde0 For every node, left becomes right.\n    - \ud83d\udca1 Post-order or Pre-order traversal works fine.\n\n    Algorithm:\n    1. Swap - Action.\n    2. Recurse - Propagate.\n    3. Base - Stop.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n    \n    invertTree(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* __init__(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* __init__(TreeNode* root) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) invertTree(root *TreeNode) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) invertTree(root *TreeNode) *TreeNode {\n\tif root == nil {\n\t\treturn root\n\t}\n\tl, r := invertTree(root.Left), invertTree(root.Right)\n\troot.Left, root.Right = r, l\n\treturn root\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn invert_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        if let Some(node) = root.clone() {\n            let mut node = node.borrow_mut();\n            let left = node.left.take();\n            let right = node.right.take();\n            node.left = Self::invert_tree(right);\n            node.right = Self::invert_tree(left);\n        }\n        root\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "coin-change": {
    "title": "Coin Change",
    "pattern": "1D DP",
    "patternEmoji": "\ud83e\ude99",
    "timeComplexity": "O(amount * n)",
    "spaceComplexity": "O(amount)",
    "oneliner": "dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
    "intuition": [
      "\ud83c\udfaf Min coins to make amount.",
      "\ud83e\udde0 dp[i] = min coins for amount i.",
      "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
    ],
    "testCases": [
      {
        "input": "coins = [1,2,5], amount = 11",
        "output": "3"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1"
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def coinChange(self, coins, amount):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min coins to make amount.\n        - \ud83e\udde0 dp[i] = min coins for amount i.\n        - \ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1).\n        \"\"\"\n        dp = [float('inf')] * (amount + 1)  # Initialize DP table to store results.\n        dp[0] = 0\n        for coin in coins:  # Iterate over elements.\n            for i in range(coin, amount + 1):  # Iterate through the range.\n                dp[i] = min(dp[i], dp[i - coin] + 1)  # Take the minimum value.\n        return dp[amount] if dp[amount] != float('inf') else -1",
    "keyInsight": "Bottom-up DP iterating coins first or amount first.",
    "visualizationType": "array",
    "initialState": [
      0,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      3,
      3,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "coins=[1,2,5], amount=11",
        "transientMessage": "dp[0]=0, rest=\u221e",
        "arrayState": [
          0,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "dp[1] = dp[0] + 1 = 1 (using coin 1)",
        "transientMessage": "Amount 1 needs 1 coins",
        "arrayState": [
          0,
          1,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "dp[2] = dp[1] + 1 = 2 (using coin 1)",
        "transientMessage": "Amount 2 needs 2 coins",
        "arrayState": [
          0,
          1,
          2,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "dp[2] = dp[0] + 1 = 1 (using coin 2)",
        "transientMessage": "Amount 2 needs 1 coins",
        "arrayState": [
          0,
          1,
          1,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "dp[3] = dp[2] + 1 = 2 (using coin 1)",
        "transientMessage": "Amount 3 needs 2 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "dp[4] = dp[3] + 1 = 3 (using coin 1)",
        "transientMessage": "Amount 4 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          3,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "dp[4] = dp[2] + 1 = 2 (using coin 2)",
        "transientMessage": "Amount 4 needs 2 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          2,
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "dp[5] = dp[4] + 1 = 3 (using coin 1)",
        "transientMessage": "Amount 5 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          3,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          4,
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "dp[5] = dp[0] + 1 = 1 (using coin 5)",
        "transientMessage": "Amount 5 needs 1 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          0,
          5
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "dp[6] = dp[5] + 1 = 2 (using coin 1)",
        "transientMessage": "Amount 6 needs 2 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "dp[7] = dp[6] + 1 = 3 (using coin 1)",
        "transientMessage": "Amount 7 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          3,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          6,
          7
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "dp[7] = dp[5] + 1 = 2 (using coin 2)",
        "transientMessage": "Amount 7 needs 2 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          "\u221e",
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          5,
          7
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "dp[8] = dp[7] + 1 = 3 (using coin 1)",
        "transientMessage": "Amount 8 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          "\u221e",
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 8
          }
        ],
        "indices": [
          7,
          8
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "dp[9] = dp[8] + 1 = 4 (using coin 1)",
        "transientMessage": "Amount 9 needs 4 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          4,
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 9
          }
        ],
        "indices": [
          8,
          9
        ],
        "color": "success"
      },
      {
        "step": 15,
        "visual": "dp[9] = dp[7] + 1 = 3 (using coin 2)",
        "transientMessage": "Amount 9 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          3,
          "\u221e",
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 9
          }
        ],
        "indices": [
          7,
          9
        ],
        "color": "success"
      },
      {
        "step": 16,
        "visual": "dp[10] = dp[9] + 1 = 4 (using coin 1)",
        "transientMessage": "Amount 10 needs 4 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          3,
          4,
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 10
          }
        ],
        "indices": [
          9,
          10
        ],
        "color": "success"
      },
      {
        "step": 17,
        "visual": "dp[10] = dp[5] + 1 = 2 (using coin 5)",
        "transientMessage": "Amount 10 needs 2 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          3,
          2,
          "\u221e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 10
          }
        ],
        "indices": [
          5,
          10
        ],
        "color": "success"
      },
      {
        "step": 18,
        "visual": "dp[11] = dp[10] + 1 = 3 (using coin 1)",
        "transientMessage": "Amount 11 needs 3 coins",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          3,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 11
          }
        ],
        "indices": [
          10,
          11
        ],
        "color": "success"
      },
      {
        "step": 19,
        "visual": "Result: 3 coins",
        "transientMessage": "Minimum coins found!",
        "arrayState": [
          0,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          3,
          3,
          2,
          3
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 11
          }
        ],
        "indices": [
          11
        ],
        "color": "success"
      }
    ],
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "examples": [
      {
        "input": "coins = [1,2,5], amount = 11",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": "Cannot make 3 with only 2s."
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": "No coins needed for amount 0."
      }
    ],
    "constraints": [
      "1 <= coins.length <= 12",
      "1 <= coins[i] <= 2^31 - 1",
      "0 <= amount <= 10^4"
    ],
    "hints": [
      "Use dynamic programming.",
      "dp[i] = minimum coins needed to make amount i.",
      "For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
    ],
    "relatedProblems": [
      "coin-change-ii",
      "minimum-cost-for-tickets",
      "perfect-squares"
    ],
    "videoId": "H9bfqozjoqs",
    "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "1D DP: dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
    "suggestedNextQuestion": {
      "slug": "coin-change-ii",
      "title": "Coin Change II",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def coinChange(self, coins, amount):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def coinChange(coins, amount):\n    # Brute force (DFS)\n    def dfs(rem):\n        if rem < 0: return -1\n        if rem == 0: return 0\n        min_cost = float('inf')\n        for c in coins:\n            res = dfs(rem - c)\n            if res != -1:\n                min_cost = min(min_cost, res + 1)\n        return min_cost if min_cost != float('inf') else -1\n    return dfs(amount)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(amount * n)",
        "spaceComplexity": "O(amount)",
        "intuition": [
          "\ud83c\udfaf Min coins to make amount.",
          "\ud83e\udde0 dp[i] = min coins for amount i.",
          "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
        ],
        "code": "def coinChange(coins, amount):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min coins to make amount.\n    - \ud83e\udde0 dp[i] = min coins for amount i.\n    - \ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1).\n    \"\"\"\n    dp = [float('inf')] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 0\n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] = min(dp[i], dp[i - coin] + 1)  # Take the minimum value.\n    return dp[amount] if dp[amount] != float('inf') else -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    coinChange(coins, amount) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} coins, amount\n     * @return {any}\n     */\n    coinChange(coins, amount) {\n        const m = coins.length;\n        const n = amount;\n        const f = Array(m + 1)\n            .fill(0)\n            .map(() => Array(n + 1).fill(1 << 30));\n        f[0][0] = 0;\n        for (let i = 1; i <= m; ++i) {\n            for (let j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    f[i][j] = Math.min(f[i][j], f[i][j - coins[i - 1]] + 1);\n                }\n            }\n    }\n    return f[m][n] > n ? -1 : f[m][n];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        final int inf = 1 << 30;\n        int m = coins.length;\n        int n = amount;\n        int[][] f = new int[m + 1][n + 1];\n        for (var g : f) {\n            Arrays.fill(g, inf);\n        }\n        f[0][0] = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    f[i][j] = Math.min(f[i][j], f[i][j - coins[i - 1]] + 1);\n                }\n            }\n        }\n        return f[m][n] >= inf ? -1 : f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int coinChange(vector<int>& coins, int amount) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int m = coins.size(), n = amount;\n        int f[m + 1][n + 1];\n        memset(f, 0x3f, sizeof(f));\n        f[0][0] = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    f[i][j] = min(f[i][j], f[i][j - coins[i - 1]] + 1);\n                }\n            }\n        }\n        return f[m][n] > n ? -1 : f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) coinChange(coins []int, amount int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) coinChange(coins []int, amount int) int {\n\tm, n := len(coins), amount\n\tf := make([][]int, m+1)\n\tconst inf = 1 << 30\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t\tfor j := range f[i] {\n\t\t\tf[i][j] = inf\n\t\t}\n\t}\n\tf[0][0] = 0\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 0; j <= n; j++ {\n\t\t\tf[i][j] = f[i-1][j]\n\t\t\tif j >= coins[i-1] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][j-coins[i-1]]+1)\n\t\t\t}\n\t\t}\n\t}\n\tif f[m][n] > n {\n\t\treturn -1\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {\n        let n = amount as usize;\n        let mut f = vec![n + 1; n + 1];\n        f[0] = 0;\n        for &x in &coins {\n            for j in x as usize..=n {\n                f[j] = f[j].min(f[j - (x as usize)] + 1);\n            }\n        }\n        if f[n] > n {\n            -1\n        } else {\n            f[n] as i32\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def coinChange(self, coins, amount):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    coinChange(coins: number[], amount: number): number  {\n    const m = coins.length;\n    const n = amount;\n    const f: number[][] = Array(m + 1)\n        .fill(0)\n        .map(() => Array(n + 1).fill(1 << 30));\n    f[0][0] = 0;\n    for (let i = 1; i <= m; ++i) {\n        for (let j = 0; j <= n; ++j) {\n            f[i][j] = f[i - 1][j];\n            if (j >= coins[i - 1]) {\n                f[i][j] = Math.min(f[i][j], f[i][j - coins[i - 1]] + 1);\n            }\n        }\n    }\n    return f[m][n] > n ? -1 : f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    coinChange(coins: number[], amount: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "two-sum": {
    "title": "Two Sum",
    "pattern": "Hash Map",
    "patternEmoji": "\u2795",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Store seen numbers; check if (target - current) exists in map.",
    "intuition": [
      "\ud83c\udfaf We need: nums[j] = target - nums[i].",
      "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
      "\ud83d\udca1 Look back: do we have the complement?"
    ],
    "testCases": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]"
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Scan",
        "visual": "Visit 2. Need 7. Map: {2:0}.",
        "explanation": "Remember 2."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "Visit 7. Need 2. 2 is in Map!",
        "explanation": "Pair found."
      },
      {
        "step": 3,
        "title": "Found",
        "visual": "Return [Map[2], CurrentIndex].",
        "explanation": "Indices found."
      }
    ],
    "code": "class Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We need: nums[j] = target - nums[i].\n        - \ud83e\udde0 While iterating, store {val: index} of what we've seen.\n        - \ud83d\udca1 Look back: do we have the complement?\n\n        Algorithm:\n        1. Scan - Remember 2.\n        2. Check - Pair found.\n        3. Found - Indices found.\n        \"\"\"\n        prevMap = {}\n        for i, n in enumerate(nums):  # Iterate over elements.\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n        return []",
    "keyInsight": "One pass is sufficient because the pair is commutative; we find it when we reach the *second* number.",
    "visualizationType": "array",
    "initialState": [
      2,
      7,
      11,
      15
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Find two numbers that sum to 9",
        "transientMessage": "Initialize empty hash map",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Check arr[0] = 2",
        "transientMessage": "Need complement: 9 - 2 = 7",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Store 2 \u2192 index 0 in map",
        "transientMessage": "Map: {2:0}",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Check arr[1] = 7",
        "transientMessage": "Need complement: 9 - 7 = 2",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Found 2 at index 0!",
        "transientMessage": "Return [0, 1]",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "j",
            "index": 0
          },
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      }
    ],
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]",
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]",
        "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "hints": [
      "A really brute force way would be to search for all possible pairs of numbers but that would be too slow.",
      "Try using a hash map to store the complement of each number.",
      "Can you do it in one pass through the array?"
    ],
    "relatedProblems": [
      "three-sum",
      "two-sum-ii---input-array-is-sorted",
      "two-sum-iv---input-is-a-bst"
    ],
    "videoId": "KLlXCFG5TnA",
    "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map: Store seen numbers; check if (target - current) exists in map.",
    "suggestedNextQuestion": {
      "slug": "valid-anagram",
      "title": "Valid Anagram",
      "difficulty": "Easy",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def twoSum(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def twoSum_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf We need: nums[j] = target - nums[i].",
          "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
          "\ud83d\udca1 Look back: do we have the complement?"
        ],
        "code": "def twoSum(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need: nums[j] = target - nums[i].\n    - \ud83e\udde0 While iterating, store {val: index} of what we've seen.\n    - \ud83d\udca1 Look back: do we have the complement?\n\n    Algorithm:\n    1. Scan - Remember 2.\n    2. Check - Pair found.\n    3. Found - Indices found.\n    \"\"\"\n    prevMap = {}\n    for i, n in enumerate(nums):  # Iterate over elements.\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    twoSum(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    twoSum(nums, target) {\n        const d = new Map();\n        for (let i = 0; ; ++i) {\n            const x = nums[i];\n            const y = target - x;\n            if (d.has(y)) {\n                return [d.get(y), i];\n            }\n            d.set(x, i);\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (d.containsKey(y)) {\n                return new int[] {d.get(y), i};\n            }\n            d.put(x, i);\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> d;\n        for (int i = 0;; ++i) {\n            int x = nums[i];\n            int y = target - x;\n            if (d.contains(y)) {\n                return {d[y], i};\n            }\n            d[x] = i;\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) twoSum(nums []int, target int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) twoSum(nums []int, target int) []int {\n\td := map[int]int{}\n\tfor i := 0; ; i++ {\n\t\tx := nums[i]\n\t\ty := target - x\n\t\tif j, ok := d[y]; ok {\n\t\t\treturn []int{j, i}\n\t\t}\n\t\td[x] = i\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut d = HashMap::new();\n        for (i, &x) in nums.iter().enumerate() {\n            let y = target - x;\n            if let Some(&j) = d.get(&y) {\n                return vec![j as i32, i as i32];\n            }\n            d.insert(x, i);\n        }\n        vec![]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def twoSum(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    twoSum(nums: number[], target: number): number[]  {\n    const d = new Map<number, number>();\n    for (let i = 0; ; ++i) {\n        const x = nums[i];\n        const y = target - x;\n        if (d.has(y)) {\n            return [d.get(y)!, i];\n        }\n        d.set(x, i);\n    }\n}\n}",
        "initialCode": "class Solution {\n    twoSum(nums: number[], target: number): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "remove-element": {
    "title": "Remove Element",
    "pattern": "Two Pointers",
    "patternEmoji": "\u270c\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use a read pointer and a write pointer to filter in-place.",
    "intuition": [
      "\ud83c\udfaf We need to remove all instances of val in-place",
      "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
      "\ud83d\udca1 If current element != val, put it at k and increment k"
    ],
    "testCases": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2"
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5"
      }
    ],
    "code": "class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We need to remove all instances of val in-place\n        - \ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements\n        - \ud83d\udca1 If current element != val, put it at k and increment k\n        \"\"\"\n        k = 0\n        for i in range(len(nums)):  # Iterate through the range.\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k",
    "keyInsight": "Overwrite values we don't want with the ones we keep!",
    "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.",
    "examples": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2, nums = [2,2,_,_]",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5, nums = [0,1,4,0,3,_,_,_]",
        "explanation": "Your function should return k = 5."
      }
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 100"
    ],
    "hints": [
      "Use two pointers - one for iteration, one for placing valid elements.",
      "Overwrite elements equal to val with elements from the end.",
      "The order doesn't matter, so we can swap freely."
    ],
    "relatedProblems": [
      "remove-duplicates-from-sorted-array",
      "move-zeroes",
      "remove-linked-list-elements"
    ],
    "videoId": "Pcd1ii9P9ZI",
    "problemStatement": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "visualizationType": "array",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [3, 2, 2, 3], val=3",
        "transientMessage": "Remove all occurrences of val",
        "arrayState": [
          3,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "k",
            "index": 0
          }
        ],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "nums[0]=3 == 3",
        "transientMessage": "Skip",
        "arrayState": [
          3,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "nums[1]=2 != 3",
        "transientMessage": "Keep at position 0",
        "arrayState": [
          2,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "k",
            "index": 0
          },
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "nums[2]=2 != 3",
        "transientMessage": "Keep at position 1",
        "arrayState": [
          2,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "k",
            "index": 1
          },
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "nums[3]=3 == 3",
        "transientMessage": "Skip",
        "arrayState": [
          2,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "2 elements remaining",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      }
    ],
    "initialState": [
      3,
      2,
      2,
      3
    ],
    "approach": "Two Pointers: Use a read pointer and a write pointer to filter in-place.",
    "suggestedNextQuestion": {
      "slug": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def removeElement(self, nums, val):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def removeElement(nums, val):\n    idx = 0\n    for x in nums:\n        if x != val:\n            nums[idx] = x\n            idx += 1\n    return idx"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf We need to remove all instances of val in-place",
          "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
          "\ud83d\udca1 If current element != val, put it at k and increment k"
        ],
        "code": "def removeElement(nums, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove all instances of val in-place\n    - \ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements\n    - \ud83d\udca1 If current element != val, put it at k and increment k\n    \"\"\"\n    k = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    removeElement(nums, val) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums, val\n     * @return {any}\n     */\n    removeElement(nums, val) {\n        let k = 0;\n        for (const x of nums) {\n            if (x !== val) {\n                nums[k++] = x;\n            }\n    }\n    return k;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int k = 0;\n        for (int x : nums) {\n            if (x != val) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int removeElement(vector<int>& nums, int val) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int k = 0;\n        for (int x : nums) {\n            if (x != val) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) removeElement(nums []int, val int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) removeElement(nums []int, val int) int {\n\tk := 0\n\tfor _, x := range nums {\n\t\tif x != val {\n\t\t\tnums[k] = x\n\t\t\tk++\n\t\t}\n\t}\n\treturn k\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {\n        let mut k = 0;\n        for i in 0..nums.len() {\n            if nums[i] != val {\n                nums[k] = nums[i];\n                k += 1;\n            }\n        }\n        k as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We need to remove all instances of val in-place\n        - \ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements\n        - \ud83d\udca1 If current element != val, put it at k and increment k\n        \"\"\"\n        k = 0\n        for i in range(len(nums)):  # Iterate through the range.\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k"
      },
      "typescript": {
        "code": "class Solution {\n    removeElement(nums: number[], val: number): number  {\n    let k: number = 0;\n    for (const x of nums) {\n        if (x !== val) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n}\n}",
        "initialCode": "class Solution {\n    removeElement(nums: number[], val: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "majority-element": {
    "title": "Majority Element",
    "pattern": "Boyer-Moore Voting",
    "patternEmoji": "\ud83d\uddf3\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Cancel out different elements; the majority always survives!",
    "intuition": [
      "\ud83c\udfaf Majority element appears > n/2 times",
      "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
      "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
    ],
    "testCases": [
      {
        "input": "nums = [3,2,3]",
        "output": "3"
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Majority element appears > n/2 times\n        - \ud83e\udde0 Think of it as a war: mixed pair die, majority wins\n        - \ud83d\udca1 Count +, Count -. If count 0, pick new candidate.\n        \"\"\"\n        count = 0\n        candidate = None\n\n        for num in nums:  # Iterate over elements.\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate",
    "keyInsight": "If >50% of people vote Red, even if everyone else pairs up against them, Red wins!",
    "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": "3 appears 2 times out of 3."
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": "2 appears 4 times out of 7."
      }
    ],
    "constraints": [
      "n == nums.length",
      "1 <= n <= 5 * 10^4",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Use Boyer-Moore Voting Algorithm.",
      "Maintain a candidate and count.",
      "If count is 0, pick new candidate. If same, increment, else decrement."
    ],
    "relatedProblems": [
      "majority-element-ii",
      "check-if-a-number-is-majority-element-in-a-sorted-array"
    ],
    "videoId": "7pnhv842keE",
    "problemStatement": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "array",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [2, 2, 1, 1, 1, 2, 2]",
        "transientMessage": "Boyer-Moore Voting Algorithm",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "New candidate: 2",
        "transientMessage": "count = 1",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "c",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "2 == candidate",
        "transientMessage": "count++ = 2",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "1 != candidate",
        "transientMessage": "count-- = 1",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "1 != candidate",
        "transientMessage": "count-- = 0",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "New candidate: 1",
        "transientMessage": "count = 1",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "c",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "2 != candidate",
        "transientMessage": "count-- = 0",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "New candidate: 2",
        "transientMessage": "count = 1",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "c",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Majority element: 2",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          2,
          1,
          1,
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "initialState": [
      2,
      2,
      1,
      1,
      1,
      2,
      2
    ],
    "approach": "Boyer-Moore Voting: Cancel out different elements; the majority always survives!",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def majorityElement(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def majorityElement(nums):\n    # Brute force: Count occurance of each element\n    majority_count = len(nums) // 2\n    for num in nums:\n        count = sum(1 for x in nums if x == num)\n        if count > majority_count:\n            return num"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Majority element appears > n/2 times",
          "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
          "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
        ],
        "code": "def majorityElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Majority element appears > n/2 times\n    - \ud83e\udde0 Think of it as a war: mixed pair die, majority wins\n    - \ud83d\udca1 Count +, Count -. If count 0, pick new candidate.\n    \"\"\"\n    count = 0\n    candidate = None\n    \n    for num in nums:  # Iterate over elements.\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    majorityElement(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    majorityElement(nums) {\n        let cnt = 0;\n        let m = 0;\n        for (const x of nums) {\n            if (cnt === 0) {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += m === x ? 1 : -1;\n            }\n    }\n    return m;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int majorityElement(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int majorityElement(int[] nums) {\n        int cnt = 0, m = 0;\n        for (int x : nums) {\n            if (cnt == 0) {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += m == x ? 1 : -1;\n            }\n        }\n        return m;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int majorityElement(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int cnt = 0, m = 0;\n        for (int& x : nums) {\n            if (cnt == 0) {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += m == x ? 1 : -1;\n            }\n        }\n        return m;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) majorityElement(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) majorityElement(nums []int) int {\n\tvar cnt, m int\n\tfor _, x := range nums {\n\t\tif cnt == 0 {\n\t\t\tm, cnt = x, 1\n\t\t} else {\n\t\t\tif m == x {\n\t\t\t\tcnt++\n\t\t\t} else {\n\t\t\t\tcnt--\n\t\t\t}\n\t\t}\n\t}\n\treturn m\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn majority_element(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn majority_element(nums: Vec<i32>) -> i32 {\n        let mut m = 0;\n        let mut cnt = 0;\n        for &x in nums.iter() {\n            if cnt == 0 {\n                m = x;\n                cnt = 1;\n            } else {\n                cnt += if m == x { 1 } else { -1 };\n            }\n        }\n        m\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def majorityElement(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    majorityElement(nums: number[]): number  {\n    let cnt: number = 0;\n    let m: number = 0;\n    for (const x of nums) {\n        if (cnt === 0) {\n            m = x;\n            cnt = 1;\n        } else {\n            cnt += m === x ? 1 : -1;\n        }\n    }\n    return m;\n}\n}",
        "initialCode": "class Solution {\n    majorityElement(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "binary-search",
      "title": "Binary Search",
      "difficulty": "Easy",
      "pattern": "Divide & Conquer"
    }
  },
  "ransom-note": {
    "title": "Ransom Note",
    "pattern": "Hash Map / Counter",
    "patternEmoji": "\ud83d\udcc3",
    "timeComplexity": "O(m+n)",
    "spaceComplexity": "O(1) (26 chars)",
    "oneliner": "Count letters in magazine; ensure every letter in note is available.",
    "intuition": [
      "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
      "\ud83e\udde0 Count frequency of each char in magazine.",
      "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
    ],
    "testCases": [
      {
        "input": "ransomNote = \"a\", magazine = \"b\"",
        "output": "false"
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"ab\"",
        "output": "false"
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"aab\"",
        "output": "true"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Count Magazine",
        "visual": "Map: {a:2, b:1}",
        "explanation": "Available resources."
      },
      {
        "step": 2,
        "title": "Check Note",
        "visual": "Need 'a'? Map['a']--. Remaining: 1.",
        "explanation": "Consume resource."
      },
      {
        "step": 3,
        "title": "Verify",
        "visual": "If Map[char] < 0, impossible.",
        "explanation": "Not enough letters."
      }
    ],
    "code": "class Solution:\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Can we construct 'note' from 'magazine' letters?\n        - \ud83e\udde0 Count frequency of each char in magazine.\n        - \ud83d\udca1 For each char in note, subtract count. If count < 0, False.\n\n        Algorithm:\n        1. Count Magazine - Available resources.\n        2. Check Note - Consume resource.\n        3. Verify - Not enough letters.\n        \"\"\"\n        from collections import Counter\n        counts = Counter(magazine)\n        for c in ransomNote:  # Iterate over elements.\n            counts[c] -= 1\n            if counts[c] < 0: return False  # Condition not met.\n        return True  # Condition satisfied.",
    "keyInsight": "Using an array of size 26 is slightly faster than a hashmap, but Counter is cleaner.",
    "visualizationType": "array",
    "initialState": "ransomNote='aa', magazine='aab'",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Input: [r, a, n, s, o, m...]",
        "transientMessage": "HashMap approach",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process r",
        "transientMessage": "Map: {\"r\":1}",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process a",
        "transientMessage": "Map: {\"r\":1,\"a\":1}",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process n",
        "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1}",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Process s",
        "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1,\"s\":1}",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process o",
        "transientMessage": "Map: {\"r\":1,\"a\":1,\"n\":1,\"s\":1,\"o\":1}",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "HashMap complete",
        "transientMessage": "Found 5 unique elements",
        "arrayState": [
          "r",
          "a",
          "n",
          "s",
          "o",
          "m",
          "N",
          "o"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote.",
    "examples": [
      {
        "input": "ransomNote = \"a\", magazine = \"b\"",
        "output": "false",
        "explanation": "'a' is not in magazine."
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"aab\"",
        "output": "true",
        "explanation": "Both 'a's can be found in magazine."
      }
    ],
    "constraints": [
      "1 <= ransomNote.length, magazine.length <= 10^5",
      "ransomNote and magazine consist of lowercase English letters."
    ],
    "hints": [
      "Count character frequencies in magazine.",
      "Check if ransomNote's frequencies are all <= magazine's.",
      "Use a hash map or array of size 26."
    ],
    "relatedProblems": [
      "stickers-to-spell-word",
      "first-unique-character-in-a-string"
    ],
    "videoId": "i3bvxJyUB40",
    "problemStatement": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map / Counter: Count letters in magazine; ensure every letter in note is available.",
    "suggestedNextQuestion": {
      "slug": "roman-to-integer",
      "title": "Roman to Integer",
      "difficulty": "Easy",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def canConstruct(self, ransomNote, magazine):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def canConstruct_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m+n)",
        "spaceComplexity": "O(1) (26 chars)",
        "intuition": [
          "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
          "\ud83e\udde0 Count frequency of each char in magazine.",
          "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
        ],
        "code": "def canConstruct(ransomNote, magazine):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can we construct 'note' from 'magazine' letters?\n    - \ud83e\udde0 Count frequency of each char in magazine.\n    - \ud83d\udca1 For each char in note, subtract count. If count < 0, False.\n\n    Algorithm:\n    1. Count Magazine - Available resources.\n    2. Check Note - Consume resource.\n    3. Verify - Not enough letters.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(magazine)\n    for c in ransomNote:  # Iterate over elements.\n        counts[c] -= 1\n        if counts[c] < 0: return False  # Condition not met.\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    canConstruct(ransomNote, magazine) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} ransomNote, magazine\n     * @return {any}\n     */\n    canConstruct(ransomNote, magazine) {\n        const map = new Map();\n\n        for (let i = magazine.length - 1; i > -1; i--) {\n          map.set(magazine[i], (map.get(magazine[i]) || 0) + 1);\n        }\n\n        for (let i = ransomNote.length - 1; i > -1; i--) {\n          if ((map.get(ransomNote[i]) || 0) < 1) {\n            return false;\n          }\n          map.set(ransomNote[i], map.get(ransomNote[i]) - 1);\n      }\n\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] cnt = new int[26];\n        for (int i = 0; i < magazine.length(); ++i) {\n            ++cnt[magazine.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < ransomNote.length(); ++i) {\n            if (--cnt[ransomNote.charAt(i) - 'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool canConstruct(string ransomNote, string magazine) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        int cnt[26]{};\n        for (char& c : magazine) {\n            ++cnt[c - 'a'];\n        }\n        for (char& c : ransomNote) {\n            if (--cnt[c - 'a'] < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canConstruct(ransomNote string, magazine string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canConstruct(ransomNote string, magazine string) bool {\n\tcnt := [26]int{}\n\tfor _, c := range magazine {\n\t\tcnt[c-'a']++\n\t}\n\tfor _, c := range ransomNote {\n\t\tcnt[c-'a']--\n\t\tif cnt[c-'a'] < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_construct(ransomNote: i32, magazine: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn can_construct(ransom_note: String, magazine: String) -> bool {\n        let mut hm: HashMap<char, i32> = HashMap::new();\n        if ransom_note.len() > magazine.len() {\n            return false;\n        }\n        if ransom_note == magazine {\n            return true;\n        }\n        for c in magazine.chars() {\n            let e = hm.entry(c).or_default();\n            *e += 1;\n        }\n        for c in ransom_note.chars() {\n            if let Some(v) = hm.get_mut(&c) {\n                *v -= 1;\n                if *v < 0 {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let r = \"a\".to_string();\n    let m = \"b\".to_string();\n    assert_eq!(Solution::can_construct(r, m), false);\n    let r = \"aa\".to_string();\n    let m = \"ab\".to_string();\n    assert_eq!(Solution::can_construct(r, m), false);\n    let r = \"aa\".to_string();\n    let m = \"aab\".to_string();\n    assert_eq!(Solution::can_construct(r, m), true);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canConstruct(self, ransomNote, magazine):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    canConstruct(ransomNote: string, magazine: string): boolean  {\n    const cnt: number[] = Array(26).fill(0);\n    for (const c of magazine) {\n        ++cnt[c.charCodeAt(0) - 97];\n    }\n    for (const c of ransomNote) {\n        if (--cnt[c.charCodeAt(0) - 97] < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    canConstruct(ransomNote: string, magazine: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "valid-anagram": {
    "title": "Valid Anagram",
    "pattern": "Hash Map / Sorting",
    "patternEmoji": "\ud83d\udd00",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Check if character counts are identical.",
    "intuition": [
      "\ud83c\udfaf Anagram = same letters, rearranged.",
      "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
      "\ud83d\udca1 Count S, subtract T. All zero? True."
    ],
    "testCases": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true"
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Count S",
        "visual": "{a:3, n:1, g:1, r:1, m:1}",
        "explanation": "Tally up."
      },
      {
        "step": 2,
        "title": "Subtract T",
        "visual": "Decrement counts for 'nagaram'.",
        "explanation": "Cancel out."
      },
      {
        "step": 3,
        "title": "Result",
        "visual": "All zero? Match.",
        "explanation": "Any non-zero means mismatch."
      }
    ],
    "code": "class Solution:\n    def isAnagram(self, s, t):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Anagram = same letters, rearranged.\n        - \ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).\n        - \ud83d\udca1 Count S, subtract T. All zero? True.\n\n        Algorithm:\n        1. Count S - Tally up.\n        2. Subtract T - Cancel out.\n        3. Result - Any non-zero means mismatch.\n        \"\"\"\n        if len(s) != len(t): return False  # Condition not met.\n        # return sorted(s) == sorted(t)\n        from collections import Counter\n        return Counter(s) == Counter(t)",
    "keyInsight": "Length check first is a cheap optimization.",
    "visualizationType": "array",
    "initialState": [
      "a",
      "n",
      "a",
      "g",
      "r",
      "a",
      "m"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "s=\"anagram\", t=\"nagaram\"",
        "transientMessage": "Count characters in s",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Count 'a': 1",
        "transientMessage": "Map: {\"a\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Count 'n': 1",
        "transientMessage": "Map: {\"a\":1,\"n\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Count 'a': 2",
        "transientMessage": "Map: {\"a\":2,\"n\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Count 'g': 1",
        "transientMessage": "Map: {\"a\":2,\"n\":1,\"g\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Count 'r': 1",
        "transientMessage": "Map: {\"a\":2,\"n\":1,\"g\":1,\"r\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Count 'a': 3",
        "transientMessage": "Map: {\"a\":3,\"n\":1,\"g\":1,\"r\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Count 'm': 1",
        "transientMessage": "Map: {\"a\":3,\"n\":1,\"g\":1,\"r\":1,\"m\":1}",
        "arrayState": [
          "a",
          "n",
          "a",
          "g",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Now subtract using t",
        "transientMessage": "Check if all counts become 0",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Subtract 'n': 0",
        "transientMessage": "Matched!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Subtract 'a': 2",
        "transientMessage": "Updated",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Subtract 'g': 0",
        "transientMessage": "Matched!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "Subtract 'a': 1",
        "transientMessage": "Updated",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 14,
        "visual": "Subtract 'r': 0",
        "transientMessage": "Matched!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 15,
        "visual": "Subtract 'a': 0",
        "transientMessage": "Matched!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 16,
        "visual": "Subtract 'm': 0",
        "transientMessage": "Matched!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 17,
        "visual": "Result: Valid Anagram",
        "transientMessage": "Complete!",
        "arrayState": [
          "n",
          "a",
          "g",
          "a",
          "r",
          "a",
          "m"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": "Both have same letter counts."
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false",
        "explanation": "Different letter counts."
      }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters."
    ],
    "hints": [
      "If lengths differ, return false immediately.",
      "Count character frequencies and compare.",
      "Or sort both strings and compare."
    ],
    "relatedProblems": [
      "group-anagrams",
      "find-all-anagrams-in-a-string",
      "find-resultant-array-after-removing-anagrams"
    ],
    "videoId": "9UtInBqnCgA",
    "problemStatement": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map / Sorting: Check if character counts are identical.",
    "suggestedNextQuestion": {
      "slug": "word-pattern",
      "title": "Word Pattern",
      "difficulty": "Easy",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def isAnagram(self, s, t):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def isAnagram_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Anagram = same letters, rearranged.",
          "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
          "\ud83d\udca1 Count S, subtract T. All zero? True."
        ],
        "code": "def isAnagram(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Anagram = same letters, rearranged.\n    - \ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).\n    - \ud83d\udca1 Count S, subtract T. All zero? True.\n\n    Algorithm:\n    1. Count S - Tally up.\n    2. Subtract T - Cancel out.\n    3. Result - Any non-zero means mismatch.\n    \"\"\"\n    if len(s) != len(t): return False  # Condition not met.\n    # return sorted(s) == sorted(t)\n    from collections import Counter\n    return Counter(s) == Counter(t)"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isAnagram(s, t) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} s, t\n     * @return {any}\n     */\n    isAnagram(s, t) {\n        if (s.length !== t.length) {\n            return false;\n        }\n        const cnt = new Array(26).fill(0);\n        for (let i = 0; i < s.length; ++i) {\n            ++cnt[s.charCodeAt(i) - 'a'.charCodeAt(0)];\n            --cnt[t.charCodeAt(i) - 'a'.charCodeAt(0)];\n    }\n    return cnt.every(x => x === 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        int[] cnt = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt[s.charAt(i) - 'a'];\n            --cnt[t.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (cnt[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isAnagram(string s, string t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n        vector<int> cnt(26);\n        for (int i = 0; i < s.size(); ++i) {\n            ++cnt[s[i] - 'a'];\n            --cnt[t[i] - 'a'];\n        }\n        return all_of(cnt.begin(), cnt.end(), [](int x) { return x == 0; });\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isAnagram(s string, t string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isAnagram(s string, t string) bool {\n\tif len(s) != len(t) {\n\t\treturn false\n\t}\n\tcnt := [26]int{}\n\tfor i := 0; i < len(s); i++ {\n\t\tcnt[s[i]-'a']++\n\t\tcnt[t[i]-'a']--\n\t}\n\tfor _, v := range cnt {\n\t\tif v != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_anagram(s: String, t: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_anagram(s: String, t: String) -> bool {\n        let n = s.len();\n        let m = t.len();\n        if n != m {\n            return false;\n        }\n        let mut s = s.chars().collect::<Vec<char>>();\n        let mut t = t.chars().collect::<Vec<char>>();\n        s.sort();\n        t.sort();\n        for i in 0..n {\n            if s[i] != t[i] {\n                return false;\n            }\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isAnagram(self, s, t):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isAnagram(s: string, t: string): boolean  {\n    if (s.length !== t.length) {\n        return false;\n    }\n    const cnt = new Array(26).fill(0);\n    for (let i = 0; i < s.length; ++i) {\n        ++cnt[s.charCodeAt(i) - 'a'.charCodeAt(0)];\n        --cnt[t.charCodeAt(i) - 'a'.charCodeAt(0)];\n    }\n    return cnt.every(x => x === 0);\n}\n}",
        "initialCode": "class Solution {\n    isAnagram(s: string, t: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "happy-number": {
    "title": "Happy Number",
    "pattern": "Floyd's Cycle Finding",
    "patternEmoji": "\ud83d\ude00",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
    "intuition": [
      "\ud83c\udfaf Process: replace n with sum of squares of digits.",
      "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
      "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
    ],
    "testCases": [
      {
        "input": "n = 19",
        "output": "true"
      },
      {
        "input": "n = 2",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Simulate",
        "visual": "19 -> 1^2+9^2=82 -> 68 -> 100 -> 1.",
        "explanation": "Converged to 1."
      },
      {
        "step": 2,
        "title": "Cycle",
        "visual": "2 -> 4 -> 16... -> 4 (Loop!).",
        "explanation": "Detected visited number."
      },
      {
        "step": 3,
        "title": "Result",
        "visual": "If 1: True. If Cycle: False.",
        "explanation": "Decision."
      }
    ],
    "code": "class Solution:\n    def isHappy(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Process: replace n with sum of squares of digits.\n        - \ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).\n        - \ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop.\n\n        Algorithm:\n        1. Simulate - Converged to 1.\n        2. Cycle - Detected visited number.\n        3. Result - Decision.\n        \"\"\"\n        visit = set()\n        while n not in visit:\n            visit.add(n)\n            n = sum(int(d)**2 for d in str(n))\n            if n == 1: return True  # Condition satisfied.\n        return False  # Condition not met.",
    "keyInsight": "The cycle doesn't grow infinitely; digits reduce numbers drastically (999 -> 243). Loop is guaranteed small.",
    "visualizationType": "linkedlist",
    "initialState": "19",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Happy Number",
        "transientMessage": "Input: [1, 9]",
        "arrayState": [
          "1",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "1",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 2",
        "arrayState": [
          "1",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 9",
        "transientMessage": "Step 2 of 2",
        "arrayState": [
          "1",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          "1",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.",
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "1\u00b2 + 9\u00b2 = 82 \u2192 8\u00b2 + 2\u00b2 = 68 \u2192 ... \u2192 1"
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": "2 \u2192 4 \u2192 16 \u2192 37 \u2192 58 \u2192 89 \u2192 145 \u2192 42 \u2192 20 \u2192 4 (cycle)"
      }
    ],
    "constraints": [
      "1 <= n <= 2^31 - 1"
    ],
    "hints": [
      "Use Floyd's cycle detection (fast and slow).",
      "Or use a hash set to detect cycles.",
      "If you see a number twice, it's not happy."
    ],
    "relatedProblems": [
      "linked-list-cycle",
      "add-digits",
      "ugly-number"
    ],
    "videoId": "ljz85bxOYJ0",
    "problemStatement": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nReturn true if n is a happy number, and false if not.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Floyd's Cycle Finding: Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
    "suggestedNextQuestion": {
      "slug": "is-subsequence",
      "title": "Is Subsequence",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
    "initialCode": "class Solution:\n    def isHappy(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(d)**2 for d in str(n))\n    return n == 1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Process: replace n with sum of squares of digits.",
          "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
          "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
        ],
        "code": "def isHappy(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Process: replace n with sum of squares of digits.\n    - \ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).\n    - \ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop.\n\n    Algorithm:\n    1. Simulate - Converged to 1.\n    2. Cycle - Detected visited number.\n    3. Result - Decision.\n    \"\"\"\n    visit = set()\n    while n not in visit:\n        visit.add(n)\n        n = sum(int(d)**2 for d in str(n))\n        if n == 1: return True  # Condition satisfied.\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isHappy(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    isHappy(n) {\n        while (n !== 1) {\n          n = [...String(n)].reduce((sum, digit) => sum + digit ** 2, 0);\n          if (n === 4) {\n            return false;\n          }\n      }\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isHappy(int n) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean isHappy(int n) {\n        Set<Integer> vis = new HashSet<>();\n        while (n != 1 && !vis.contains(n)) {\n            vis.add(n);\n            int x = 0;\n            while (n != 0) {\n                x += (n % 10) * (n % 10);\n                n /= 10;\n            }\n            n = x;\n        }\n        return n == 1;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isHappy(int n) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_set<int> vis;\n        while (n != 1 && !vis.count(n)) {\n            vis.insert(n);\n            int x = 0;\n            for (; n; n /= 10) {\n                x += (n % 10) * (n % 10);\n            }\n            n = x;\n        }\n        return n == 1;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isHappy(n int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isHappy(n int) bool {\n\tvis := map[int]bool{}\n\tfor n != 1 && !vis[n] {\n\t\tvis[n] = true\n\t\tx := 0\n\t\tfor ; n > 0; n /= 10 {\n\t\t\tx += (n % 10) * (n % 10)\n\t\t}\n\t\tn = x\n\t}\n\treturn n == 1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_happy(mut n: i32) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashSet;\nimpl Solution {\n    fn get_next(mut n: i32) -> i32 {\n        let mut res = 0;\n        while n != 0 {\n            res += (n % 10).pow(2);\n            n /= 10;\n        }\n        res\n    }\n\n    pub fn is_happy(mut n: i32) -> bool {\n        let mut set = HashSet::new();\n        while n != 1 {\n            let next = Self::get_next(n);\n            if set.contains(&next) {\n                return false;\n            }\n            set.insert(next);\n            n = next;\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isHappy(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isHappy(n: number): boolean  {\n    const getNext = (n: number) => {\n        let res = 0;\n        while (n !== 0) {\n            res += (n % 10) ** 2;\n            n = Math.floor(n / 10);\n        }\n        return res;\n    };\n    const set = new Set();\n    while (n !== 1) {\n        const next = getNext(n);\n        if (set.has(next)) {\n            return false;\n        }\n        set.add(next);\n        n = next;\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    isHappy(n: number): boolean {\n        // Your code here\n        return false;\n    }\n}"
      }
    }
  },
  "middle-of-the-linked-list": {
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use two pointers, one moving twice as fast as the other, to find the middle.",
    "intuition": [
      "The faster pointer will reach the end when the slower one is at the middle.",
      "Move slow and fast pointers; fast moves two steps while slow moves one."
    ],
    "visualizationType": "linkedlist",
    "initialState": [
      "A",
      "B",
      "C",
      "D",
      "E"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Middle of the Linked List",
        "transientMessage": "Input: [A, B, C, D, E]",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: A",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: B",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: C",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: D",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: E",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          "A",
          "B",
          "C",
          "D",
          "E"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def middleNode(self, head):\n        \"\"\"\n        Intuition:\n        - The faster pointer will reach the end when the slower one is at the middle.\n        - Move slow and fast pointers; fast moves two steps while slow moves one.\n        \"\"\"\n        slow = fast = head  # Initialize cycle detection pointers.\n        while fast and fast.next:  # Traverse until end of list.\n            slow = slow.next\n            fast = fast.next.next\n        return slow  # Return the result node.",
    "keyInsight": "The fast pointer will reach the end when the slow one is at the middle.",
    "testCases": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[3,4,5]"
      },
      {
        "input": "head = [1,2,3,4,5,6]",
        "output": "[4,5,6]"
      }
    ],
    "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[3,4,5]",
        "explanation": "The middle node is 3."
      },
      {
        "input": "head = [1,2,3,4,5,6]",
        "output": "[4,5,6]",
        "explanation": "There are two middles, return the second one."
      }
    ],
    "constraints": [
      "The number of nodes is in range [1, 100].",
      "1 <= Node.val <= 100"
    ],
    "hints": [
      "Use slow and fast pointers.",
      "Slow moves 1 step, fast moves 2 steps.",
      "When fast reaches end, slow is at middle."
    ],
    "relatedProblems": [
      "delete-the-middle-node-of-a-linked-list",
      "linked-list-cycle",
      "reorder-list"
    ],
    "videoId": "A2_ldqM4QcY",
    "problemStatement": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
    "title": "Middle of the Linked List",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use two pointers, one moving twice as fast as the other, to find the middle.",
    "suggestedNextQuestion": {
      "slug": "minimum-absolute-difference",
      "title": "Minimum Absolute Difference",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def middleNode(self, head):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def middleNode(head):\n    # Count length first\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n    \n    # Move to middle\n    curr = head\n    for _ in range(length // 2):\n        curr = curr.next\n    return curr"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "The faster pointer will reach the end when the slower one is at the middle.",
          "Move slow and fast pointers; fast moves two steps while slow moves one."
        ],
        "code": "def middleNode(head):\n    \"\"\"\n    Intuition:\n    - The faster pointer will reach the end when the slower one is at the middle.\n    - Move slow and fast pointers; fast moves two steps while slow moves one.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow = slow.next\n        fast = fast.next.next\n    return slow  # Return the result node."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode __init__(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode __init__(ListNode head) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* __init__(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* __init__(ListNode* head) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) middleNode(head *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) middleNode(head *ListNode) *ListNode {\n\tslow, fast := head, head\n\tfor fast != nil && fast.Next != nil {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\treturn slow\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn middle_node(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn middle_node(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut slow = &head;\n        let mut fast = &head;\n        while fast.is_some() && fast.as_ref().unwrap().next.is_some() {\n            slow = &slow.as_ref().unwrap().next;\n            fast = &fast.as_ref().unwrap().next.as_ref().unwrap().next;\n        }\n        slow.clone()\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def middleNode(self, head):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "time-needed-to-buy-tickets": {
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use two pointers to simulate buying tickets in a queue.",
    "intuition": [
      "Track the time taken for each person to buy their ticket using two pointers.",
      "Adjust pointers based on the number of tickets needed and available."
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Time Needed to Buy Tickets",
        "transientMessage": "Input: [2, 3, 2]",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 2",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 3",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 2",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def time_needed_to_buy(self, tickets, k):\n        \"\"\"\n        Intuition:\n        - Track the time taken for each person to buy their ticket using two pointers.\n        - Adjust pointers based on the number of tickets needed and available.\n        \"\"\"\n        time = 0\n        n = len(tickets)\n        while tickets[k] > 0:\n            for i in range(n):  # Iterate through the range.\n                if tickets[i] == 0:\n                    continue\n                tickets[i] -= 1\n                time += 1\n                if tickets[k] == 0:\n                    return time",
    "keyInsight": "Simulate the queue by decrementing ticket counts and incrementing time.",
    "testCases": [
      {
        "input": "tickets = [2,3,2], k = 2",
        "output": "6"
      },
      {
        "input": "tickets = [5,1,1,1], k = 0",
        "output": "8"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Time Needed to Buy Tickets",
    "description": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line to buy more tickets. Return the time taken for the person at position k to finish buying all their tickets.",
    "examples": [
      {
        "input": "tickets = [2,3,2], k = 2",
        "output": "6",
        "explanation": "Person 2 finishes after 6 seconds."
      },
      {
        "input": "tickets = [5,1,1,1], k = 0",
        "output": "8",
        "explanation": "Person 0 needs 5 tickets, takes 8 seconds total."
      }
    ],
    "constraints": [
      "n == tickets.length",
      "1 <= n <= 100",
      "1 <= tickets[i] <= 100",
      "0 <= k < n"
    ],
    "hints": [
      "For people before k: min(tickets[i], tickets[k]).",
      "For people at k: tickets[k].",
      "For people after k: min(tickets[i], tickets[k] - 1)."
    ],
    "relatedProblems": [
      "number-of-students-unable-to-eat-lunch"
    ],
    "videoId": "cVmS9N6kf2Y",
    "problemStatement": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\nYou are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\nEach person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\nReturn the time taken for the person initially at position k (0-indexed) to finish buying tickets.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use two pointers to simulate buying tickets in a queue.",
    "suggestedNextQuestion": {
      "slug": "two-sum-ii---input-array-is-sorted",
      "title": "Two Sum II - Input Array Is Sorted",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def time_needed_to_buy(self, tickets, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def timeRequiredToBuy(tickets, k):\n    time = 0\n    while tickets[k] > 0:\n        for i in range(len(tickets)):\n            if tickets[k] == 0: break\n            if tickets[i] > 0:\n                tickets[i] -= 1\n                time += 1\n    return time"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Track the time taken for each person to buy their ticket using two pointers.",
          "Adjust pointers based on the number of tickets needed and available."
        ],
        "code": "def time_needed_to_buy(tickets, k):\n    \"\"\"\n    Intuition:\n    - Track the time taken for each person to buy their ticket using two pointers.\n    - Adjust pointers based on the number of tickets needed and available.\n    \"\"\"\n    time = 0\n    n = len(tickets)\n    while tickets[k] > 0:\n        for i in range(n):  # Iterate through the range.\n            if tickets[i] == 0:\n                continue\n            tickets[i] -= 1\n            time += 1\n            if tickets[k] == 0:\n                return time"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    timeRequiredToBuy(tickets, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} tickets, k\n     * @return {any}\n     */\n    timeRequiredToBuy(tickets, k) {\n        const target = tickets[k];\n        let result = 0;\n\n        for (let i = 0; i < tickets.length; i++) {\n          if (i <= k) {\n            result += Math.min(tickets[i], target);\n          } else {\n            result += Math.min(tickets[i], target - 1);\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int timeRequiredToBuy(int[] tickets, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int timeRequiredToBuy(int[] tickets, int k) {\n        int ans = 0;\n        for (int i = 0; i < tickets.length; ++i) {\n            ans += Math.min(tickets[i], i <= k ? tickets[k] : tickets[k] - 1);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\n        int ans = 0;\n        for (int i = 0; i < tickets.size(); ++i) {\n            ans += min(tickets[i], i <= k ? tickets[k] : tickets[k] - 1);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) timeRequiredToBuy(tickets []int, k int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) timeRequiredToBuy(tickets []int, k int) (ans int) {\n\tfor i, x := range tickets {\n\t\tt := tickets[k]\n\t\tif i > k {\n\t\t\tt--\n\t\t}\n\t\tans += min(x, t)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn time_needed_to_buy(tickets: i32, k: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn time_required_to_buy(tickets: Vec<i32>, k: i32) -> i32 {\n        let mut res = 0;\n        let n = tickets.len();\n        let mut arr = vec![0; n];\n        let mut i = 0;\n        let k = k as usize;\n        while arr[k] != tickets[k] {\n            if arr[i] < tickets[i] {\n                arr[i] += 1;\n                res += 1;\n            }\n\n            i += 1;\n            i %= n;\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let tickets = vec![2, 3, 2];\n    let k = 2;\n    let res = 6;\n    assert_eq!(Solution::time_required_to_buy(tickets, k), res);\n    let tickets = vec![5, 1, 1, 1];\n    let k = 0;\n    let res = 8;\n    assert_eq!(Solution::time_required_to_buy(tickets, k), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def time_needed_to_buy(self, tickets, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    time_needed_to_buy(tickets: number[], k: number): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    time_needed_to_buy(tickets: number[], k: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "minimum-absolute-difference": {
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Sort the array and use two pointers to find the minimum absolute difference.",
    "intuition": [
      "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
      "Two pointers starting from consecutive positions can efficiently track the smallest difference."
    ],
    "visualizationType": "array",
    "initialState": [
      4,
      2,
      1,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Absolute Difference",
        "transientMessage": "Input: [4, 2, 1, 3]",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 4",
        "transientMessage": "Step 1 of 4",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 4",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 1",
        "transientMessage": "Step 3 of 4",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 3",
        "transientMessage": "Step 4 of 4",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def minimumAbsDifference(self, nums):\n        \"\"\"\n        Intuition:\n        - Sorting helps in easily finding the closest pairs by comparing adjacent elements.\n        - Two pointers starting from consecutive positions can efficiently track the smallest difference.\n        \"\"\"\n        nums.sort()\n        min_diff = float('inf')\n        result = []\n        for i in range(1, len(nums)):  # Iterate through the range.\n            diff = nums[i] - nums[i-1]\n            if diff < min_diff:\n                min_diff = diff\n                result = [[nums[i-1], nums[i]]]\n            elif diff == min_diff:\n                result.append([nums[i-1], nums[i]])  # Add to end.\n        return result  # Return the final result.",
    "keyInsight": "Sorting the array allows us to only check adjacent elements for the minimum difference.",
    "testCases": [
      {
        "input": "arr = [4,2,1,3]",
        "output": "[[1,2],[2,3],[3,4]]"
      },
      {
        "input": "arr = [1,3,6,10,15]",
        "output": "[[1,3]]"
      },
      {
        "input": "arr = [3,8,-10,23,19,-4,-14,27]",
        "output": "[[-14,-10],[19,23],[23,27]]"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Minimum Absolute Difference",
    "description": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order (with respect to pairs), each pair [a, b] follows a < b.",
    "examples": [
      {
        "input": "arr = [4,2,1,3]",
        "output": "[[1,2],[2,3],[3,4]]",
        "explanation": "Min diff is 1, all adjacent pairs after sorting."
      },
      {
        "input": "arr = [1,3,6,10,15]",
        "output": "[[1,3]]",
        "explanation": "Min diff is 2."
      }
    ],
    "constraints": [
      "2 <= arr.length <= 10^5",
      "-10^6 <= arr[i] <= 10^6"
    ],
    "hints": [
      "Sort the array first.",
      "Minimum difference must be between adjacent elements.",
      "Find min diff, then collect all pairs with that diff."
    ],
    "relatedProblems": [
      "minimum-absolute-difference-in-bst",
      "k-diff-pairs-in-an-array"
    ],
    "videoId": "mH1aEjOEjcQ",
    "problemStatement": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Sort the array and use two pointers to find the minimum absolute difference.",
    "suggestedNextQuestion": {
      "slug": "minimum-time-visiting-all-points",
      "title": "Minimum Time Visiting All Points",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def minimumAbsDifference(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def minimumAbsDifference(arr):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        min_diff = min(min_diff, arr[i+1] - arr[i])\n    \n    res = []\n    for i in range(len(arr) - 1):\n        if arr[i+1] - arr[i] == min_diff:\n            res.append([arr[i], arr[i+1]])\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
          "Two pointers starting from consecutive positions can efficiently track the smallest difference."
        ],
        "code": "def minimumAbsDifference(nums):\n    \"\"\"\n    Intuition:\n    - Sorting helps in easily finding the closest pairs by comparing adjacent elements.\n    - Two pointers starting from consecutive positions can efficiently track the smallest difference.\n    \"\"\"\n    nums.sort()\n    min_diff = float('inf')\n    result = []\n    for i in range(1, len(nums)):  # Iterate through the range.\n        diff = nums[i] - nums[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = [[nums[i-1], nums[i]]]\n        elif diff == min_diff:\n            result.append([nums[i-1], nums[i]])  # Add to end.\n    return result  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minimumAbsDifference(arr) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} arr\n     * @return {any}\n     */\n    minimumAbsDifference(arr) {\n        arr.sort((a, b) => a - b);\n\n        const min = arr.reduce((m, n, i) => Math.min(m, n - (arr[i - 1] ?? -Infinity)), Infinity);\n        return arr.reduce((result, n, i) => {\n          if (min === n - arr[i - 1]) {\n            result.push([arr[i - 1], n]);\n      }\n      return result;\n    }, []);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> minimumAbsDifference(int[] arr) {\n        Arrays.sort(arr);\n        int n = arr.length;\n        int mi = 1 << 30;\n        for (int i = 0; i < n - 1; ++i) {\n            mi = Math.min(mi, arr[i + 1] - arr[i]);\n        }\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n - 1; ++i) {\n            if (arr[i + 1] - arr[i] == mi) {\n                ans.add(List.of(arr[i], arr[i + 1]));\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int mi = 1 << 30;\n        int n = arr.size();\n        for (int i = 0; i < n - 1; ++i) {\n            mi = min(mi, arr[i + 1] - arr[i]);\n        }\n        vector<vector<int>> ans;\n        for (int i = 0; i < n - 1; ++i) {\n            if (arr[i + 1] - arr[i] == mi) {\n                ans.push_back({arr[i], arr[i + 1]});\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minimumAbsDifference(arr []int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minimumAbsDifference(arr []int) (ans [][]int) {\n\tsort.Ints(arr)\n\tmi := 1 << 30\n\tn := len(arr)\n\tfor i := 0; i < n-1; i++ {\n\t\tif t := arr[i+1] - arr[i]; t < mi {\n\t\t\tmi = t\n\t\t}\n\t}\n\tfor i := 0; i < n-1; i++ {\n\t\tif arr[i+1]-arr[i] == mi {\n\t\t\tans = append(ans, []int{arr[i], arr[i+1]})\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn minimum_abs_difference(nums: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::i32;\n\nimpl Solution {\n    fn minimum_abs_difference(mut arr: Vec<i32>) -> Vec<Vec<i32>> {\n        arr.sort_unstable();\n        let min = arr\n            .windows(2)\n            .fold(i32::MAX, |x, v| i32::min(x, v[1] - v[0]));\n        let mut res: Vec<Vec<i32>> = vec![];\n        for v in arr.windows(2) {\n            if v[1] - v[0] == min {\n                res.push(v.to_vec())\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let arr = vec![4, 2, 1, 3];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 2], [2, 3], [3, 4]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n    let arr = vec![1, 3, 6, 10, 15];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[1, 3]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n    let arr = vec![3, 8, -10, 23, 19, -4, -14, 27];\n    let res: Vec<Vec<i32>> = vec_vec_i32![[-14, -10], [19, 23], [23, 27]];\n    assert_eq!(Solution::minimum_abs_difference(arr), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minimumAbsDifference(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minimumAbsDifference(arr: number[]): number[][]  {\n    arr.sort((a, b) => a - b);\n    let mi = 1 << 30;\n    const n = arr.length;\n    for (let i = 0; i < n - 1; ++i) {\n        mi = Math.min(mi, arr[i + 1] - arr[i]);\n    }\n    const ans: number[][] = [];\n    for (let i = 0; i < n - 1; ++i) {\n        if (arr[i + 1] - arr[i] === mi) {\n            ans.push([arr[i], arr[i + 1]]);\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    minimumAbsDifference(arr: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "missing-number": {
    "pattern": "Math",
    "patternEmoji": "\u2716\ufe0f\u2795",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Calculate the expected sum and subtract the actual sum.",
    "intuition": [
      "Use the formula for the sum of the first n natural numbers.",
      "Subtract the actual sum from this expected sum to find the missing number."
    ],
    "visualizationType": "array",
    "initialState": [
      3,
      0,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [3, 0, 1], n=3",
        "transientMessage": "Sum formula: n*(n+1)/2",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Expected sum: 3*4/2 = 6",
        "transientMessage": "Sum of 0 to n",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Add 3: sum = 3",
        "transientMessage": "Running total",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Add 0: sum = 3",
        "transientMessage": "Running total",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Add 1: sum = 4",
        "transientMessage": "Running total",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Missing: 6 - 4 = 2",
        "transientMessage": "Found missing number!",
        "arrayState": [
          3,
          0,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def missingNumber(self, nums):\n        \"\"\"\n        Intuition:\n        - Use the formula for the sum of the first n natural numbers.\n        - Subtract the actual sum from this expected sum to find the missing number.\n        \"\"\"\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2  # Gauss formula for sum of N numbers.\n        actual_sum = sum(nums)  # Calculate sum of all elements.\n        return expected_sum - actual_sum",
    "keyInsight": "The sum of numbers from 0 to n is a known formula: n(n+1)/2.",
    "testCases": [
      {
        "input": "nums = [3,0,1]",
        "output": "2"
      },
      {
        "input": "nums = [0,1]",
        "output": "2"
      },
      {
        "input": "nums = [9,6,4,2,3,5,7,0,1]",
        "output": "8"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Missing Number",
    "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "examples": [
      {
        "input": "nums = [3,0,1]",
        "output": "2",
        "explanation": "n = 3, range is [0,3], 2 is missing."
      },
      {
        "input": "nums = [0,1]",
        "output": "2",
        "explanation": "n = 2, range is [0,2], 2 is missing."
      }
    ],
    "constraints": [
      "n == nums.length",
      "1 <= n <= 10^4",
      "0 <= nums[i] <= n",
      "All numbers in nums are unique."
    ],
    "hints": [
      "Use XOR: XOR all numbers 0 to n, then XOR with array.",
      "Or use sum formula: n*(n+1)/2 - sum(nums).",
      "Both approaches are O(n) time, O(1) space."
    ],
    "relatedProblems": [
      "single-number",
      "find-the-duplicate-number",
      "first-missing-positive"
    ],
    "videoId": "WnPLSRLSANE",
    "problemStatement": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "difficulty": "Easy",
    "walkthrough": [
      "Identify mathematical pattern or formula",
      "Handle edge cases (zero, negative, overflow)",
      "Apply mathematical operations",
      "Optimize with mathematical properties",
      "Return computed result"
    ],
    "approach": "Math: Calculate the expected sum and subtract the actual sum.",
    "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
    "initialCode": "class Solution:\n    def missingNumber(self, nums):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def missingNumber(nums):\n    n = len(nums)\n    # Check 0 to n\n    for i in range(n + 1):\n        if i not in nums:\n            return i"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use the formula for the sum of the first n natural numbers.",
          "Subtract the actual sum from this expected sum to find the missing number."
        ],
        "code": "def missingNumber(nums):\n    \"\"\"\n    Intuition:\n    - Use the formula for the sum of the first n natural numbers.\n    - Subtract the actual sum from this expected sum to find the missing number.\n    \"\"\"\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2  # Gauss formula for sum of N numbers.\n    actual_sum = sum(nums)  # Calculate sum of all elements.\n    return expected_sum - actual_sum"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    missingNumber(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    missingNumber(nums) {\n        const n = nums.length;\n        let ans = n;\n        for (let i = 0; i < n; ++i) {\n            ans ^= i ^ nums[i];\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int missingNumber(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            ans ^= (i ^ nums[i]);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int missingNumber(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            ans ^= (i ^ nums[i]);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) missingNumber(nums []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) missingNumber(nums []int) (ans int) {\n\tn := len(nums)\n\tans = n\n\tfor i, v := range nums {\n\t\tans ^= (i ^ v)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn missing_number(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn missing_number(nums: Vec<i32>) -> i32 {\n        let n = nums.len() as i32;\n        let mut ans = n;\n        for (i, v) in nums.iter().enumerate() {\n            ans ^= (i as i32) ^ v;\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def missingNumber(self, nums):\n        \"\"\"\n        Intuition:\n        - Use the formula for the sum of the first n natural numbers.\n        - Subtract the actual sum from this expected sum to find the missing number.\n        \"\"\"\n        n = len(nums)\n        expected_sum = n * (n + 1) // 2  # Gauss formula for sum of N numbers.\n        actual_sum = sum(nums)  # Calculate sum of all elements.\n        return expected_sum - actual_sum"
      },
      "typescript": {
        "code": "class Solution {\n    missingNumber(nums: number[]): number  {\n    const n = nums.length;\n    let ans = n;\n    for (let i = 0; i < n; ++i) {\n        ans ^= i ^ nums[i];\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    missingNumber(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "reverse-integer",
      "title": "Reverse Integer",
      "difficulty": "Medium",
      "pattern": "Math"
    }
  },
  "minimum-time-visiting-all-points": {
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use two pointers to traverse points and calculate min time.",
    "intuition": [
      "Calculate the time to move from one point to another using Manhattan distance.",
      "Traverse through all points sequentially."
    ],
    "visualizationType": "array",
    "initialState": [
      [
        1,
        1
      ],
      [
        3,
        4
      ],
      [
        -1,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Time Visiting All Points",
        "transientMessage": "Input: [1,1, 3,4, -1,0]",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1,1",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 3,4",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: -1,0",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          [
            1,
            1
          ],
          [
            3,
            4
          ],
          [
            -1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def minTimeToVisitAllPoints(self, points):\n        \"\"\"\n        Intuition:\n        - Calculate the time to move from one point to another using Manhattan distance.\n        - Traverse through all points sequentially.\n        \"\"\"\n        total_time = 0\n        for i in range(len(points) - 1):  # Iterate through the range.\n            current_point = points[i]\n            next_point = points[i + 1]\n            time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))  # Take the maximum value.\n            total_time += time_to_next\n        return total_time",
    "keyInsight": "Manhattan distance gives the minimum time to move between two points.",
    "testCases": [
      {
        "input": "points = [[1,1],[3,4],[-1,0]]",
        "output": "7"
      },
      {
        "input": "points = [[3,2],[-2,2]]",
        "output": "5"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Minimum Time Visiting All Points",
    "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move diagonally 1 unit in 1 second, or move horizontally or vertically 1 unit in 1 second.",
    "examples": [
      {
        "input": "points = [[1,1],[3,4],[-1,0]]",
        "output": "7",
        "explanation": "(1,1) to (3,4) = 3 steps, (3,4) to (-1,0) = 4 steps."
      },
      {
        "input": "points = [[3,2],[-2,2]]",
        "output": "5",
        "explanation": "5 horizontal steps."
      }
    ],
    "constraints": [
      "points.length == n",
      "1 <= n <= 100",
      "-1000 <= points[i][0], points[i][1] <= 1000"
    ],
    "hints": [
      "For two points, time = max(|dx|, |dy|).",
      "Chebyshev distance works here.",
      "Sum distances between consecutive points."
    ],
    "relatedProblems": [
      "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
    ],
    "videoId": "5BuKVS-Vnws",
    "problemStatement": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\nYou can move according to these rules:",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use two pointers to traverse points and calculate min time.",
    "suggestedNextQuestion": {
      "slug": "remove-duplicates-from-sorted-array-ii",
      "title": "Remove Duplicates from Sorted Array II",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def minTimeToVisitAllPoints(self, points):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(len(points) - 1):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        time += max(abs(x2 - x1), abs(y2 - y1))\n    return time"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Calculate the time to move from one point to another using Manhattan distance.",
          "Traverse through all points sequentially."
        ],
        "code": "def minTimeToVisitAllPoints(points):\n    \"\"\"\n    Intuition:\n    - Calculate the time to move from one point to another using Manhattan distance.\n    - Traverse through all points sequentially.\n    \"\"\"\n    total_time = 0\n    for i in range(len(points) - 1):  # Iterate through the range.\n        current_point = points[i]\n        next_point = points[i + 1]\n        time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))  # Take the maximum value.\n        total_time += time_to_next\n    return total_time"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minTimeToVisitAllPoints(points) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} points\n     * @return {any}\n     */\n    minTimeToVisitAllPoints(points) {\n        return points.reduce((steps, point, i) => steps + (!points[i + 1] ? 0 : Math.max(\n          Math.abs(point[0] - points[i + 1][0]), Math.abs(point[1] - points[i + 1][1])\n        )), 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int ans = 0;\n        for (int i = 1; i < points.length; ++i) {\n            int dx = Math.abs(points[i][0] - points[i - 1][0]);\n            int dy = Math.abs(points[i][1] - points[i - 1][1]);\n            ans += Math.max(dx, dy);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 1; i < points.size(); ++i) {\n            int dx = abs(points[i][0] - points[i - 1][0]);\n            int dy = abs(points[i][1] - points[i - 1][1]);\n            ans += max(dx, dy);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minTimeToVisitAllPoints(points [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minTimeToVisitAllPoints(points [][]int) (ans int) {\n\tfor i, p := range points[1:] {\n\t\tdx := abs(p[0] - points[i][0])\n\t\tdy := abs(p[1] - points[i][1])\n\t\tans += max(dx, dy)\n\t}\n\treturn\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_time_to_visit_all_points(points: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_time_to_visit_all_points(points: Vec<Vec<i32>>) -> i32 {\n        let n = points.len();\n        let mut ans = 0;\n        for i in 1..n {\n            let x = (points[i - 1][0] - points[i][0]).abs();\n            let y = (points[i - 1][1] - points[i][1]).abs();\n            ans += x.max(y);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minTimeToVisitAllPoints(self, points):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minTimeToVisitAllPoints(points: number[][]): number  {\n    let ans = 0;\n    for (let i = 1; i < points.length; i++) {\n        let dx = Math.abs(points[i][0] - points[i - 1][0]),\n            dy = Math.abs(points[i][1] - points[i - 1][1]);\n        ans += Math.max(dx, dy);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    minTimeToVisitAllPoints(points: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "fizz-buzz": {
    "pattern": "Iterative",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
    "intuition": [
      "Check each number for divisibility by 3 and 5.",
      "Use modulo operation to determine if a number is divisible."
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Fizz Buzz",
        "transientMessage": "Input: [1, 2, 3, 4, 5, 6, 7, 8...]",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 3",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 4",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 5",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def fizzBuzz(self, n):\n        \"\"\"\n        Intuition:\n        - Check each number for divisibility by 3 and 5.\n        - Use modulo operation to determine if a number is divisible.\n        \"\"\"\n        result = []\n        for i in range(1, n+1):  # Iterate through the range.\n            if i % 15 == 0:\n                result.append('FizzBuzz')  # Add to end.\n            elif i % 3 == 0:\n                result.append('Fizz')  # Add to end.\n            elif i % 5 == 0:\n                result.append('Buzz')  # Add to end.\n            else:\n                result.append(str(i))  # Add to end.\n        return result  # Return the final result.",
    "keyInsight": "Modulo operation helps in checking divisibility efficiently.",
    "testCases": [
      {
        "input": "n = 3",
        "output": "[\"1\",\"2\",\"Fizz\"]"
      },
      {
        "input": "n = 5",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
      },
      {
        "input": "n = 15",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Fizz Buzz",
    "description": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5, answer[i] == \"Fizz\" if i is divisible by 3, answer[i] == \"Buzz\" if i is divisible by 5, answer[i] == i (as a string) if none of the above conditions are true.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"1\",\"2\",\"Fizz\"]",
        "explanation": "1 and 2 are neither, 3 is divisible by 3."
      },
      {
        "input": "n = 5",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
        "explanation": "5 is divisible by 5."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4"
    ],
    "hints": [
      "Check divisibility by 15 first (3 AND 5).",
      "Then check 3, then 5, then default to number.",
      "Use string concatenation for cleaner code."
    ],
    "relatedProblems": [
      "fizz-buzz-multithreaded"
    ],
    "videoId": "AfxHGNRtFac",
    "problemStatement": "Given an integer n, return a string array answer (1-indexed) where:",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Iterative: Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def fizzBuzz(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def fizzBuzz(n):\n    res = []\n    for i in range(1, n + 1):\n        s = \"\"\n        if i % 3 == 0: s += \"Fizz\"\n        if i % 5 == 0: s += \"Buzz\"\n        if not s: s = str(i)\n        res.append(s)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Check each number for divisibility by 3 and 5.",
          "Use modulo operation to determine if a number is divisible."
        ],
        "code": "def fizzBuzz(n):\n    \"\"\"\n    Intuition:\n    - Check each number for divisibility by 3 and 5.\n    - Use modulo operation to determine if a number is divisible.\n    \"\"\"\n    result = []\n    for i in range(1, n+1):  # Iterate through the range.\n        if i % 15 == 0:\n            result.append('FizzBuzz')  # Add to end.\n        elif i % 3 == 0:\n            result.append('Fizz')  # Add to end.\n        elif i % 5 == 0:\n            result.append('Buzz')  # Add to end.\n        else:\n            result.append(str(i))  # Add to end.\n    return result  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    fizzBuzz(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nclass Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    fizzBuzz(n) {\n        const ans = [];\n        for (let i = 1; i <= n; ++i) {\n            if (i % 15 === 0) {\n                ans.push('FizzBuzz');\n            } else if (i % 3 === 0) {\n                ans.push('Fizz');\n            } else if (i % 5 === 0) {\n                ans.push('Buzz');\n            } else {\n                ans.push(`${i}`);\n            }\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> fizzBuzz(int n) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String> ans = new ArrayList<>();\n        for (int i = 1; i <= n; ++i) {\n            String s = \"\";\n            if (i % 3 == 0) {\n                s += \"Fizz\";\n            }\n            if (i % 5 == 0) {\n                s += \"Buzz\";\n            }\n            if (s.length() == 0) {\n                s += i;\n            }\n            ans.add(s);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> fizzBuzz(int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> fizzBuzz(int n) {\n        vector<string> ans;\n        for (int i = 1; i <= n; ++i) {\n            string s = \"\";\n            if (i % 3 == 0) {\n                s += \"Fizz\";\n            }\n            if (i % 5 == 0) {\n                s += \"Buzz\";\n            }\n            if (s.empty()) {\n                s = to_string(i);\n            }\n            ans.push_back(s);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) fizzBuzz(n int) []string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) fizzBuzz(n int) []string {\n\tans := make([]string, 0, n)\n\tfor i := 1; i < n+1; i++ {\n\t\tswitch {\n\t\tcase i%15 == 0:\n\t\t\tans = append(ans, \"FizzBuzz\")\n\t\tcase i%3 == 0:\n\t\t\tans = append(ans, \"Fizz\")\n\t\tcase i%5 == 0:\n\t\t\tans = append(ans, \"Buzz\")\n\t\tdefault:\n\t\t\tans = append(ans, strconv.Itoa(i))\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn fizz_buzz(n: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn fizz_buzz(n: i32) -> Vec<String> {\n        let mut res = vec![];\n        for i in 1..=n {\n            let fizz = i % 3 == 0;\n            let buzz = i % 5 == 0;\n            let s = match (fizz, buzz) {\n                (true, true) => \"FizzBuzz\".to_string(),\n                (true, false) => \"Fizz\".to_string(),\n                (false, true) => \"Buzz\".to_string(),\n                (false, false) => format!(\"{}\", i),\n            };\n            res.push(s);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let output: Vec<String> = vec_string![\n        \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\",\n        \"FizzBuzz\"\n    ];\n    assert_eq!(Solution::fizz_buzz(15), output);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def fizzBuzz(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    fizzBuzz(n: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    fizzBuzz(n: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "reverse-linked-list",
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "pattern": "Iterative Pointer Swap"
    }
  },
  "count-and-say": {
    "pattern": "Iterative with String Manipulation",
    "patternEmoji": "\ud83d\udd04\ud83d\udcac",
    "timeComplexity": "O(n * m)",
    "spaceComplexity": "O(m)",
    "oneliner": "Iteratively build each sequence by counting and saying the previous one.",
    "intuition": [
      "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
      "Use a loop to count consecutive digits and form the new string accordingly."
    ],
    "visualizationType": "array",
    "initialState": [
      "1"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Count and Say",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "1"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "1"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute result phase 6",
        "transientMessage": "Building solution",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def countAndSay(self, n):\n        \"\"\"\n        Intuition:\n        - Start with the initial '1' and iteratively generate the next sequence by describing the current one.\n        - Use a loop to count consecutive digits and form the new string accordingly.\n        \"\"\"\n        if n == 1:\n            return '1'\n        current = '1'\n        for _ in range(1, n):  # Iterate through the range.\n            next_seq = ''\n            i = 0\n            while i < len(current):\n                count = 1\n                while i + 1 < len(current) and current[i] == current[i + 1]:\n                    i += 1\n                    count += 1\n                next_seq += str(count) + current[i]\n                i += 1\n            current = next_seq\n        return current",
    "keyInsight": "Each number is generated by reading off the digits of the previous number.",
    "testCases": [
      {
        "input": "n = 1",
        "output": "\"1\""
      },
      {
        "input": "n = 4",
        "output": "\"1211\""
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Count and Say",
    "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\", countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1). To determine how you \"say\" a digit string, group it into runs of consecutive identical digits. Then for each group, say the number of digits, then the digit.",
    "examples": [
      {
        "input": "n = 1",
        "output": "\"1\"",
        "explanation": "Base case."
      },
      {
        "input": "n = 4",
        "output": "\"1211\"",
        "explanation": "1 -> 11 -> 21 -> 1211"
      }
    ],
    "constraints": [
      "1 <= n <= 30"
    ],
    "hints": [
      "Build iteratively from 1 to n.",
      "For each string, group consecutive digits.",
      "Build next string: count + digit for each group."
    ],
    "relatedProblems": [
      "encode-and-decode-strings",
      "string-compression"
    ],
    "videoId": "htSwmFGdFUI",
    "problemStatement": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the nth element of the count-and-say sequence.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Iterative with String Manipulation: Iteratively build each sequence by counting and saying the previous one.",
    "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
    "initialCode": "class Solution:\n    def countAndSay(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def countAndSay(n):\n    if n == 1: return \"1\"\n    prev = countAndSay(n - 1)\n    res = \"\"\n    i = 0\n    while i < len(prev):\n        count = 1\n        while i + 1 < len(prev) and prev[i] == prev[i+1]:\n            i += 1\n            count += 1\n        res += str(count) + prev[i]\n        i += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n * m)",
        "spaceComplexity": "O(m)",
        "intuition": [
          "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
          "Use a loop to count consecutive digits and form the new string accordingly."
        ],
        "code": "def countAndSay(n):\n    \"\"\"\n    Intuition:\n    - Start with the initial '1' and iteratively generate the next sequence by describing the current one.\n    - Use a loop to count consecutive digits and form the new string accordingly.\n    \"\"\"\n    if n == 1:\n        return '1'\n    current = '1'\n    for _ in range(1, n):  # Iterate through the range.\n        next_seq = ''\n        i = 0\n        while i < len(current):\n            count = 1\n            while i + 1 < len(current) and current[i] == current[i + 1]:\n                i += 1\n                count += 1\n            next_seq += str(count) + current[i]\n            i += 1\n        current = next_seq\n    return current"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    countAndSay(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    countAndSay(n) {\n        let s = '1';\n\n        for (let i = 2; i <= n; i++) {\n            let count = 1,\n                str = '',\n                len = s.length;\n\n            for (let j = 0; j < len; j++) {\n                if (j < len - 1 && s[j] === s[j + 1]) {\n                    count++;\n                } else {\n                    str += `${count}${s[j]}`;\n                    count = 1;\n                }\n            }\n            s = str;\n    }\n    return s;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String countAndSay(int n) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String countAndSay(int n) {\n        String s = \"1\";\n        while (--n > 0) {\n            StringBuilder t = new StringBuilder();\n            for (int i = 0; i < s.length();) {\n                int j = i;\n                while (j < s.length() && s.charAt(j) == s.charAt(i)) {\n                    ++j;\n                }\n                t.append((j - i) + \"\");\n                t.append(s.charAt(i));\n                i = j;\n            }\n            s = t.toString();\n        }\n        return s;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string countAndSay(int n) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string countAndSay(int n) {\n        string s = \"1\";\n        while (--n) {\n            string t = \"\";\n            for (int i = 0; i < s.size();) {\n                int j = i;\n                while (j < s.size() && s[j] == s[i]) ++j;\n                t += to_string(j - i);\n                t += s[i];\n                i = j;\n            }\n            s = t;\n        }\n        return s;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) countAndSay(n int) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) countAndSay(n int) string {\n\ts := \"1\"\n\tfor k := 0; k < n-1; k++ {\n\t\tt := &strings.Builder{}\n\t\ti := 0\n\t\tfor i < len(s) {\n\t\t\tj := i\n\t\t\tfor j < len(s) && s[j] == s[i] {\n\t\t\t\tj++\n\t\t\t}\n\t\t\tt.WriteString(strconv.Itoa(j - i))\n\t\t\tt.WriteByte(s[i])\n\t\t\ti = j\n\t\t}\n\t\ts = t.String()\n\t}\n\treturn s\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn count_and_say(n: i32) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::iter::once;\n\nimpl Solution {\n    pub fn count_and_say(n: i32) -> String {\n        (1..n)\n            .fold(vec![1], |curr, _| {\n                let mut next = vec![];\n                let mut slow = 0;\n                for fast in 0..=curr.len() {\n                    if fast == curr.len() || curr[slow] != curr[fast] {\n                        next.extend(once((fast - slow) as u8).chain(once(curr[slow])));\n                        slow = fast;\n                    }\n                }\n                next\n            })\n            .into_iter()\n            .map(|digit| (digit + b'0') as char)\n            .collect()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def countAndSay(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    countAndSay(n: number): string  {\n    let s = '1';\n    for (let i = 1; i < n; i++) {\n        let t = '';\n        let cur = s[0];\n        let count = 1;\n        for (let j = 1; j < s.length; j++) {\n            if (s[j] !== cur) {\n                t += `${count}${cur}`;\n                cur = s[j];\n                count = 0;\n            }\n            count++;\n        }\n        t += `${count}${cur}`;\n        s = t;\n    }\n    return s;\n}\n}",
        "initialCode": "class Solution {\n    countAndSay(n: number): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "coin-change",
      "title": "Coin Change",
      "difficulty": "Medium",
      "pattern": "1D DP"
    }
  },
  "two-sum-iv---input-is-a-bst": {
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Use in-order traversal to collect elements, then apply two-pointer technique.",
    "intuition": [
      "Perform an in-order traversal of the BST to get a sorted list of numbers.",
      "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
    ],
    "visualizationType": "tree",
    "initialState": [
      2,
      7,
      11,
      15
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Two Sum IV - Input is a BST",
        "transientMessage": "Input: [2, 7, 11, 15]",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 2",
        "transientMessage": "Step 1 of 4",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 7",
        "transientMessage": "Step 2 of 4",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 11",
        "transientMessage": "Step 3 of 4",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 15",
        "transientMessage": "Step 4 of 4",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def twoSumBST(self, root, target):\n        \"\"\"\n        Intuition:\n        - Perform an in-order traversal of the BST to get a sorted list of numbers.\n        - Use two pointers starting from ends of this sorted list to find the pair that sums up to the target.\n        \"\"\"\n        def inorder(node):  # Recursive inorder traversal.\n            if not node: return []\n            return inorder(node.left) + [node.val] + inorder(node.right)  # Recursive inorder traversal.\n        nums = inorder(root)  # Recursive inorder traversal.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            current_sum = nums[left] + nums[right]\n            if current_sum == target:\n                return [nums[left], nums[right]]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return []",
    "keyInsight": "The BST in-order traversal provides a sorted array, enabling the two-pointer technique.",
    "testCases": [
      {
        "input": "root = [5,3,6,2,4,null,7], k = 9",
        "output": "[2, 7]"
      },
      {
        "input": "root = [5,3,6,2,4,null,7], k = 28",
        "output": "[]"
      }
    ],
    "generated": true,
    "validationPassed": false,
    "title": "Two Sum IV - Input is a BST",
    "description": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
    "examples": [
      {
        "input": "root = [5,3,6,2,4,null,7], k = 9",
        "output": "true",
        "explanation": "5 + 4 = 9."
      },
      {
        "input": "root = [5,3,6,2,4,null,7], k = 28",
        "output": "false",
        "explanation": "No pair sums to 28."
      }
    ],
    "constraints": [
      "The number of nodes is in range [1, 10^4].",
      "-10^4 <= Node.val <= 10^4",
      "root is guaranteed to be a valid BST.",
      "-10^5 <= k <= 10^5"
    ],
    "hints": [
      "Use in-order traversal to get sorted array, then two pointers.",
      "Or use a hash set while traversing.",
      "For each node, check if k - node.val exists."
    ],
    "relatedProblems": [
      "two-sum",
      "two-sum-ii---input-array-is-sorted",
      "two-sum-iii---data-structure-design"
    ],
    "videoId": "ssL3sHwPeb4",
    "problemStatement": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use in-order traversal to collect elements, then apply two-pointer technique.",
    "suggestedNextQuestion": {
      "slug": "trapping-rain-water",
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def twoSumBST(self, root, target):\n        pass\n\n        def inorder(node):  # Recursive inorder traversal.\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def findTarget(root, k):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    \n    for i in range(len(vals)):\n        for j in range(i + 1, len(vals)):\n            if vals[i] + vals[j] == k:\n                return True\n    return False"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "Perform an in-order traversal of the BST to get a sorted list of numbers.",
          "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
        ],
        "code": "def twoSumBST(root, target):\n    \"\"\"\n    Intuition:\n    - Perform an in-order traversal of the BST to get a sorted list of numbers.\n    - Use two pointers starting from ends of this sorted list to find the pair that sums up to the target.\n    \"\"\"\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return []\n        return inorder(node.left) + [node.val] + inorder(node.right)  # Recursive inorder traversal.\n    nums = inorder(root)  # Recursive inorder traversal.\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // JavaScript implementation\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\npublic:\n    __init__() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findTarget(root *TreeNode, k int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) findTarget(root *TreeNode, k int) bool {\n\tvis := map[int]bool{}\n\tvar dfs func(*TreeNode) bool\n\tdfs = func(root *TreeNode) bool {\n\t\tif root == nil {\n\t\t\treturn false\n\t\t}\n\t\tif vis[k-root.Val] {\n\t\t\treturn true\n\t\t}\n\t\tvis[root.Val] = true\n\t\treturn dfs(root.Left) || dfs(root.Right)\n\t}\n\treturn dfs(root)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::{HashSet, VecDeque};\nuse std::rc::Rc;\nimpl Solution {\n    pub fn find_target(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> bool {\n        let mut set = HashSet::new();\n        let mut q = VecDeque::new();\n        q.push_back(root);\n        while let Some(node) = q.pop_front() {\n            if let Some(node) = node {\n                let mut node = node.as_ref().borrow_mut();\n                if set.contains(&node.val) {\n                    return true;\n                }\n                set.insert(k - node.val);\n                q.push_back(node.left.take());\n                q.push_back(node.right.take());\n            }\n        }\n        false\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def twoSumBST(self, root, target):\n        pass\n\n        def inorder(node):  # Recursive inorder traversal.\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "isomorphic-strings": {
    "title": "Isomorphic Strings",
    "pattern": "Hash Map (Bi-directional)",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
    "intuition": [
      "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
      "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
      "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
    ],
    "testCases": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true"
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false"
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Iterate",
        "visual": "Pair (s[i], t[i]).",
        "explanation": "Check character mapping."
      },
      {
        "step": 2,
        "title": "Check S->T",
        "visual": "MapS[s[i]] exists? Must equal t[i].",
        "explanation": "Forward consistency."
      },
      {
        "step": 3,
        "title": "Check T->S",
        "visual": "MapT[t[i]] exists? Must equal s[i].",
        "explanation": "Backward consistency (No two chars map to same target)."
      }
    ],
    "code": "class Solution:\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf 'egg' -> 'add'. e->a, g->d.\n        - \ud83e\udde0 Must be consistent (1-to-1 mapping).\n        - \ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY.\n\n        Algorithm:\n        1. Iterate - Check character mapping.\n        2. Check S->T - Forward consistency.\n        3. Check T->S - Backward consistency (No two chars map to same target).\n        \"\"\"\n        mapST, mapTS = {}, {}\n        for c1, c2 in zip(s, t):  # Iterate over elements.\n            if (c1 in mapST and mapST[c1] != c2) or \\\n               (c2 in mapTS and mapTS[c2] != c1):\n                return False  # Condition not met.\n            mapST[c1] = c2\n            mapTS[c2] = c1\n        return True  # Condition satisfied.",
    "keyInsight": "Using two maps prevents 'many-to-one' mapping errors (like 'ab' -> 'cc').",
    "visualizationType": "array",
    "initialState": [
      "e",
      "g",
      "g"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "s=\"egg\", t=\"add\"",
        "transientMessage": "Check bijective mapping",
        "arrayState": [
          "e",
          "g",
          "g"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "'e' \u2194 'a'",
        "transientMessage": "Mapping: {\"e\":\"a\"}",
        "arrayState": [
          "e",
          "g",
          "g"
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "'g' \u2194 'd'",
        "transientMessage": "Mapping: {\"e\":\"a\",\"g\":\"d\"}",
        "arrayState": [
          "e",
          "g",
          "g"
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "'g' \u2194 'd'",
        "transientMessage": "Mapping: {\"e\":\"a\",\"g\":\"d\"}",
        "arrayState": [
          "e",
          "g",
          "g"
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Result: true",
        "transientMessage": "Complete!",
        "arrayState": [
          "e",
          "g",
          "g"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": "e->a, g->d"
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false",
        "explanation": "o cannot map to both a and r."
      }
    ],
    "constraints": [
      "1 <= s.length <= 5 * 10^4",
      "t.length == s.length",
      "s and t consist of any valid ascii character."
    ],
    "hints": [
      "Use two hash maps for bidirectional mapping.",
      "Map s[i] to t[i] and t[i] to s[i].",
      "If any mapping conflicts, return false."
    ],
    "relatedProblems": [
      "word-pattern",
      "word-pattern-ii"
    ],
    "videoId": "7yF-U1hLEqQ",
    "problemStatement": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map (Bi-directional): Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
    "suggestedNextQuestion": {
      "slug": "ransom-note",
      "title": "Ransom Note",
      "difficulty": "Easy",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def isIsomorphic(self, s, t):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def isIsomorphic_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
          "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
          "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
        ],
        "code": "def isIsomorphic(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf 'egg' -> 'add'. e->a, g->d.\n    - \ud83e\udde0 Must be consistent (1-to-1 mapping).\n    - \ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY.\n\n    Algorithm:\n    1. Iterate - Check character mapping.\n    2. Check S->T - Forward consistency.\n    3. Check T->S - Backward consistency (No two chars map to same target).\n    \"\"\"\n    mapST, mapTS = {}, {}\n    for c1, c2 in zip(s, t):  # Iterate over elements.\n        if (c1 in mapST and mapST[c1] != c2) or \\\n           (c2 in mapTS and mapTS[c2] != c1):\n            return False  # Condition not met.\n        mapST[c1] = c2\n        mapTS[c2] = c1\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isIsomorphic(s, t) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s, t\n     * @return {any}\n     */\n    isIsomorphic(s, t) {\n        for (let i = 0; i < s.length; i++) {\n          if (s.indexOf(s[i], i + 1) !== t.indexOf(t[i], i + 1)) {\n            return false;\n          }\n      }\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        Map<Character, Character> d1 = new HashMap<>();\n        Map<Character, Character> d2 = new HashMap<>();\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char a = s.charAt(i), b = t.charAt(i);\n            if (d1.containsKey(a) && d1.get(a) != b) {\n                return false;\n            }\n            if (d2.containsKey(b) && d2.get(b) != a) {\n                return false;\n            }\n            d1.put(a, b);\n            d2.put(b, a);\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isIsomorphic(string s, string t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        int d1[256]{};\n        int d2[256]{};\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            char a = s[i], b = t[i];\n            if (d1[a] != d2[b]) {\n                return false;\n            }\n            d1[a] = d2[b] = i + 1;\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isIsomorphic(s string, t string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isIsomorphic(s string, t string) bool {\n\td1 := [256]int{}\n\td2 := [256]int{}\n\tfor i := range s {\n\t\tif d1[s[i]] != d2[t[i]] {\n\t\t\treturn false\n\t\t}\n\t\td1[s[i]] = i + 1\n\t\td2[t[i]] = i + 1\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_isomorphic(s: String, t: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\nimpl Solution {\n    fn help(s: &[u8], t: &[u8]) -> bool {\n        let mut map = HashMap::new();\n        for i in 0..s.len() {\n            if map.contains_key(&s[i]) {\n                if map.get(&s[i]).unwrap() != &t[i] {\n                    return false;\n                }\n            } else {\n                map.insert(s[i], t[i]);\n            }\n        }\n        true\n    }\n\n    pub fn is_isomorphic(s: String, t: String) -> bool {\n        let (s, t) = (s.as_bytes(), t.as_bytes());\n        Self::help(s, t) && Self::help(t, s)\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isIsomorphic(self, s, t):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isIsomorphic(s: string, t: string): boolean  {\n    const d1: number[] = new Array(256).fill(0);\n    const d2: number[] = new Array(256).fill(0);\n    for (let i = 0; i < s.length; ++i) {\n        const a = s.charCodeAt(i);\n        const b = t.charCodeAt(i);\n        if (d1[a] !== d2[b]) {\n            return false;\n        }\n        d1[a] = i + 1;\n        d2[b] = i + 1;\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    isIsomorphic(s: string, t: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "word-pattern": {
    "title": "Word Pattern",
    "pattern": "Hash Map (Bi-directional)",
    "patternEmoji": "\ud83e\udde9",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Same as Isomorphic Strings, but mapping Char -> Word.",
    "intuition": [
      "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
      "\ud83e\udde0 a -> dog, b -> cat.",
      "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
    ],
    "testCases": [
      {
        "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
        "output": "true"
      },
      {
        "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
        "output": "false"
      },
      {
        "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Split",
        "visual": "['dog', 'cat', 'cat', 'dog']",
        "explanation": "Get tokens."
      },
      {
        "step": 2,
        "title": "Length Check",
        "visual": "If len(pattern) != len(words): False.",
        "explanation": "Must match length."
      },
      {
        "step": 3,
        "title": "Bi-Map",
        "visual": "Map P->W and W->P. Check conflicts.",
        "explanation": "Ensure consistency."
      }
    ],
    "code": "class Solution:\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.\n        - \ud83e\udde0 a -> dog, b -> cat.\n        - \ud83d\udca1 Split string by space, then check 1-to-1 mapping.\n\n        Algorithm:\n        1. Split - Get tokens.\n        2. Length Check - Must match length.\n        3. Bi-Map - Ensure consistency.\n        \"\"\"\n        words = s.split()  # Split string into list.\n        if len(pattern) != len(words): return False  # Condition not met.\n        c_to_w, w_to_c = {}, {}\n        for c, w in zip(pattern, words):  # Iterate over elements.\n            if c in c_to_w and c_to_w[c] != w: return False  # Condition not met.\n            if w in w_to_c and w_to_c[w] != c: return False  # Condition not met.\n            c_to_w[c] = w\n            w_to_c[w] = c\n        return True  # Condition satisfied.",
    "keyInsight": "Don't forget to check if lengths differ first!",
    "visualizationType": "array",
    "initialState": "abba -> dog cat cat dog",
    "animationSteps": [
      {
        "step": 1,
        "visual": "pattern=\"abba\", s=\"dog cat cat dog\"",
        "transientMessage": "Split s: [dog, cat, cat, dog]",
        "arrayState": [
          "dog",
          "cat",
          "cat",
          "dog"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "a \u2192 dog",
        "transientMessage": "Map a\u2194dog",
        "arrayState": [
          "dog",
          "cat",
          "cat",
          "dog"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "b \u2192 cat",
        "transientMessage": "Map b\u2194cat",
        "arrayState": [
          "dog",
          "cat",
          "cat",
          "dog"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "b \u2192 cat (check), a \u2192 dog (check)",
        "transientMessage": "All mappings consistent!",
        "arrayState": [
          "dog",
          "cat",
          "cat",
          "dog"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Answer: true",
        "transientMessage": "Pattern matches string \u2705",
        "arrayState": [
          "dog",
          "cat",
          "cat",
          "dog"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.",
    "examples": [
      {
        "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
        "output": "true",
        "explanation": "a->dog, b->cat"
      },
      {
        "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
        "output": "false",
        "explanation": "a cannot map to both dog and fish."
      }
    ],
    "constraints": [
      "1 <= pattern.length <= 300",
      "pattern contains only lowercase letters.",
      "1 <= s.length <= 3000",
      "s contains lowercase letters and spaces."
    ],
    "hints": [
      "Split s by spaces to get words array.",
      "Use two maps: pattern[i] -> word and word -> pattern[i].",
      "Check for conflicts in both directions."
    ],
    "relatedProblems": [
      "isomorphic-strings",
      "word-pattern-ii"
    ],
    "videoId": "W_akoecmCbM",
    "problemStatement": "Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map (Bi-directional): Same as Isomorphic Strings, but mapping Char -> Word.",
    "suggestedNextQuestion": {
      "slug": "contains-duplicate",
      "title": "Contains Duplicate",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def wordPattern(self, pattern, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def wordPattern_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
          "\ud83e\udde0 a -> dog, b -> cat.",
          "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
        ],
        "code": "def wordPattern(pattern, s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.\n    - \ud83e\udde0 a -> dog, b -> cat.\n    - \ud83d\udca1 Split string by space, then check 1-to-1 mapping.\n\n    Algorithm:\n    1. Split - Get tokens.\n    2. Length Check - Must match length.\n    3. Bi-Map - Ensure consistency.\n    \"\"\"\n    words = s.split()  # Split string into list.\n    if len(pattern) != len(words): return False  # Condition not met.\n    c_to_w, w_to_c = {}, {}\n    for c, w in zip(pattern, words):  # Iterate over elements.\n        if c in c_to_w and c_to_w[c] != w: return False  # Condition not met.\n        if w in w_to_c and w_to_c[w] != c: return False  # Condition not met.\n        c_to_w[c] = w\n        w_to_c[w] = c\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    wordPattern(pattern, s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} pattern, s\n     * @return {any}\n     */\n    wordPattern(pattern, s) {\n        const words = s.split(' ');\n        if (pattern.length !== words.length) return false;\n        const map = new Map();\n        return pattern.split('').every((char, i) =>\n          map.has(char)\n            ? map.get(char) === words[i]\n            : !([...map.values()].includes(words[i])) && map.set(char, words[i])\n        );\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[] ws = s.split(\" \");\n        if (pattern.length() != ws.length) {\n            return false;\n        }\n        Map<Character, String> d1 = new HashMap<>();\n        Map<String, Character> d2 = new HashMap<>();\n        for (int i = 0; i < ws.length; ++i) {\n            char a = pattern.charAt(i);\n            String b = ws[i];\n            if (!d1.getOrDefault(a, b).equals(b) || d2.getOrDefault(b, a) != a) {\n                return false;\n            }\n            d1.put(a, b);\n            d2.put(b, a);\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool wordPattern(string pattern, string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        istringstream is(s);\n        vector<string> ws;\n        while (is >> s) {\n            ws.push_back(s);\n        }\n        if (pattern.size() != ws.size()) {\n            return false;\n        }\n        unordered_map<char, string> d1;\n        unordered_map<string, char> d2;\n        for (int i = 0; i < ws.size(); ++i) {\n            char a = pattern[i];\n            string b = ws[i];\n            if ((d1.count(a) && d1[a] != b) || (d2.count(b) && d2[b] != a)) {\n                return false;\n            }\n            d1[a] = b;\n            d2[b] = a;\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) wordPattern(pattern string, s string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) wordPattern(pattern string, s string) bool {\n\tws := strings.Split(s, \" \")\n\tif len(ws) != len(pattern) {\n\t\treturn false\n\t}\n\td1 := map[rune]string{}\n\td2 := map[string]rune{}\n\tfor i, a := range pattern {\n\t\tb := ws[i]\n\t\tif v, ok := d1[a]; ok && v != b {\n\t\t\treturn false\n\t\t}\n\t\tif v, ok := d2[b]; ok && v != a {\n\t\t\treturn false\n\t\t}\n\t\td1[a] = b\n\t\td2[b] = a\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn word_pattern(pattern: String, s: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn word_pattern(pattern: String, s: String) -> bool {\n        let cs1: Vec<char> = pattern.chars().collect();\n        let cs2: Vec<&str> = s.split_whitespace().collect();\n        let n = cs1.len();\n        if n != cs2.len() {\n            return false;\n        }\n        let mut map1 = HashMap::new();\n        let mut map2 = HashMap::new();\n        for i in 0..n {\n            let c = cs1[i];\n            let s = cs2[i];\n            if !map1.contains_key(&c) {\n                map1.insert(c, i);\n            }\n            if !map2.contains_key(&s) {\n                map2.insert(s, i);\n            }\n            if map1.get(&c) != map2.get(&s) {\n                return false;\n            }\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def wordPattern(self, pattern, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    wordPattern(pattern: string, s: string): boolean  {\n    const ws = s.split(' ');\n    if (pattern.length !== ws.length) {\n        return false;\n    }\n    const d1 = new Map<string, string>();\n    const d2 = new Map<string, string>();\n    for (let i = 0; i < pattern.length; ++i) {\n        const a = pattern[i];\n        const b = ws[i];\n        if (d1.has(a) && d1.get(a) !== b) {\n            return false;\n        }\n        if (d2.has(b) && d2.get(b) !== a) {\n            return false;\n        }\n        d1.set(a, b);\n        d2.set(b, a);\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    wordPattern(pattern: string, s: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "group-anagrams": {
    "title": "Group Anagrams",
    "pattern": "Hash Map",
    "patternEmoji": "\ud83d\udcc2",
    "timeComplexity": "O(NK)",
    "spaceComplexity": "O(NK)",
    "oneliner": "Map sorted string (or char-count tuple) to list of strings.",
    "intuition": [
      "\ud83c\udfaf All anagrams have the same 'signature'.",
      "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
      "\ud83d\udca1 Store {signature: [list of words]}."
    ],
    "testCases": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]"
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Hash Key",
        "visual": "\"eat\" -> (1,0,0...1...1) OR \"aet\"",
        "explanation": "Generate canonical key."
      },
      {
        "step": 2,
        "title": "Bucket",
        "visual": "Map[key].append(word).",
        "explanation": "Group them."
      },
      {
        "step": 3,
        "title": "Collect",
        "visual": "Return Map.values()",
        "explanation": "List of lists."
      }
    ],
    "code": "class Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf All anagrams have the same 'signature'.\n        - \ud83e\udde0 Signature = sorted string ('eat' -> 'aet').\n        - \ud83d\udca1 Store {signature: [list of words]}.\n\n        Algorithm:\n        1. Hash Key - Generate canonical key.\n        2. Bucket - Group them.\n        3. Collect - List of lists.\n        \"\"\"\n        from collections import defaultdict\n        res = defaultdict(list)\n        for s in strs:  # Iterate over elements.\n            # Using tuple(sorted(s)) as key\n            # Or char count tuple for O(N) instead of O(N log K)\n            count = [0] * 26\n            for c in s:  # Iterate over elements.\n                count[ord(c) - ord('a')] += 1\n            res[tuple(count)].append(s)  # Add to end.\n        return list(res.values())",
    "keyInsight": "Using a count-tuple `(2, 1, 0...)` as a dictionary key is efficient and avoids sorting overhead.",
    "visualizationType": "array",
    "initialState": [
      "eat",
      "tea",
      "tan",
      "ate",
      "nat",
      "bat"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Group Anagrams",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = eat",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = tea",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = tan",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = ate",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = nat",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = bat",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "eat",
          "tea",
          "tan",
          "ate",
          "nat",
          "bat"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": "Grouped by sorted characters."
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": "Empty string is its own group."
      }
    ],
    "constraints": [
      "1 <= strs.length <= 10^4",
      "0 <= strs[i].length <= 100",
      "strs[i] consists of lowercase English letters."
    ],
    "hints": [
      "Sort each word and use as key.",
      "Or use character count tuple as key.",
      "Group words with same key together."
    ],
    "relatedProblems": [
      "valid-anagram",
      "find-all-anagrams-in-a-string",
      "group-shifted-strings"
    ],
    "videoId": "vzdNOK2oB2E",
    "problemStatement": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map: Map sorted string (or char-count tuple) to list of strings.",
    "suggestedNextQuestion": {
      "slug": "insert-delete-getrandom-o1",
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def groupAnagrams(self, strs):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def groupAnagrams_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(NK)",
        "spaceComplexity": "O(NK)",
        "intuition": [
          "\ud83c\udfaf All anagrams have the same 'signature'.",
          "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
          "\ud83d\udca1 Store {signature: [list of words]}."
        ],
        "code": "def groupAnagrams(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All anagrams have the same 'signature'.\n    - \ud83e\udde0 Signature = sorted string ('eat' -> 'aet').\n    - \ud83d\udca1 Store {signature: [list of words]}.\n\n    Algorithm:\n    1. Hash Key - Generate canonical key.\n    2. Bucket - Group them.\n    3. Collect - List of lists.\n    \"\"\"\n    from collections import defaultdict\n    res = defaultdict(list)\n    for s in strs:  # Iterate over elements.\n        # Using tuple(sorted(s)) as key\n        # Or char count tuple for O(N) instead of O(N log K)\n        count = [0] * 26\n        for c in s:  # Iterate over elements.\n            count[ord(c) - ord('a')] += 1\n        res[tuple(count)].append(s)  # Add to end.\n    return list(res.values())"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    groupAnagrams(strs) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} strs\n     * @return {any}\n     */\n    groupAnagrams(strs) {\n        const map = {};\n\n        strs.forEach(str => {\n          const key = [...str].sort();\n          map[key] = map[key] ? [...map[key], str] : [str];\n        });\n\n        return Object.values(map);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> d = new HashMap<>();\n        for (String s : strs) {\n            char[] t = s.toCharArray();\n            Arrays.sort(t);\n            String k = String.valueOf(t);\n            d.computeIfAbsent(k, key -> new ArrayList<>()).add(s);\n        }\n        return new ArrayList<>(d.values());\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> d;\n        for (auto& s : strs) {\n            string k = s;\n            sort(k.begin(), k.end());\n            d[k].emplace_back(s);\n        }\n        vector<vector<string>> ans;\n        for (auto& [_, v] : d) ans.emplace_back(v);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) groupAnagrams(strs []string) (ans [][]string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) groupAnagrams(strs []string) (ans [][]string) {\n\td := map[string][]string{}\n\tfor _, s := range strs {\n\t\tt := []byte(s)\n\t\tsort.Slice(t, func(i, j int) bool { return t[i] < t[j] })\n\t\tk := string(t)\n\t\td[k] = append(d[k], s)\n\t}\n\tfor _, v := range d {\n\t\tans = append(ans, v)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {\n        let mut map = HashMap::new();\n        for s in strs {\n            let key = {\n                let mut arr = s.chars().collect::<Vec<char>>();\n                arr.sort();\n                arr.iter().collect::<String>()\n            };\n            let val = map.entry(key).or_insert(vec![]);\n            val.push(s);\n        }\n        map.into_iter().map(|(_, v)| v).collect()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def groupAnagrams(self, strs):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    groupAnagrams(strs: string[]): string[][]  {\n    const d: Map<string, string[]> = new Map();\n    for (const s of strs) {\n        const k = s.split('').sort().join('');\n        if (!d.has(k)) {\n            d.set(k, []);\n        }\n        d.get(k)!.push(s);\n    }\n    return Array.from(d.values());\n}\n}",
        "initialCode": "class Solution {\n    groupAnagrams(strs: string[]): string[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "contains-duplicate-ii": {
    "title": "Contains Duplicate II",
    "pattern": "Sliding Window / Hash Map",
    "patternEmoji": "\u26a0\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(k)",
    "oneliner": "Maintain a window of size k using a set; duplicate in window triggers True.",
    "intuition": [
      "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
      "\ud83e\udde0 Keep latest k elements in a set.",
      "\ud83d\udca1 If current num is in set -> found it!"
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,1], k = 3",
        "output": "true"
      },
      {
        "input": "nums = [1,0,1,1], k = 1",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,1,2,3], k = 2",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Expand",
        "visual": "Add nums[i] to window set.",
        "explanation": "Track recent."
      },
      {
        "step": 2,
        "title": "Shrink",
        "visual": "If window size > k, remove nums[i-k].",
        "explanation": "Maintain invariant."
      },
      {
        "step": 3,
        "title": "Check",
        "visual": "nums[i] already in set? True.",
        "explanation": "Collision detected."
      }
    ],
    "code": "class Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).\n        - \ud83e\udde0 Keep latest k elements in a set.\n        - \ud83d\udca1 If current num is in set -> found it!\n\n        Algorithm:\n        1. Expand - Track recent.\n        2. Shrink - Maintain invariant.\n        3. Check - Collision detected.\n        \"\"\"\n        window = set()\n        l = 0\n        for r in range(len(nums)):  # Iterate through the range.\n            if r - l > k:\n                window.remove(nums[l])\n                l += 1\n            if nums[r] in window:\n                return True  # Condition satisfied.\n            window.add(nums[r])\n        return False  # Condition not met.",
    "keyInsight": "Removing the element falling out of the window makes lookups O(1).",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "nums = [1,2,3,1], k = 3",
        "transientMessage": "Sliding window of size k. Track indices in hashmap.",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "i=0: num=1",
        "transientMessage": "1 not seen. map[1]=0",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "i=1: num=2",
        "transientMessage": "2 not seen. map[2]=1",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "i=2: num=3",
        "transientMessage": "3 not seen. map[3]=2",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "i=3: num=1 seen before!",
        "transientMessage": "1 at index 0. |3-0|=3 \u2264 k=3 \u2192 TRUE! \ud83c\udfaf",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          0,
          3
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Answer: true",
        "transientMessage": "Duplicate found within distance k \u2705",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          3
        ],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
    "examples": [
      {
        "input": "nums = [1,2,3,1], k = 3",
        "output": "true",
        "explanation": "nums[0] == nums[3] and 3-0 = 3 <= 3."
      },
      {
        "input": "nums = [1,2,3,1,2,3], k = 2",
        "output": "false",
        "explanation": "Duplicate 1s are 3 apart, not <= 2."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9",
      "0 <= k <= 10^5"
    ],
    "hints": [
      "Use sliding window with hash set of size k.",
      "Or use hash map storing last seen index.",
      "Check if current index - last index <= k."
    ],
    "relatedProblems": [
      "contains-duplicate",
      "contains-duplicate-iii"
    ],
    "videoId": "ypn0aZ0nrL4",
    "problemStatement": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Sliding Window / Hash Map: Maintain a window of size k using a set; duplicate in window triggers True.",
    "suggestedNextQuestion": {
      "slug": "longest-repeating-character-replacement",
      "title": "Longest Repeating Character Replacement",
      "difficulty": "Medium",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def containsNearbyDuplicate_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
          "\ud83e\udde0 Keep latest k elements in a set.",
          "\ud83d\udca1 If current num is in set -> found it!"
        ],
        "code": "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).\n    - \ud83e\udde0 Keep latest k elements in a set.\n    - \ud83d\udca1 If current num is in set -> found it!\n\n    Algorithm:\n    1. Expand - Track recent.\n    2. Shrink - Maintain invariant.\n    3. Check - Collision detected.\n    \"\"\"\n    window = set()\n    l = 0\n    for r in range(len(nums)):  # Iterate through the range.\n        if r - l > k:\n            window.remove(nums[l])\n            l += 1\n        if nums[r] in window:\n            return True  # Condition satisfied.\n        window.add(nums[r])\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    containsNearbyDuplicate(nums, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} nums, k\n     * @return {any}\n     */\n    containsNearbyDuplicate(nums, k) {\n        const d = new Map();\n        for (let i = 0; i < nums.length; ++i) {\n            if (d.has(nums[i]) && i - d.get(nums[i]) <= k) {\n                return true;\n            }\n            d.set(nums[i], i);\n    }\n    return false;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (i - d.getOrDefault(nums[i], -1000000) <= k) {\n                return true;\n            }\n            d.put(nums[i], i);\n        }\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> d;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (d.count(nums[i]) && i - d[nums[i]] <= k) {\n                return true;\n            }\n            d[nums[i]] = i;\n        }\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) containsNearbyDuplicate(nums []int, k int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) containsNearbyDuplicate(nums []int, k int) bool {\n\td := map[int]int{}\n\tfor i, x := range nums {\n\t\tif j, ok := d[x]; ok && i-j <= k {\n\t\t\treturn true\n\t\t}\n\t\td[x] = i\n\t}\n\treturn false\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [219] Contains Duplicate II\n *\n * Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n *\n * <div>\n * Example 1:\n *\n *\n * Input: nums = <span id=\"example-input-1-1\">[1,2,3,1]</span>, k = <span id=\"example-input-1-2\">3</span>\n * Output: <span id=\"example-output-1\">true</span>\n *\n *\n * <div>\n * Example 2:\n *\n *\n * Input: nums = <span id=\"example-input-2-1\">[1,0,1,1]</span>, k = <span id=\"example-input-2-2\">1</span>\n * Output: <span id=\"example-output-2\">true</span>\n *\n *\n * <div>\n * Example 3:\n *\n *\n * Input: nums = <span id=\"example-input-3-1\">[1,2,3,1,2,3]</span>, k = <span id=\"example-input-3-2\">2</span>\n * Output: <span id=\"example-output-3\">false</span>\n *\n * </div>\n * </div>\n * </div>\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/contains-duplicate-ii/\n// discuss: https://leetcode.com/problems/contains-duplicate-ii/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nuse std::collections::HashMap;\nimpl Solution {\n    pub fn contains_nearby_duplicate(nums: Vec<i32>, k: i32) -> bool {\n        let mut map = HashMap::new();\n        for (idx, &num) in nums.iter().enumerate() {\n            match map.get(&num) {\n                Some(v) => {\n                    if idx - v <= k as usize {\n                        return true;\n                    }\n                    map.insert(num, idx);\n                }\n                None => {\n                    map.insert(num, idx);\n                }\n            }\n        }\n        false\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_219() {\n        assert_eq!(\n            Solution::contains_nearby_duplicate(vec![1, 2, 3, 1, 2, 3], 2),\n            false\n        );\n        assert_eq!(\n            Solution::contains_nearby_duplicate(vec![1, 2, 3, 1, 2, 3], 3),\n            true\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    containsNearbyDuplicate(nums: number[], k: number): boolean  {\n    const d: Map<number, number> = new Map();\n    for (let i = 0; i < nums.length; ++i) {\n        if (d.has(nums[i]) && i - d.get(nums[i])! <= k) {\n            return true;\n        }\n        d.set(nums[i], i);\n    }\n    return false;\n}\n}",
        "initialCode": "class Solution {\n    containsNearbyDuplicate(nums: number[], k: number): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "longest-consecutive-sequence": {
    "title": "Longest Consecutive Sequence",
    "pattern": "Hash Set",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
    "intuition": [
      "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
      "\ud83e\udde0 Hash Set gives O(1) lookup.",
      "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
    ],
    "testCases": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4"
      },
      {
        "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
        "output": "9"
      },
      {
        "input": "nums = [1,0,1,2]",
        "output": "3"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Setify",
        "visual": "{100, 4, 200, 1, 3, 2}",
        "explanation": "Remove dupes, fast access."
      },
      {
        "step": 2,
        "title": "Check Start",
        "visual": "Is 100-1 in set? No. Start chain. 100... len 1.\nIs 4-1 (3) in set? Yes. Skip.",
        "explanation": "Ensure single traversal."
      },
      {
        "step": 3,
        "title": "Expand",
        "visual": "At 1: 1 in, 2 in, 3 in, 4 in. Stop. Len 4.",
        "explanation": "Count sequence."
      }
    ],
    "code": "class Solution:\n    def longestConsecutive(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.\n        - \ud83e\udde0 Hash Set gives O(1) lookup.\n        - \ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2).\n\n        Algorithm:\n        1. Setify - Remove dupes, fast access.\n        2. Check Start - Ensure single traversal.\n        3. Expand - Count sequence.\n        \"\"\"\n        numSet = set(nums)\n        longest = 0\n        for n in numSet:  # Iterate over elements.\n            if (n - 1) not in numSet:\n                length = 0\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)  # Take the maximum value.\n        return longest",
    "keyInsight": "Checking `if (n-1) not in set` ensures each sequence is only processed ONCE, making it linear.",
    "visualizationType": "array",
    "initialState": [
      100,
      4,
      200,
      1,
      3,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Consecutive Sequence",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          100,
          4,
          200,
          1,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 100",
        "arrayState": [
          100,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          100,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 4",
        "arrayState": [
          100,
          4,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          100,
          4,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 200",
        "arrayState": [
          100,
          4,
          200,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          100,
          4,
          200,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 1",
        "arrayState": [
          100,
          4,
          200,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          100,
          4,
          200,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 3",
        "arrayState": [
          100,
          4,
          200,
          1,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          100,
          4,
          200,
          1,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          100,
          4,
          200,
          1,
          3,
          0
        ],
        "pointers": [],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          100,
          4,
          200,
          1,
          3,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
    "examples": [
      {
        "input": "nums = [100,4,200,1,3,2]",
        "output": "4",
        "explanation": "Longest consecutive is [1,2,3,4]."
      },
      {
        "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
        "output": "9",
        "explanation": "0 to 8 is 9 consecutive."
      }
    ],
    "constraints": [
      "0 <= nums.length <= 10^5",
      "-10^9 <= nums[i] <= 10^9"
    ],
    "hints": [
      "Put all numbers in a set.",
      "For each number, check if it's the start of a sequence (n-1 not in set).",
      "If so, count consecutive numbers."
    ],
    "relatedProblems": [
      "binary-tree-longest-consecutive-sequence",
      "find-three-consecutive-integers-that-sum-to-a-given-number"
    ],
    "videoId": "P6RZZMu_maU",
    "problemStatement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Set: Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
    "suggestedNextQuestion": {
      "slug": "range-sum-query---immutable",
      "title": "Range Sum Query - Immutable",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def longestConsecutive(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def longestConsecutive(nums):\n    if not nums: return 0\n    nums.sort()\n    longest = 1\n    current = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            if nums[i] == nums[i-1] + 1:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = 1\n    return max(longest, current)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
          "\ud83e\udde0 Hash Set gives O(1) lookup.",
          "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
        ],
        "code": "def longestConsecutive(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.\n    - \ud83e\udde0 Hash Set gives O(1) lookup.\n    - \ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2).\n\n    Algorithm:\n    1. Setify - Remove dupes, fast access.\n    2. Check Start - Ensure single traversal.\n    3. Expand - Count sequence.\n    \"\"\"\n    numSet = set(nums)\n    longest = 0\n    for n in numSet:  # Iterate over elements.\n        if (n - 1) not in numSet:\n            length = 0\n            while (n + length) in numSet:\n                length += 1\n            longest = max(length, longest)  # Take the maximum value.\n    return longest"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    longestConsecutive(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    longestConsecutive(nums) {\n        const s = new Set(nums);\n        let ans = 0;\n        const d = new Map();\n        for (const x of nums) {\n            let y = x;\n            while (s.has(y)) {\n                s.delete(y++);\n            }\n            d.set(x, (d.get(y) || 0) + (y - x));\n            ans = Math.max(ans, d.get(x));\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> s = new HashSet<>();\n        for (int x : nums) {\n            s.add(x);\n        }\n        int ans = 0;\n        Map<Integer, Integer> d = new HashMap<>();\n        for (int x : nums) {\n            int y = x;\n            while (s.contains(y)) {\n                s.remove(y++);\n            }\n            d.put(x, d.getOrDefault(y, 0) + y - x);\n            ans = Math.max(ans, d.get(x));\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int longestConsecutive(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(), nums.end());\n        int ans = 0;\n        unordered_map<int, int> d;\n        for (int x : nums) {\n            int y = x;\n            while (s.contains(y)) {\n                s.erase(y++);\n            }\n            d[x] = (d.contains(y) ? d[y] : 0) + y - x;\n            ans = max(ans, d[x]);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestConsecutive(nums []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestConsecutive(nums []int) (ans int) {\n\ts := map[int]bool{}\n\tfor _, x := range nums {\n\t\ts[x] = true\n\t}\n\td := map[int]int{}\n\tfor _, x := range nums {\n\t\ty := x\n\t\tfor s[y] {\n\t\t\tdelete(s, y)\n\t\t\ty++\n\t\t}\n\t\td[x] = d[y] + y - x\n\t\tans = max(ans, d[x])\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::{HashMap, HashSet};\n\nimpl Solution {\n    pub fn longest_consecutive(nums: Vec<i32>) -> i32 {\n        let mut s: HashSet<i32> = nums.iter().cloned().collect();\n        let mut ans = 0;\n        let mut d: HashMap<i32, i32> = HashMap::new();\n        for &x in &nums {\n            let mut y = x;\n            while s.contains(&y) {\n                s.remove(&y);\n                y += 1;\n            }\n            let length = d.get(&(y)).unwrap_or(&0) + y - x;\n            d.insert(x, length);\n            ans = ans.max(length);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def longestConsecutive(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    longestConsecutive(nums: number[]): number  {\n    const s = new Set(nums);\n    let ans = 0;\n    const d = new Map<number, number>();\n    for (const x of nums) {\n        let y = x;\n        while (s.has(y)) {\n            s.delete(y++);\n        }\n        d.set(x, (d.get(y) || 0) + (y - x));\n        ans = Math.max(ans, d.get(x)!);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    longestConsecutive(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "insert-delete-getrandom-o1": {
    "title": "Insert Delete GetRandom O(1)",
    "pattern": "Hash Map + Dynamic Array",
    "patternEmoji": "\ud83c\udfb2",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(n)",
    "oneliner": "Map stores {val: index}. To delete, swap val with last element, then pop.",
    "intuition": [
      "\ud83c\udfaf List allows O(1) random access (choice).",
      "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
      "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
    ],
    "testCases": [
      {
        "input": "ops = [\"RandomizedSet\",\"insert\",\"remove\",\"getRandom\"]; args = [[],[1],[2],[]]",
        "output": "[null,true,false,1]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Insert",
        "visual": "Append to list. Map[val] = len-1.",
        "explanation": "Easy O(1)."
      },
      {
        "step": 2,
        "title": "Delete",
        "visual": "Val at index `i`. Swap list[i] with list[end]. Update map for swapped item. Pop list.",
        "explanation": "O(1) removal."
      },
      {
        "step": 3,
        "title": "Random",
        "visual": "random.choice(list)",
        "explanation": "Uniform distribution."
      }
    ],
    "code": "class Solution:\n    import random\n    class RandomizedSet:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf List allows O(1) random access (choice).\n        - \ud83e\udde0 Hashmap allows O(1) lookup/delete logic.\n        - \ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!\n    \n        Algorithm:\n        1. Insert - Easy O(1).\n        2. Delete - O(1) removal.\n        3. Random - Uniform distribution.\n        \"\"\"\n            self.valMap = {}\n            self.valList = []\n        def insert(self, val):\n            if val in self.valMap: return False  # Condition not met.\n            self.valMap[val] = len(self.valList)\n            self.valList.append(val)  # Add to end.\n            return True  # Condition satisfied.\n        def remove(self, val):\n            if val not in self.valMap: return False  # Condition not met.\n            idx = self.valMap[val]\n            lastVal = self.valList[-1]\n            self.valList[idx] = lastVal\n            self.valMap[lastVal] = idx\n            self.valList.pop()  # Remove and return last element.\n            del self.valMap[val]\n            return True  # Condition satisfied.\n        def getRandom(self):\n            return random.choice(self.valList)",
    "keyInsight": "The 'Swap and Pop' technique is crucial for O(1) deletions in arrays.",
    "visualizationType": "array",
    "initialState": [
      "RandomizedSet",
      "insert",
      "remove",
      "getRandom"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Insert Delete GetRandom O(1)",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = RandomizedSet",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = insert",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = remove",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = getRandom",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "RandomizedSet",
          "insert",
          "remove",
          "getRandom"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Implement the RandomizedSet class: RandomizedSet() Initializes the object. bool insert(int val) Inserts an item val if not present. Returns true if not present, false otherwise. bool remove(int val) Removes an item val if present. Returns true if present, false otherwise. int getRandom() Returns a random element from the current set. Each element must have the same probability of being returned.",
    "examples": [
      {
        "input": "[[\"RandomizedSet\"],[\"insert\"],[\"remove\"],[\"insert\"],[\"getRandom\"],[\"remove\"],[\"insert\"],[\"getRandom\"]], [[],[1],[2],[2],[],[1],[2],[]]",
        "output": "[null,true,false,true,2,true,false,2]",
        "explanation": "Operations performed in sequence."
      }
    ],
    "constraints": [
      "-2^31 <= val <= 2^31 - 1",
      "At most 2 * 10^5 calls will be made to insert, remove, and getRandom.",
      "There will be at least one element in the data structure when getRandom is called."
    ],
    "hints": [
      "Use array + hash map.",
      "Hash map stores val -> index.",
      "On remove, swap with last element for O(1)."
    ],
    "relatedProblems": [
      "insert-delete-getrandom-o1-duplicates-allowed"
    ],
    "videoId": "j4KwhBziOpg",
    "problemStatement": "Implement the RandomizedSet class:\nYou must implement the functions of the class such that each function works in average O(1) time complexity.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map + Dynamic Array: Map stores {val: index}. To delete, swap val with last element, then pop.",
    "suggestedNextQuestion": {
      "slug": "longest-consecutive-sequence",
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def insert(self, val: int) -> bool:\n        # Insert val if not present, return True if inserted\n        pass\n\n    def remove(self, val: int) -> bool:\n        # Remove val if present, return True if removed\n        pass\n\n    def getRandom(self) -> int:\n        # Return a random element from the set\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf List allows O(1) random access (choice).",
          "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
          "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
        ],
        "code": "import random\nclass RandomizedSet:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf List allows O(1) random access (choice).\n    - \ud83e\udde0 Hashmap allows O(1) lookup/delete logic.\n    - \ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!\n\n    Algorithm:\n    1. Insert - Easy O(1).\n    2. Delete - O(1) removal.\n    3. Random - Uniform distribution.\n    \"\"\"\n        self.valMap = {}\n        self.valList = []\n    def insert(self, val):\n        if val in self.valMap: return False  # Condition not met.\n        self.valMap[val] = len(self.valList)\n        self.valList.append(val)  # Add to end.\n        return True  # Condition satisfied.\n    def remove(self, val):\n        if val not in self.valMap: return False  # Condition not met.\n        idx = self.valMap[val]\n        lastVal = self.valList[-1]\n        self.valList[idx] = lastVal\n        self.valMap[lastVal] = idx\n        self.valList.pop()  # Remove and return last element.\n        del self.valMap[val]\n        return True  # Condition satisfied.\n    def getRandom(self):\n        return random.choice(self.valList)"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "import java.util.*;\n\nclass Solution {\n    private Map<Integer, Integer> map;\n    private List<Integer> list;\n\n    public Solution() {\n        this.map = new HashMap<>();\n        this.list = new ArrayList<>();\n    }\n}",
        "code": "import java.util.*;\n\nclass Solution {\n    private Map<Integer, Integer> map;\n    private List<Integer> list;\n\n    public Solution() {\n        this.map = new HashMap<>();\n        this.list = new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {}\n};",
        "code": "class Solution {\npublic:\n    Solution() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() RandomizedSet {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype RandomizedSet struct {\n\td map[int]int\n\tq []int\n}\n\nfunc (s *Solution) Constructor() RandomizedSet {\n\treturn RandomizedSet{map[int]int{}, []int{}}\n}\n\nfunc (this *RandomizedSet) Insert(val int) bool {\n\tif _, ok := this.d[val]; ok {\n\t\treturn false\n\t}\n\tthis.d[val] = len(this.q)\n\tthis.q = append(this.q, val)\n\treturn true\n}\n\nfunc (this *RandomizedSet) Remove(val int) bool {\n\tif _, ok := this.d[val]; !ok {\n\t\treturn false\n\t}\n\ti := this.d[val]\n\tthis.d[this.q[len(this.q)-1]] = i\n\tthis.q[i] = this.q[len(this.q)-1]\n\tthis.q = this.q[:len(this.q)-1]\n\tdelete(this.d, val)\n\treturn true\n}\n\nfunc (this *RandomizedSet) GetRandom() int {\n\treturn this.q[rand.Intn(len(this.q))]\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * obj := Constructor();\n * param_1 := obj.Insert(val);\n * param_2 := obj.Remove(val);\n * param_3 := obj.GetRandom();\n */"
      },
      "rust": {
        "initialCode": "use rand::Rng;\n\nstruct RandomizedSet {\n    // Your data structure here\n}\n\nimpl RandomizedSet {\n    fn new() -> Self {\n        RandomizedSet {}\n    }\n    \n    fn insert(&mut self, val: i32) -> bool {\n        // Insert val if not present, return true if inserted\n        false\n    }\n    \n    fn remove(&mut self, val: i32) -> bool {\n        // Remove val if present, return true if removed\n        false\n    }\n    \n    fn get_random(&self) -> i32 {\n        // Return a random element from the set\n        0\n    }\n}\n",
        "code": "use rand::Rng;\nuse std::collections::HashSet;\n\nstruct RandomizedSet {\n    list: HashSet<i32>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl RandomizedSet {\n    fn new() -> Self {\n        Self {\n            list: HashSet::new(),\n        }\n    }\n\n    fn insert(&mut self, val: i32) -> bool {\n        self.list.insert(val)\n    }\n\n    fn remove(&mut self, val: i32) -> bool {\n        self.list.remove(&val)\n    }\n\n    fn get_random(&self) -> i32 {\n        let i = rand::thread_rng().gen_range(0, self.list.len());\n        *self.list.iter().collect::<Vec<&i32>>()[i]\n    }\n}"
      },
      "python": {
        "initialCode": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def insert(self, val: int) -> bool:\n        # Insert val if not present, return True if inserted\n        pass\n\n    def remove(self, val: int) -> bool:\n        # Remove val if present, return True if removed\n        pass\n\n    def getRandom(self) -> int:\n        # Return a random element from the set\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "how-many-numbers-are-smaller-than-the-current-number": {
    "title": "How Many Numbers Are Smaller Than the Current Number",
    "pattern": "Bucket Sort / Counting",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1) (range limited)",
    "oneliner": "Count occurrences, prefix sum to find cumulative count smaller.",
    "intuition": [
      "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
      "\ud83e\udde0 Frequency array tracks counts.",
      "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
    ],
    "testCases": [
      {
        "input": "nums = [8,1,2,2,3]",
        "output": "[4,0,1,1,3]"
      },
      {
        "input": "nums = [6,5,4,8]",
        "output": "[2,1,0,3]"
      },
      {
        "input": "nums = [7,7,7,7]",
        "output": "[0,0,0,0]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Count",
        "visual": "Freq array of size 101.",
        "explanation": "Constraints say nums[i] <= 100."
      },
      {
        "step": 2,
        "title": "Prefix Sum",
        "visual": "freq[i] += freq[i-1].",
        "explanation": "Cumulative count."
      },
      {
        "step": 3,
        "title": "Map",
        "visual": "Res[i] = freq[nums[i]-1].",
        "explanation": "Get numbers strictly smaller."
      }
    ],
    "code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.\n        - \ud83e\udde0 Frequency array tracks counts.\n        - \ud83d\udca1 Prefix sums give 'count of numbers <= i'.\n\n        Algorithm:\n        1. Count - Constraints say nums[i] <= 100.\n        2. Prefix Sum - Cumulative count.\n        3. Map - Get numbers strictly smaller.\n        \"\"\"\n        count = [0] * 102\n        for n in nums: count[n+1] += 1  # Iterate over elements.\n        for i in range(1, 102): count[i] += count[i-1]  # Iterate through the range.\n        return [count[n] for n in nums]",
    "keyInsight": "Using the input constraints (0-100) allows faster-than-sorting O(n) solution using counting sort ideas.",
    "visualizationType": "array",
    "initialState": [
      8,
      1,
      2,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: How Many Numbers Are Smaller Than the Current Number",
        "transientMessage": "Input: [8, 1, 2, 2, 3]",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 8",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 1",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 2",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 2",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 3",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          8,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].",
    "examples": [
      {
        "input": "nums = [8,1,2,2,3]",
        "output": "[4,0,1,1,3]",
        "explanation": "For 8, there are 4 smaller numbers."
      },
      {
        "input": "nums = [6,5,4,8]",
        "output": "[2,1,0,3]",
        "explanation": "Count smaller numbers for each."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 500",
      "0 <= nums[i] <= 100"
    ],
    "hints": [
      "Use counting sort since values <= 100.",
      "Build prefix sum of counts.",
      "Answer for nums[i] is prefix[nums[i]]."
    ],
    "relatedProblems": [
      "count-of-smaller-numbers-after-self",
      "reverse-pairs"
    ],
    "videoId": "yajqqld8Svc",
    "problemStatement": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].\nReturn the answer in an array.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Bucket Sort / Counting: Count occurrences, prefix sum to find cumulative count smaller.",
    "mentalModel": "Like tallying votes. Frequency matters more than order.",
    "initialCode": "class Solution:\n    def smallerNumbersThanCurrent(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def smallerNumbersThanCurrent(nums):\n    res = []\n    for i in range(len(nums)):\n        count = 0\n        for j in range(len(nums)):\n            if j != i and nums[j] < nums[i]:\n                count += 1\n        res.append(count)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1) (range limited)",
        "intuition": [
          "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
          "\ud83e\udde0 Frequency array tracks counts.",
          "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
        ],
        "code": "def smallerNumbersThanCurrent(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.\n    - \ud83e\udde0 Frequency array tracks counts.\n    - \ud83d\udca1 Prefix sums give 'count of numbers <= i'.\n\n    Algorithm:\n    1. Count - Constraints say nums[i] <= 100.\n    2. Prefix Sum - Cumulative count.\n    3. Map - Get numbers strictly smaller.\n    \"\"\"\n    count = [0] * 102\n    for n in nums: count[n+1] += 1  # Iterate over elements.\n    for i in range(1, 102): count[i] += count[i-1]  # Iterate through the range.\n    return [count[n] for n in nums]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    smallerNumbersThanCurrent(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    smallerNumbersThanCurrent(nums) {\n        const sorted = nums.slice().sort((a, b) => a - b);\n        return nums.map(num => sorted.indexOf(num));\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] arr = nums.clone();\n        Arrays.sort(arr);\n        for (int i = 0; i < nums.length; ++i) {\n            nums[i] = search(arr, nums[i]);\n        }\n        return nums;\n    }\n\n    private int search(int[] nums, int x) {\n        int l = 0, r = nums.length;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        vector<int> arr = nums;\n        sort(arr.begin(), arr.end());\n        for (int i = 0; i < nums.size(); ++i) {\n            nums[i] = lower_bound(arr.begin(), arr.end(), nums[i]) - arr.begin();\n        }\n        return nums;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) smallerNumbersThanCurrent(nums []int) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) smallerNumbersThanCurrent(nums []int) (ans []int) {\n\tarr := make([]int, len(nums))\n\tcopy(arr, nums)\n\tsort.Ints(arr)\n\tfor i, x := range nums {\n\t\tnums[i] = sort.SearchInts(arr, x)\n\t}\n\treturn nums\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn smaller_numbers_than_current(nums: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn smaller_numbers_than_current(nums: Vec<i32>) -> Vec<i32> {\n        let mut count = vec![0; 101];\n        for &x in &nums {\n            count[x as usize] += 1;\n        }\n        for i in 0..100 {\n            count[i + 1] += count[i]\n        }\n        let mut res = vec![];\n        for &x in &nums {\n            let v = if x == 0 { 0 } else { count[(x - 1) as usize] };\n            res.push(v)\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![8, 1, 2, 2, 3];\n    let res = vec![4, 0, 1, 1, 3];\n    assert_eq!(Solution::smaller_numbers_than_current(nums), res);\n    let nums = vec![6, 5, 4, 8];\n    let res = vec![2, 1, 0, 3];\n    assert_eq!(Solution::smaller_numbers_than_current(nums), res);\n    let nums = vec![7, 7, 7, 7];\n    let res = vec![0, 0, 0, 0];\n    assert_eq!(Solution::smaller_numbers_than_current(nums), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def smallerNumbersThanCurrent(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    smallerNumbersThanCurrent(nums: number[]): number[]  {\n    const search = (nums: number[], x: number) => {\n        let l = 0,\n            r = nums.length;\n        while (l < r) {\n            const mid = (l + r) >> 1;\n            if (nums[mid] >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    };\n    const arr = nums.slice().sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        nums[i] = search(arr, nums[i]);\n    }\n    return nums;\n}\n}",
        "initialCode": "class Solution {\n    smallerNumbersThanCurrent(nums: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "reverse-linked-list",
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "pattern": "Iterative Pointer Swap"
    }
  },
  "simplify-path": {
    "title": "Simplify Path",
    "pattern": "Stack",
    "patternEmoji": "\ud83d\udcc2",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
    "intuition": [
      "\ud83c\udfaf Canonical path logic.",
      "\ud83e\udde0 '..' means go up (pop).",
      "\ud83d\udca1 '.' or empty means stay (ignore)."
    ],
    "testCases": [
      {
        "input": "path = \"/home/\"",
        "output": "\"/home\""
      },
      {
        "input": "path = \"/home//foo/\"",
        "output": "\"/home/foo\""
      },
      {
        "input": "path = \"/home/user/Documents/../Pictures\"",
        "output": "\"/home/user/Pictures\""
      },
      {
        "input": "path = \"/../\"",
        "output": "\"/\""
      },
      {
        "input": "path = \"/.../a/../b/c/../d/./\"",
        "output": "\"/.../b/d\""
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Split",
        "visual": "['a', '.', 'b', '..', '..', 'c']",
        "explanation": "Tokenize."
      },
      {
        "step": 2,
        "title": "Process",
        "visual": "'a': push. '.': skip. 'b': push. '..': pop(b). '..': pop(a). 'c': push.",
        "explanation": "Stack operations."
      },
      {
        "step": 3,
        "title": "Join",
        "visual": "'/' + join(stack)",
        "explanation": "Rebuild."
      }
    ],
    "code": "class Solution:\n    def simplifyPath(self, path):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Canonical path logic.\n        - \ud83e\udde0 '..' means go up (pop).\n        - \ud83d\udca1 '.' or empty means stay (ignore).\n\n        Algorithm:\n        1. Split - Tokenize.\n        2. Process - Stack operations.\n        3. Join - Rebuild.\n        \"\"\"\n        stack = []  # Initialize stack for tracking.\n        for portion in path.split('/'):  # Iterate over elements.\n            if portion == '..':\n                if stack: stack.pop()  # Remove and return last element.\n            elif portion == '.' or not portion:\n                continue\n            else:\n                stack.append(portion)  # Add to end.\n        return '/' + '/'.join(stack)",
    "keyInsight": "Splitting by slash handles multiple slashes `//` automatically (producing empty strings to ignore).",
    "visualizationType": "array",
    "initialState": "/a/./b/../../c/",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Simplify Path",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          "/",
          "b",
          "/",
          ".",
          ".",
          "/",
          ".",
          ".",
          "/",
          "c",
          "/"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = /",
        "arrayState": [
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = a",
        "arrayState": [
          "/",
          "a",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          "/",
          "a",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = /",
        "arrayState": [
          "/",
          "a",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          "/",
          "a",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = .",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = /",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          14
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          "/",
          "a",
          "/",
          ".",
          "/",
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.",
    "examples": [
      {
        "input": "path = \"/home/\"",
        "output": "\"/home\"",
        "explanation": "Remove trailing slash."
      },
      {
        "input": "path = \"/../\"",
        "output": "\"/\"",
        "explanation": "Cannot go above root."
      },
      {
        "input": "path = \"/home//foo/\"",
        "output": "\"/home/foo\"",
        "explanation": "Multiple slashes treated as one."
      }
    ],
    "constraints": [
      "1 <= path.length <= 3000",
      "path consists of English letters, digits, period '.', slash '/' or '_'."
    ],
    "hints": [
      "Split by '/' and use a stack.",
      "Ignore empty strings and '.'. Pop for '..'.",
      "Join stack with '/' at the end."
    ],
    "relatedProblems": [
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "qYlHrAKJfyA",
    "problemStatement": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\nThe rules of a Unix-style file system are as follows:\nThe simplified canonical path should follow these rules:\nReturn the simplified canonical path.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize empty stack",
      "Iterate through elements",
      "Push/pop based on problem logic",
      "Maintain monotonic property if needed",
      "Process remaining stack elements if needed"
    ],
    "approach": "Stack: Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def simplifyPath(self, path):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def simplifyPath_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Canonical path logic.",
          "\ud83e\udde0 '..' means go up (pop).",
          "\ud83d\udca1 '.' or empty means stay (ignore)."
        ],
        "code": "def simplifyPath(path):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Canonical path logic.\n    - \ud83e\udde0 '..' means go up (pop).\n    - \ud83d\udca1 '.' or empty means stay (ignore).\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Process - Stack operations.\n    3. Join - Rebuild.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for portion in path.split('/'):  # Iterate over elements.\n        if portion == '..':\n            if stack: stack.pop()  # Remove and return last element.\n        elif portion == '.' or not portion:\n            continue\n        else:\n            stack.append(portion)  # Add to end.\n    return '/' + '/'.join(stack)"
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    simplifyPath(path) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} path\n     * @return {any}\n     */\n    simplifyPath(path) {\n        const stack = [];\n        for (const segment of path.split('/')) {\n          if (segment === '.' || segment === '') continue;\n          if (segment === '..') stack.pop();\n          else stack.push(segment);\n      }\n    return `/${stack.join('/')}`;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String simplifyPath(String path) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stk = new ArrayDeque<>();\n        for (String s : path.split(\"/\")) {\n            if (\"\".equals(s) || \".\".equals(s)) {\n                continue;\n            }\n            if (\"..\".equals(s)) {\n                stk.pollLast();\n            } else {\n                stk.offerLast(s);\n            }\n        }\n        return \"/\" + String.join(\"/\", stk);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string simplifyPath(string path) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        deque<string> stk;\n        stringstream ss(path);\n        string t;\n        while (getline(ss, t, '/')) {\n            if (t == \"\" || t == \".\") {\n                continue;\n            }\n            if (t == \"..\") {\n                if (!stk.empty()) {\n                    stk.pop_back();\n                }\n            } else {\n                stk.push_back(t);\n            }\n        }\n        if (stk.empty()) {\n            return \"/\";\n        }\n        string ans;\n        for (auto& s : stk) {\n            ans += \"/\" + s;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) simplifyPath(path string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) simplifyPath(path string) string {\n\tvar stk []string\n\tfor _, s := range strings.Split(path, \"/\") {\n\t\tif s == \"\" || s == \".\" {\n\t\t\tcontinue\n\t\t}\n\t\tif s == \"..\" {\n\t\t\tif len(stk) > 0 {\n\t\t\t\tstk = stk[0 : len(stk)-1]\n\t\t\t}\n\t\t} else {\n\t\t\tstk = append(stk, s)\n\t\t}\n\t}\n\treturn \"/\" + strings.Join(stk, \"/\")\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn simplify_path(path: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn simplify_path(path: String) -> String {\n        let mut stk = Vec::new();\n        for s in path.split('/') {\n            match s {\n                \"\" | \".\" => continue,\n                \"..\" => {\n                    stk.pop();\n                }\n                _ => stk.push(s),\n            }\n        }\n        \"/\".to_string() + &stk.join(\"/\")\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def simplifyPath(self, path):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    simplifyPath(path: string): string  {\n    const stk: string[] = [];\n    for (const s of path.split('/')) {\n        if (s === '' || s === '.') {\n            continue;\n        }\n        if (s === '..') {\n            if (stk.length) {\n                stk.pop();\n            }\n        } else {\n            stk.push(s);\n        }\n    }\n    return '/' + stk.join('/');\n}\n}",
        "initialCode": "class Solution {\n    simplifyPath(path: string): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "evaluate-reverse-polish-notation",
      "title": "Evaluate Reverse Polish Notation",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "min-stack": {
    "title": "Min Stack",
    "pattern": "Stack (Two Stacks)",
    "patternEmoji": "\u2b07\ufe0f",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(n)",
    "oneliner": "Maintain a second stack tracking the minimum value at each depth.",
    "intuition": [
      "\ud83c\udfaf Get Min in O(1).",
      "\ud83e\udde0 Normal stack holds values.",
      "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
    ],
    "testCases": [
      {
        "input": "ops = [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]; args = [[],[-2],[0],[-3],[],[],[],[]]",
        "output": "[null,null,null,null,-3,null,0,-2]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Push",
        "visual": "Main: [-2]. MinStack: [-2].",
        "explanation": "Init."
      },
      {
        "step": 2,
        "title": "Push Smaller",
        "visual": "Main: [-2, -3]. MinStack: [-2, -3].",
        "explanation": "New min found."
      },
      {
        "step": 3,
        "title": "Pop",
        "visual": "Pop both. Min reverts to -2.",
        "explanation": "Sync."
      }
    ],
    "code": "class Solution:\n    class MinStack:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Get Min in O(1).\n        - \ud83e\udde0 Normal stack holds values.\n        - \ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both.\n    \n        Algorithm:\n        1. Push - Init.\n        2. Push Smaller - New min found.\n        3. Pop - Sync.\n        \"\"\"\n            self.stack = []  # Initialize stack for tracking.\n            self.minStack = []\n        def push(self, val):\n            self.stack.append(val)  # Add to end.\n            val = min(val, self.minStack[-1] if self.minStack else val)  # Take the minimum value.\n            self.minStack.append(val)  # Add to end.\n        def pop(self):  # Remove and return last element.\n            self.stack.pop()  # Remove and return last element.\n            self.minStack.pop()  # Remove and return last element.\n        def top(self): return self.stack[-1]\n        def getMin(self): return self.minStack[-1]",
    "keyInsight": "The minimum history needs to be stacked because when we pop the minimum, we need to know what the *previous* minimum was.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Min Stack",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "examples": [
      {
        "input": "[[\"MinStack\"],[\"push\"],[\"push\"],[\"push\"],[\"getMin\"],[\"pop\"],[\"top\"],[\"getMin\"]], [[],[-2],[0],[-3],[],[],[],[]]",
        "output": "[null,null,null,null,-3,null,0,-2]",
        "explanation": "Min tracking works correctly."
      }
    ],
    "constraints": [
      "-2^31 <= val <= 2^31 - 1",
      "Methods pop, top and getMin will always be called on non-empty stacks.",
      "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
    ],
    "hints": [
      "Use two stacks: one for values, one for minimums.",
      "Or store pairs (value, current_min) in single stack.",
      "Update min on each push."
    ],
    "relatedProblems": [
      "max-stack",
      "implement-stack-using-queues"
    ],
    "videoId": "qkLl7nAwDPo",
    "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nYou must implement a solution with O(1) time complexity for each function.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Stack (Two Stacks): Maintain a second stack tracking the minimum value at each depth.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class MinStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def push(self, val: int) -> None:\n        # Push element val onto stack\n        pass\n\n    def pop(self) -> None:\n        # Remove the element on top of the stack\n        pass\n\n    def top(self) -> int:\n        # Get the top element\n        pass\n\n    def getMin(self) -> int:\n        # Retrieve the minimum element in the stack\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def __init___brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Get Min in O(1).",
          "\ud83e\udde0 Normal stack holds values.",
          "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
        ],
        "code": "class MinStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Get Min in O(1).\n    - \ud83e\udde0 Normal stack holds values.\n    - \ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both.\n\n    Algorithm:\n    1. Push - Init.\n    2. Push Smaller - New min found.\n    3. Pop - Sync.\n    \"\"\"\n        self.stack = []  # Initialize stack for tracking.\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)  # Add to end.\n        val = min(val, self.minStack[-1] if self.minStack else val)  # Take the minimum value.\n        self.minStack.append(val)  # Add to end.\n    def pop(self):  # Remove and return last element.\n        self.stack.pop()  # Remove and return last element.\n        self.minStack.pop()  # Remove and return last element.\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.minStack[-1]"
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class MinStack {\n    public MinStack() {\n        // Initialize your data structure here\n    }\n    \n    public void push(int val) {\n        // Push element val onto stack\n    }\n    \n    public void pop() {\n        // Remove the element on top of the stack\n    }\n    \n    public int top() {\n        // Get the top element\n        return 0;\n    }\n    \n    public int getMin() {\n        // Retrieve the minimum element in the stack\n        return 0;\n    }\n}\n",
        "code": "class MinStack {\n    private Deque<Integer> stk1 = new ArrayDeque<>();\n    private Deque<Integer> stk2 = new ArrayDeque<>();\n\n    public MinStack() {\n        stk2.push(Integer.MAX_VALUE);\n    }\n\n    public void push(int val) {\n        stk1.push(val);\n        stk2.push(Math.min(val, stk2.peek()));\n    }\n\n    public void pop() {\n        stk1.pop();\n        stk2.pop();\n    }\n\n    public int top() {\n        return stk1.peek();\n    }\n\n    public int getMin() {\n        return stk2.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */"
      },
      "cpp": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\npublic:\n    __init__() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() MinStack {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype MinStack struct {\n\tstk1 []int\n\tstk2 []int\n}\n\nfunc (s *Solution) Constructor() MinStack {\n\treturn MinStack{[]int{}, []int{math.MaxInt32}}\n}\n\nfunc (this *MinStack) Push(val int) {\n\tthis.stk1 = append(this.stk1, val)\n\tthis.stk2 = append(this.stk2, min(val, this.stk2[len(this.stk2)-1]))\n}\n\nfunc (this *MinStack) Pop() {\n\tthis.stk1 = this.stk1[:len(this.stk1)-1]\n\tthis.stk2 = this.stk2[:len(this.stk2)-1]\n}\n\nfunc (this *MinStack) Top() int {\n\treturn this.stk1[len(this.stk1)-1]\n}\n\nfunc (this *MinStack) GetMin() int {\n\treturn this.stk2[len(this.stk2)-1]\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(val);\n * obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.GetMin();\n */"
      },
      "rust": {
        "initialCode": "struct MinStack {\n    // Your data structure here\n}\n\nimpl MinStack {\n    fn new() -> Self {\n        MinStack {}\n    }\n    \n    fn push(&mut self, val: i32) {\n        // Push element val onto stack\n    }\n    \n    fn pop(&mut self) {\n        // Remove the element on top of the stack\n    }\n    \n    fn top(&self) -> i32 {\n        // Get the top element\n        0\n    }\n    \n    fn get_min(&self) -> i32 {\n        // Retrieve the minimum element in the stack\n        0\n    }\n}\n",
        "code": "use std::collections::VecDeque;\nstruct MinStack {\n    stk1: VecDeque<i32>,\n    stk2: VecDeque<i32>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl MinStack {\n    fn new() -> Self {\n        Self {\n            stk1: VecDeque::new(),\n            stk2: VecDeque::new(),\n        }\n    }\n\n    fn push(&mut self, x: i32) {\n        self.stk1.push_back(x);\n        if self.stk2.is_empty() || *self.stk2.back().unwrap() >= x {\n            self.stk2.push_back(x);\n        }\n    }\n\n    fn pop(&mut self) {\n        let val = self.stk1.pop_back().unwrap();\n        if *self.stk2.back().unwrap() == val {\n            self.stk2.pop_back();\n        }\n    }\n\n    fn top(&self) -> i32 {\n        *self.stk1.back().unwrap()\n    }\n\n    fn get_min(&self) -> i32 {\n        *self.stk2.back().unwrap()\n    }\n}"
      },
      "python": {
        "initialCode": "class MinStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def push(self, val: int) -> None:\n        # Push element val onto stack\n        pass\n\n    def pop(self) -> None:\n        # Remove the element on top of the stack\n        pass\n\n    def top(self) -> int:\n        # Get the top element\n        pass\n\n    def getMin(self) -> int:\n        # Retrieve the minimum element in the stack\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__() {}\n}",
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "group-anagrams",
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "pattern": "Hash Map"
    }
  },
  "evaluate-reverse-polish-notation": {
    "title": "Evaluate Reverse Polish Notation",
    "pattern": "Stack",
    "patternEmoji": "\u2797\u2796",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Push numbers. Operator? Pop two, apply, push result.",
    "intuition": [
      "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
      "\ud83e\udde0 Stack holds operands waiting for an operator.",
      "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
    ],
    "testCases": [
      {
        "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "output": "9"
      },
      {
        "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "output": "6"
      },
      {
        "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
        "output": "22"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Push",
        "visual": "Stack: [2, 1]",
        "explanation": "Operands."
      },
      {
        "step": 2,
        "title": "Op +",
        "visual": "Pop 1, 2. Add -> 3. Stack: [3].",
        "explanation": "Execute."
      },
      {
        "step": 3,
        "title": "Continue",
        "visual": "Push 3. Op *. 3 * 3 = 9.",
        "explanation": "Chain."
      }
    ],
    "code": "class Solution:\n    def evalRPN(self, tokens):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.\n        - \ud83e\udde0 Stack holds operands waiting for an operator.\n        - \ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7.\n\n        Algorithm:\n        1. Push - Operands.\n        2. Op + - Execute.\n        3. Continue - Chain.\n        \"\"\"\n        stack = []  # Initialize stack for tracking.\n        for t in tokens:  # Iterate over elements.\n            if t not in \"+-*/\":\n                stack.append(int(t))  # Add to end.\n            else:\n                b, a = stack.pop(), stack.pop()  # Remove and return last element.\n                if t == \"+\": stack.append(a + b)  # Add to end.\n                elif t == \"-\": stack.append(a - b)  # Add to end.\n                elif t == \"*\": stack.append(a * b)  # Add to end.\n                else: stack.append(int(a / b))  # Add to end.\n        return stack[0]",
    "keyInsight": "Careful with division: 'int(a / b)' truncates toward zero in Python, unlike '//' which floors.",
    "visualizationType": "array",
    "initialState": [
      "2",
      "1",
      "+",
      "3",
      "*"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Evaluate Reverse Polish Notation",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = +",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 3",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = *",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "2",
          "1",
          "+",
          "3",
          "*"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
    "examples": [
      {
        "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "output": "9",
        "explanation": "((2 + 1) * 3) = 9"
      },
      {
        "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "output": "6",
        "explanation": "(4 + (13 / 5)) = 6"
      }
    ],
    "constraints": [
      "1 <= tokens.length <= 10^4",
      "tokens[i] is an operator or an integer in range [-200, 200]."
    ],
    "hints": [
      "Use a stack.",
      "Push operands. On operator, pop two operands, compute, push result.",
      "Note: division truncates toward zero."
    ],
    "relatedProblems": [
      "basic-calculator",
      "basic-calculator-ii",
      "expression-add-operators"
    ],
    "videoId": "iu0082c4HDE",
    "problemStatement": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize empty stack",
      "Iterate through elements",
      "Push/pop based on problem logic",
      "Maintain monotonic property if needed",
      "Process remaining stack elements if needed"
    ],
    "approach": "Stack: Push numbers. Operator? Pop two, apply, push result.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def evalRPN(self, tokens):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def evalRPN_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
          "\ud83e\udde0 Stack holds operands waiting for an operator.",
          "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
        ],
        "code": "def evalRPN(tokens):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.\n    - \ud83e\udde0 Stack holds operands waiting for an operator.\n    - \ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7.\n\n    Algorithm:\n    1. Push - Operands.\n    2. Op + - Execute.\n    3. Continue - Chain.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    for t in tokens:  # Iterate over elements.\n        if t not in \"+-*/\":\n            stack.append(int(t))  # Add to end.\n        else:\n            b, a = stack.pop(), stack.pop()  # Remove and return last element.\n            if t == \"+\": stack.append(a + b)  # Add to end.\n            elif t == \"-\": stack.append(a - b)  # Add to end.\n            elif t == \"*\": stack.append(a * b)  # Add to end.\n            else: stack.append(int(a / b))  # Add to end.\n    return stack[0]"
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    evalRPN(tokens) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} tokens\n     * @return {any}\n     */\n    evalRPN(tokens) {\n        const stack = [];\n        const operators = {\n          '+': (a, b) => a + b,\n          '-': (a, b) => a - b,\n          '*': (a, b) => a * b,\n          '/': (a, b) => a / b >= 0 ? Math.floor(a / b) : Math.ceil(a / b),\n        };\n\n        tokens.forEach(token => {\n          if (operators[token]) {\n            const item = stack.pop();\n            stack.push(operators[token](stack.pop(), item));\n          } else {\n            stack.push(Number(token));\n      }\n    });\n\n    return stack.pop();\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int evalRPN(String[] tokens) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int evalRPN(String[] tokens) {\n        Deque<Integer> stk = new ArrayDeque<>();\n        for (String t : tokens) {\n            if (t.length() > 1 || Character.isDigit(t.charAt(0))) {\n                stk.push(Integer.parseInt(t));\n            } else {\n                int y = stk.pop();\n                int x = stk.pop();\n                switch (t) {\n                case \"+\":\n                    stk.push(x + y);\n                    break;\n                case \"-\":\n                    stk.push(x - y);\n                    break;\n                case \"*\":\n                    stk.push(x * y);\n                    break;\n                default:\n                    stk.push(x / y);\n                    break;\n                }\n            }\n        }\n        return stk.pop();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int evalRPN(vector<string>& tokens) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> stk;\n        for (auto& t : tokens) {\n            if (t.size() > 1 || isdigit(t[0])) {\n                stk.push(stoi(t));\n            } else {\n                int y = stk.top();\n                stk.pop();\n                int x = stk.top();\n                stk.pop();\n                if (t[0] == '+')\n                    stk.push(x + y);\n                else if (t[0] == '-')\n                    stk.push(x - y);\n                else if (t[0] == '*')\n                    stk.push(x * y);\n                else\n                    stk.push(x / y);\n            }\n        }\n        return stk.top();\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) evalRPN(tokens []string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) evalRPN(tokens []string) int {\n\t// https://github.com/emirpasic/gods#arraystack\n\tstk := arraystack.New()\n\tfor _, token := range tokens {\n\t\tif len(token) > 1 || token[0] >= '0' && token[0] <= '9' {\n\t\t\tnum, _ := strconv.Atoi(token)\n\t\t\tstk.Push(num)\n\t\t} else {\n\t\t\ty := popInt(stk)\n\t\t\tx := popInt(stk)\n\t\t\tswitch token {\n\t\t\tcase \"+\":\n\t\t\t\tstk.Push(x + y)\n\t\t\tcase \"-\":\n\t\t\t\tstk.Push(x - y)\n\t\t\tcase \"*\":\n\t\t\t\tstk.Push(x * y)\n\t\t\tdefault:\n\t\t\t\tstk.Push(x / y)\n\t\t\t}\n\t\t}\n\t}\n\treturn popInt(stk)\n}\n\nfunc popInt(stack *arraystack.Stack) int {\n\tv, _ := stack.Pop()\n\treturn v.(int)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn eval_rpn(tokens: Vec<String>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn eval_rpn(tokens: Vec<String>) -> i32 {\n        let mut stack = vec![];\n        for token in tokens {\n            match token.parse() {\n                Ok(num) => stack.push(num),\n                Err(_) => {\n                    let a = stack.pop().unwrap();\n                    let b = stack.pop().unwrap();\n                    stack.push(match token.as_str() {\n                        \"+\" => b + a,\n                        \"-\" => b - a,\n                        \"*\" => b * a,\n                        \"/\" => b / a,\n                        _ => 0,\n                    });\n                }\n            }\n        }\n        stack[0]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def evalRPN(self, tokens):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    evalRPN(tokens: string[]): number  {\n    const stack = [];\n    for (const token of tokens) {\n        if (/\\d/.test(token)) {\n            stack.push(Number(token));\n        } else {\n            const a = stack.pop();\n            const b = stack.pop();\n            switch (token) {\n                case '+':\n                    stack.push(b + a);\n                    break;\n                case '-':\n                    stack.push(b - a);\n                    break;\n                case '*':\n                    stack.push(b * a);\n                    break;\n                case '/':\n                    stack.push(~~(b / a));\n                    break;\n            }\n        }\n    }\n    return stack[0];\n}\n}",
        "initialCode": "class Solution {\n    evalRPN(tokens: string[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "simplify-path",
      "title": "Simplify Path",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "basic-calculator": {
    "title": "Basic Calculator",
    "pattern": "Stack (Signs)",
    "patternEmoji": "\ud83d\udc22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Track result and sign. Parenthesis? Push current result & sign, reset.",
    "intuition": [
      "\ud83c\udfaf Linear scan with recursion simulated by stack.",
      "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
      "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
    ],
    "testCases": [
      {
        "input": "s = \"1 + 1\"",
        "output": "2"
      },
      {
        "input": "s = \" 2-1 + 2 \"",
        "output": "3"
      },
      {
        "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
        "output": "23"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Scan",
        "visual": "Update 'res' with num*sign.",
        "explanation": "Accumulate."
      },
      {
        "step": 2,
        "title": "Open (",
        "visual": "Push res, sign. Res=0, Sign=1.",
        "explanation": "Context switch."
      },
      {
        "step": 3,
        "title": "Close )",
        "visual": "Res = Res * pop_sign + pop_res.",
        "explanation": "Resolve scope."
      }
    ],
    "code": "class Solution:\n    def calculate(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Linear scan with recursion simulated by stack.\n        - \ud83e\udde0 '(': Stash current state. Start fresh sub-problem.\n        - \ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result.\n\n        Algorithm:\n        1. Scan - Accumulate.\n        2. Open ( - Context switch.\n        3. Close ) - Resolve scope.\n        \"\"\"\n        res, num, sign, stack = 0, 0, 1, []\n        for c in s:  # Iterate over elements.\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-':\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(': \n                stack.append(res)  # Add to end.\n                stack.append(sign)  # Add to end.\n                sign = 1\n                res = 0  # Initialize result variable.\n            elif c == ')':\n                res += sign * num\n                res *= stack.pop()  # Remove and return last element.\n                res += stack.pop()  # Remove and return last element.\n                num = 0\n        return res + num * sign  # Return the final result.",
    "keyInsight": "Only one 'sign' variable is needed to handle +/-, applying it lazily when a number ends.",
    "visualizationType": "array",
    "initialState": "(1+(4+5+2)-3)+(6+8)",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Basic Calculator",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = (",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = +",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = (",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 4",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = +",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "(",
          "1",
          "+",
          "(",
          "4",
          "+",
          "5",
          "+",
          "2",
          ")",
          "-",
          "3",
          ")",
          "+",
          "(",
          "6",
          "+",
          "8",
          ")"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions.",
    "examples": [
      {
        "input": "s = \"1 + 1\"",
        "output": "2",
        "explanation": "1 + 1 = 2"
      },
      {
        "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
        "output": "23",
        "explanation": "Evaluate nested parentheses."
      }
    ],
    "constraints": [
      "1 <= s.length <= 3 * 10^5",
      "s consists of digits, '+', '-', '(', ')', and ' '.",
      "s represents a valid expression.",
      "'+' is not used as unary operation."
    ],
    "hints": [
      "Use stack to handle nested parentheses.",
      "Track current result and sign.",
      "On '(', push current state. On ')', pop and apply."
    ],
    "relatedProblems": [
      "basic-calculator-ii",
      "basic-calculator-iii",
      "evaluate-reverse-polish-notation"
    ],
    "videoId": "081AqOuasw0",
    "problemStatement": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Stack (Signs): Track result and sign. Parenthesis? Push current result & sign, reset.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def calculate(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def calculate_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Linear scan with recursion simulated by stack.",
          "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
          "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
        ],
        "code": "def calculate(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Linear scan with recursion simulated by stack.\n    - \ud83e\udde0 '(': Stash current state. Start fresh sub-problem.\n    - \ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result.\n\n    Algorithm:\n    1. Scan - Accumulate.\n    2. Open ( - Context switch.\n    3. Close ) - Resolve scope.\n    \"\"\"\n    res, num, sign, stack = 0, 0, 1, []\n    for c in s:  # Iterate over elements.\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c in '+-':\n            res += sign * num\n            num = 0\n            sign = 1 if c == '+' else -1\n        elif c == '(': \n            stack.append(res)  # Add to end.\n            stack.append(sign)  # Add to end.\n            sign = 1\n            res = 0  # Initialize result variable.\n        elif c == ')':\n            res += sign * num\n            res *= stack.pop()  # Remove and return last element.\n            res += stack.pop()  # Remove and return last element.\n            num = 0\n    return res + num * sign  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    calculate(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    calculate(s) {\n        const stack = [];\n        let result = 0;\n\n        for (let i = 0, sign = 1; i < s.length; i += 1) {\n          if (s[i] >= '0' && s[i] <= '9') {\n            let value = 0;\n            while (s[i] >= '0' && s[i] <= '9') {\n              value = (value * 10) + (s[i] - '0');\n              i += 1;\n            }\n            result += value * sign;\n            i -= 1;\n          } else if (s[i] === '+') {\n            sign = 1;\n          } else if (s[i] === '-') {\n            sign = -1;\n          } else if (s[i] === '(') {\n            stack.push(result, sign);\n            result = 0;\n            sign = 1;\n          } else if (s[i] === ')') {\n            result = stack.pop() * result;\n            result += stack.pop();\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int calculate(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int calculate(String s) {\n        Deque<Integer> stk = new ArrayDeque<>();\n        int sign = 1;\n        int ans = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                int j = i;\n                int x = 0;\n                while (j < n && Character.isDigit(s.charAt(j))) {\n                    x = x * 10 + s.charAt(j) - '0';\n                    j++;\n                }\n                ans += sign * x;\n                i = j - 1;\n            } else if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                stk.push(ans);\n                stk.push(sign);\n                ans = 0;\n                sign = 1;\n            } else if (c == ')') {\n                ans = stk.pop() * ans + stk.pop();\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int calculate(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int calculate(string s) {\n        stack<int> stk;\n        int ans = 0, sign = 1;\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            if (isdigit(s[i])) {\n                int x = 0;\n                int j = i;\n                while (j < n && isdigit(s[j])) {\n                    x = x * 10 + (s[j] - '0');\n                    ++j;\n                }\n                ans += sign * x;\n                i = j - 1;\n            } else if (s[i] == '+') {\n                sign = 1;\n            } else if (s[i] == '-') {\n                sign = -1;\n            } else if (s[i] == '(') {\n                stk.push(ans);\n                stk.push(sign);\n                ans = 0;\n                sign = 1;\n            } else if (s[i] == ')') {\n                ans *= stk.top();\n                stk.pop();\n                ans += stk.top();\n                stk.pop();\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) calculate(s string) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) calculate(s string) (ans int) {\n\tstk := []int{}\n\tsign := 1\n\tn := len(s)\n\tfor i := 0; i < n; i++ {\n\t\tswitch s[i] {\n\t\tcase ' ':\n\t\tcase '+':\n\t\t\tsign = 1\n\t\tcase '-':\n\t\t\tsign = -1\n\t\tcase '(':\n\t\t\tstk = append(stk, ans)\n\t\t\tstk = append(stk, sign)\n\t\t\tans, sign = 0, 1\n\t\tcase ')':\n\t\t\tans *= stk[len(stk)-1]\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\tans += stk[len(stk)-1]\n\t\t\tstk = stk[:len(stk)-1]\n\t\tdefault:\n\t\t\tx := 0\n\t\t\tj := i\n\t\t\tfor ; j < n && '0' <= s[j] && s[j] <= '9'; j++ {\n\t\t\t\tx = x*10 + int(s[j]-'0')\n\t\t\t}\n\t\t\tans += sign * x\n\t\t\ti = j - 1\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn calculate(s: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [224] Basic Calculator\n *\n * Implement a basic calculator to evaluate a simple expression string.\n *\n * The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\n *\n * Example 1:\n *\n *\n * Input: \"1 + 1\"\n * Output: 2\n *\n *\n * Example 2:\n *\n *\n * Input: \" 2-1 + 2 \"\n * Output: 3\n *\n * Example 3:\n *\n *\n * Input: \"(1+(4+5+2)-3)+(6+8)\"\n * Output: 23\n * Note:\n *\n *\n * \tYou may assume that the given expression is always valid.\n * \tDo not use the eval built-in library function.\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/basic-calculator/\n// discuss: https://leetcode.com/problems/basic-calculator/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n#[derive(PartialEq, Copy, Clone, Debug)]\nenum Token {\n    LeftBracket,\n    RightBracket,\n    PlusSign,\n    MinusSign,\n    Number(i64),\n}\n\nimpl Solution {\n    pub fn calculate(s: String) -> i32 {\n        // lexer\n        let mut token_stream = Vec::new();\n        let mut num = 0_i64;\n        let mut in_num = false;\n        for ch in s.chars() {\n            match ch {\n                '0'..='9' => {\n                    in_num = true;\n                    num = 10 * num + (ch as u8 - '0' as u8) as i64;\n                }\n                _ => {\n                    if in_num {\n                        token_stream.push(Token::Number(num));\n                        num = 0;\n                        in_num = false;\n                    }\n                    match ch {\n                        '(' => {\n                            token_stream.push(Token::LeftBracket);\n                        }\n                        ')' => {\n                            token_stream.push(Token::RightBracket);\n                        }\n                        '+' => {\n                            token_stream.push(Token::PlusSign);\n                        }\n                        '-' => {\n                            token_stream.push(Token::MinusSign);\n                        }\n                        _ => {}\n                    };\n                }\n            }\n        }\n        if in_num {\n            token_stream.push(Token::Number(num));\n        }\n\n        // parser\n        let mut stack = Vec::new();\n        let mut iter = token_stream.into_iter();\n        let mut pause = false;\n        let mut token = Token::LeftBracket;\n        loop {\n            if !pause {\n                token = if let Some(token) = iter.next() {\n                    token\n                } else {\n                    break;\n                }\n            } else {\n                pause = false;\n            }\n            match token {\n                Token::LeftBracket => {\n                    stack.push(token);\n                }\n                Token::RightBracket => {\n                    if let Token::Number(right_hand) = stack.pop().unwrap() {\n                        stack.pop();\n                        pause = true;\n                        token = Token::Number(right_hand);\n                    }\n                }\n                Token::PlusSign => {\n                    stack.push(token);\n                }\n                Token::MinusSign => {\n                    stack.push(token);\n                }\n                Token::Number(num) => {\n                    if stack.is_empty() || Token::LeftBracket == *stack.last().unwrap() {\n                        stack.push(Token::Number(num));\n                    } else {\n                        let sign = stack.pop().unwrap();\n                        if let Token::Number(left_hand) = stack.pop().unwrap() {\n                            let res =\n                                left_hand + num * if Token::PlusSign == sign { 1 } else { -1 };\n                            stack.push(Token::Number(res));\n                        }\n                    }\n                }\n            }\n        }\n        if let Token::Number(num) = stack.pop().unwrap() {\n            return num as i32;\n        }\n        0\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_224() {\n        assert_eq!(Solution::calculate(\"(1+(4+5+2)-3)+(6+8)\".to_owned()), 23);\n        assert_eq!(Solution::calculate(\"1+1\".to_owned()), 2);\n        assert_eq!(Solution::calculate(\"0\".to_owned()), 0);\n        assert_eq!(Solution::calculate(\"2147483647\".to_owned()), 2147483647);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def calculate(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    calculate(s: string): number  {\n    const stk: number[] = [];\n    let sign = 1;\n    let ans = 0;\n    const n = s.length;\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === ' ') {\n            continue;\n        }\n        if (s[i] === '+') {\n            sign = 1;\n        } else if (s[i] === '-') {\n            sign = -1;\n        } else if (s[i] === '(') {\n            stk.push(ans);\n            stk.push(sign);\n            ans = 0;\n            sign = 1;\n        } else if (s[i] === ')') {\n            ans *= stk.pop() as number;\n            ans += stk.pop() as number;\n        } else {\n            let x = 0;\n            let j = i;\n            for (; j < n && !isNaN(Number(s[j])) && s[j] !== ' '; ++j) {\n                x = x * 10 + (s[j].charCodeAt(0) - '0'.charCodeAt(0));\n            }\n            ans += sign * x;\n            i = j - 1;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    calculate(s: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "trapping-rain-water",
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "pattern": "Two Pointers"
    }
  },
  "implement-stack-using-queues": {
    "title": "Implement Stack using Queues",
    "pattern": "Queue Rotation",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "Push O(n), Pop O(1)",
    "spaceComplexity": "O(n)",
    "oneliner": "Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
    "intuition": [
      "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
      "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
      "\ud83d\udca1 After appending X, rotate all other N items behind X."
    ],
    "testCases": [
      {
        "input": "ops = [\"MyStack\",\"push\",\"push\",\"pop\",\"top\",\"empty\"]; args = [[],[1],[2],[],[],[]]",
        "output": "[null,null,null,2,1,false]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Push X",
        "visual": "Q appends X. Q: [1, 2, X].",
        "explanation": "Wrong order."
      },
      {
        "step": 2,
        "title": "Rotate",
        "visual": "Pop 1, Push 1. Pop 2, Push 2. Q: [X, 1, 2].",
        "explanation": "X is now front."
      },
      {
        "step": 3,
        "title": "Pop",
        "visual": "Q.popleft() returns X.",
        "explanation": "LIFO behavior achieved."
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    class MyStack:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Queue is FIFO. Stack is LIFO.\n        - \ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.\n        - \ud83d\udca1 After appending X, rotate all other N items behind X.\n    \n        Algorithm:\n        1. Push X - Wrong order.\n        2. Rotate - X is now front.\n        3. Pop - LIFO behavior achieved.\n        \"\"\"\n            self.q = deque()  # Initialize queue for BFS.\n        def push(self, x):\n            self.q.append(x)  # Add to end.\n            for _ in range(len(self.q) - 1):  # Iterate through the range.\n                self.q.append(self.q.popleft())  # Add to end.\n        def pop(self): return self.q.popleft()  # Remove and return last element.\n        def top(self): return self.q[0]\n        def empty(self): return not self.q",
    "keyInsight": "Single queue is sufficient if we rotate it!",
    "visualizationType": "array",
    "initialState": [
      "MyStack",
      "push",
      "push",
      "pop",
      "top",
      "empty"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Input: [MyStack, push, push, pop, top, empty]",
        "transientMessage": "Stack-based solution",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Push MyStack",
        "transientMessage": "Stack: [MyStack]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Push push",
        "transientMessage": "Stack: [MyStack, push]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Push push",
        "transientMessage": "Stack: [MyStack, push, push]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Push pop",
        "transientMessage": "Stack: [MyStack, push, push, pop]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Push top",
        "transientMessage": "Stack: [MyStack, push, push, pop, top]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Pop top",
        "transientMessage": "Stack: [MyStack, push, push, pop]",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Complete!",
        "transientMessage": "Result ready",
        "arrayState": [
          "MyStack",
          "push",
          "push",
          "pop",
          "top",
          "empty"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
    "examples": [
      {
        "input": "[[\"MyStack\"],[\"push\"],[\"push\"],[\"top\"],[\"pop\"],[\"empty\"]], [[],[1],[2],[],[],[]]",
        "output": "[null,null,null,2,2,false]",
        "explanation": "Stack operations using queues."
      }
    ],
    "constraints": [
      "1 <= x <= 9",
      "At most 100 calls will be made to push, pop, top, and empty.",
      "All calls to pop and top are valid."
    ],
    "hints": [
      "On push, add to queue then rotate n-1 times.",
      "This puts new element at front.",
      "Pop and top become O(1)."
    ],
    "relatedProblems": [
      "implement-queue-using-stacks",
      "min-stack"
    ],
    "videoId": "rW4vm0-DLYc",
    "problemStatement": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nNotes:",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Queue Rotation: Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
    "mentalModel": "Like a grocery line. First come, first served (FIFO).",
    "initialCode": "from collections import deque\n\nclass MyStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def push(self, x: int) -> None:\n        # Push element x onto stack\n        pass\n\n    def pop(self) -> int:\n        # Remove the element on top of the stack and return it\n        pass\n\n    def top(self) -> int:\n        # Get the top element\n        pass\n\n    def empty(self) -> bool:\n        # Return whether the stack is empty\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class MyStack:\n    def __init__(self):\n        self.q = []\n\n    def push(self, x: int) -> None:\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.pop(0))\n\n    def pop(self) -> int:\n        return self.q.pop(0)\n\n    def top(self) -> int:\n        return self.q[0]\n\n    def empty(self) -> bool:\n        return len(self.q) == 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "Push O(n), Pop O(1)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
          "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
          "\ud83d\udca1 After appending X, rotate all other N items behind X."
        ],
        "code": "from collections import deque\nclass MyStack:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Queue is FIFO. Stack is LIFO.\n    - \ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.\n    - \ud83d\udca1 After appending X, rotate all other N items behind X.\n\n    Algorithm:\n    1. Push X - Wrong order.\n    2. Rotate - X is now front.\n    3. Pop - LIFO behavior achieved.\n    \"\"\"\n        self.q = deque()  # Initialize queue for BFS.\n    def push(self, x):\n        self.q.append(x)  # Add to end.\n        for _ in range(len(self.q) - 1):  # Iterate through the range.\n            self.q.append(self.q.popleft())  # Add to end.\n    def pop(self): return self.q.popleft()  # Remove and return last element.\n    def top(self): return self.q[0]\n    def empty(self): return not self.q"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Solution() {\n        // Constructor implementation goes here\n    }\n}",
        "code": "class Solution {\n    public Solution() {\n        // Constructor implementation goes here\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {}\n};",
        "code": "class Solution {\npublic:\n    Solution() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() MyStack {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype MyStack struct {\n\tq1 []int\n\tq2 []int\n}\n\nfunc (s *Solution) Constructor() MyStack {\n\treturn MyStack{}\n}\n\nfunc (this *MyStack) Push(x int) {\n\tthis.q2 = append(this.q2, x)\n\tfor len(this.q1) > 0 {\n\t\tthis.q2 = append(this.q2, this.q1[0])\n\t\tthis.q1 = this.q1[1:]\n\t}\n\tthis.q1, this.q2 = this.q2, this.q1\n}\n\nfunc (this *MyStack) Pop() int {\n\tx := this.q1[0]\n\tthis.q1 = this.q1[1:]\n\treturn x\n}\n\nfunc (this *MyStack) Top() int {\n\treturn this.q1[0]\n}\n\nfunc (this *MyStack) Empty() bool {\n\treturn len(this.q1) == 0\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Top();\n * param_4 := obj.Empty();\n */"
      },
      "rust": {
        "initialCode": "struct MyStack {\n    // Your data structure here\n}\n\nimpl MyStack {\n    fn new() -> Self {\n        MyStack {}\n    }\n    \n    fn push(&mut self, x: i32) {\n        // Push element x onto stack\n    }\n    \n    fn pop(&mut self) -> i32 {\n        // Remove the element on top of the stack and return it\n        0\n    }\n    \n    fn top(&self) -> i32 {\n        // Get the top element\n        0\n    }\n    \n    fn empty(&self) -> bool {\n        // Return whether the stack is empty\n        true\n    }\n}\n",
        "code": "use std::collections::VecDeque;\n\nstruct MyStack {\n    /// There could only be two status at all time\n    /// 1. One contains N elements, the other is empty\n    /// 2. One contains N - 1 elements, the other contains exactly 1 element\n    q_1: VecDeque<i32>,\n    q_2: VecDeque<i32>,\n    // Either 1 or 2, originally begins from 1\n    index: i32,\n}\n\nimpl MyStack {\n    fn new() -> Self {\n        Self {\n            q_1: VecDeque::new(),\n            q_2: VecDeque::new(),\n            index: 1,\n        }\n    }\n\n    fn move_data(&mut self) {\n        // Always move from q1 to q2\n        assert!(self.q_2.len() == 1);\n        while !self.q_1.is_empty() {\n            self.q_2.push_back(self.q_1.pop_front().unwrap());\n        }\n        let tmp = self.q_1.clone();\n        self.q_1 = self.q_2.clone();\n        self.q_2 = tmp;\n    }\n\n    fn push(&mut self, x: i32) {\n        self.q_2.push_back(x);\n        self.move_data();\n    }\n\n    fn pop(&mut self) -> i32 {\n        self.q_1.pop_front().unwrap()\n    }\n\n    fn top(&mut self) -> i32 {\n        *self.q_1.front().unwrap()\n    }\n\n    fn empty(&self) -> bool {\n        self.q_1.is_empty()\n    }\n}"
      },
      "python": {
        "initialCode": "from collections import deque\n\nclass MyStack:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def push(self, x: int) -> None:\n        # Push element x onto stack\n        pass\n\n    def pop(self) -> int:\n        # Remove the element on top of the stack and return it\n        pass\n\n    def top(self) -> int:\n        # Get the top element\n        pass\n\n    def empty(self) -> bool:\n        # Return whether the stack is empty\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "merge-sorted-array",
      "title": "Merge Sorted Array",
      "difficulty": "Easy",
      "pattern": "Three Pointers (Reverse)"
    }
  },
  "add-two-numbers": {
    "title": "Add Two Numbers",
    "pattern": "Linked List Math",
    "patternEmoji": "\ud83d\udcda",
    "timeComplexity": "O(max(m, n))",
    "spaceComplexity": "O(max(m, n))",
    "oneliner": "Traverse both lists, add digits + carry, create new node.",
    "intuition": [
      "\ud83c\udfaf Just like elementary math: add right-to-left.",
      "\ud83e\udde0 Lists are already reversed (digits at head).",
      "\ud83d\udca1 Don't forget the final carry if it exists!"
    ],
    "testCases": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]"
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]"
      },
      {
        "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
        "output": "[8,9,9,9,0,0,0,1]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "Dummy node. Carry = 0.",
        "explanation": "Base setup."
      },
      {
        "step": 2,
        "title": "Add",
        "visual": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum // 10.",
        "explanation": "Standard addition."
      },
      {
        "step": 3,
        "title": "Next",
        "visual": "Move l1, l2 pointers if not null.",
        "explanation": "Iterate."
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Just like elementary math: add right-to-left.\n        - \ud83e\udde0 Lists are already reversed (digits at head).\n        - \ud83d\udca1 Don't forget the final carry if it exists!\n    \n        Algorithm:\n        1. Init - Base setup.\n        2. Add - Standard addition.\n        3. Next - Iterate.\n        \"\"\"\n        dummy = ListNode()  # Use dummy node to simplify edge cases.\n        cur = dummy  # Initialize current pointer.\n        carry = 0\n        while l1 or l2 or carry:  # Process digits and carry.\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n            cur = cur.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "Using 'v1 = l1.val if l1 else 0' cleans up the code significantly, removing null checks inside the addition.",
    "visualizationType": "linkedlist",
    "initialState": [
      2,
      4,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Add Two Numbers",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          2,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807"
      },
      {
        "input": "l1 = [9,9,9,9], l2 = [9,9,9]",
        "output": "[8,9,9,0,1]",
        "explanation": "9999 + 999 = 10998"
      }
    ],
    "constraints": [
      "The number of nodes in each list is in range [1, 100].",
      "0 <= Node.val <= 9",
      "The lists represent numbers without leading zeros (except 0 itself)."
    ],
    "hints": [
      "Iterate both lists simultaneously.",
      "Track carry for sums >= 10.",
      "Don't forget the final carry!"
    ],
    "relatedProblems": [
      "multiply-strings",
      "add-binary",
      "add-two-numbers-ii"
    ],
    "videoId": "wgFPrzTjm7s",
    "problemStatement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Linked List Math: Traverse both lists, add digits + carry, create new node.",
    "suggestedNextQuestion": {
      "slug": "remove-linked-list-elements",
      "title": "Remove Linked List Elements",
      "difficulty": "Medium",
      "pattern": "Linked List"
    },
    "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Use extra array to store all values.",
          "Process in array, then rebuild list."
        ],
        "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(max(m, n))",
        "spaceComplexity": "O(max(m, n))",
        "intuition": [
          "\ud83c\udfaf Just like elementary math: add right-to-left.",
          "\ud83e\udde0 Lists are already reversed (digits at head).",
          "\ud83d\udca1 Don't forget the final carry if it exists!"
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef addTwoNumbers(l1, l2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Just like elementary math: add right-to-left.\n    - \ud83e\udde0 Lists are already reversed (digits at head).\n    - \ud83d\udca1 Don't forget the final carry if it exists!\n\n    Algorithm:\n    1. Init - Base setup.\n    2. Add - Standard addition.\n    3. Next - Iterate.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    cur = dummy  # Initialize current pointer.\n    carry = 0\n    while l1 or l2 or carry:  # Process digits and carry.\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        val = v1 + v2 + carry\n        carry = val // 10\n        val = val % 10\n        cur.next = ListNode(val)\n        cur = cur.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Losing reference to head",
      "Not handling single node case",
      "Creating cycles accidentally"
    ],
    "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(l1, l2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(l1, l2) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode __init__(ListNode l1, ListNode l2) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode __init__(ListNode l1, ListNode l2) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void __init__() {\n        // Your code here\n    }\n}",
        "code": "class Solution {\npublic:\n    void __init__() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n\tdummy := &ListNode{}\n\tcarry := 0\n\tcur := dummy\n\tfor l1 != nil || l2 != nil || carry != 0 {\n\t\ts := carry\n\t\tif l1 != nil {\n\t\t\ts += l1.Val\n\t\t}\n\t\tif l2 != nil {\n\t\t\ts += l2.Val\n\t\t}\n\t\tcarry = s / 10\n\t\tcur.Next = &ListNode{s % 10, nil}\n\t\tcur = cur.Next\n\t\tif l1 != nil {\n\t\t\tl1 = l1.Next\n\t\t}\n\t\tif l2 != nil {\n\t\t\tl2 = l2.Next\n\t\t}\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn add_two_numbers(\n        mut l1: Option<Box<ListNode>>,\n        mut l2: Option<Box<ListNode>>,\n    ) -> Option<Box<ListNode>> {\n        let mut dummy = Some(Box::new(ListNode::new(0)));\n        let mut cur = &mut dummy;\n        let mut sum = 0;\n        while l1.is_some() || l2.is_some() || sum != 0 {\n            if let Some(node) = l1 {\n                sum += node.val;\n                l1 = node.next;\n            }\n            if let Some(node) = l2 {\n                sum += node.val;\n                l2 = node.next;\n            }\n            cur.as_mut().unwrap().next = Some(Box::new(ListNode::new(sum % 10)));\n            cur = &mut cur.as_mut().unwrap().next;\n            sum /= 10;\n        }\n        dummy.unwrap().next.take()\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "merge-two-sorted-lists": {
    "title": "Merge Two Sorted Lists",
    "pattern": "Linked List / Two Pointers",
    "patternEmoji": "\ud83d\udd00",
    "timeComplexity": "O(m+n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
    "intuition": [
      "\ud83c\udfaf Zipper merge.",
      "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
      "\ud83d\udca1 Advance the chosen one."
    ],
    "testCases": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Dummy",
        "visual": "Tail -> Dummy.",
        "explanation": "Simplifies edge cases."
      },
      {
        "step": 2,
        "title": "Stitch",
        "visual": "l1.val < l2.val? Tail.next = l1. l1 = l1.next.",
        "explanation": "Pick smallest."
      },
      {
        "step": 3,
        "title": "Cleanup",
        "visual": "Tail.next = l1 or l2 (whichever remains).",
        "explanation": "Attach rest."
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Zipper merge.\n        - \ud83e\udde0 Compare heads. Attach smaller to 'tail'.\n        - \ud83d\udca1 Advance the chosen one.\n    \n        Algorithm:\n        1. Dummy - Simplifies edge cases.\n        2. Stitch - Pick smallest.\n        3. Cleanup - Attach rest.\n        \"\"\"\n        dummy = ListNode()  # Use dummy node to simplify edge cases.\n        tail = dummy  # Initialize tail pointer.\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "We don't create new nodes; we just re-link existing ones.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "list1: 1\u21922\u21924, list2: 1\u21923\u21924",
        "transientMessage": "Create dummy head, compare first elements",
        "arrayState": [
          1,
          2,
          4,
          1,
          3,
          4
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 0
          },
          {
            "label": "p2",
            "index": 3
          }
        ],
        "indices": [
          0,
          3
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "1 vs 1 \u2192 pick list1's 1",
        "transientMessage": "result: 1\u2192, move p1",
        "arrayState": [
          1,
          2,
          4,
          1,
          3,
          4
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 1
          },
          {
            "label": "p2",
            "index": 3
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "2 vs 1 \u2192 pick list2's 1",
        "transientMessage": "result: 1\u21921\u2192, move p2",
        "arrayState": [
          1,
          2,
          4,
          1,
          3,
          4
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 1
          },
          {
            "label": "p2",
            "index": 4
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "2 vs 3 \u2192 pick 2",
        "transientMessage": "result: 1\u21921\u21922\u2192, move p1",
        "arrayState": [
          1,
          2,
          4,
          1,
          3,
          4
        ],
        "pointers": [
          {
            "label": "p1",
            "index": 2
          },
          {
            "label": "p2",
            "index": 4
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Continue merging...",
        "transientMessage": "result: 1\u21921\u21922\u21923\u21924\u21924",
        "arrayState": [
          1,
          1,
          2,
          3,
          4,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "color": "success"
      }
    ],
    "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merged in sorted order."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both empty."
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": "One empty, one with element."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both lists are sorted in non-decreasing order."
    ],
    "hints": [
      "Use a dummy node to simplify the code.",
      "Compare heads of both lists, take the smaller one.",
      "Move the pointer forward on the list you took from."
    ],
    "relatedProblems": [
      "merge-sorted-array",
      "merge-k-sorted-lists",
      "sort-list"
    ],
    "videoId": "XIdigk956u0",
    "problemStatement": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Linked List / Two Pointers: Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
    "suggestedNextQuestion": {
      "slug": "remove-duplicates-from-sorted-array",
      "title": "Remove Duplicates from Sorted Array",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def mergeTwoLists(list1, list2):\n    if not list1: return list2\n    if not list2: return list1\n    if list1.val < list2.val:\n        list1.next = mergeTwoLists(list1.next, list2)\n        return list1\n    else:\n        list2.next = mergeTwoLists(list1, list2.next)\n        return list2"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m+n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Zipper merge.",
          "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
          "\ud83d\udca1 Advance the chosen one."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Zipper merge.\n    - \ud83e\udde0 Compare heads. Attach smaller to 'tail'.\n    - \ud83d\udca1 Advance the chosen one.\n\n    Algorithm:\n    1. Dummy - Simplifies edge cases.\n    2. Stitch - Pick smallest.\n    3. Cleanup - Attach rest.\n    \"\"\"\n    dummy = ListNode()  # Use dummy node to simplify edge cases.\n    tail = dummy  # Initialize tail pointer.\n    while list1 and list2:\n        if list1.val < list2.val:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    if list1:\n        tail.next = list1\n    elif list2:\n        tail.next = list2\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...args) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...args) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode __init__(ListNode l1, ListNode l2) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode __init__(ListNode l1, ListNode l2) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* __init__(ListNode* l1, ListNode* l2) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* __init__(ListNode* l1, ListNode* l2) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n\tif list1 == nil {\n\t\treturn list2\n\t}\n\tif list2 == nil {\n\t\treturn list1\n\t}\n\tif list1.Val <= list2.Val {\n\t\tlist1.Next = mergeTwoLists(list1.Next, list2)\n\t\treturn list1\n\t} else {\n\t\tlist2.Next = mergeTwoLists(list1, list2.Next)\n\t\treturn list2\n\t}\n}"
      },
      "rust": {
        "initialCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn merge_two_lists(\n        list1: Option<Box<ListNode>>,\n        list2: Option<Box<ListNode>>,\n    ) -> Option<Box<ListNode>> {\n        match (list1, list2) {\n            (None, None) => None,\n            (Some(list), None) => Some(list),\n            (None, Some(list)) => Some(list),\n            (Some(mut list1), Some(mut list2)) => {\n                if list1.val < list2.val {\n                    list1.next = Self::merge_two_lists(list1.next, Some(list2));\n                    Some(list1)\n                } else {\n                    list2.next = Self::merge_two_lists(Some(list1), list2.next);\n                    Some(list2)\n                }\n            }\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(l1: ListNode | null, l2: ListNode | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(l1: ListNode | null, l2: ListNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "copy-list-with-random-pointer": {
    "title": "Copy List with Random Pointer",
    "pattern": "Hash Map / Interweaving",
    "patternEmoji": "\ud83d\udcc3",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n) (or O(1) interweave)",
    "oneliner": "Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
    "intuition": [
      "\ud83c\udfaf Deep copy means new nodes.",
      "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
      "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
    ],
    "testCases": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
      },
      {
        "input": "head = [[1,1],[2,1]]",
        "output": "[[1,1],[2,1]]"
      },
      {
        "input": "head = [[3,null],[3,0],[3,null]]",
        "output": "[[3,null],[3,0],[3,null]]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Map",
        "visual": "Iterate. Map[old] = Node(old.val).",
        "explanation": "Create clones."
      },
      {
        "step": 2,
        "title": "Link",
        "visual": "Iterate. copy.next = map[old.next]. copy.random = map[old.random].",
        "explanation": "Wire up."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "Return map[head].",
        "explanation": "Done."
      }
    ],
    "code": "class Solution:\n    class Node:  # Node definition with random pointer.\n        def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Deep copy means new nodes.\n        - \ud83e\udde0 Random pointers might point to nodes not visited yet.\n        - \ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues.\n    \n        Algorithm:\n        1. Map - Create clones.\n        2. Link - Wire up.\n        3. Return - Done.\n        \"\"\"\n            self.val = int(x)\n            self.next = next\n            self.random = random\n    \n    def copyRandomList(self, head):\n        if not head: return None\n        oldToCopy = {None: None}  # Map old nodes to new copies.\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]",
    "keyInsight": "The hashmap approach is simplest. The O(1) space 'interweaving' approach is clever but much harder to implement correctly in an interview.",
    "visualizationType": "linkedlist",
    "initialState": [
      [
        7
      ],
      [
        13,
        0
      ],
      [
        11,
        4
      ],
      [
        10,
        2
      ],
      [
        1,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Copy List with Random Pointer",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 7",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 13,0",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 11,4",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 10,2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 1,0",
        "transientMessage": "Iteration 5",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            7
          ],
          [
            13,
            0
          ],
          [
            11,
            4
          ],
          [
            10,
            2
          ],
          [
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list.",
    "examples": [
      {
        "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
        "explanation": "Deep copy with same structure."
      }
    ],
    "constraints": [
      "0 <= n <= 1000",
      "-10^4 <= Node.val <= 10^4",
      "Node.random is null or points to a node in the list."
    ],
    "hints": [
      "Use hash map: old node -> new node.",
      "First pass: create all new nodes.",
      "Second pass: connect next and random pointers."
    ],
    "relatedProblems": [
      "clone-graph",
      "clone-binary-tree-with-random-pointer"
    ],
    "videoId": "5Y2EiZST97Y",
    "problemStatement": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nYour code will only be given the head of the original linked list.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map / Interweaving: Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
    "suggestedNextQuestion": {
      "slug": "design-twitter",
      "title": "Design Twitter",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Node:  # Node definition with random pointer.\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        pass\n\ndef copyRandomList(head):\n    pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n) (or O(1) interweave)",
        "intuition": [
          "\ud83c\udfaf Deep copy means new nodes.",
          "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
          "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
        ],
        "code": "class Node:  # Node definition with random pointer.\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means new nodes.\n    - \ud83e\udde0 Random pointers might point to nodes not visited yet.\n    - \ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues.\n\n    Algorithm:\n    1. Map - Create clones.\n    2. Link - Wire up.\n    3. Return - Done.\n    \"\"\"\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head: return None\n    oldToCopy = {None: None}  # Map old nodes to new copies.\n    cur = head\n    while cur:\n        copy = Node(cur.val)\n        oldToCopy[cur] = copy\n        cur = cur.next\n    cur = head\n    while cur:\n        copy = oldToCopy[cur]\n        copy.next = oldToCopy[cur.next]\n        copy.random = oldToCopy[cur.random]\n        cur = cur.next\n    return oldToCopy[head]"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor(val, next = null, random = null) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Node {\n    constructor(val, next = null, random = null) {\n        this.val = val;\n        this.next = next;\n        this.random = random;\n    }\n}\n\nclass Solution {\n    __init__(head: Node | null): Node | null {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Node __init__(Node head) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public Node __init__(Node head) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    Node* copyRandomList(Node* head) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) copyRandomList(head *Node) *Node {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Next *Node\n *     Random *Node\n * }\n */\n\nfunc (s *Solution) copyRandomList(head *Node) *Node {\n\tdummy := &Node{}\n\ttail := dummy\n\td := map[*Node]*Node{}\n\tfor cur := head; cur != nil; cur = cur.Next {\n\t\tnode := &Node{Val: cur.Val}\n\t\td[cur] = node\n\t\ttail.Next = node\n\t\ttail = node\n\t}\n\tfor cur := head; cur != nil; cur = cur.Next {\n\t\tif cur.Random != nil {\n\t\t\td[cur].Random = d[cur.Random]\n\t\t}\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "// Solution requires complex Rc/RefCell handling in Rust."
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Node:  # Node definition with random pointer.\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        pass\n\ndef copyRandomList(head):\n    pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: Node | null): Node | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: Node | null): Node | null {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "reverse-linked-list-ii": {
    "title": "Reverse Linked List II",
    "pattern": "Linked List Manipulation",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Reach 'left'; reverse 'right-left' times; reconnect.",
    "intuition": [
      "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
      "\ud83e\udde0 'prev' sits before reversing starts.",
      "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1,4,3,2,5]"
      },
      {
        "input": "head = [5], left = 1, right = 1",
        "output": "[5]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Reach",
        "visual": "Move prev to left-1.",
        "explanation": "Positioning."
      },
      {
        "step": 2,
        "title": "Reverse",
        "visual": "For i in range(r-l): temp=curr.next; curr.next=temp.next; temp.next=prev.next; prev.next=temp.",
        "explanation": "Bubble swap."
      },
      {
        "step": 3,
        "title": "Done",
        "visual": "Return dummy.next.",
        "explanation": "Head might change."
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Use a Dummy to handle edge case (left=1).\n        - \ud83e\udde0 'prev' sits before reversing starts.\n        - \ud83d\udca1 Reverse the sub-segment standard way. Fix connections.\n    \n        Algorithm:\n        1. Reach - Positioning.\n        2. Reverse - Bubble swap.\n        3. Done - Head might change.\n        \"\"\"\n        dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n        leftPrev, cur = dummy, head  # Initialize current pointer.\n        for i in range(left - 1):  # Iterate through the range.\n            leftPrev, cur = cur, cur.next\n        prev = None\n        for i in range(right - left + 1):  # Iterate through the range.\n            tmp = cur.next\n            cur.next = prev\n            prev, cur = cur, tmp\n        # Connect\n        leftPrev.next.next = cur\n        leftPrev.next = prev\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "It's easier to fully reverse the sublist using standard Prev/Curr/Next logic, then stitch the ends `leftPrev` and `cur` back.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reverse Linked List II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5], left = 2, right = 4",
        "output": "[1,4,3,2,5]",
        "explanation": "Nodes 2-4 are reversed."
      },
      {
        "input": "head = [5], left = 1, right = 1",
        "output": "[5]",
        "explanation": "Single node, nothing to reverse."
      }
    ],
    "constraints": [
      "The number of nodes is n.",
      "1 <= n <= 500",
      "-500 <= Node.val <= 500",
      "1 <= left <= right <= n"
    ],
    "hints": [
      "Use dummy node for clean edge cases.",
      "Find the node before 'left' position.",
      "Reverse nodes from left to right using standard technique."
    ],
    "relatedProblems": [
      "reverse-linked-list",
      "reverse-nodes-in-k-group"
    ],
    "videoId": "RF_M9tX4Eag",
    "problemStatement": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Linked List Manipulation: Reach 'left'; reverse 'right-left' times; reconnect.",
    "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Use extra array to store all values.",
          "Process in array, then rebuild list."
        ],
        "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
          "\ud83e\udde0 'prev' sits before reversing starts.",
          "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseBetween(head, left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use a Dummy to handle edge case (left=1).\n    - \ud83e\udde0 'prev' sits before reversing starts.\n    - \ud83d\udca1 Reverse the sub-segment standard way. Fix connections.\n\n    Algorithm:\n    1. Reach - Positioning.\n    2. Reverse - Bubble swap.\n    3. Done - Head might change.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    leftPrev, cur = dummy, head  # Initialize current pointer.\n    for i in range(left - 1):  # Iterate through the range.\n        leftPrev, cur = cur, cur.next\n    prev = None\n    for i in range(right - left + 1):  # Iterate through the range.\n        tmp = cur.next\n        cur.next = prev\n        prev, cur = cur, tmp\n    # Connect\n    leftPrev.next.next = cur\n    leftPrev.next = prev\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Losing reference to head",
      "Not handling single node case",
      "Creating cycles accidentally"
    ],
    "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverseBetween(head *ListNode, left int, right int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) reverseBetween(head *ListNode, left int, right int) *ListNode {\n\tif head.Next == nil || left == right {\n\t\treturn head\n\t}\n\tdummy := &ListNode{0, head}\n\tpre := dummy\n\tfor i := 0; i < left-1; i++ {\n\t\tpre = pre.Next\n\t}\n\tp, q := pre, pre.Next\n\tcur := q\n\tfor i := 0; i < right-left+1; i++ {\n\t\tt := cur.Next\n\t\tcur.Next = pre\n\t\tpre = cur\n\t\tcur = t\n\t}\n\tp.Next = pre\n\tq.Next = cur\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_between(\n        head: Option<Box<ListNode>>,\n        left: i32,\n        right: i32,\n    ) -> Option<Box<ListNode>> {\n        let mut dummy = Some(Box::new(ListNode { val: 0, next: head }));\n        let mut pre = &mut dummy;\n        for _ in 1..left {\n            pre = &mut pre.as_mut().unwrap().next;\n        }\n        let mut cur = pre.as_mut().unwrap().next.take();\n        for _ in 0..right - left + 1 {\n            let mut next = cur.as_mut().unwrap().next.take();\n            cur.as_mut().unwrap().next = pre.as_mut().unwrap().next.take();\n            pre.as_mut().unwrap().next = cur.take();\n            cur = next;\n        }\n        for _ in 0..right - left + 1 {\n            pre = &mut pre.as_mut().unwrap().next;\n        }\n        pre.as_mut().unwrap().next = cur;\n        dummy.unwrap().next\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) {\n        // Method implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "group-anagrams",
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "pattern": "Hash Map"
    }
  },
  "maximum-depth-of-binary-tree": {
    "title": "Maximum Depth of Binary Tree",
    "pattern": "DFS (Recursion)",
    "patternEmoji": "\ud83d\udccf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "1 + max(dfs(left), dfs(right))",
    "intuition": [
      "\ud83c\udfaf Base case: Null node has depth 0.",
      "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
      "\ud83d\udca1 Return 1 + max(L, R)."
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3"
      },
      {
        "input": "root = [1,null,2]",
        "output": "2"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Base",
        "visual": "If zero? Ret 0.",
        "explanation": "Leaf check."
      },
      {
        "step": 2,
        "title": "Recurse",
        "visual": "L = depth(left), R = depth(right).",
        "explanation": "Explore."
      },
      {
        "step": 3,
        "title": "Combine",
        "visual": "Ret 1 + max(L, R).",
        "explanation": "Count me."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def maxDepth(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Base case: Null node has depth 0.\n        - \ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.\n        - \ud83d\udca1 Return 1 + max(L, R).\n    \n        Algorithm:\n        1. Base - Leaf check.\n        2. Recurse - Explore.\n        3. Combine - Count me.\n        \"\"\"\n        if not root: return 0  # Base case: Check if tree is empty.\n        return 1 + max(maxDepth(root.left), maxDepth(root.right))  # Take the maximum value.",
    "keyInsight": "Simplest recursion pattern. BFS also works for level counting.",
    "visualizationType": "tree",
    "initialState": [
      3,
      9,
      20,
      15,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "    3\n   / \\\n  9  20\n    /  \\\n   15   7",
        "transientMessage": "DFS from root, track depth",
        "arrayState": [
          3,
          9,
          20,
          15,
          7
        ],
        "pointers": [
          {
            "label": "node",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "At node 9: depth=2, no children",
        "transientMessage": "Left subtree max depth = 2",
        "arrayState": [
          3,
          9,
          20,
          15,
          7
        ],
        "pointers": [
          {
            "label": "node",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "At node 20: go deeper",
        "transientMessage": "Check children 15 and 7 at depth 3",
        "arrayState": [
          3,
          9,
          20,
          15,
          7
        ],
        "pointers": [
          {
            "label": "node",
            "index": 2
          }
        ],
        "indices": [
          2,
          5,
          6
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Right subtree max depth = 3",
        "transientMessage": "max(left=2, right=3) + 1 = 3",
        "arrayState": [
          3,
          9,
          20,
          15,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          2,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Answer: 3",
        "transientMessage": "Maximum depth is 3 \u2705",
        "arrayState": [
          3,
          9,
          20,
          15,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "Root -> 20 -> 15 or 7 is 3 levels."
      },
      {
        "input": "root = [1,null,2]",
        "output": "2",
        "explanation": "Root -> 2 is 2 levels."
      }
    ],
    "constraints": [
      "The number of nodes is in range [0, 10^4].",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "Use recursion: depth = 1 + max(left, right).",
      "Or use BFS level order traversal.",
      "Count levels as you traverse."
    ],
    "relatedProblems": [
      "minimum-depth-of-binary-tree",
      "balanced-binary-tree",
      "maximum-depth-of-n-ary-tree"
    ],
    "videoId": "hTM3phVI6YQ",
    "problemStatement": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS (Recursion): 1 + max(dfs(left), dfs(right))",
    "suggestedNextQuestion": {
      "slug": "path-sum",
      "title": "Path Sum",
      "difficulty": "Easy",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Base case: Null node has depth 0.",
          "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
          "\ud83d\udca1 Return 1 + max(L, R)."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef maxDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Base case: Null node has depth 0.\n    - \ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.\n    - \ud83d\udca1 Return 1 + max(L, R).\n\n    Algorithm:\n    1. Base - Leaf check.\n    2. Recurse - Explore.\n    3. Combine - Count me.\n    \"\"\"\n    if not root: return 0  # Base case: Check if tree is empty.\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))  # Take the maximum value."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxDepth(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public int maxDepth(TreeNode root) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxDepth(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tl, r := maxDepth(root.Left), maxDepth(root.Right)\n\treturn 1 + max(l, r)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        if root.is_none() {\n            return 0;\n        }\n        let node = root.as_ref().unwrap().borrow();\n        1 + Self::dfs(&node.left).max(Self::dfs(&node.right))\n    }\n\n    pub fn max_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        Self::dfs(&root)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "same-tree": {
    "title": "Same Tree",
    "pattern": "DFS (Recursion)",
    "patternEmoji": "\ud83d\udc6f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
    "intuition": [
      "\ud83c\udfaf Are they structural clones with same values?",
      "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
      "\ud83d\udca1 Else, check children recursively."
    ],
    "testCases": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true"
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false"
      },
      {
        "input": "p = [1,2,1], q = [1,1,2]",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Null Check",
        "visual": "Both None -> True. One None -> False.",
        "explanation": "Structure."
      },
      {
        "step": 2,
        "title": "Val Check",
        "visual": "p.val != q.val -> False.",
        "explanation": "Data."
      },
      {
        "step": 3,
        "title": "Recurse",
        "visual": "return same(L,L) and same(R,R).",
        "explanation": "Deep check."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def isSameTree(self, p, q):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Are they structural clones with same values?\n        - \ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.\n        - \ud83d\udca1 Else, check children recursively.\n    \n        Algorithm:\n        1. Null Check - Structure.\n        2. Val Check - Data.\n        3. Recurse - Deep check.\n        \"\"\"\n        if not p and not q: return True  # Condition satisfied.\n        if not p or not q or p.val != q.val: return False  # Condition not met.\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
    "keyInsight": "Checking 'not p and not q' handles the leaf success case naturally.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Same Tree",
        "transientMessage": "Input: [1, 2, 3]",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 3",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
      {
        "input": "p = [1,2,3], q = [1,2,3]",
        "output": "true",
        "explanation": "Both trees have same structure and values."
      },
      {
        "input": "p = [1,2], q = [1,null,2]",
        "output": "false",
        "explanation": "Different structure."
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in range [0, 100].",
      "-10^4 <= Node.val <= 10^4"
    ],
    "hints": [
      "If both null, return true. If one null, return false.",
      "If values differ, return false.",
      "Recursively check left and right subtrees."
    ],
    "relatedProblems": [
      "symmetric-tree",
      "subtree-of-another-tree"
    ],
    "videoId": "vRbbcKXCxOw",
    "problemStatement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS (Recursion): Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
    "suggestedNextQuestion": {
      "slug": "symmetric-tree",
      "title": "Symmetric Tree",
      "difficulty": "Easy",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isSameTree(p, q):\n    if not p and not q: return True\n    if not p or not q or p.val != q.val: return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Are they structural clones with same values?",
          "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
          "\ud83d\udca1 Else, check children recursively."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSameTree(p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Are they structural clones with same values?\n    - \ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.\n    - \ud83d\udca1 Else, check children recursively.\n\n    Algorithm:\n    1. Null Check - Structure.\n    2. Val Check - Data.\n    3. Recurse - Deep check.\n    \"\"\"\n    if not p and not q: return True  # Condition satisfied.\n    if not p or not q or p.val != q.val: return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(p: TreeNode | null, q: TreeNode | null): void {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(p: TreeNode | null, q: TreeNode | null): void {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__() {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isSameTree(p *TreeNode, q *TreeNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) isSameTree(p *TreeNode, q *TreeNode) bool {\n\tif p == q {\n\t\treturn true\n\t}\n\tif p == nil || q == nil || p.Val != q.Val {\n\t\treturn false\n\t}\n\treturn isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\n        if p.is_none() && q.is_none() {\n            return true;\n        }\n        if p.is_none() || q.is_none() {\n            return false;\n        }\n        let r1 = p.as_ref().unwrap().borrow();\n        let r2 = q.as_ref().unwrap().borrow();\n        r1.val == r2.val && Self::dfs(&r1.left, &r2.left) && Self::dfs(&r1.right, &r2.right)\n    }\n\n    pub fn is_same_tree(\n        p: Option<Rc<RefCell<TreeNode>>>,\n        q: Option<Rc<RefCell<TreeNode>>>,\n    ) -> bool {\n        Self::dfs(&p, &q)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "symmetric-tree": {
    "title": "Symmetric Tree",
    "pattern": "DFS (Helpers)",
    "patternEmoji": "\ud83e\ude9e",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
    "intuition": [
      "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
      "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
      "\ud83d\udca1 Key is crossing the comparison."
    ],
    "testCases": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true"
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Helper",
        "visual": "check(L, R)",
        "explanation": "Start split."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "L.val == R.val?",
        "explanation": "Values."
      },
      {
        "step": 3,
        "title": "Recurse",
        "visual": "check(L.left, R.right) AND check(L.right, R.left).",
        "explanation": "Mirror logic."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def isSymmetric(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.\n        - \ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?\n        - \ud83d\udca1 Key is crossing the comparison.\n    \n        Algorithm:\n        1. Helper - Start split.\n        2. Check - Values.\n        3. Recurse - Mirror logic.\n        \"\"\"\n        if not root: return True  # Base case: Check if tree is empty.\n        def dfs(self, left, right):\n            if not left and not right: return True  # Condition satisfied.\n            if not left or not right: return False  # Condition not met.\n            return (left.val == right.val and \n                    dfs(left.left, right.right) and \n                    dfs(left.right, right.left))\n        return dfs(root.left, root.right)",
    "keyInsight": "You need a helper function because the 'root' only has specific logic, while the recursive step compares TWO nodes.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      2,
      3,
      4,
      4,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Symmetric Tree",
        "transientMessage": "Input: [1, 2, 2, 3, 4, 4, 3]",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 2",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 3",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 4",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          2,
          3,
          4,
          4,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "Left and right subtrees are mirrors."
      },
      {
        "input": "root = [1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "Not symmetric."
      }
    ],
    "constraints": [
      "The number of nodes is in range [1, 1000].",
      "-100 <= Node.val <= 100"
    ],
    "hints": [
      "Compare left subtree with right subtree.",
      "Left's left should equal Right's right.",
      "Left's right should equal Right's left."
    ],
    "relatedProblems": [
      "same-tree",
      "flip-equivalent-binary-trees"
    ],
    "videoId": "Mao9uzxwvmc",
    "problemStatement": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS (Helpers): Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
    "suggestedNextQuestion": {
      "slug": "binary-tree-level-order-traversal",
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isSymmetric(root):\n    if not root: return True\n    def isMirror(t1, t2):\n        if not t1 and not t2: return True\n        if not t1 or not t2 or t1.val != t2.val: return False\n        return isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n    return isMirror(root.left, root.right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
          "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
          "\ud83d\udca1 Key is crossing the comparison."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSymmetric(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.\n    - \ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?\n    - \ud83d\udca1 Key is crossing the comparison.\n\n    Algorithm:\n    1. Helper - Start split.\n    2. Check - Values.\n    3. Recurse - Mirror logic.\n    \"\"\"\n    if not root: return True  # Base case: Check if tree is empty.\n    def dfs(left, right):\n        if not left and not right: return True  # Condition satisfied.\n        if not left or not right: return False  # Condition not met.\n        return (left.val == right.val and \n                dfs(left.left, right.right) and \n                dfs(left.right, right.left))\n    return dfs(root.left, root.right)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isSymmetric(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isSymmetric(root *TreeNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) isSymmetric(root *TreeNode) bool {\n\tvar dfs func(root1, root2 *TreeNode) bool\n\tdfs = func(root1, root2 *TreeNode) bool {\n\t\tif root1 == root2 {\n\t\t\treturn true\n\t\t}\n\t\tif root1 == nil || root2 == nil || root1.Val != root2.Val {\n\t\t\treturn false\n\t\t}\n\t\treturn dfs(root1.Left, root2.Right) && dfs(root1.Right, root2.Left)\n\t}\n\treturn dfs(root.Left, root.Right)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        fn dfs(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> bool {\n            match (root1, root2) {\n                (Some(node1), Some(node2)) => {\n                    let node1 = node1.borrow();\n                    let node2 = node2.borrow();\n                    node1.val == node2.val\n                        && dfs(node1.left.clone(), node2.right.clone())\n                        && dfs(node1.right.clone(), node2.left.clone())\n                }\n                (None, None) => true,\n                _ => false,\n            }\n        }\n\n        match root {\n            Some(root) => dfs(root.borrow().left.clone(), root.borrow().right.clone()),\n            None => true,\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "binary-tree-level-order-traversal": {
    "title": "Binary Tree Level Order Traversal",
    "pattern": "BFS (Queue)",
    "patternEmoji": "\ud83d\udcc2",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use a deque; process current level sizet times; append children.",
    "intuition": [
      "\ud83c\udfaf Breadth-first.",
      "\ud83e\udde0 Queue valid nodes.",
      "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]"
      },
      {
        "input": "root = [1]",
        "output": "[[1]]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "Q = [root]",
        "explanation": "Start."
      },
      {
        "step": 2,
        "title": "Level Loop",
        "visual": "For _ in range(len(Q)): Pop, Add data, Push children.",
        "explanation": "Batch process."
      },
      {
        "step": 3,
        "title": "Result",
        "visual": "Append level list to results.",
        "explanation": "Structure."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def levelOrder(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Breadth-first.\n        - \ud83e\udde0 Queue valid nodes.\n        - \ud83d\udca1 Snapshot queue length 'L' to know boundary of current level.\n    \n        Algorithm:\n        1. Init - Start.\n        2. Level Loop - Batch process.\n        3. Result - Structure.\n        \"\"\"\n        import collections\n        res = []  # Initialize list to store results.\n        q = collections.deque()\n        q.append(root)  # Add to end.\n        while q:\n            qLen = len(q)\n            level = []\n            for i in range(qLen):  # Iterate through the range.\n                node = q.popleft()  # Remove from front of queue.\n                if node:\n                    level.append(node.val)  # Add to end.\n                    q.append(node.left)  # Add to end.\n                    q.append(node.right)  # Add to end.\n            if level:\n                res.append(level)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "Checking `if node:` inside the loop is cleaner than checking children individually before appending.",
    "visualizationType": "tree",
    "initialState": [
      3,
      9,
      20,
      15,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Binary Tree Level Order Traversal",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": "Level by level from top to bottom."
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": "Single node."
      }
    ],
    "constraints": [
      "The number of nodes is in range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "hints": [
      "Use BFS with a queue.",
      "Track level size to separate levels.",
      "Add all nodes at current level, then move to next."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal-ii",
      "binary-tree-zigzag-level-order-traversal",
      "average-of-levels-in-binary-tree"
    ],
    "videoId": "6ZnyEApgFYg",
    "problemStatement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BFS (Queue): Use a deque; process current level sizet times; append children.",
    "suggestedNextQuestion": {
      "slug": "binary-tree-right-side-view",
      "title": "Binary Tree Right Side View",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def levelOrder(root):\n    if not root: return []\n    res = []\n    q = [root]\n    while q:\n        level = []\n        next_q = []\n        for node in q:\n            level.append(node.val)\n            if node.left: next_q.append(node.left)\n            if node.right: next_q.append(node.right)\n        res.append(level)\n        q = next_q\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Breadth-first.",
          "\ud83e\udde0 Queue valid nodes.",
          "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef levelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Breadth-first.\n    - \ud83e\udde0 Queue valid nodes.\n    - \ud83d\udca1 Snapshot queue length 'L' to know boundary of current level.\n\n    Algorithm:\n    1. Init - Start.\n    2. Level Loop - Batch process.\n    3. Result - Structure.\n    \"\"\"\n    import collections\n    res = []  # Initialize list to store results.\n    q = collections.deque()\n    q.append(root)  # Add to end.\n    while q:\n        qLen = len(q)\n        level = []\n        for i in range(qLen):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if node:\n                level.append(node.val)  # Add to end.\n                q.append(node.left)  # Add to end.\n                q.append(node.right)  # Add to end.\n        if level:\n            res.append(level)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> __init__(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> __init__(TreeNode root) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) levelOrder(root *TreeNode) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) levelOrder(root *TreeNode) (ans [][]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tq := []*TreeNode{root}\n\tfor len(q) > 0 {\n\t\tt := []int{}\n\t\tfor n := len(q); n > 0; n-- {\n\t\t\tnode := q[0]\n\t\t\tq = q[1:]\n\t\t\tt = append(t, node.Val)\n\t\t\tif node.Left != nil {\n\t\t\t\tq = append(q, node.Left)\n\t\t\t}\n\t\t\tif node.Right != nil {\n\t\t\t\tq = append(q, node.Right)\n\t\t\t}\n\t\t}\n\t\tans = append(ans, t)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut ans = Vec::new();\n        if let Some(root_node) = root {\n            let mut q = VecDeque::new();\n            q.push_back(root_node);\n            while !q.is_empty() {\n                let mut t = Vec::new();\n                for _ in 0..q.len() {\n                    if let Some(node) = q.pop_front() {\n                        let node_ref = node.borrow();\n                        t.push(node_ref.val);\n                        if let Some(ref left) = node_ref.left {\n                            q.push_back(Rc::clone(left));\n                        }\n                        if let Some(ref right) = node_ref.right {\n                            q.push_back(Rc::clone(right));\n                        }\n                    }\n                }\n                ans.push(t);\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n    \n    levelOrder(root: TreeNode | null): number[][] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "clone-graph": {
    "title": "Clone Graph",
    "pattern": "Graph (Hashtable + DFS)",
    "patternEmoji": "\ud83d\udd78",
    "timeComplexity": "O(N + E)",
    "spaceComplexity": "O(N)",
    "oneliner": "Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
    "intuition": [
      "\ud83c\udfaf Deep copy means creating new instances for every node.",
      "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
      "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
    ],
    "testCases": [
      {
        "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
        "output": "[[2,4],[1,3],[2,4],[1,3]]"
      },
      {
        "input": "adjList = [[]]",
        "output": "[[]]"
      },
      {
        "input": "adjList = []",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Map",
        "visual": "Init map = {}. DFS(node).",
        "explanation": "Start traversal."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "If node in map? Return map[node].",
        "explanation": "Cycle handled."
      },
      {
        "step": 3,
        "title": "Copy",
        "visual": "copy = Node(node.val). map[node] = copy.",
        "explanation": "Create node."
      },
      {
        "step": 4,
        "title": "Neighbors",
        "visual": "For nei in neighbors: copy.neighbors.append(dfs(nei)).",
        "explanation": "Recurse."
      }
    ],
    "code": "class Solution:\n    # Definition for a Node.\n    # class Node:\n    #     def __init__(self, val = 0, neighbors = None):\n    #         self.val = val\n    #         self.neighbors = neighbors if neighbors is not None else []\n    class Node:  # Node definition with random pointer.\n        def __init__(self, val = 0, neighbors = None):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Deep copy means creating new instances for every node.\n        - \ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.\n        - \ud83d\udca1 Map acts as 'visited' set AND reference storage.\n    \n        Algorithm:\n        1. Map - Start traversal.\n        2. Check - Cycle handled.\n        3. Copy - Create node.\n        4. Neighbors - Recurse.\n        \"\"\"\n            self.val = val\n            self.neighbors = neighbors if neighbors is not None else []\n    \n    def cloneGraph(self, node):\n        if not node: return None\n        oldToNew = {}\n        \n        def dfs(self, node):\n            if node in oldToNew:\n                return oldToNew[node]\n            \n            copy = Node(node.val)\n            oldToNew[node] = copy\n            \n            for nei in node.neighbors:  # Iterate over elements.\n                copy.neighbors.append(dfs(nei))  # Add to end.\n            return copy\n            \n        return dfs(node)",
    "keyInsight": "The hashmap is essential. Without it, you'd get stuck in an infinite loop due to cycles.",
    "visualizationType": "graph",
    "initialState": [
      [
        2,
        4
      ],
      [
        1,
        3
      ],
      [
        2,
        4
      ],
      [
        1,
        3
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Input: Connected Graph",
        "transientMessage": "node.val = 1, neighbors = [2,4]",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 100
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 200
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 200
            },
            {
              "id": "4",
              "label": "4",
              "x": 200,
              "y": 300
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "1",
              "to": "4"
            },
            {
              "from": "2",
              "to": "3"
            },
            {
              "from": "3",
              "to": "4"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "BFS: Start at node 1",
        "transientMessage": "Create clone, add to visited",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 200
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 200
            },
            {
              "id": "4",
              "label": "4",
              "x": 200,
              "y": 300
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "1",
              "to": "4"
            },
            {
              "from": "2",
              "to": "3"
            },
            {
              "from": "3",
              "to": "4"
            }
          ]
        },
        "pointers": [
          {
            "label": "curr",
            "node": "1"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Clone neighbors 2, 4",
        "transientMessage": "Connect clones to node 1",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 100,
              "y": 200,
              "visited": true
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 200
            },
            {
              "id": "4",
              "label": "4 \u2713",
              "x": 200,
              "y": 300,
              "visited": true
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2",
              "highlight": true
            },
            {
              "from": "1",
              "to": "4",
              "highlight": true
            },
            {
              "from": "2",
              "to": "3"
            },
            {
              "from": "3",
              "to": "4"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Clone neighbor 3",
        "transientMessage": "Complete all edges",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 100,
              "y": 200,
              "visited": true
            },
            {
              "id": "3",
              "label": "3 \u2713",
              "x": 300,
              "y": 200,
              "visited": true
            },
            {
              "id": "4",
              "label": "4 \u2713",
              "x": 200,
              "y": 300,
              "visited": true
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "1",
              "to": "4"
            },
            {
              "from": "2",
              "to": "3",
              "highlight": true
            },
            {
              "from": "3",
              "to": "4",
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "success"
      }
    ],
    "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.",
    "examples": [
      {
        "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
        "output": "[[2,4],[1,3],[2,4],[1,3]]",
        "explanation": "Deep copy of the graph."
      }
    ],
    "constraints": [
      "The number of nodes is in range [0, 100].",
      "1 <= Node.val <= 100",
      "Node.val is unique for each node.",
      "There are no repeated edges and no self-loops."
    ],
    "hints": [
      "Use hash map: old node -> cloned node.",
      "Use BFS or DFS to traverse.",
      "Clone node first, then clone neighbors."
    ],
    "relatedProblems": [
      "copy-list-with-random-pointer",
      "clone-n-ary-tree",
      "clone-binary-tree-with-random-pointer"
    ],
    "videoId": "mQeF6bN8hMk",
    "problemStatement": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nTest case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Graph (Hashtable + DFS): Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
    "graphNodes": [
      {
        "id": 1,
        "label": "1"
      },
      {
        "id": 2,
        "label": "2"
      },
      {
        "id": 3,
        "label": "3"
      },
      {
        "id": 4,
        "label": "4"
      }
    ],
    "graphEdges": [
      {
        "from": 1,
        "to": 2
      },
      {
        "from": 1,
        "to": 4
      },
      {
        "from": 2,
        "to": 3
      },
      {
        "from": 3,
        "to": 4
      }
    ],
    "suggestedNextQuestion": {
      "slug": "count-good-nodes-in-binary-tree",
      "title": "Count Good Nodes In Binary Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Node:  # Node definition with random pointer.\n    def __init__(self, val = 0, neighbors = None):\n        pass\n\ndef cloneGraph(node):\n    pass\n\n    def dfs(node):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(V * E) or O(V!)",
        "spaceComplexity": "O(V)",
        "intuition": [
          "Explore all possible paths.",
          "Use DFS/BFS without optimization."
        ],
        "code": "def __init___brute(graph, start, end):\n    # DFS all paths\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start, set())"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N + E)",
        "spaceComplexity": "O(N)",
        "intuition": [
          "\ud83c\udfaf Deep copy means creating new instances for every node.",
          "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
          "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
        ],
        "code": "# Definition for a Node.\n# class Node:\n#     def __init__(self, val = 0, neighbors = None):\n#         self.val = val\n#         self.neighbors = neighbors if neighbors is not None else []\nclass Node:  # Node definition with random pointer.\n    def __init__(self, val = 0, neighbors = None):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Deep copy means creating new instances for every node.\n    - \ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.\n    - \ud83d\udca1 Map acts as 'visited' set AND reference storage.\n\n    Algorithm:\n    1. Map - Start traversal.\n    2. Check - Cycle handled.\n    3. Copy - Create node.\n    4. Neighbors - Recurse.\n    \"\"\"\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node: return None\n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        \n        for nei in node.neighbors:  # Iterate over elements.\n            copy.neighbors.append(dfs(nei))  # Add to end.\n        return copy\n        \n    return dfs(node)"
      }
    ],
    "commonMistakes": [
      "Forgetting to mark nodes as visited",
      "Not handling disconnected components",
      "Wrong initialization of distance array"
    ],
    "interviewTip": "Clarify: directed/undirected, weighted/unweighted. Mention BFS for shortest path.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(node) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(node) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Node cloneGraph(Node node) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public Node cloneGraph(Node node) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    Node() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) cloneGraph(node *Node) *Node {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Neighbors []*Node\n * }\n */\n\nfunc (s *Solution) cloneGraph(node *Node) *Node {\n\tg := map[*Node]*Node{}\n\tvar dfs func(node *Node) *Node\n\tdfs = func(node *Node) *Node {\n\t\tif node == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif n, ok := g[node]; ok {\n\t\t\treturn n\n\t\t}\n\t\tcloned := &Node{node.Val, []*Node{}}\n\t\tg[node] = cloned\n\t\tfor _, nxt := range node.Neighbors {\n\t\t\tcloned.Neighbors = append(cloned.Neighbors, dfs(nxt))\n\t\t}\n\t\treturn cloned\n\t}\n\treturn dfs(node)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn solve() {\n        // Your code here\n    }\n}\n",
        "code": "// Solution requires complex Rc/RefCell node handling in Rust."
      },
      "python": {
        "initialCode": "class Node:  # Node definition with random pointer.\n    def __init__(self, val = 0, neighbors = None):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(node: Node | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(node: Node | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "course-schedule": {
    "title": "Course Schedule",
    "pattern": "Topological Sort (DFS/BFS)",
    "patternEmoji": "\ud83d\udcc3",
    "timeComplexity": "O(N + E)",
    "spaceComplexity": "O(N + E)",
    "oneliner": "Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
    "intuition": [
      "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
      "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
      "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
    ],
    "testCases": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true"
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Build",
        "visual": "Adj List: {0: [1]}.",
        "explanation": "Graph rep."
      },
      {
        "step": 2,
        "title": "DFS",
        "visual": "Visit 0. State[0]=Visiting. Visit children.",
        "explanation": "Traverse."
      },
      {
        "step": 3,
        "title": "Cycle?",
        "visual": "Back edge to Visiting? Cycle! Finish: State[0]=Visited.",
        "explanation": "Detection."
      }
    ],
    "code": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.\n        - \ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.\n        - \ud83d\udca1 If we meet '1' (visiting), cycle detected.\n\n        Algorithm:\n        1. Build - Graph rep.\n        2. DFS - Traverse.\n        3. Cycle? - Detection.\n        \"\"\"\n        preMap = { i: [] for i in range(numCourses) }  # Iterate through the range.\n        for crs, pre in prerequisites:  # Iterate over elements.\n            preMap[crs].append(pre)  # Add to end.\n\n        visitSet = set() # Visiting\n\n        def dfs(crs):\n            if crs in visitSet:\n                return False  # Condition not met.\n            if preMap[crs] == []: # No prereqs or already verified\n                return True  # Condition satisfied.\n\n            visitSet.add(crs)\n            for pre in preMap[crs]:  # Iterate over elements.\n                if not dfs(pre): return False  # Condition not met.\n            visitSet.remove(crs)\n            preMap[crs] = [] # Optimization: marked as verified\n            return True  # Condition satisfied.\n\n        for crs in range(numCourses):  # Iterate through the range.\n            if not dfs(crs): return False  # Condition not met.\n        return True  # Condition satisfied.",
    "keyInsight": "Clearing `preMap[crs] = []` acts as marking it 'Visited' (safe), optimizing so we don't re-check safe nodes.",
    "visualizationType": "graph",
    "initialState": {
      "numCourses": 2,
      "prerequisites": [
        [
          1,
          0
        ]
      ]
    },
    "animationSteps": [
      {
        "step": 1,
        "visual": "Build DAG",
        "transientMessage": "prereqs=[[1,0],[2,0],[3,1],[3,2]]",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0",
              "x": 200,
              "y": 50
            },
            {
              "id": "1",
              "label": "1",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Indegree = [0,1,1,2]",
        "transientMessage": "Course 0 has no prereqs",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 (in:0)",
              "x": 200,
              "y": 50,
              "highlight": true
            },
            {
              "id": "1",
              "label": "1 (in:1)",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 (in:1)",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3 (in:2)",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Take course 0",
        "transientMessage": "Decrement neighbors",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 (in:0)",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "2",
              "label": "2 (in:0)",
              "x": 300,
              "y": 150,
              "highlight": true
            },
            {
              "id": "3",
              "label": "3",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "highlight": true
            },
            {
              "from": "0",
              "to": "2",
              "highlight": true
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [
          {
            "label": "taken",
            "value": "1"
          }
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Take 1 & 2",
        "transientMessage": "Both ready (indegree=0)",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 150,
              "visited": true
            },
            {
              "id": "3",
              "label": "3 (in:0)",
              "x": 200,
              "y": 250,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [
          {
            "label": "taken",
            "value": "3"
          }
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Result: True",
        "transientMessage": "All 4 courses completed!",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3 \u2713",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [],
        "color": "success"
      }
    ],
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": "Take 0 first, then 1."
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": "Cycle exists, impossible."
      }
    ],
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses"
    ],
    "hints": [
      "This is cycle detection in a directed graph.",
      "Use topological sort (Kahn's algorithm or DFS).",
      "If cycle exists, cannot complete all courses."
    ],
    "relatedProblems": [
      "course-schedule-ii",
      "course-schedule-iv",
      "minimum-height-trees"
    ],
    "videoId": "EgI5nU9etnU",
    "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn true if you can finish all courses. Otherwise, return false.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Topological Sort (DFS/BFS): Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
    "suggestedNextQuestion": {
      "slug": "course-schedule-ii",
      "title": "Course Schedule II",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def canFinish(numCourses, prerequisites):\n    # Build graph\n    adj = [[] for _ in range(numCourses)]\n    for dest, src in prerequisites:\n        adj[src].append(dest)\n    \n    visited = [0] * numCourses # 0=unvisited, 1=visiting, 2=visited\n    def hasCycle(node):\n        if visited[node] == 1: return True\n        if visited[node] == 2: return False\n        visited[node] = 1\n        for neighbor in adj[node]:\n            if hasCycle(neighbor): return True\n        visited[node] = 2\n        return False\n        \n    for i in range(numCourses):\n        if hasCycle(i): return False\n    return True"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N + E)",
        "spaceComplexity": "O(N + E)",
        "intuition": [
          "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
          "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
          "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
        ],
        "code": "def canFinish(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.\n    - \ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.\n    - \ud83d\udca1 If we meet '1' (visiting), cycle detected.\n\n    Algorithm:\n    1. Build - Graph rep.\n    2. DFS - Traverse.\n    3. Cycle? - Detection.\n    \"\"\"\n    preMap = { i: [] for i in range(numCourses) }  # Iterate through the range.\n    for crs, pre in prerequisites:  # Iterate over elements.\n        preMap[crs].append(pre)  # Add to end.\n        \n    visitSet = set() # Visiting\n    \n    def dfs(crs):\n        if crs in visitSet:\n            return False  # Condition not met.\n        if preMap[crs] == []: # No prereqs or already verified\n            return True  # Condition satisfied.\n            \n        visitSet.add(crs)\n        for pre in preMap[crs]:  # Iterate over elements.\n            if not dfs(pre): return False  # Condition not met.\n        visitSet.remove(crs)\n        preMap[crs] = [] # Optimization: marked as verified\n        return True  # Condition satisfied.\n        \n    for crs in range(numCourses):  # Iterate through the range.\n        if not dfs(crs): return False  # Condition not met.\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    canFinish(numCourses, prerequisites) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} numCourses, prerequisites\n     * @return {any}\n     */\n    canFinish(numCourses, prerequisites) {\n        const graph = new Map();\n        const seen = new Set();\n\n        prerequisites.forEach(([course, prerequisite]) => {\n          graph.set(course, graph.get(course) || []);\n          graph.get(course).push(prerequisite);\n        });\n\n        class Solution {\n          /**\n           * @param {any} course\n           * @return {any}\n           */\n          dfs(course) {\n          if (seen.has(course)) {\n            return false;\n          }\n          seen.add(course);\n          for (const prerequisite of graph.get(course) || []) {\n            if (!dfs(prerequisite)) return false;\n          }\n          seen.delete(course);\n          graph.set(course, []);\n          return true;\n        }\n\n        for (let i = 0; i < numCourses; i++) {\n          if (!dfs(i)) {\n            return false;\n          }\n      }\n\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<Integer>[] g = new List[numCourses];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        int[] indeg = new int[numCourses];\n        for (var p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].add(a);\n            ++indeg[a];\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        while (!q.isEmpty()) {\n            int i = q.poll();\n            --numCourses;\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.offer(j);\n                }\n            }\n        }\n        return numCourses == 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> g(numCourses);\n        vector<int> indeg(numCourses);\n        for (auto& p : prerequisites) {\n            int a = p[0], b = p[1];\n            g[b].push_back(a);\n            ++indeg[a];\n        }\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indeg[i] == 0) {\n                q.push(i);\n            }\n        }\n        while (!q.empty()) {\n            int i = q.front();\n            q.pop();\n            --numCourses;\n            for (int j : g[i]) {\n                if (--indeg[j] == 0) {\n                    q.push(j);\n                }\n            }\n        }\n        return numCourses == 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canFinish(numCourses int, prerequisites [][]int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canFinish(numCourses int, prerequisites [][]int) bool {\n\tg := make([][]int, numCourses)\n\tindeg := make([]int, numCourses)\n\tfor _, p := range prerequisites {\n\t\ta, b := p[0], p[1]\n\t\tg[b] = append(g[b], a)\n\t\tindeg[a]++\n\t}\n\tq := []int{}\n\tfor i, x := range indeg {\n\t\tif x == 0 {\n\t\t\tq = append(q, i)\n\t\t}\n\t}\n\tfor len(q) > 0 {\n\t\ti := q[0]\n\t\tq = q[1:]\n\t\tnumCourses--\n\t\tfor _, j := range g[i] {\n\t\t\tindeg[j]--\n\t\t\tif indeg[j] == 0 {\n\t\t\t\tq = append(q, j)\n\t\t\t}\n\t\t}\n\t}\n\treturn numCourses == 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_finish(mut num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::VecDeque;\n\nimpl Solution {\n    pub fn can_finish(mut num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        let mut g: Vec<Vec<i32>> = vec![vec![]; num_courses as usize];\n        let mut indeg: Vec<i32> = vec![0; num_courses as usize];\n\n        for p in prerequisites {\n            let a = p[0] as usize;\n            let b = p[1] as usize;\n            g[b].push(a as i32);\n            indeg[a] += 1;\n        }\n\n        let mut q: VecDeque<usize> = VecDeque::new();\n        for i in 0..num_courses {\n            if indeg[i as usize] == 0 {\n                q.push_back(i as usize);\n            }\n        }\n\n        while let Some(i) = q.pop_front() {\n            num_courses -= 1;\n            for &j in &g[i] {\n                let j = j as usize;\n                indeg[j] -= 1;\n                if indeg[j] == 0 {\n                    q.push_back(j);\n                }\n            }\n        }\n\n        num_courses == 0\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    canFinish(numCourses: number, prerequisites: number[][]): boolean  {\n    const g: number[][] = Array.from({ length: numCourses }, () => []);\n    const indeg: number[] = Array(numCourses).fill(0);\n    for (const [a, b] of prerequisites) {\n        g[b].push(a);\n        indeg[a]++;\n    }\n    const q: number[] = [];\n    for (let i = 0; i < numCourses; ++i) {\n        if (indeg[i] === 0) {\n            q.push(i);\n        }\n    }\n    for (const i of q) {\n        --numCourses;\n        for (const j of g[i]) {\n            if (--indeg[j] === 0) {\n                q.push(j);\n            }\n        }\n    }\n    return numCourses === 0;\n}\n}",
        "initialCode": "class Solution {\n    canFinish(numCourses: number, prerequisites: number[][]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "permutations": {
    "title": "Permutations",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(N!)",
    "spaceComplexity": "O(N)",
    "oneliner": "Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
    "intuition": [
      "\ud83c\udfaf Ordering matters.",
      "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
      "\ud83d\udca1 Base case: len(path) == len(nums)."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]"
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Choose",
        "visual": "Pick 1. Remaining: [2,3].",
        "explanation": "Branch."
      },
      {
        "step": 2,
        "title": "Recurse",
        "visual": "dfs(path + [1]).",
        "explanation": "Explore."
      },
      {
        "step": 3,
        "title": "Backtrack",
        "visual": "Pop 1. Try 2.",
        "explanation": "Undo."
      }
    ],
    "code": "class Solution:\n    def permute(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Ordering matters.\n        - \ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...\n        - \ud83d\udca1 Base case: len(path) == len(nums).\n\n        Algorithm:\n        1. Choose - Branch.\n        2. Recurse - Explore.\n        3. Backtrack - Undo.\n        \"\"\"\n        res = []  # Initialize list to store results.\n\n        if (len(nums) == 1):\n            return [nums[:]]\n\n        for i in range(len(nums)):  # Iterate through the range.\n            n = nums.pop(0)  # Remove and return last element.\n            perms = permute(nums)\n\n            for p in perms:  # Iterate over elements.\n                p.append(n)  # Add to end.\n            res.extend(perms)\n            nums.append(n)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "The iterative swapping or popping/appending creates the variations without explicit visited sets.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [1, 2, 3]",
        "transientMessage": "Generate all permutations",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Pick 1, remaining: [2, 3]",
        "transientMessage": "Path: [1]",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Pick 2, remaining: [3]",
        "transientMessage": "Path: [1, 2]",
        "arrayState": [
          2,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Pick 3, remaining: []",
        "transientMessage": "Path: [1, 2, 3]",
        "arrayState": [
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Found: [1, 2, 3]",
        "transientMessage": "1 permutations",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Pick 3, remaining: [2]",
        "transientMessage": "Path: [1, 3]",
        "arrayState": [
          2,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Pick 2, remaining: []",
        "transientMessage": "Path: [1, 3, 2]",
        "arrayState": [
          2
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Found: [1, 3, 2]",
        "transientMessage": "2 permutations",
        "arrayState": [
          1,
          3,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Pick 2, remaining: [1, 3]",
        "transientMessage": "Path: [2]",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Pick 1, remaining: [3]",
        "transientMessage": "Path: [2, 1]",
        "arrayState": [
          1,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Pick 3, remaining: []",
        "transientMessage": "Path: [2, 1, 3]",
        "arrayState": [
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Found: [2, 1, 3]",
        "transientMessage": "3 permutations",
        "arrayState": [
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "Pick 3, remaining: [1]",
        "transientMessage": "Path: [2, 3]",
        "arrayState": [
          1,
          3
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 14,
        "visual": "Pick 1, remaining: []",
        "transientMessage": "Path: [2, 3, 1]",
        "arrayState": [
          1
        ],
        "pointers": [
          {
            "label": "pick",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 15,
        "visual": "Found: [2, 3, 1]",
        "transientMessage": "4 permutations",
        "arrayState": [
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 16,
        "visual": "Total: 4 permutations",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": "All 6 permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Only one permutation."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 6",
      "-10 <= nums[i] <= 10",
      "All integers in nums are unique."
    ],
    "hints": [
      "Use backtracking.",
      "At each position, try all remaining numbers.",
      "Swap elements to avoid using extra space."
    ],
    "relatedProblems": [
      "permutations-ii",
      "next-permutation",
      "combinations"
    ],
    "videoId": "s7AvT7cGdSo",
    "problemStatement": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
    "suggestedNextQuestion": {
      "slug": "subsets",
      "title": "Subsets",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def permute(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def permute_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N!)",
        "spaceComplexity": "O(N)",
        "intuition": [
          "\ud83c\udfaf Ordering matters.",
          "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
          "\ud83d\udca1 Base case: len(path) == len(nums)."
        ],
        "code": "def permute(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Ordering matters.\n    - \ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...\n    - \ud83d\udca1 Base case: len(path) == len(nums).\n\n    Algorithm:\n    1. Choose - Branch.\n    2. Recurse - Explore.\n    3. Backtrack - Undo.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    if (len(nums) == 1):\n        return [nums[:]]\n        \n    for i in range(len(nums)):  # Iterate through the range.\n        n = nums.pop(0)  # Remove and return last element.\n        perms = permute(nums)\n        \n        for p in perms:  # Iterate over elements.\n            p.append(n)  # Add to end.\n        res.extend(perms)\n        nums.append(n)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    permute(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    permute(nums) {\n        const n = nums.length;\n        const ans = [];\n        const vis = Array(n).fill(false);\n        const t = Array(n).fill(0);\n        const dfs = i => {\n            if (i >= n) {\n                ans.push(t.slice());\n                return;\n            }\n            for (let j = 0; j < n; ++j) {\n                if (!vis[j]) {\n                    vis[j] = true;\n                    t[i] = nums[j];\n                    dfs(i + 1);\n                    vis[j] = false;\n                }\n        }\n    };\n    dfs(0);\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private boolean[] vis;\n    private int[] nums;\n\n    public List<List<Integer>> permute(int[] nums) {\n        this.nums = nums;\n        vis = new boolean[nums.length];\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = 0; j < nums.length; ++j) {\n            if (!vis[j]) {\n                vis[j] = true;\n                t.add(nums[j]);\n                dfs(i + 1);\n                t.remove(t.size() - 1);\n                vis[j] = false;\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> permute(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> ans;\n        vector<int> t(n);\n        vector<bool> vis(n);\n        auto dfs = [&](this auto&& dfs, int i) -> void {\n            if (i == n) {\n                ans.emplace_back(t);\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (!vis[j]) {\n                    vis[j] = true;\n                    t[i] = nums[j];\n                    dfs(i + 1);\n                    vis[j] = false;\n                }\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) permute(nums []int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) permute(nums []int) (ans [][]int) {\n\tn := len(nums)\n\tt := make([]int, n)\n\tvis := make([]bool, n)\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i == n {\n\t\t\tans = append(ans, slices.Clone(t))\n\t\t\treturn\n\t\t}\n\t\tfor j, x := range nums {\n\t\t\tif !vis[j] {\n\t\t\t\tvis[j] = true\n\t\t\t\tt[i] = x\n\t\t\t\tdfs(i + 1)\n\t\t\t\tvis[j] = false\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn permute(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let n = nums.len();\n        let mut ans = Vec::new();\n        let mut t = vec![0; n];\n        let mut vis = vec![false; n];\n        fn dfs(\n            nums: &Vec<i32>,\n            n: usize,\n            t: &mut Vec<i32>,\n            vis: &mut Vec<bool>,\n            ans: &mut Vec<Vec<i32>>,\n            i: usize,\n        ) {\n            if i == n {\n                ans.push(t.clone());\n                return;\n            }\n            for j in 0..n {\n                if !vis[j] {\n                    vis[j] = true;\n                    t[i] = nums[j];\n                    dfs(nums, n, t, vis, ans, i + 1);\n                    vis[j] = false;\n                }\n            }\n        }\n        dfs(&nums, n, &mut t, &mut vis, &mut ans, 0);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def permute(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    permute(nums: number[]): number[][]  {\n    const n = nums.length;\n    const ans: number[][] = [];\n    const vis: boolean[] = Array(n).fill(false);\n    const t: number[] = Array(n).fill(0);\n    const dfs = (i: number) => {\n        if (i >= n) {\n            ans.push(t.slice());\n            return;\n        }\n        for (let j = 0; j < n; ++j) {\n            if (!vis[j]) {\n                vis[j] = true;\n                t[i] = nums[j];\n                dfs(i + 1);\n                vis[j] = false;\n            }\n        }\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    permute(nums: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "combination-sum": {
    "title": "Combination Sum",
    "pattern": "Backtracking (Decision Tree)",
    "patternEmoji": "\ud83c\udf81",
    "timeComplexity": "O(2^Target)",
    "spaceComplexity": "O(Target)",
    "oneliner": "At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
    "intuition": [
      "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
      "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
      "\ud83d\udca1 Avoid duplicates by only moving forward index."
    ],
    "testCases": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]"
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]"
      },
      {
        "input": "candidates = [2], target = 1",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Include",
        "visual": "Add 2. New sum. Recurse(i).",
        "explanation": "Reuse."
      },
      {
        "step": 2,
        "title": "Exclude",
        "visual": "Pop 2. Recurse(i+1).",
        "explanation": "Skip."
      },
      {
        "step": 3,
        "title": "Base",
        "visual": "Sum > Target? Return.",
        "explanation": "Prune."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Unlimited use of same number -> stay at index `i`.\n        - \ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.\n        - \ud83d\udca1 Avoid duplicates by only moving forward index.\n    \n        Algorithm:\n        1. Include - Reuse.\n        2. Exclude - Skip.\n        3. Base - Prune.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        \n        def dfs(self, i, cur, total):\n            if total == target:\n                res.append(cur.copy())  # Add to end.\n                return\n            if i >= len(candidates) or total > target:\n                return\n                \n            # Decision 1: Include candidate[i] -> stay at i\n            cur.append(candidates[i])  # Add to end.\n            dfs(i, cur, total + candidates[i])\n            \n            # Decision 2: Exclude candidate[i] -> move to i+1\n            cur.pop()  # Remove and return last element.\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res  # Return the final result.",
    "keyInsight": "Splitting the decision into 'include current' OR 'never use current again' avoids duplicate combinations perfectly.",
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Candidates: [2, 3, 6, 7], target: 7",
        "transientMessage": "Backtracking search",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Try 2: [2] = 2",
        "transientMessage": "Continue",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try 2: [2, 2] = 4",
        "transientMessage": "Continue",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Try 2: [2, 2, 2] = 6",
        "transientMessage": "Continue",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try 2: [2, 2, 2, 2] = 8",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Try 3: [2, 2, 2, 3] = 9",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Try 6: [2, 2, 2, 6] = 12",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try 7: [2, 2, 2, 7] = 13",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Try 3: [2, 2, 3] = 7",
        "transientMessage": "Continue",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found: [2, 2, 3] = 7",
        "transientMessage": "1 solution(s)",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Try 6: [2, 2, 6] = 10",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Try 7: [2, 2, 7] = 11",
        "transientMessage": "Too big, backtrack",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "Try 3: [2, 3] = 5",
        "transientMessage": "Continue",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "+",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 14,
        "visual": "Found 1 combinations",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          3,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.",
    "examples": [
      {
        "input": "candidates = [2,3,6,7], target = 7",
        "output": "[[2,2,3],[7]]",
        "explanation": "2+2+3=7 and 7=7."
      },
      {
        "input": "candidates = [2,3,5], target = 8",
        "output": "[[2,2,2,2],[2,3,3],[3,5]]",
        "explanation": "Three valid combinations."
      }
    ],
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements in candidates are distinct.",
      "1 <= target <= 40"
    ],
    "hints": [
      "Use backtracking.",
      "Allow reusing same element (start index doesn't advance).",
      "Prune when sum exceeds target."
    ],
    "relatedProblems": [
      "combination-sum-ii",
      "combination-sum-iii",
      "subsets"
    ],
    "videoId": "GBKI9VSKdGg",
    "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Backtracking (Decision Tree): At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
    "suggestedNextQuestion": {
      "slug": "combination-sum-ii",
      "title": "Combination Sum II",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(2^Target)",
        "spaceComplexity": "O(Target)",
        "intuition": [
          "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
          "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
          "\ud83d\udca1 Avoid duplicates by only moving forward index."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef combinationSum(candidates, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited use of same number -> stay at index `i`.\n    - \ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.\n    - \ud83d\udca1 Avoid duplicates by only moving forward index.\n\n    Algorithm:\n    1. Include - Reuse.\n    2. Exclude - Skip.\n    3. Base - Prune.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    \n    def dfs(i, cur, total):\n        if total == target:\n            res.append(cur.copy())  # Add to end.\n            return\n        if i >= len(candidates) or total > target:\n            return\n            \n        # Decision 1: Include candidate[i] -> stay at i\n        cur.append(candidates[i])  # Add to end.\n        dfs(i, cur, total + candidates[i])\n        \n        # Decision 2: Exclude candidate[i] -> move to i+1\n        cur.pop()  # Remove and return last element.\n        dfs(i + 1, cur, total)\n        \n    dfs(0, [], 0)\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) combinationSum(candidates []int, target int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) combinationSum(candidates []int, target int) (ans [][]int) {\n\tsort.Ints(candidates)\n\tt := []int{}\n\tvar dfs func(i, s int)\n\tdfs = func(i, s int) {\n\t\tif s == 0 {\n\t\t\tans = append(ans, slices.Clone(t))\n\t\t\treturn\n\t\t}\n\t\tif s < candidates[i] {\n\t\t\treturn\n\t\t}\n\t\tfor j := i; j < len(candidates); j++ {\n\t\t\tt = append(t, candidates[j])\n\t\t\tdfs(j, s-candidates[j])\n\t\t\tt = t[:len(t)-1]\n\t\t}\n\t}\n\tdfs(0, target)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn combination_sum(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(i: usize, s: i32, candidates: &Vec<i32>, t: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {\n        if s == 0 {\n            ans.push(t.clone());\n            return;\n        }\n        if s < candidates[i] {\n            return;\n        }\n        for j in i..candidates.len() {\n            t.push(candidates[j]);\n            Self::dfs(j, s - candidates[j], candidates, t, ans);\n            t.pop();\n        }\n    }\n\n    pub fn combination_sum(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        candidates.sort();\n        let mut ans = Vec::new();\n        Self::dfs(0, target, &candidates, &mut vec![], &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "word-search": {
    "title": "Word Search",
    "pattern": "Backtracking (Matrix)",
    "patternEmoji": "\ud83d\udd0e",
    "timeComplexity": "O(N * M * 4^L)",
    "spaceComplexity": "O(L)",
    "oneliner": "DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
    "intuition": [
      "\ud83c\udfaf Snake through the grid.",
      "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
      "\ud83d\udca1 Prune immediately if char mismatch."
    ],
    "testCases": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true"
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Find Start",
        "visual": "Scan for word[0]. Start DFS.",
        "explanation": "Init."
      },
      {
        "step": 2,
        "title": "DFS",
        "visual": "Match? Path.add. Recurse 4 dirs.",
        "explanation": "Pathfinding."
      },
      {
        "step": 3,
        "title": "Backtrack",
        "visual": "Return. Path.remove.",
        "explanation": "Cleanup."
      }
    ],
    "code": "class Solution:\n    def exist(self, board, word):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Snake through the grid.\n        - \ud83e\udde0 Cannot reuse cell in same path (need path_visited set).\n        - \ud83d\udca1 Prune immediately if char mismatch.\n\n        Algorithm:\n        1. Find Start - Init.\n        2. DFS - Pathfinding.\n        3. Backtrack - Cleanup.\n        \"\"\"\n        ROWS, COLS = len(board), len(board[0])\n        path = set()\n\n        def dfs(r, c, i):\n            if i == len(word):\n                return True  # Condition satisfied.\n            if (r < 0 or c < 0 or \n                r >= ROWS or c >= COLS or \n                word[i] != board[r][c] or \n                (r,c) in path):\n                return False  # Condition not met.\n\n            path.add((r, c))\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n            path.remove((r, c))\n            return res  # Return the final result.\n\n        for r in range(ROWS):  # Iterate through the range.\n            for c in range(COLS):  # Iterate through the range.\n                if dfs(r, c, 0): return True  # Condition satisfied.\n        return False  # Condition not met.",
    "keyInsight": "Using a set for the current path is cleaner than modifying the board, though board modification (e.g. replacing with '#') saves space.",
    "visualizationType": "grid",
    "initialState": [
      [
        "A",
        "B",
        "C",
        "E"
      ],
      [
        "S",
        "F",
        "C",
        "S"
      ],
      [
        "A",
        "D",
        "E",
        "E"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Word Search",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: A",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: B",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: S",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: F",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "A",
            "B",
            "C",
            "E"
          ],
          [
            "S",
            "F",
            "C",
            "S"
          ],
          [
            "A",
            "D",
            "E",
            "E"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": "Path exists."
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": "Cannot reuse cells."
      }
    ],
    "constraints": [
      "m == board.length",
      "n = board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "board and word only contain uppercase and lowercase English letters."
    ],
    "hints": [
      "Use backtracking with DFS.",
      "Mark visited cells temporarily.",
      "Restore after backtracking."
    ],
    "relatedProblems": [
      "word-search-ii"
    ],
    "videoId": "pfiQ_PS1g8E",
    "problemStatement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Backtracking (Matrix): DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
    "suggestedNextQuestion": {
      "slug": "n-queens",
      "title": "N Queens",
      "difficulty": "Hard",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def exist(self, board, word):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def exist_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N * M * 4^L)",
        "spaceComplexity": "O(L)",
        "intuition": [
          "\ud83c\udfaf Snake through the grid.",
          "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
          "\ud83d\udca1 Prune immediately if char mismatch."
        ],
        "code": "def exist(board, word):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Snake through the grid.\n    - \ud83e\udde0 Cannot reuse cell in same path (need path_visited set).\n    - \ud83d\udca1 Prune immediately if char mismatch.\n\n    Algorithm:\n    1. Find Start - Init.\n    2. DFS - Pathfinding.\n    3. Backtrack - Cleanup.\n    \"\"\"\n    ROWS, COLS = len(board), len(board[0])\n    path = set()\n    \n    def dfs(r, c, i):\n        if i == len(word):\n            return True  # Condition satisfied.\n        if (r < 0 or c < 0 or \n            r >= ROWS or c >= COLS or \n            word[i] != board[r][c] or \n            (r,c) in path):\n            return False  # Condition not met.\n            \n        path.add((r, c))\n        res = (dfs(r + 1, c, i + 1) or\n               dfs(r - 1, c, i + 1) or\n               dfs(r, c + 1, i + 1) or\n               dfs(r, c - 1, i + 1))\n        path.remove((r, c))\n        return res  # Return the final result.\n        \n    for r in range(ROWS):  # Iterate through the range.\n        for c in range(COLS):  # Iterate through the range.\n            if dfs(r, c, 0): return True  # Condition satisfied.\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    exist(board, word) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} board, word\n     * @return {any}\n     */\n    exist(board, word) {\n        const [m, n] = [board.length, board[0].length];\n        const dirs = [-1, 0, 1, 0, -1];\n        const dfs = (i, j, k) => {\n            if (k === word.length - 1) {\n                return board[i][j] === word[k];\n            }\n            if (board[i][j] !== word[k]) {\n                return false;\n            }\n            const c = board[i][j];\n            board[i][j] = '0';\n            for (let u = 0; u < 4; ++u) {\n                const [x, y] = [i + dirs[u], j + dirs[u + 1]];\n                const ok = x >= 0 && x < m && y >= 0 && y < n;\n                if (ok && board[x][y] !== '0' && dfs(x, y, k + 1)) {\n                    return true;\n                }\n            }\n            board[i][j] = c;\n            return false;\n        };\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    private int m;\n    private int n;\n    private String word;\n    private char[][] board;\n\n    public boolean exist(char[][] board, String word) {\n        m = board.length;\n        n = board[0].length;\n        this.word = word;\n        this.board = board;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int i, int j, int k) {\n        if (k == word.length() - 1) {\n            return board[i][j] == word.charAt(k);\n        }\n        if (board[i][j] != word.charAt(k)) {\n            return false;\n        }\n        char c = board[i][j];\n        board[i][j] = '0';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int u = 0; u < 4; ++u) {\n            int x = i + dirs[u], y = j + dirs[u + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '0' && dfs(x, y, k + 1)) {\n                return true;\n            }\n        }\n        board[i][j] = c;\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool exist(vector<vector<char>>& board, string word) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size(), n = board[0].size();\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\n            if (k == word.size() - 1) {\n                return board[i][j] == word[k];\n            }\n            if (board[i][j] != word[k]) {\n                return false;\n            }\n            char c = board[i][j];\n            board[i][j] = '0';\n            for (int u = 0; u < 4; ++u) {\n                int x = i + dirs[u], y = j + dirs[u + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '0' && dfs(x, y, k + 1)) {\n                    return true;\n                }\n            }\n            board[i][j] = c;\n            return false;\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) exist(board [][]byte, word string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) exist(board [][]byte, word string) bool {\n\tm, n := len(board), len(board[0])\n\tvar dfs func(int, int, int) bool\n\tdfs = func(i, j, k int) bool {\n\t\tif k == len(word)-1 {\n\t\t\treturn board[i][j] == word[k]\n\t\t}\n\t\tif board[i][j] != word[k] {\n\t\t\treturn false\n\t\t}\n\t\tdirs := [5]int{-1, 0, 1, 0, -1}\n\t\tc := board[i][j]\n\t\tboard[i][j] = '0'\n\t\tfor u := 0; u < 4; u++ {\n\t\t\tx, y := i+dirs[u], j+dirs[u+1]\n\t\t\tif x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '0' && dfs(x, y, k+1) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tboard[i][j] = c\n\t\treturn false\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif dfs(i, j, 0) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(\n        i: usize,\n        j: usize,\n        c: usize,\n        word: &[u8],\n        board: &Vec<Vec<char>>,\n        vis: &mut Vec<Vec<bool>>,\n    ) -> bool {\n        if (board[i][j] as u8) != word[c] {\n            return false;\n        }\n        if c == word.len() - 1 {\n            return true;\n        }\n        vis[i][j] = true;\n        let dirs = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n        for [x, y] in dirs.into_iter() {\n            let i = x + (i as i32);\n            let j = y + (j as i32);\n            if i < 0 || i == (board.len() as i32) || j < 0 || j == (board[0].len() as i32) {\n                continue;\n            }\n            let (i, j) = (i as usize, j as usize);\n            if !vis[i][j] && Self::dfs(i, j, c + 1, word, board, vis) {\n                return true;\n            }\n        }\n        vis[i][j] = false;\n        false\n    }\n\n    pub fn exist(board: Vec<Vec<char>>, word: String) -> bool {\n        let m = board.len();\n        let n = board[0].len();\n        let word = word.as_bytes();\n        let mut vis = vec![vec![false; n]; m];\n        for i in 0..m {\n            for j in 0..n {\n                if Self::dfs(i, j, 0, word, &board, &mut vis) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def exist(self, board, word):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    exist(board: string[][], word: string): boolean  {\n    const [m, n] = [board.length, board[0].length];\n    const dirs = [-1, 0, 1, 0, -1];\n    const dfs = (i: number, j: number, k: number): boolean => {\n        if (k === word.length - 1) {\n            return board[i][j] === word[k];\n        }\n        if (board[i][j] !== word[k]) {\n            return false;\n        }\n        const c = board[i][j];\n        board[i][j] = '0';\n        for (let u = 0; u < 4; ++u) {\n            const [x, y] = [i + dirs[u], j + dirs[u + 1]];\n            const ok = x >= 0 && x < m && y >= 0 && y < n;\n            if (ok && board[x][y] !== '0' && dfs(x, y, k + 1)) {\n                return true;\n            }\n        }\n        board[i][j] = c;\n        return false;\n    };\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (dfs(i, j, 0)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n}",
        "initialCode": "class Solution {\n    exist(board: string[][], word: string): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "kth-largest-element-in-an-array": {
    "title": "Kth Largest Element in an Array",
    "pattern": "Heap / QuickSelect",
    "patternEmoji": "\ud83e\udd47",
    "timeComplexity": "O(N) avg",
    "spaceComplexity": "O(1) / O(K)",
    "oneliner": "QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
    "intuition": [
      "\ud83c\udfaf We want the Kth item if sorted descending.",
      "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
      "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
    ],
    "testCases": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5"
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
        "output": "4"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Pivot",
        "visual": "Pick pivot, partition < pivot, > pivot.",
        "explanation": "Split."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "Is pivot index == len-k? Return pivot.",
        "explanation": "Target?"
      },
      {
        "step": 3,
        "title": "Recurse",
        "visual": "If idx < target, go right. Else left.",
        "explanation": "Search."
      }
    ],
    "code": "class Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We want the Kth item if sorted descending.\n        - \ud83e\udde0 Sorting is O(NlogN). Can we do better?\n        - \ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half.\n\n        Algorithm:\n        1. Pivot - Split.\n        2. Check - Target?\n        3. Recurse - Search.\n        \"\"\"\n        k = len(nums) - k\n\n        def quickSelect(l, r):\n            pivot, p = nums[r], l\n            for i in range(l, r):  # Iterate through the range.\n                if nums[i] <= pivot:\n                    nums[p], nums[i] = nums[i], nums[p]\n                    p += 1\n            nums[p], nums[r] = nums[r], nums[p]\n\n            if p > k: return quickSelect(l, p - 1)\n            elif p < k: return quickSelect(p + 1, r)\n            else: return nums[p]\n\n        return quickSelect(0, len(nums) - 1)",
    "keyInsight": "Running QuickSelect is theoretically O(N) average, superior to Heap's O(N log K) if K is large, although Python's `heapq.nlargest` is very optimized.",
    "visualizationType": "array",
    "initialState": [
      3,
      2,
      1,
      5,
      6,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Kth Largest Element in an Array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 5",
        "transientMessage": "Iteration 4",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 6",
        "transientMessage": "Iteration 5",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 4",
        "transientMessage": "Iteration 6",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          3,
          2,
          1,
          5,
          6,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5",
        "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5."
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
        "output": "4",
        "explanation": "4th largest is 4."
      }
    ],
    "constraints": [
      "1 <= k <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "hints": [
      "Use a min-heap of size k.",
      "Or use Quickselect for O(n) average.",
      "Heap gives O(n log k)."
    ],
    "relatedProblems": [
      "top-k-frequent-elements",
      "find-k-pairs-with-smallest-sums",
      "kth-smallest-element-in-a-sorted-matrix"
    ],
    "videoId": "XEmy13g1Qxc",
    "problemStatement": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Heap / QuickSelect: QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def findKthLargest(self, nums, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def findKthLargest_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N) avg",
        "spaceComplexity": "O(1) / O(K)",
        "intuition": [
          "\ud83c\udfaf We want the Kth item if sorted descending.",
          "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
          "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
        ],
        "code": "def findKthLargest(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We want the Kth item if sorted descending.\n    - \ud83e\udde0 Sorting is O(NlogN). Can we do better?\n    - \ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half.\n\n    Algorithm:\n    1. Pivot - Split.\n    2. Check - Target?\n    3. Recurse - Search.\n    \"\"\"\n    k = len(nums) - k\n    \n    def quickSelect(l, r):\n        pivot, p = nums[r], l\n        for i in range(l, r):  # Iterate through the range.\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        nums[p], nums[r] = nums[r], nums[p]\n        \n        if p > k: return quickSelect(l, p - 1)\n        elif p < k: return quickSelect(p + 1, r)\n        else: return nums[p]\n        \n    return quickSelect(0, len(nums) - 1)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findKthLargest(nums, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums, k\n     * @return {any}\n     */\n    findKthLargest(nums, k) {\n        return nums.sort((a, b) => a - b)[nums.length - k];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private int[] nums;\n    private int k;\n\n    public int findKthLargest(int[] nums, int k) {\n        this.nums = nums;\n        this.k = nums.length - k;\n        return quickSort(0, nums.length - 1);\n    }\n\n    private int quickSort(int l, int r) {\n        if (l == r) {\n            return nums[l];\n        }\n        int i = l - 1, j = r + 1;\n        int x = nums[(l + r) >>> 1];\n        while (i < j) {\n            while (nums[++i] < x) {\n            }\n            while (nums[--j] > x) {\n            }\n            if (i < j) {\n                int t = nums[i];\n                nums[i] = nums[j];\n                nums[j] = t;\n            }\n        }\n        if (j < k) {\n            return quickSort(j + 1, r);\n        }\n        return quickSort(l, j);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findKthLargest(vector<int>& nums, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = n - k;\n        auto quickSort = [&](auto&& quickSort, int l, int r) -> int {\n            if (l == r) {\n                return nums[l];\n            }\n            int i = l - 1, j = r + 1;\n            int x = nums[(l + r) >> 1];\n            while (i < j) {\n                while (nums[++i] < x) {\n                }\n                while (nums[--j] > x) {\n                }\n                if (i < j) {\n                    swap(nums[i], nums[j]);\n                }\n            }\n            if (j < k) {\n                return quickSort(quickSort, j + 1, r);\n            }\n            return quickSort(quickSort, l, j);\n        };\n        return quickSort(quickSort, 0, n - 1);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findKthLargest(nums []int, k int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findKthLargest(nums []int, k int) int {\n\tk = len(nums) - k\n\tvar quickSort func(l, r int) int\n\tquickSort = func(l, r int) int {\n\t\tif l == r {\n\t\t\treturn nums[l]\n\t\t}\n\t\ti, j := l-1, r+1\n\t\tx := nums[(l+r)>>1]\n\t\tfor i < j {\n\t\t\tfor {\n\t\t\t\ti++\n\t\t\t\tif nums[i] >= x {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor {\n\t\t\t\tj--\n\t\t\t\tif nums[j] <= x {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i < j {\n\t\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t\t}\n\t\t}\n\t\tif j < k {\n\t\t\treturn quickSort(j+1, r)\n\t\t}\n\t\treturn quickSort(l, j)\n\t}\n\treturn quickSort(0, len(nums)-1)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_kth_largest(mut nums: Vec<i32>, k: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_kth_largest(mut nums: Vec<i32>, k: i32) -> i32 {\n        let len = nums.len();\n        let k = len - k as usize;\n        Self::quick_sort(&mut nums, 0, len - 1, k)\n    }\n\n    fn quick_sort(nums: &mut Vec<i32>, l: usize, r: usize, k: usize) -> i32 {\n        if l == r {\n            return nums[l];\n        }\n\n        let (mut i, mut j) = (l as isize - 1, r as isize + 1);\n        let x = nums[(l + r) / 2];\n\n        while i < j {\n            i += 1;\n            while nums[i as usize] < x {\n                i += 1;\n            }\n\n            j -= 1;\n            while nums[j as usize] > x {\n                j -= 1;\n            }\n\n            if i < j {\n                nums.swap(i as usize, j as usize);\n            }\n        }\n\n        let j = j as usize;\n        if j < k {\n            Self::quick_sort(nums, j + 1, r, k)\n        } else {\n            Self::quick_sort(nums, l, j, k)\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findKthLargest(self, nums, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findKthLargest(nums: number[], k: number): number  {\n    const n = nums.length;\n    k = n - k;\n    const quickSort = (l: number, r: number): number => {\n        if (l === r) {\n            return nums[l];\n        }\n        let [i, j] = [l - 1, r + 1];\n        const x = nums[(l + r) >> 1];\n        while (i < j) {\n            while (nums[++i] < x);\n            while (nums[--j] > x);\n            if (i < j) {\n                [nums[i], nums[j]] = [nums[j], nums[i]];\n            }\n        }\n        if (j < k) {\n            return quickSort(j + 1, r);\n        }\n        return quickSort(l, j);\n    };\n    return quickSort(0, n - 1);\n}\n}",
        "initialCode": "class Solution {\n    findKthLargest(nums: number[], k: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "count-and-say",
      "title": "Count and Say",
      "difficulty": "Medium",
      "pattern": "Iterative with String Manipulation"
    }
  },
  "top-k-frequent-elements": {
    "title": "Top K Frequent Elements",
    "pattern": "Bucket Sort / Heap",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(N)",
    "oneliner": "Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
    "intuition": [
      "\ud83c\udfaf Map {num -> count}.",
      "\ud83e\udde0 Max freq is N. Create array where index is freq.",
      "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
    ],
    "testCases": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]"
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Count",
        "visual": "Hashmap counts.",
        "explanation": "Freqs."
      },
      {
        "step": 2,
        "title": "Bucket",
        "visual": "bucket[count].append(num).",
        "explanation": "Group."
      },
      {
        "step": 3,
        "title": "Gather",
        "visual": "Flatten buckets in reverse.",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Map {num -> count}.\n        - \ud83e\udde0 Max freq is N. Create array where index is freq.\n        - \ud83d\udca1 Iterate bucket from N down to 1 to find most frequent.\n\n        Algorithm:\n        1. Count - Freqs.\n        2. Bucket - Group.\n        3. Gather - Result.\n        \"\"\"\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]  # Iterate through the range.\n\n        for n in nums:  # Iterate over elements.\n            count[n] = 1 + count.get(n, 0)\n        for n, c in count.items():  # Iterate over elements.\n            freq[c].append(n)  # Add to end.\n\n        res = []  # Initialize list to store results.\n        for i in range(len(freq) - 1, 0, -1):  # Iterate through the range.\n            for n in freq[i]:  # Iterate over elements.\n                res.append(n)  # Add to end.\n                if len(res) == k:\n                    return res  # Return the final result.",
    "keyInsight": "Bucket Sort is essentially O(N) here because frequencies are bounded by array size.",
    "visualizationType": "array",
    "initialState": [
      1,
      1,
      1,
      2,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Top K Frequent Elements",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 3",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": "1 appears 3 times, 2 appears 2 times."
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "k is in range [1, the number of unique elements].",
      "It is guaranteed that the answer is unique."
    ],
    "hints": [
      "Count frequencies with a hash map.",
      "Use a min-heap of size k.",
      "Or use bucket sort for O(n)."
    ],
    "relatedProblems": [
      "kth-largest-element-in-an-array",
      "sort-characters-by-frequency",
      "top-k-frequent-words"
    ],
    "videoId": "YPTqKIgVk-k",
    "problemStatement": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Bucket Sort / Heap: Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def topKFrequent(self, nums, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def topKFrequent_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N)",
        "spaceComplexity": "O(N)",
        "intuition": [
          "\ud83c\udfaf Map {num -> count}.",
          "\ud83e\udde0 Max freq is N. Create array where index is freq.",
          "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
        ],
        "code": "def topKFrequent(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Map {num -> count}.\n    - \ud83e\udde0 Max freq is N. Create array where index is freq.\n    - \ud83d\udca1 Iterate bucket from N down to 1 to find most frequent.\n\n    Algorithm:\n    1. Count - Freqs.\n    2. Bucket - Group.\n    3. Gather - Result.\n    \"\"\"\n    count = {}\n    freq = [[] for i in range(len(nums) + 1)]  # Iterate through the range.\n    \n    for n in nums:  # Iterate over elements.\n        count[n] = 1 + count.get(n, 0)\n    for n, c in count.items():  # Iterate over elements.\n        freq[c].append(n)  # Add to end.\n        \n    res = []  # Initialize list to store results.\n    for i in range(len(freq) - 1, 0, -1):  # Iterate through the range.\n        for n in freq[i]:  # Iterate over elements.\n            res.append(n)  # Add to end.\n            if len(res) == k:\n                return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    topKFrequent(nums, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums, k\n     * @return {any}\n     */\n    topKFrequent(nums, k) {\n        const map = new Map();\n\n        nums.forEach(value => map.set(value, (map.get(value) || 0) + 1));\n\n        return [...map]\n          .sort((a, b) => b[1] - a[1])\n          .slice(0, k)\n          .map(([value]) => value)\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> cnt = new HashMap<>();\n        for (int x : nums) {\n            cnt.merge(x, 1, Integer::sum);\n        }\n        PriorityQueue<Map.Entry<Integer, Integer>> pq\n            = new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));\n        for (var e : cnt.entrySet()) {\n            pq.offer(e);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        return pq.stream().mapToInt(Map.Entry::getKey).toArray();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> cnt;\n        using pii = pair<int, int>;\n        for (int x : nums) {\n            ++cnt[x];\n        }\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        for (auto& [x, c] : cnt) {\n            pq.push({c, x});\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n        vector<int> ans;\n        while (!pq.empty()) {\n            ans.push_back(pq.top().second);\n            pq.pop();\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) topKFrequent(nums []int, k int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) topKFrequent(nums []int, k int) []int {\n\tcnt := map[int]int{}\n\tfor _, x := range nums {\n\t\tcnt[x]++\n\t}\n\tpq := hp{}\n\tfor x, c := range cnt {\n\t\theap.Push(&pq, pair{x, c})\n\t\tif pq.Len() > k {\n\t\t\theap.Pop(&pq)\n\t\t}\n\t}\n\tans := make([]int, k)\n\tfor i := 0; i < k; i++ {\n\t\tans[i] = heap.Pop(&pq).(pair).v\n\t}\n\treturn ans\n}\n\ntype pair struct{ v, cnt int }\ntype hp []pair\n\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].cnt < h[j].cnt }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::cmp::Reverse;\nuse std::collections::{BinaryHeap, HashMap};\n\nimpl Solution {\n    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        let mut cnt = HashMap::new();\n        for x in nums {\n            *cnt.entry(x).or_insert(0) += 1;\n        }\n        let mut pq = BinaryHeap::with_capacity(k as usize);\n        for (&x, &c) in cnt.iter() {\n            pq.push(Reverse((c, x)));\n            if pq.len() > k as usize {\n                pq.pop();\n            }\n        }\n        pq.into_iter().map(|Reverse((_, x))| x).collect()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def topKFrequent(self, nums, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    topKFrequent(nums: number[], k: number): number[]  {\n    const cnt = new Map<number, number>();\n    for (const x of nums) {\n        cnt.set(x, (cnt.get(x) ?? 0) + 1);\n    }\n    const pq = new MinPriorityQueue();\n    for (const [x, c] of cnt) {\n        pq.enqueue(x, c);\n        if (pq.size() > k) {\n            pq.dequeue();\n        }\n    }\n    return pq.toArray().map(x => x.element);\n}\n}",
        "initialCode": "class Solution {\n    topKFrequent(nums: number[], k: number): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    }
  },
  "remove-duplicates-from-sorted-array": {
    "title": "Remove Duplicates from Sorted Array",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc46\ud83d\udc46",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
    "intuition": [
      "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
      "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
      "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
    ],
    "testCases": [
      {
        "input": "nums = [1,1,2]",
        "output": "2"
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "slow=0, fast=1",
        "explanation": "Start pointers."
      },
      {
        "step": 2,
        "title": "Compare",
        "visual": "nums[fast] != nums[slow]? Move slow, copy.",
        "explanation": "Unique found."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "Return slow + 1",
        "explanation": "Length of unique elements."
      }
    ],
    "code": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.\n        - \ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.\n        - \ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1].\n\n        Algorithm:\n        1. Init - Start pointers.\n        2. Compare - Unique found.\n        3. Return - Length of unique elements.\n        \"\"\"\n        if not nums: return 0\n        slow = 0\n        for fast in range(1, len(nums)):  # Iterate through the range.\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n        return slow + 1  # Return the result node.",
    "keyInsight": "The slow pointer always points to the last unique element.",
    "visualizationType": "array",
    "initialState": [
      0,
      0,
      1,
      1,
      1,
      2,
      2,
      3,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]",
        "transientMessage": "Two pointer approach",
        "arrayState": [
          0,
          0,
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "nums[1]=0 is duplicate",
        "transientMessage": "Skip",
        "arrayState": [
          0,
          0,
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 0
          },
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "nums[2]=1 is new",
        "transientMessage": "Place at k=1",
        "arrayState": [
          0,
          1,
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 1
          },
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "nums[3]=1 is duplicate",
        "transientMessage": "Skip",
        "arrayState": [
          0,
          1,
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 1
          },
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "nums[4]=1 is duplicate",
        "transientMessage": "Skip",
        "arrayState": [
          0,
          1,
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 1
          },
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "nums[5]=2 is new",
        "transientMessage": "Place at k=2",
        "arrayState": [
          0,
          1,
          2,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 2
          },
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          2,
          5
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "nums[6]=2 is duplicate",
        "transientMessage": "Skip",
        "arrayState": [
          0,
          1,
          2,
          1,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 2
          },
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "nums[7]=3 is new",
        "transientMessage": "Place at k=3",
        "arrayState": [
          0,
          1,
          2,
          3,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 3
          },
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          3,
          7
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "nums[8]=3 is duplicate",
        "transientMessage": "Skip",
        "arrayState": [
          0,
          1,
          2,
          3,
          1,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 3
          },
          {
            "label": "i",
            "index": 8
          }
        ],
        "indices": [
          8
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "nums[9]=4 is new",
        "transientMessage": "Place at k=4",
        "arrayState": [
          0,
          1,
          2,
          3,
          4,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "k",
            "index": 4
          },
          {
            "label": "i",
            "index": 9
          }
        ],
        "indices": [
          4,
          9
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "5 unique elements",
        "transientMessage": "Complete!",
        "arrayState": [
          0,
          1,
          2,
          3,
          4,
          2,
          2,
          3,
          3,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3,
          4
        ],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2, nums = [1,2,_]",
        "explanation": "Return k=2, first 2 elements are unique."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
        "explanation": "5 unique elements."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "hints": [
      "Use two pointers - slow for unique position, fast for scanning.",
      "If nums[fast] != nums[slow], copy to slow+1.",
      "Return slow + 1 as count."
    ],
    "relatedProblems": [
      "remove-duplicates-from-sorted-array-ii",
      "remove-element",
      "move-zeroes"
    ],
    "videoId": "DEJAZBq0FDA",
    "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
    "suggestedNextQuestion": {
      "slug": "remove-element",
      "title": "Remove Element",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def removeDuplicates(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
          "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
          "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
        ],
        "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.\n    - \ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.\n    - \ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1].\n\n    Algorithm:\n    1. Init - Start pointers.\n    2. Compare - Unique found.\n    3. Return - Length of unique elements.\n    \"\"\"\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1  # Return the result node."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    removeDuplicates(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    removeDuplicates(nums) {\n        let k = 0;\n        for (const x of nums) {\n            if (k === 0 || x !== nums[k - 1]) {\n                nums[k++] = x;\n            }\n    }\n    return k;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k == 0 || x != nums[k - 1]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int removeDuplicates(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k == 0 || x != nums[k - 1]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) removeDuplicates(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) removeDuplicates(nums []int) int {\n\tk := 0\n\tfor _, x := range nums {\n\t\tif k == 0 || x != nums[k-1] {\n\t\t\tnums[k] = x\n\t\t\tk++\n\t\t}\n\t}\n\treturn k\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let mut k = 0;\n        for i in 0..nums.len() {\n            if k == 0 || nums[i] != nums[k - 1] {\n                nums[k] = nums[i];\n                k += 1;\n            }\n        }\n        k as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def removeDuplicates(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    removeDuplicates(nums: number[]): number  {\n    let k: number = 0;\n    for (const x of nums) {\n        if (k === 0 || x !== nums[k - 1]) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n}\n}",
        "initialCode": "class Solution {\n    removeDuplicates(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "remove-duplicates-from-sorted-array-ii": {
    "title": "Remove Duplicates from Sorted Array II",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc46\ud83d\udc46",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
    "intuition": [
      "\ud83c\udfaf Each unique element can appear at most twice.",
      "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
      "\ud83d\udca1 If different, copy and advance slow."
    ],
    "testCases": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5"
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "slow=2, fast=2",
        "explanation": "First 2 are always kept."
      },
      {
        "step": 2,
        "title": "Compare",
        "visual": "nums[fast] != nums[slow-2]?",
        "explanation": "Check 2 back."
      },
      {
        "step": 3,
        "title": "Copy",
        "visual": "nums[slow] = nums[fast]; slow++",
        "explanation": "Keep element."
      }
    ],
    "code": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Each unique element can appear at most twice.\n        - \ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).\n        - \ud83d\udca1 If different, copy and advance slow.\n\n        Algorithm:\n        1. Init - First 2 are always kept.\n        2. Compare - Check 2 back.\n        3. Copy - Keep element.\n        \"\"\"\n        if len(nums) <= 2: return len(nums)\n        slow = 2\n        for fast in range(2, len(nums)):  # Iterate through the range.\n            if nums[fast] != nums[slow - 2]:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow  # Return the result node.",
    "keyInsight": "The key insight is comparing with slow-2, not slow-1.",
    "visualizationType": "array",
    "initialState": [
      1,
      1,
      1,
      2,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Remove Duplicates from Sorted Array II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 3",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3]",
        "output": "5, nums = [1,1,2,2,3,_]",
        "explanation": "Keep at most 2 of each."
      },
      {
        "input": "nums = [0,0,1,1,1,1,2,3,3]",
        "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
        "explanation": "7 elements after removing extras."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in non-decreasing order."
    ],
    "hints": [
      "Use two pointers with a count variable.",
      "Allow at most 2 of each element.",
      "Compare with element 2 positions back."
    ],
    "relatedProblems": [
      "remove-duplicates-from-sorted-array",
      "remove-duplicates-from-sorted-list-ii"
    ],
    "videoId": "ycAq8iqh0TI",
    "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
    "suggestedNextQuestion": {
      "slug": "remove-duplicates-from-sorted-list-ii",
      "title": "Remove Duplicates from Sorted List II",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def removeDuplicates(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def removeDuplicates(nums):\n    i = 0\n    for n in nums:\n        if i < 2 or n > nums[i-2]:\n            nums[i] = n\n            i += 1\n    return i"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Each unique element can appear at most twice.",
          "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
          "\ud83d\udca1 If different, copy and advance slow."
        ],
        "code": "def removeDuplicates(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each unique element can appear at most twice.\n    - \ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).\n    - \ud83d\udca1 If different, copy and advance slow.\n\n    Algorithm:\n    1. Init - First 2 are always kept.\n    2. Compare - Check 2 back.\n    3. Copy - Keep element.\n    \"\"\"\n    if len(nums) <= 2: return len(nums)\n    slow = 2\n    for fast in range(2, len(nums)):  # Iterate through the range.\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow  # Return the result node."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    removeDuplicates(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    removeDuplicates(nums) {\n        let k = 0;\n        for (const x of nums) {\n            if (k < 2 || x !== nums[k - 2]) {\n                nums[k++] = x;\n            }\n    }\n    return k;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k < 2 || x != nums[k - 2]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int removeDuplicates(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int x : nums) {\n            if (k < 2 || x != nums[k - 2]) {\n                nums[k++] = x;\n            }\n        }\n        return k;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) removeDuplicates(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) removeDuplicates(nums []int) int {\n\tk := 0\n\tfor _, x := range nums {\n\t\tif k < 2 || x != nums[k-2] {\n\t\t\tnums[k] = x\n\t\t\tk++\n\t\t}\n\t}\n\treturn k\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {\n        let mut k = 0;\n        for i in 0..nums.len() {\n            if k < 2 || nums[i] != nums[k - 2] {\n                nums[k] = nums[i];\n                k += 1;\n            }\n        }\n        k as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def removeDuplicates(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    removeDuplicates(nums: number[]): number  {\n    let k = 0;\n    for (const x of nums) {\n        if (k < 2 || x !== nums[k - 2]) {\n            nums[k++] = x;\n        }\n    }\n    return k;\n}\n}",
        "initialCode": "class Solution {\n    removeDuplicates(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "rotate-array": {
    "title": "Rotate Array",
    "pattern": "Reverse Trick",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Reverse entire array, then reverse first k, then reverse rest.",
    "intuition": [
      "\ud83c\udfaf Rotate array right by k steps.",
      "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
      "\ud83d\udca1 Handles k > len(nums) with k %= len."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]"
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Normalize",
        "visual": "k = k % n",
        "explanation": "Handle overflow."
      },
      {
        "step": 2,
        "title": "Reverse All",
        "visual": "[7,6,5,4,3,2,1]",
        "explanation": "Flip entire array."
      },
      {
        "step": 3,
        "title": "Reverse Parts",
        "visual": "[5,6,7] + [1,2,3,4]",
        "explanation": "Flip both halves."
      }
    ],
    "code": "class Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Rotate array right by k steps.\n        - \ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].\n        - \ud83d\udca1 Handles k > len(nums) with k %= len.\n\n        Algorithm:\n        1. Normalize - Handle overflow.\n        2. Reverse All - Flip entire array.\n        3. Reverse Parts - Flip both halves.\n        \"\"\"\n        n = len(nums)\n        k %= n\n        def reverse(l, r):\n            while l < r:  # Continue until pointers meet.\n                nums[l], nums[r] = nums[r], nums[l]\n                l, r = l + 1, r - 1  # Initialize two pointers.\n        reverse(0, n - 1)\n        reverse(0, k - 1)\n        reverse(k, n - 1)\n        return nums",
    "keyInsight": "Three reverses is more elegant than slicing or cyclic replacement.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Rotate Array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 6",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate right 3 times."
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": "Rotate right 2 times."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1",
      "0 <= k <= 10^5"
    ],
    "hints": [
      "Use the reverse technique.",
      "Reverse the entire array.",
      "Reverse first k elements, then reverse remaining elements."
    ],
    "relatedProblems": [
      "rotate-list",
      "reverse-words-in-a-string",
      "rotate-image"
    ],
    "videoId": "BHr381Guz3Y",
    "problemStatement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Reverse Trick: Reverse entire array, then reverse first k, then reverse rest.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def rotate(self, nums, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rotate(nums, k):\n    k %= len(nums)\n    # 1. Reverse whole array\n    # 2. Reverse first k\n    # 3. Reverse last n-k\n    def rev(l, r):\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n    n = len(nums)\n    rev(0, n - 1)\n    rev(0, k - 1)\n    rev(k, n - 1)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Rotate array right by k steps.",
          "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
          "\ud83d\udca1 Handles k > len(nums) with k %= len."
        ],
        "code": "def rotate(nums, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate array right by k steps.\n    - \ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].\n    - \ud83d\udca1 Handles k > len(nums) with k %= len.\n\n    Algorithm:\n    1. Normalize - Handle overflow.\n    2. Reverse All - Flip entire array.\n    3. Reverse Parts - Flip both halves.\n    \"\"\"\n    n = len(nums)\n    k %= n\n    def reverse(l, r):\n        while l < r:  # Continue until pointers meet.\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1  # Initialize two pointers.\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    rotate(nums, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nclass Solution {\n    /**\n     * @param {any} nums, k\n     * @return {any}\n     */\n    rotate(nums, k) {\n        const n = nums.length;\n        k %= n;\n        const reverse = (i, j) => {\n            for (; i < j; ++i, --j) {\n                [nums[i], nums[j]] = [nums[j], nums[i]];\n        }\n    };\n    reverse(0, n - 1);\n    reverse(0, k - 1);\n    reverse(k, n - 1);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void rotate(int[] nums, int k) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    private int[] nums;\n\n    public void rotate(int[] nums, int k) {\n        this.nums = nums;\n        int n = nums.length;\n        k %= n;\n        reverse(0, n - 1);\n        reverse(0, k - 1);\n        reverse(k, n - 1);\n    }\n\n    private void reverse(int i, int j) {\n        for (; i < j; ++i, --j) {\n            int t = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void rotate(vector<int>& nums, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k %= n;\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rotate(nums []int, k int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) rotate(nums []int, k int) {\n\tn := len(nums)\n\tk %= n\n\treverse := func(i, j int) {\n\t\tfor ; i < j; i, j = i+1, j-1 {\n\t\t\tnums[i], nums[j] = nums[j], nums[i]\n\t\t}\n\t}\n\treverse(0, n-1)\n\treverse(0, k-1)\n\treverse(k, n-1)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn rotate(nums: &mut Vec<i32>, k: i32) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn rotate(nums: &mut Vec<i32>, k: i32) {\n        let n = nums.len();\n        let k = (k as usize) % n;\n        nums.reverse();\n        nums[..k].reverse();\n        nums[k..].reverse();\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def rotate(self, nums, k):\n        pass\n"
      },
      "typescript": {
        "code": "/**\n Do not return anything, modify nums in-place instead.\n */\nclass Solution {\n    rotate(nums: number[], k: number): void  {\n    const n: number = nums.length;\n    k %= n;\n    const reverse = (i: number, j: number): void => {\n        for (; i < j; ++i, --j) {\n            const t: number = nums[i];\n            nums[i] = nums[j];\n            nums[j] = t;\n        }\n    };\n    reverse(0, n - 1);\n    reverse(0, k - 1);\n    reverse(k, n - 1);\n}\n}",
        "initialCode": "class Solution {\n    rotate(nums: number[], k: number): void {\n        // Your code here\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "insert-delete-getrandom-o1",
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "Medium",
      "pattern": "Hash Map + Dynamic Array"
    }
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "title": "Best Time to Buy and Sell Stock II",
    "pattern": "Greedy",
    "patternEmoji": "\ud83d\udcb0",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Buy before every rise, sell after every rise. Collect all profits.",
    "intuition": [
      "\ud83c\udfaf Unlimited transactions allowed.",
      "\ud83e\udde0 Collect profit for every upward movement.",
      "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
    ],
    "testCases": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7"
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4"
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Scan",
        "visual": "Check pairs",
        "explanation": "Compare consecutive."
      },
      {
        "step": 2,
        "title": "Profit",
        "visual": "If up, add diff",
        "explanation": "Greedy gain."
      },
      {
        "step": 3,
        "title": "Sum",
        "visual": "Total = 7",
        "explanation": "All upward moves."
      }
    ],
    "code": "class Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Unlimited transactions allowed.\n        - \ud83e\udde0 Collect profit for every upward movement.\n        - \ud83d\udca1 If prices[i] > prices[i-1], add the difference.\n\n        Algorithm:\n        1. Scan - Compare consecutive.\n        2. Profit - Greedy gain.\n        3. Sum - All upward moves.\n        \"\"\"\n        profit = 0\n        for i in range(1, len(prices)):  # Iterate through the range.\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit",
    "keyInsight": "Every upward slope contributes to profit. Just sum them all.",
    "visualizationType": "array",
    "initialState": [
      7,
      1,
      5,
      3,
      6,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Best Time to Buy and Sell Stock II",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 7",
        "arrayState": [
          7,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          7,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 1",
        "arrayState": [
          7,
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          7,
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 5",
        "arrayState": [
          7,
          1,
          5,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          7,
          1,
          5,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          7,
          1,
          5,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          7,
          1,
          5,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 6",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          0
        ],
        "pointers": [],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          7,
          1,
          5,
          3,
          6,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy at 1, sell at 5, profit 4. Buy at 3, sell at 6, profit 3. Total 7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy at 1, sell at 5, or sum all increases."
      }
    ],
    "constraints": [
      "1 <= prices.length <= 3 * 10^4",
      "0 <= prices[i] <= 10^4"
    ],
    "hints": [
      "Capture every upward price movement.",
      "Sum of (prices[i] - prices[i-1]) for all increases.",
      "Greedy approach works here."
    ],
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock",
      "best-time-to-buy-and-sell-stock-iii",
      "best-time-to-buy-and-sell-stock-with-cooldown"
    ],
    "videoId": "3SJ3pUkPQMc",
    "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
    "difficulty": "Medium",
    "walkthrough": [
      "Sort input if needed for optimal substructure",
      "Make locally optimal choice at each step",
      "Update state based on current choice",
      "Validate choice doesn't violate constraints",
      "Build solution incrementally"
    ],
    "approach": "Greedy: Buy before every rise, sell after every rise. Collect all profits.",
    "suggestedNextQuestion": {
      "slug": "gas-station",
      "title": "Gas Station",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
    "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            profit += (prices[i] - prices[i-1])\n    return profit"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Unlimited transactions allowed.",
          "\ud83e\udde0 Collect profit for every upward movement.",
          "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
        ],
        "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Unlimited transactions allowed.\n    - \ud83e\udde0 Collect profit for every upward movement.\n    - \ud83d\udca1 If prices[i] > prices[i-1], add the difference.\n\n    Algorithm:\n    1. Scan - Compare consecutive.\n    2. Profit - Greedy gain.\n    3. Sum - All upward moves.\n    \"\"\"\n    profit = 0\n    for i in range(1, len(prices)):  # Iterate through the range.\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProfit(prices) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} prices\n     * @return {any}\n     */\n    maxProfit(prices) {\n        let ans = 0;\n        for (let i = 1; i < prices.length; i++) {\n            ans += Math.max(0, prices[i] - prices[i - 1]);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int ans = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            ans += Math.max(0, prices[i] - prices[i - 1]);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProfit(vector<int>& prices) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int ans = 0;\n        for (int i = 1; i < prices.size(); ++i) ans += max(0, prices[i] - prices[i - 1]);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) (ans int) {\n\tfor i, v := range prices[1:] {\n\t\tt := v - prices[i]\n\t\tif t > 0 {\n\t\t\tans += t\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut res = 0;\n        for i in 1..prices.len() {\n            res += (0).max(prices[i] - prices[i - 1]);\n        }\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProfit(prices: number[]): number  {\n    let ans = 0;\n    for (let i = 1; i < prices.length; i++) {\n        ans += Math.max(0, prices[i] - prices[i - 1]);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxProfit(prices: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "jump-game": {
    "title": "Jump Game",
    "pattern": "Greedy",
    "patternEmoji": "\ud83e\udd98",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track the farthest reachable index. If i > maxReach, return False.",
    "intuition": [
      "\ud83c\udfaf Can you reach the last index?",
      "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
      "\ud83d\udca1 If current index exceeds reach, we're stuck."
    ],
    "testCases": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true"
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "reach = 0",
        "explanation": "Start."
      },
      {
        "step": 2,
        "title": "Update",
        "visual": "reach = max(reach, i + nums[i])",
        "explanation": "Extend."
      },
      {
        "step": 3,
        "title": "Check",
        "visual": "reach >= n-1?",
        "explanation": "Can reach end."
      }
    ],
    "code": "class Solution:\n    def canJump(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Can you reach the last index?\n        - \ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).\n        - \ud83d\udca1 If current index exceeds reach, we're stuck.\n\n        Algorithm:\n        1. Init - Start.\n        2. Update - Extend.\n        3. Check - Can reach end.\n        \"\"\"\n        reach = 0\n        for i in range(len(nums)):  # Iterate through the range.\n            if i > reach:\n                return False  # Condition not met.\n            reach = max(reach, i + nums[i])  # Take the maximum value.\n        return True  # Condition satisfied.",
    "keyInsight": "Greedy approach: always track the maximum reachable position.",
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      1,
      1,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Jump Game",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 4",
        "transientMessage": "Iteration 5",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Jump 1 step from 0 to 1, then 3 steps to last."
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "Always stuck at index 3."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^5"
    ],
    "hints": [
      "Track the farthest reachable index.",
      "If current index > farthest, return false.",
      "If farthest >= last index, return true."
    ],
    "relatedProblems": [
      "jump-game-ii",
      "jump-game-iii",
      "jump-game-iv"
    ],
    "videoId": "Yan0cv2cLy8",
    "problemStatement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.",
    "difficulty": "Medium",
    "walkthrough": [
      "Sort input if needed for optimal substructure",
      "Make locally optimal choice at each step",
      "Update state based on current choice",
      "Validate choice doesn't violate constraints",
      "Build solution incrementally"
    ],
    "approach": "Greedy: Track the farthest reachable index. If i > maxReach, return False.",
    "suggestedNextQuestion": {
      "slug": "merge-triplets-to-form-target-triplet",
      "title": "Merge Triplets to Form Target Triplet",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def canJump(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def canJump(nums):\n    # Backtrack from last index\n    target = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n        if i + nums[i] >= target:\n            target = i\n    return target == 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Can you reach the last index?",
          "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
          "\ud83d\udca1 If current index exceeds reach, we're stuck."
        ],
        "code": "def canJump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can you reach the last index?\n    - \ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).\n    - \ud83d\udca1 If current index exceeds reach, we're stuck.\n\n    Algorithm:\n    1. Init - Start.\n    2. Update - Extend.\n    3. Check - Can reach end.\n    \"\"\"\n    reach = 0\n    for i in range(len(nums)):  # Iterate through the range.\n        if i > reach:\n            return False  # Condition not met.\n        reach = max(reach, i + nums[i])  # Take the maximum value.\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    canJump(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    canJump(nums) {\n        let mx = 0;\n        for (let i = 0; i < nums.length; ++i) {\n            if (mx < i) {\n                return false;\n            }\n            mx = Math.max(mx, i + nums[i]);\n    }\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean canJump(int[] nums) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (mx < i) {\n                return false;\n            }\n            mx = Math.max(mx, i + nums[i]);\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool canJump(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int mx = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (mx < i) {\n                return false;\n            }\n            mx = max(mx, i + nums[i]);\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canJump(nums []int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canJump(nums []int) bool {\n\tmx := 0\n\tfor i, x := range nums {\n\t\tif mx < i {\n\t\t\treturn false\n\t\t}\n\t\tmx = max(mx, i+x)\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn can_jump(nums: Vec<i32>) -> bool {\n        let n = nums.len();\n        let mut mx = 0;\n\n        for i in 0..n {\n            if mx < i {\n                return false;\n            }\n            mx = std::cmp::max(mx, i + (nums[i] as usize));\n        }\n\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canJump(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    canJump(nums: number[]): boolean  {\n    let mx: number = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (mx < i) {\n            return false;\n        }\n        mx = Math.max(mx, i + nums[i]);\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    canJump(nums: number[]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "jump-game-ii": {
    "title": "Jump Game II",
    "pattern": "Greedy BFS",
    "patternEmoji": "\ud83e\udd98\ud83e\udd98",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "BFS-style: track current level end and farthest reachable.",
    "intuition": [
      "\ud83c\udfaf Minimum jumps to reach end.",
      "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
      "\ud83d\udca1 When we pass current level end, increment jumps."
    ],
    "testCases": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2"
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "jumps=0, end=0, far=0",
        "explanation": "Setup."
      },
      {
        "step": 2,
        "title": "Expand",
        "visual": "far = max(far, i+nums[i])",
        "explanation": "Track farthest."
      },
      {
        "step": 3,
        "title": "Level",
        "visual": "i == end? jumps++, end=far",
        "explanation": "Next jump."
      }
    ],
    "code": "class Solution:\n    def jump(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Minimum jumps to reach end.\n        - \ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.\n        - \ud83d\udca1 When we pass current level end, increment jumps.\n\n        Algorithm:\n        1. Init - Setup.\n        2. Expand - Track farthest.\n        3. Level - Next jump.\n        \"\"\"\n        jumps = 0\n        end = 0\n        farthest = 0\n        for i in range(len(nums) - 1):  # Iterate through the range.\n            farthest = max(farthest, i + nums[i])  # Take the maximum value.\n            if i == end:\n                jumps += 1\n                end = farthest\n        return jumps",
    "keyInsight": "Think of it as BFS where each 'level' represents one jump.",
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      1,
      1,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Jump Game II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 4",
        "transientMessage": "Iteration 5",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          3,
          1,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. Return the minimum number of jumps to reach nums[n - 1].",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "2",
        "explanation": "Jump 1 to index 1, then 3 to last index."
      },
      {
        "input": "nums = [2,3,0,1,4]",
        "output": "2",
        "explanation": "Same minimum jumps."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 1000",
      "It's guaranteed you can reach nums[n - 1]."
    ],
    "hints": [
      "Use BFS-like approach with levels.",
      "Track current jump's end and farthest reachable.",
      "Increment jumps when reaching current end."
    ],
    "relatedProblems": [
      "jump-game",
      "jump-game-iii",
      "minimum-jumps-to-reach-home"
    ],
    "videoId": "dJ7sWiOoK7g",
    "problemStatement": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Greedy BFS: BFS-style: track current level end and farthest reachable.",
    "suggestedNextQuestion": {
      "slug": "lowest-common-ancestor-of-a-binary-tree",
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def jump(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def jump(nums):\n    jumps = 0\n    cur_end = 0\n    cur_farthest = 0\n    for i in range(len(nums) - 1):\n        cur_farthest = max(cur_farthest, i + nums[i])\n        if i == cur_end:\n            jumps += 1\n            cur_end = cur_farthest\n    return jumps"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Minimum jumps to reach end.",
          "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
          "\ud83d\udca1 When we pass current level end, increment jumps."
        ],
        "code": "def jump(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum jumps to reach end.\n    - \ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.\n    - \ud83d\udca1 When we pass current level end, increment jumps.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Expand - Track farthest.\n    3. Level - Next jump.\n    \"\"\"\n    jumps = 0\n    end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):  # Iterate through the range.\n        farthest = max(farthest, i + nums[i])  # Take the maximum value.\n        if i == end:\n            jumps += 1\n            end = farthest\n    return jumps"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    jump(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    jump(nums) {\n        let result = 0;\n        let max = 0;\n        let previous = 0;\n\n        for (let index = 0; index < nums.length - 1; index++) {\n          max = Math.max(max, index + nums[index]);\n          if (index === previous) {\n            result++;\n            previous = max;\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int jump(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int jump(int[] nums) {\n        int ans = 0, mx = 0, last = 0;\n        for (int i = 0; i < nums.length - 1; ++i) {\n            mx = Math.max(mx, i + nums[i]);\n            if (last == i) {\n                ++ans;\n                last = mx;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int jump(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int ans = 0, mx = 0, last = 0;\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            mx = max(mx, i + nums[i]);\n            if (last == i) {\n                ++ans;\n                last = mx;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) jump(nums []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) jump(nums []int) (ans int) {\n\tmx, last := 0, 0\n\tfor i, x := range nums[:len(nums)-1] {\n\t\tmx = max(mx, i+x)\n\t\tif last == i {\n\t\t\tans++\n\t\t\tlast = mx\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn jump(nums: Vec<i32>) -> i32 {\n        let mut ans = 0;\n        let mut mx = 0;\n        let mut last = 0;\n        for i in 0..(nums.len() - 1) {\n            mx = mx.max(i as i32 + nums[i]);\n            if last == i as i32 {\n                ans += 1;\n                last = mx;\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def jump(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    jump(nums: number[]): number  {\n    let [ans, mx, last] = [0, 0, 0];\n    for (let i = 0; i < nums.length - 1; ++i) {\n        mx = Math.max(mx, i + nums[i]);\n        if (last === i) {\n            ++ans;\n            last = mx;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    jump(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "h-index": {
    "title": "H-Index",
    "pattern": "Counting Sort / Binary Search",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "videoId": "mgG5KFTvfPw",
    "oneliner": "Count papers at each citation level. Scan from high to low.",
    "intuition": [
      "\ud83c\udfaf H-index: h papers with at least h citations.",
      "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
      "\ud83d\udca1 Accumulate from high to find h where count >= h."
    ],
    "testCases": [
      {
        "input": "citations = [3,0,6,1,5]",
        "output": "3"
      },
      {
        "input": "citations = [1,3,1]",
        "output": "1"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Bucket",
        "visual": "Count citations",
        "explanation": "Counting sort."
      },
      {
        "step": 2,
        "title": "Accumulate",
        "visual": "From n down to 0",
        "explanation": "Sum papers."
      },
      {
        "step": 3,
        "title": "Find h",
        "visual": "total >= h",
        "explanation": "First valid."
      }
    ],
    "code": "class Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf H-index: h papers with at least h citations.\n        - \ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.\n        - \ud83d\udca1 Accumulate from high to find h where count >= h.\n\n        Algorithm:\n        1. Bucket - Counting sort.\n        2. Accumulate - Sum papers.\n        3. Find h - First valid.\n        \"\"\"\n        n = len(citations)\n        papers = [0] * (n + 1)\n        for c in citations:  # Iterate over elements.\n            papers[min(n, c)] += 1  # Take the minimum value.\n        total = 0\n        for h in range(n, -1, -1):  # Iterate through the range.\n            total += papers[h]\n            if total >= h:\n                return h\n        return 0",
    "keyInsight": "Counting sort avoids O(n log n) sort. Cap citations at n.",
    "visualizationType": "array",
    "initialState": [
      3,
      0,
      6,
      1,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: H-Index",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 0",
        "transientMessage": "Iteration 2",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          3,
          0,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Count papers at each citation level. Scan from high to low.\n\nH-index: h papers with at least h citations.\nUse counting sort bucket. papers[i] = count of papers with i citations.",
    "examples": [
      {
        "input": "citations = [3,0,6,1,5]",
        "output": "3"
      },
      {
        "input": "citations = [1,3,1]",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "H-index: h papers with at least h citations.",
      "Use counting sort bucket. papers[i] = count of papers with i citations.",
      "Accumulate from high to find h where count >= h."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "problemStatement": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Counting Sort / Binary Search: Count papers at each citation level. Scan from high to low.",
    "suggestedNextQuestion": {
      "slug": "koko-eating-bananas",
      "title": "Koko Eating Bananas",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def hIndex(self, citations):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def hIndex_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf H-index: h papers with at least h citations.",
          "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
          "\ud83d\udca1 Accumulate from high to find h where count >= h."
        ],
        "code": "def hIndex(citations):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf H-index: h papers with at least h citations.\n    - \ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.\n    - \ud83d\udca1 Accumulate from high to find h where count >= h.\n\n    Algorithm:\n    1. Bucket - Counting sort.\n    2. Accumulate - Sum papers.\n    3. Find h - First valid.\n    \"\"\"\n    n = len(citations)\n    papers = [0] * (n + 1)\n    for c in citations:  # Iterate over elements.\n        papers[min(n, c)] += 1  # Take the minimum value.\n    total = 0\n    for h in range(n, -1, -1):  # Iterate through the range.\n        total += papers[h]\n        if total >= h:\n            return h\n    return 0"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    hIndex(citations) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} citations\n     * @return {any}\n     */\n    hIndex(citations) {\n        citations.sort((a, b) => a - b);\n        for (let i = 0; i < citations.length; i++) {\n          if (citations[i] >= citations.length - i) {\n            return citations.length - i;\n          }\n      }\n    return 0;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int hIndex(int[] citations) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        int n = citations.length;\n        for (int h = n; h > 0; --h) {\n            if (citations[n - h] >= h) {\n                return h;\n            }\n        }\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int hIndex(vector<int>& citations) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        sort(citations.rbegin(), citations.rend());\n        for (int h = citations.size(); h; --h) {\n            if (citations[h - 1] >= h) {\n                return h;\n            }\n        }\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) hIndex(citations []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) hIndex(citations []int) int {\n\tsort.Ints(citations)\n\tn := len(citations)\n\tfor h := n; h > 0; h-- {\n\t\tif citations[n-h] >= h {\n\t\t\treturn h\n\t\t}\n\t}\n\treturn 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn h_index(citations: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn h_index(citations: Vec<i32>) -> i32 {\n        let mut citations = citations;\n        citations.sort_by(|&lhs, &rhs| rhs.cmp(&lhs));\n\n        let n = citations.len();\n\n        for i in (1..=n).rev() {\n            if citations[i - 1] >= (i as i32) {\n                return i as i32;\n            }\n        }\n\n        0\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def hIndex(self, citations):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    hIndex(citations: number[]): number  {\n    citations.sort((a, b) => b - a);\n    for (let h = citations.length; h; --h) {\n        if (citations[h - 1] >= h) {\n            return h;\n        }\n    }\n    return 0;\n}\n}",
        "initialCode": "class Solution {\n    hIndex(citations: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "product-of-array-except-self": {
    "title": "Product of Array Except Self",
    "pattern": "Prefix/Suffix Products",
    "patternEmoji": "\u2716\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Two passes: left products, then right products multiplied in.",
    "intuition": [
      "\ud83c\udfaf res[i] = product of all except nums[i].",
      "\ud83e\udde0 res[i] = (product of left) * (product of right).",
      "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]"
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Left",
        "visual": "res = [1, 1, 2, 6]",
        "explanation": "Prefix products."
      },
      {
        "step": 2,
        "title": "Right",
        "visual": "Multiply suffix",
        "explanation": "Right to left."
      },
      {
        "step": 3,
        "title": "Result",
        "visual": "[24,12,8,6]",
        "explanation": "Combined."
      }
    ],
    "code": "class Solution:\n    def productExceptSelf(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf res[i] = product of all except nums[i].\n        - \ud83e\udde0 res[i] = (product of left) * (product of right).\n        - \ud83d\udca1 First pass: left products. Second pass: multiply right products.\n\n        Algorithm:\n        1. Left - Prefix products.\n        2. Right - Right to left.\n        3. Result - Combined.\n        \"\"\"\n        n = len(nums)\n        res = [1] * n\n        left = 1\n        for i in range(n):  # Iterate through the range.\n            res[i] = left\n            left *= nums[i]\n        right = 1\n        for i in range(n - 1, -1, -1):  # Iterate through the range.\n            res[i] *= right\n            right *= nums[i]\n        return res  # Return the final result.",
    "keyInsight": "Use output array for left products, then multiply right products in-place.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [1, 2, 3, 4]",
        "transientMessage": "Calculate product except self for each position",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Left pass: result[0] = 1",
        "transientMessage": "Product of elements to the left",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Left pass: result[1] = 1",
        "transientMessage": "Product of elements to the left",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Left pass: result[2] = 2",
        "transientMessage": "Product of elements to the left",
        "arrayState": [
          1,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Left pass: result[3] = 6",
        "transientMessage": "Product of elements to the left",
        "arrayState": [
          1,
          1,
          2,
          6
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Right pass: result[3] *= 1 = 6",
        "transientMessage": "Multiply by product of elements to the right",
        "arrayState": [
          1,
          1,
          2,
          6
        ],
        "pointers": [
          {
            "label": "R",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Right pass: result[2] *= 4 = 8",
        "transientMessage": "Multiply by product of elements to the right",
        "arrayState": [
          1,
          1,
          8,
          6
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Right pass: result[1] *= 12 = 12",
        "transientMessage": "Multiply by product of elements to the right",
        "arrayState": [
          1,
          12,
          8,
          6
        ],
        "pointers": [
          {
            "label": "R",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Right pass: result[0] *= 24 = 24",
        "transientMessage": "Multiply by product of elements to the right",
        "arrayState": [
          24,
          12,
          8,
          6
        ],
        "pointers": [
          {
            "label": "R",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Result: [24, 12, 8, 6]",
        "transientMessage": "Complete!",
        "arrayState": [
          24,
          12,
          8,
          6
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]",
        "explanation": "Products accounting for the zero."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "Product of any prefix or suffix fits in 32-bit integer."
    ],
    "hints": [
      "Calculate prefix products from left.",
      "Calculate suffix products from right.",
      "answer[i] = prefix[i-1] * suffix[i+1]."
    ],
    "relatedProblems": [
      "trapping-rain-water",
      "maximum-product-subarray",
      "paint-house-ii"
    ],
    "videoId": "bNvIQI2wAjk",
    "problemStatement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Prefix/Suffix Products: Two passes: left products, then right products multiplied in.",
    "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
    "initialCode": "class Solution:\n    def productExceptSelf(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def productExceptSelf(nums):\n    n = len(nums)\n    res = [1] * n\n    # Prefix\n    pre = 1\n    for i in range(n):\n        res[i] = pre\n        pre *= nums[i]\n    # Postfix\n    post = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= post\n        post *= nums[i]\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf res[i] = product of all except nums[i].",
          "\ud83e\udde0 res[i] = (product of left) * (product of right).",
          "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
        ],
        "code": "def productExceptSelf(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf res[i] = product of all except nums[i].\n    - \ud83e\udde0 res[i] = (product of left) * (product of right).\n    - \ud83d\udca1 First pass: left products. Second pass: multiply right products.\n\n    Algorithm:\n    1. Left - Prefix products.\n    2. Right - Right to left.\n    3. Result - Combined.\n    \"\"\"\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):  # Iterate through the range.\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):  # Iterate through the range.\n        res[i] *= right\n        right *= nums[i]\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    productExceptSelf(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    productExceptSelf(nums) {\n        const n = nums.length;\n        const ans = new Array(n);\n        for (let i = 0, left = 1; i < n; ++i) {\n            ans[i] = left;\n            left *= nums[i];\n        }\n        for (let i = n - 1, right = 1; i >= 0; --i) {\n            ans[i] *= right;\n            right *= nums[i];\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0, left = 1; i < n; ++i) {\n            ans[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; i >= 0; --i) {\n            ans[i] *= right;\n            right *= nums[i];\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> productExceptSelf(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0, left = 1; i < n; ++i) {\n            ans[i] = left;\n            left *= nums[i];\n        }\n        for (int i = n - 1, right = 1; ~i; --i) {\n            ans[i] *= right;\n            right *= nums[i];\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) productExceptSelf(nums []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) productExceptSelf(nums []int) []int {\n\tn := len(nums)\n\tans := make([]int, n)\n\tleft, right := 1, 1\n\tfor i, x := range nums {\n\t\tans[i] = left\n\t\tleft *= x\n\t}\n\tfor i := n - 1; i >= 0; i-- {\n\t\tans[i] *= right\n\t\tright *= nums[i]\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut ans = vec![1; n];\n        for i in 1..n {\n            ans[i] = ans[i - 1] * nums[i - 1];\n        }\n        let mut r = 1;\n        for i in (0..n).rev() {\n            ans[i] *= r;\n            r *= nums[i];\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def productExceptSelf(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    productExceptSelf(nums: number[]): number[]  {\n    const n = nums.length;\n    const ans: number[] = new Array(n);\n    for (let i = 0, left = 1; i < n; ++i) {\n        ans[i] = left;\n        left *= nums[i];\n    }\n    for (let i = n - 1, right = 1; i >= 0; --i) {\n        ans[i] *= right;\n        right *= nums[i];\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    productExceptSelf(nums: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "longest-consecutive-sequence",
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "pattern": "Hash Set"
    }
  },
  "gas-station": {
    "title": "Gas Station",
    "pattern": "Greedy",
    "patternEmoji": "\u26fd",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "If total gas >= total cost, solution exists. Start from where deficit resets.",
    "intuition": [
      "\ud83c\udfaf Find the starting gas station to complete the circuit.",
      "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
      "\ud83d\udca1 If total >= 0, answer is the last reset point."
    ],
    "testCases": [
      {
        "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
        "output": "3"
      },
      {
        "input": "gas = [2,3,4], cost = [3,4,3]",
        "output": "-1"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Track",
        "visual": "total, tank, start",
        "explanation": "Initialize."
      },
      {
        "step": 2,
        "title": "Add",
        "visual": "tank += gas[i] - cost[i]",
        "explanation": "Net gain."
      },
      {
        "step": 3,
        "title": "Reset",
        "visual": "tank<0? start=i+1, tank=0",
        "explanation": "New start."
      }
    ],
    "code": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find the starting gas station to complete the circuit.\n        - \ud83e\udde0 Track total and current tank. Reset start when current < 0.\n        - \ud83d\udca1 If total >= 0, answer is the last reset point.\n\n        Algorithm:\n        1. Track - Initialize.\n        2. Add - Net gain.\n        3. Reset - New start.\n        \"\"\"\n        total = 0\n        tank = 0\n        start = 0\n        for i in range(len(gas)):  # Iterate through the range.\n            diff = gas[i] - cost[i]\n            total += diff\n            tank += diff\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start if total >= 0 else -1",
    "keyInsight": "If you can't reach station i+1 from some start, try starting from i+1.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "gas: [1, 2, 3, 4, 5]",
        "transientMessage": "cost: [3, 4, 5, 1, 2]",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Station 0: gas=1, cost=3, net=-2",
        "transientMessage": "currTank=-2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "start",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Tank empty! Reset start to 1",
        "transientMessage": "Cannot start from earlier stations",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "start",
            "index": 1
          }
        ],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Station 1: gas=2, cost=4, net=-2",
        "transientMessage": "currTank=-2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "start",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Tank empty! Reset start to 2",
        "transientMessage": "Cannot start from earlier stations",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "start",
            "index": 2
          }
        ],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Station 2: gas=3, cost=5, net=-2",
        "transientMessage": "currTank=-2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          },
          {
            "label": "start",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Tank empty! Reset start to 3",
        "transientMessage": "Cannot start from earlier stations",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "start",
            "index": 3
          }
        ],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Station 3: gas=4, cost=1, net=3",
        "transientMessage": "currTank=3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          },
          {
            "label": "start",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Station 4: gas=5, cost=2, net=3",
        "transientMessage": "currTank=6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          },
          {
            "label": "start",
            "index": 3
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Start from station: 3",
        "transientMessage": "Solution exists!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "\u2713",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      }
    ],
    "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.",
    "examples": [
      {
        "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
        "output": "3",
        "explanation": "Start at station 3, you can complete the circuit."
      },
      {
        "input": "gas = [2,3,4], cost = [3,4,3]",
        "output": "-1",
        "explanation": "Not possible to complete."
      }
    ],
    "constraints": [
      "n == gas.length == cost.length",
      "1 <= n <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "hints": [
      "If total gas < total cost, impossible.",
      "If we run out at station j, start can't be 0 to j.",
      "Greedy: reset start when tank goes negative."
    ],
    "relatedProblems": [
      "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
    ],
    "videoId": "lJwbPZGo05A",
    "problemStatement": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
    "difficulty": "Medium",
    "walkthrough": [
      "Sort input if needed for optimal substructure",
      "Make locally optimal choice at each step",
      "Update state based on current choice",
      "Validate choice doesn't violate constraints",
      "Build solution incrementally"
    ],
    "approach": "Greedy: If total gas >= total cost, solution exists. Start from where deficit resets.",
    "suggestedNextQuestion": {
      "slug": "hand-of-straights",
      "title": "Hand of Straights",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def canCompleteCircuit(gas, cost):\n    total_gas = 0\n    total_cost = 0\n    start = 0\n    tank = 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        tank += gas[i] - cost[i]\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total_gas >= total_cost else -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find the starting gas station to complete the circuit.",
          "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
          "\ud83d\udca1 If total >= 0, answer is the last reset point."
        ],
        "code": "def canCompleteCircuit(gas, cost):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the starting gas station to complete the circuit.\n    - \ud83e\udde0 Track total and current tank. Reset start when current < 0.\n    - \ud83d\udca1 If total >= 0, answer is the last reset point.\n\n    Algorithm:\n    1. Track - Initialize.\n    2. Add - Net gain.\n    3. Reset - New start.\n    \"\"\"\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):  # Iterate through the range.\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    canCompleteCircuit(gas, cost) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} gas, cost\n     * @return {any}\n     */\n    canCompleteCircuit(gas, cost) {\n        let total = 0, tank = 0, index = 0;\n\n        for (let i = 0; i < gas.length; i++) {\n          tank += gas[i] - cost[i];\n          total += gas[i] - cost[i];\n          if (tank < 0) {\n            tank = 0;\n            index = i + 1;\n          }\n      }\n\n    return total >= 0 ? index : -1;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int n = gas.length;\n        int i = n - 1, j = n - 1;\n        int cnt = 0, s = 0;\n        while (cnt < n) {\n            s += gas[j] - cost[j];\n            ++cnt;\n            j = (j + 1) % n;\n            while (s < 0 && cnt < n) {\n                --i;\n                s += gas[i] - cost[i];\n                ++cnt;\n            }\n        }\n        return s < 0 ? -1 : i;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n = gas.size();\n        int i = n - 1, j = n - 1;\n        int cnt = 0, s = 0;\n        while (cnt < n) {\n            s += gas[j] - cost[j];\n            ++cnt;\n            j = (j + 1) % n;\n            while (s < 0 && cnt < n) {\n                --i;\n                s += gas[i] - cost[i];\n                ++cnt;\n            }\n        }\n        return s < 0 ? -1 : i;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canCompleteCircuit(gas []int, cost []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canCompleteCircuit(gas []int, cost []int) int {\n\tn := len(gas)\n\ti, j := n-1, n-1\n\tcnt, s := 0, 0\n\tfor cnt < n {\n\t\ts += gas[j] - cost[j]\n\t\tcnt++\n\t\tj = (j + 1) % n\n\t\tfor s < 0 && cnt < n {\n\t\t\ti--\n\t\t\ts += gas[i] - cost[i]\n\t\t\tcnt++\n\t\t}\n\t}\n\tif s < 0 {\n\t\treturn -1\n\t}\n\treturn i\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [134] Gas Station\n *\n * There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\n *\n * You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\n *\n * Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n *\n * Note:\n *\n *\n * \tIf there exists a solution, it is guaranteed to be unique.\n * \tBoth input arrays are non-empty and have the same length.\n * \tEach element in the input arrays is a non-negative integer.\n *\n *\n * Example 1:\n *\n *\n * Input:\n * gas  = [1,2,3,4,5]\n * cost = [3,4,5,1,2]\n *\n * Output: 3\n *\n * Explanation:\n * Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n * Travel to station 4. Your tank = 4 - 1 + 5 = 8\n * Travel to station 0. Your tank = 8 - 2 + 1 = 7\n * Travel to station 1. Your tank = 7 - 3 + 2 = 6\n * Travel to station 2. Your tank = 6 - 4 + 3 = 5\n * Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n * Therefore, return 3 as the starting index.\n *\n *\n * Example 2:\n *\n *\n * Input:\n * gas  = [2,3,4]\n * cost = [3,4,3]\n *\n * Output: -1\n *\n * Explanation:\n * You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\n * Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n * Travel to station 0. Your tank = 4 - 3 + 2 = 3\n * Travel to station 1. Your tank = 3 - 3 + 3 = 3\n * You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\n * Therefore, you can't travel around the circuit once no matter where you start.\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/gas-station/\n// discuss: https://leetcode.com/problems/gas-station/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn can_complete_circuit(gas: Vec<i32>, cost: Vec<i32>) -> i32 {\n        0\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_134() {}\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    canCompleteCircuit(gas: number[], cost: number[]): number  {\n    const n = gas.length;\n    let i = n - 1;\n    let j = n - 1;\n    let s = 0;\n    let cnt = 0;\n    while (cnt < n) {\n        s += gas[j] - cost[j];\n        ++cnt;\n        j = (j + 1) % n;\n        while (s < 0 && cnt < n) {\n            --i;\n            s += gas[i] - cost[i];\n            ++cnt;\n        }\n    }\n    return s < 0 ? -1 : i;\n}\n}",
        "initialCode": "class Solution {\n    canCompleteCircuit(gas: number[], cost: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "candy": {
    "title": "Candy",
    "pattern": "Two Pass Greedy",
    "patternEmoji": "\ud83c\udf6c",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
    "intuition": [
      "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
      "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
      "\ud83d\udca1 Right-to-left: same logic, take max."
    ],
    "testCases": [
      {
        "input": "ratings = [1,0,2]",
        "output": "5"
      },
      {
        "input": "ratings = [1,2,2]",
        "output": "4"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "candy = [1,1,1...]",
        "explanation": "Everyone gets 1."
      },
      {
        "step": 2,
        "title": "Left",
        "visual": "Increasing? +1",
        "explanation": "Left rule."
      },
      {
        "step": 3,
        "title": "Right",
        "visual": "Decreasing? max",
        "explanation": "Right rule."
      }
    ],
    "code": "class Solution:\n    def candy(self, ratings):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.\n        - \ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.\n        - \ud83d\udca1 Right-to-left: same logic, take max.\n\n        Algorithm:\n        1. Init - Everyone gets 1.\n        2. Left - Left rule.\n        3. Right - Right rule.\n        \"\"\"\n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):  # Iterate through the range.\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 2, -1, -1):  # Iterate through the range.\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)  # Take the maximum value.\n        return sum(candies)",
    "keyInsight": "Two passes handle left and right neighbors independently, then combine.",
    "visualizationType": "array",
    "initialState": [
      1,
      0,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Candy",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 0",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 2",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          0,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.\n\nEach child gets at least 1 candy. Higher rating = more than neighbors.\nLeft-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
    "examples": [
      {
        "input": "ratings = [1,0,2]",
        "output": "5"
      },
      {
        "input": "ratings = [1,2,2]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Each child gets at least 1 candy. Higher rating = more than neighbors.",
      "Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
      "Right-to-left: same logic, take max."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "1IzCRCcK17A",
    "problemStatement": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nReturn the minimum number of candies you need to have to distribute the candies to the children.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Pass Greedy: Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
    "suggestedNextQuestion": {
      "slug": "text-justification",
      "title": "Text Justification",
      "difficulty": "Hard",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def candy(self, ratings):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1] + 1\n    for i in range(n-2, -1, -1):\n        if ratings[i] > ratings[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n    return sum(candies)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
          "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
          "\ud83d\udca1 Right-to-left: same logic, take max."
        ],
        "code": "def candy(ratings):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.\n    - \ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.\n    - \ud83d\udca1 Right-to-left: same logic, take max.\n\n    Algorithm:\n    1. Init - Everyone gets 1.\n    2. Left - Left rule.\n    3. Right - Right rule.\n    \"\"\"\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):  # Iterate through the range.\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):  # Iterate through the range.\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)  # Take the maximum value.\n    return sum(candies)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    candy(ratings) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} ratings\n     * @return {any}\n     */\n    candy(ratings) {\n        const data = new Array(ratings.length).fill(1);\n\n        for (let i = 1; i < ratings.length; i++) {\n          if (ratings[i - 1] < ratings[i]) {\n            data[i] = data[i - 1] + 1;\n          }\n        }\n\n        for (let i = ratings.length - 1; i > 0; i--) {\n          if (ratings[i - 1] > ratings[i]) {\n            data[i - 1] = data[i - 1] > data[i] + 1 ? data[i - 1] : data[i] + 1;\n          }\n      }\n\n    return data.reduce((sum, n) => sum + n, 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int candy(int[] ratings) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(left, 1);\n        Arrays.fill(right, 1);\n        for (int i = 1; i < n; ++i) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        for (int i = n - 2; i >= 0; --i) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += Math.max(left[i], right[i]);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int candy(vector<int>& ratings) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        vector<int> left(n, 1);\n        vector<int> right(n, 1);\n        for (int i = 1; i < n; ++i) {\n            if (ratings[i] > ratings[i - 1]) {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        for (int i = n - 2; ~i; --i) {\n            if (ratings[i] > ratings[i + 1]) {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += max(left[i], right[i]);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) candy(ratings []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) candy(ratings []int) int {\n\tn := len(ratings)\n\tleft := make([]int, n)\n\tright := make([]int, n)\n\tfor i := range left {\n\t\tleft[i] = 1\n\t\tright[i] = 1\n\t}\n\tfor i := 1; i < n; i++ {\n\t\tif ratings[i] > ratings[i-1] {\n\t\t\tleft[i] = left[i-1] + 1\n\t\t}\n\t}\n\tfor i := n - 2; i >= 0; i-- {\n\t\tif ratings[i] > ratings[i+1] {\n\t\t\tright[i] = right[i+1] + 1\n\t\t}\n\t}\n\tans := 0\n\tfor i, a := range left {\n\t\tb := right[i]\n\t\tans += max(a, b)\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn candy(ratings: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn candy(ratings: Vec<i32>) -> i32 {\n        let n = ratings.len();\n        let mut left = vec![1; n];\n        let mut right = vec![1; n];\n\n        for i in 1..n {\n            if ratings[i] > ratings[i - 1] {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n\n        for i in (0..n - 1).rev() {\n            if ratings[i] > ratings[i + 1] {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n\n        ratings\n            .iter()\n            .enumerate()\n            .map(|(i, _)| left[i].max(right[i]) as i32)\n            .sum()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def candy(self, ratings):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    candy(ratings: number[]): number  {\n    const n = ratings.length;\n    const left = new Array(n).fill(1);\n    const right = new Array(n).fill(1);\n    for (let i = 1; i < n; ++i) {\n        if (ratings[i] > ratings[i - 1]) {\n            left[i] = left[i - 1] + 1;\n        }\n    }\n    for (let i = n - 2; i >= 0; --i) {\n        if (ratings[i] > ratings[i + 1]) {\n            right[i] = right[i + 1] + 1;\n        }\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.max(left[i], right[i]);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    candy(ratings: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "trapping-rain-water": {
    "title": "Trapping Rain Water",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udca7",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
    "intuition": [
      "\ud83c\udfaf How much water can be trapped?",
      "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
      "\ud83d\udca1 Two pointers: move the smaller side inward."
    ],
    "testCases": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6"
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "l=0, r=n-1, maxL=maxR=0",
        "explanation": "Pointers."
      },
      {
        "step": 2,
        "title": "Compare",
        "visual": "Move smaller side",
        "explanation": "Bottleneck."
      },
      {
        "step": 3,
        "title": "Add",
        "visual": "water += max - height[i]",
        "explanation": "Accumulate."
      }
    ],
    "code": "class Solution:\n    def trap(self, height):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf How much water can be trapped?\n        - \ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.\n        - \ud83d\udca1 Two pointers: move the smaller side inward.\n\n        Algorithm:\n        1. Init - Pointers.\n        2. Compare - Bottleneck.\n        3. Add - Accumulate.\n        \"\"\"\n        if not height: return 0\n        l, r = 0, len(height) - 1  # Initialize two pointers.\n        leftMax, rightMax = height[l], height[r]\n        water = 0\n        while l < r:  # Continue until pointers meet.\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])  # Take the maximum value.\n                water += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])  # Take the maximum value.\n                water += rightMax - height[r]\n        return water",
    "keyInsight": "The smaller of leftMax/rightMax determines water level at current position.",
    "visualizationType": "array",
    "initialState": [
      0,
      1,
      0,
      2,
      1,
      0,
      1,
      3,
      2,
      1,
      2,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]",
        "transientMessage": "Initialize left=0, right=11",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 11
          }
        ],
        "indices": [
          0,
          11
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Update leftMax = 0",
        "transientMessage": "New left boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 11
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Update rightMax = 1",
        "transientMessage": "New right boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 11
          }
        ],
        "indices": [
          11
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update leftMax = 1",
        "transientMessage": "New left boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 10
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Trap 1 water at index 2",
        "transientMessage": "Total water: 1",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 10
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Update rightMax = 2",
        "transientMessage": "New right boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 10
          }
        ],
        "indices": [
          10
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Trap 1 water at index 9",
        "transientMessage": "Total water: 2",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 9
          }
        ],
        "indices": [
          9
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Update rightMax = 2",
        "transientMessage": "New right boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 8
          }
        ],
        "indices": [
          8
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Update leftMax = 2",
        "transientMessage": "New left boundary",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Trap 1 water at index 4",
        "transientMessage": "Total water: 3",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Trap 2 water at index 5",
        "transientMessage": "Total water: 5",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 5
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Trap 1 water at index 6",
        "transientMessage": "Total water: 6",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "L",
            "index": 6
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "Result: 6 units of water",
        "transientMessage": "Complete!",
        "arrayState": [
          0,
          1,
          0,
          2,
          1,
          0,
          1,
          3,
          2,
          1,
          2,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "Water fills between bars."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": "Water fills between 4,5 and intermediate bars."
      }
    ],
    "constraints": [
      "n == height.length",
      "1 <= n <= 2 * 10^4",
      "0 <= height[i] <= 10^5"
    ],
    "hints": [
      "Water at position i = min(maxLeft, maxRight) - height[i].",
      "Use two pointers from both ends.",
      "Or precompute maxLeft and maxRight arrays."
    ],
    "relatedProblems": [
      "container-with-most-water",
      "product-of-array-except-self",
      "trapping-rain-water-ii"
    ],
    "videoId": "ZI2z5pq0TqA",
    "problemStatement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "difficulty": "Hard",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
    "mentalModel": "Imagine filling a landscape with water. The water level is determined by the shortest enclosing wall.",
    "initialCode": "class Solution:\n    def trap(self, height):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def trap(height):\n    if not height: return 0\n    l, r = 0, len(height) - 1\n    leftMax, rightMax = height[l], height[r]\n    res = 0\n    while l < r:\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])\n            res += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])\n            res += rightMax - height[r]\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf How much water can be trapped?",
          "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
          "\ud83d\udca1 Two pointers: move the smaller side inward."
        ],
        "code": "def trap(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf How much water can be trapped?\n    - \ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.\n    - \ud83d\udca1 Two pointers: move the smaller side inward.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Bottleneck.\n    3. Add - Accumulate.\n    \"\"\"\n    if not height: return 0\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    leftMax, rightMax = height[l], height[r]\n    water = 0\n    while l < r:  # Continue until pointers meet.\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])  # Take the maximum value.\n            water += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])  # Take the maximum value.\n            water += rightMax - height[r]\n    return water"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    trap(height) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} height\n     * @return {any}\n     */\n    trap(height) {\n        let result = 0;\n\n        for (let left = 0, right = height.length - 1, maxL = 0, maxR = 0; left < right;) {\n          maxL = Math.max(maxL, height[left]);\n          maxR = Math.max(maxR, height[right]);\n          result += maxL < maxR ? maxL - height[left++] : maxR - height[right--];\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int trap(int[] height) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];\n        int[] right = new int[n];\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n        for (int i = 1; i < n; ++i) {\n            left[i] = Math.max(left[i - 1], height[i]);\n            right[n - i - 1] = Math.max(right[n - i], height[n - i - 1]);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += Math.min(left[i], right[i]) - height[i];\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int trap(vector<int>& height) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int left[n], right[n];\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n        for (int i = 1; i < n; ++i) {\n            left[i] = max(left[i - 1], height[i]);\n            right[n - i - 1] = max(right[n - i], height[n - i - 1]);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += min(left[i], right[i]) - height[i];\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) trap(height []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) trap(height []int) (ans int) {\n\tn := len(height)\n\tleft := make([]int, n)\n\tright := make([]int, n)\n\tleft[0], right[n-1] = height[0], height[n-1]\n\tfor i := 1; i < n; i++ {\n\t\tleft[i] = max(left[i-1], height[i])\n\t\tright[n-i-1] = max(right[n-i], height[n-i-1])\n\t}\n\tfor i, h := range height {\n\t\tans += min(left[i], right[i]) - h\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn trap(height: Vec<i32>) -> i32 {\n        let n = height.len();\n        let mut left: Vec<i32> = vec![0; n];\n        let mut right: Vec<i32> = vec![0; n];\n\n        left[0] = height[0];\n        right[n - 1] = height[n - 1];\n\n        // Initialize the left & right vector\n        for i in 1..n {\n            left[i] = std::cmp::max(left[i - 1], height[i]);\n            right[n - i - 1] = std::cmp::max(right[n - i], height[n - i - 1]);\n        }\n\n        let mut ans = 0;\n\n        // Calculate the ans\n        for i in 0..n {\n            ans += std::cmp::min(left[i], right[i]) - height[i];\n        }\n\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def trap(self, height):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    trap(height: number[]): number  {\n    const n = height.length;\n    const left: number[] = new Array(n).fill(height[0]);\n    const right: number[] = new Array(n).fill(height[n - 1]);\n    for (let i = 1; i < n; ++i) {\n        left[i] = Math.max(left[i - 1], height[i]);\n        right[n - i - 1] = Math.max(right[n - i], height[n - i - 1]);\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    trap(height: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "remove-duplicates-from-sorted-array-ii",
      "title": "Remove Duplicates from Sorted Array II",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    }
  },
  "roman-to-integer": {
    "title": "Roman to Integer",
    "pattern": "Hash Map",
    "patternEmoji": "\ud83c\udfdb\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "If current < next, subtract; else add.",
    "intuition": [
      "\ud83c\udfaf Convert Roman numeral to integer.",
      "\ud83e\udde0 Map each symbol to value.",
      "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
    ],
    "testCases": [
      {
        "input": "s = \"III\"",
        "output": "3"
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58"
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Map",
        "visual": "I=1, V=5, X=10...",
        "explanation": "Values."
      },
      {
        "step": 2,
        "title": "Scan",
        "visual": "Compare curr and next",
        "explanation": "Direction."
      },
      {
        "step": 3,
        "title": "Add/Sub",
        "visual": "Accumulate result",
        "explanation": "Total."
      }
    ],
    "code": "class Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Convert Roman numeral to integer.\n        - \ud83e\udde0 Map each symbol to value.\n        - \ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add.\n\n        Algorithm:\n        1. Map - Values.\n        2. Scan - Direction.\n        3. Add/Sub - Total.\n        \"\"\"\n        roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        for i in range(len(s)):  # Iterate through the range.\n            if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n                total -= roman[s[i]]\n            else:\n                total += roman[s[i]]\n        return total",
    "keyInsight": "Subtraction happens when a smaller value precedes a larger one.",
    "visualizationType": "array",
    "initialState": [
      "M",
      "C",
      "M",
      "X",
      "C",
      "I",
      "V"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Roman: \"MCMXCIV\"",
        "transientMessage": "Convert to integer",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "M=1000",
        "transientMessage": "Add: result = 1000",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "+",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "C=100 < M=1000",
        "transientMessage": "Subtract: result = 900",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "-",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "M=1000",
        "transientMessage": "Add: result = 1900",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "+",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "X=10 < C=100",
        "transientMessage": "Subtract: result = 1890",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "-",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "C=100",
        "transientMessage": "Add: result = 1990",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "+",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "I=1 < V=5",
        "transientMessage": "Subtract: result = 1989",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "-",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "V=5",
        "transientMessage": "Add: result = 1994",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [
          {
            "label": "+",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Result: 1994",
        "transientMessage": "Complete!",
        "arrayState": [
          "M",
          "C",
          "M",
          "X",
          "C",
          "I",
          "V"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.",
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "III = 1 + 1 + 1 = 3."
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V= 5, III = 3."
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90, IV = 4."
      }
    ],
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
      "It is guaranteed that s is a valid roman numeral."
    ],
    "hints": [
      "Create a mapping of symbols to values.",
      "If current < next, subtract current.",
      "Otherwise add current."
    ],
    "relatedProblems": [
      "integer-to-roman"
    ],
    "videoId": "3jdxYj3DD98",
    "problemStatement": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nGiven a roman numeral, convert it to an integer.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map: If current < next, subtract; else add.",
    "suggestedNextQuestion": {
      "slug": "two-sum",
      "title": "Two Sum",
      "difficulty": "Easy",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def romanToInt(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def romanToInt_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Convert Roman numeral to integer.",
          "\ud83e\udde0 Map each symbol to value.",
          "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
        ],
        "code": "def romanToInt(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert Roman numeral to integer.\n    - \ud83e\udde0 Map each symbol to value.\n    - \ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add.\n\n    Algorithm:\n    1. Map - Values.\n    2. Scan - Direction.\n    3. Add/Sub - Total.\n    \"\"\"\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i in range(len(s)):  # Iterate through the range.\n        if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    romanToInt(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    romanToInt(s) {\n        const d = {\n            I: 1,\n            V: 5,\n            X: 10,\n            L: 50,\n            C: 100,\n            D: 500,\n            M: 1000,\n        };\n        let ans = d[s[s.length - 1]];\n        for (let i = 0; i < s.length - 1; ++i) {\n            const sign = d[s[i]] < d[s[i + 1]] ? -1 : 1;\n            ans += sign * d[s[i]];\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int romanToInt(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int romanToInt(String s) {\n        String cs = \"IVXLCDM\";\n        int[] vs = {1, 5, 10, 50, 100, 500, 1000};\n        Map<Character, Integer> d = new HashMap<>();\n        for (int i = 0; i < vs.length; ++i) {\n            d.put(cs.charAt(i), vs[i]);\n        }\n        int n = s.length();\n        int ans = d.get(s.charAt(n - 1));\n        for (int i = 0; i < n - 1; ++i) {\n            int sign = d.get(s.charAt(i)) < d.get(s.charAt(i + 1)) ? -1 : 1;\n            ans += sign * d.get(s.charAt(i));\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int romanToInt(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> nums{\n            {'I', 1},\n            {'V', 5},\n            {'X', 10},\n            {'L', 50},\n            {'C', 100},\n            {'D', 500},\n            {'M', 1000},\n        };\n        int ans = nums[s.back()];\n        for (int i = 0; i < s.size() - 1; ++i) {\n            int sign = nums[s[i]] < nums[s[i + 1]] ? -1 : 1;\n            ans += sign * nums[s[i]];\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) romanToInt(s string) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) romanToInt(s string) (ans int) {\n\td := map[byte]int{'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n\tfor i := 0; i < len(s)-1; i++ {\n\t\tif d[s[i]] < d[s[i+1]] {\n\t\t\tans -= d[s[i]]\n\t\t} else {\n\t\t\tans += d[s[i]]\n\t\t}\n\t}\n\tans += d[s[len(s)-1]]\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn roman_to_int(s: String) -> i32 {\n        let d = vec![\n            ('I', 1),\n            ('V', 5),\n            ('X', 10),\n            ('L', 50),\n            ('C', 100),\n            ('D', 500),\n            ('M', 1000),\n        ]\n        .into_iter()\n        .collect::<std::collections::HashMap<_, _>>();\n\n        let s: Vec<char> = s.chars().collect();\n        let mut ans = 0;\n        let len = s.len();\n\n        for i in 0..len - 1 {\n            if d[&s[i]] < d[&s[i + 1]] {\n                ans -= d[&s[i]];\n            } else {\n                ans += d[&s[i]];\n            }\n        }\n\n        ans += d[&s[len - 1]];\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def romanToInt(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    romanToInt(s: string): number  {\n    const d: Map<string, number> = new Map([\n        ['I', 1],\n        ['V', 5],\n        ['X', 10],\n        ['L', 50],\n        ['C', 100],\n        ['D', 500],\n        ['M', 1000],\n    ]);\n    let ans: number = d.get(s[s.length - 1])!;\n    for (let i = 0; i < s.length - 1; ++i) {\n        const sign = d.get(s[i])! < d.get(s[i + 1])! ? -1 : 1;\n        ans += sign * d.get(s[i])!;\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    romanToInt(s: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "integer-to-roman": {
    "title": "Integer to Roman",
    "pattern": "Greedy",
    "patternEmoji": "\ud83c\udfdb\ufe0f",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "oneliner": "Greedily subtract largest possible value and append symbol.",
    "intuition": [
      "\ud83c\udfaf Convert integer to Roman numeral.",
      "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
      "\ud83d\udca1 Repeatedly subtract and append until num is 0."
    ],
    "testCases": [
      {
        "input": "num = 3749",
        "output": "\"MMMDCCXLIX\""
      },
      {
        "input": "num = 58",
        "output": "\"LVIII\""
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "List",
        "visual": "(1000,M), (900,CM)...",
        "explanation": "All values."
      },
      {
        "step": 2,
        "title": "Greed",
        "visual": "While num >= val: append",
        "explanation": "Subtract."
      },
      {
        "step": 3,
        "title": "Build",
        "visual": "Concatenate symbols",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def intToRoman(self, num):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Convert integer to Roman numeral.\n        - \ud83e\udde0 Use a list of (value, symbol) pairs in descending order.\n        - \ud83d\udca1 Repeatedly subtract and append until num is 0.\n\n        Algorithm:\n        1. List - All values.\n        2. Greed - Subtract.\n        3. Build - Result.\n        \"\"\"\n        val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n                   (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n                   (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n        res = []  # Initialize list to store results.\n        for val, sym in val_sym:  # Iterate over elements.\n            while num >= val:\n                res.append(sym)  # Add to end.\n                num -= val\n        return ''.join(res)",
    "keyInsight": "Include subtraction pairs (CM, CD, XC, etc.) in the lookup table.",
    "visualizationType": "array",
    "initialState": "3749",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Integer to Roman",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 7",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 4",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 9",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "3",
          "7",
          "4",
          "9"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Greedily subtract largest possible value and append symbol.\n\nConvert integer to Roman numeral.\nUse a list of (value, symbol) pairs in descending order.",
    "examples": [
      {
        "input": "num = 3749",
        "output": "\"MMMDCCXLIX\""
      },
      {
        "input": "num = 58",
        "output": "\"LVIII\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Convert integer to Roman numeral.",
      "Use a list of (value, symbol) pairs in descending order.",
      "Repeatedly subtract and append until num is 0."
    ],
    "relatedProblems": [
      "jump-game",
      "gas-station",
      "best-time-to-buy-and-sell-stock-ii"
    ],
    "videoId": "ohBNdSJyLh8",
    "problemStatement": "Seven different symbols represent Roman numerals with the following values:\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nGiven an integer, convert it to a Roman numeral.",
    "difficulty": "Medium",
    "walkthrough": [
      "Sort input if needed for optimal substructure",
      "Make locally optimal choice at each step",
      "Update state based on current choice",
      "Validate choice doesn't violate constraints",
      "Build solution incrementally"
    ],
    "approach": "Greedy: Greedily subtract largest possible value and append symbol.",
    "suggestedNextQuestion": {
      "slug": "jump-game",
      "title": "Jump Game",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def intToRoman(self, num):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def intToRoman(num):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n        ]\n    syb = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n        ]\n    roman_num = ''\n    i = 0\n    while  num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syb[i]\n            num -= val[i]\n        i += 1\n    return roman_num"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Convert integer to Roman numeral.",
          "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
          "\ud83d\udca1 Repeatedly subtract and append until num is 0."
        ],
        "code": "def intToRoman(num):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert integer to Roman numeral.\n    - \ud83e\udde0 Use a list of (value, symbol) pairs in descending order.\n    - \ud83d\udca1 Repeatedly subtract and append until num is 0.\n\n    Algorithm:\n    1. List - All values.\n    2. Greed - Subtract.\n    3. Build - Result.\n    \"\"\"\n    val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    res = []  # Initialize list to store results.\n    for val, sym in val_sym:  # Iterate over elements.\n        while num >= val:\n            res.append(sym)  # Add to end.\n            num -= val\n    return ''.join(res)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    intToRoman(num) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} num\n     * @return {any}\n     */\n    intToRoman(num) {\n        const map = {\n          M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90,\n          L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1\n        };\n\n        return Object.entries(map).reduce((result, [letter, n]) => {\n          result += letter.repeat(Math.floor(num / n));\n          num %= n;\n          return result;\n        }, '');\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String intToRoman(int num) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String intToRoman(int num) {\n        List<String> cs\n            = List.of(\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\");\n        List<Integer> vs = List.of(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);\n        StringBuilder ans = new StringBuilder();\n        for (int i = 0, n = cs.size(); i < n; ++i) {\n            while (num >= vs.get(i)) {\n                num -= vs.get(i);\n                ans.append(cs.get(i));\n            }\n        }\n        return ans.toString();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string intToRoman(int num) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        vector<string> cs = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        vector<int> vs = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        string ans;\n        for (int i = 0; i < cs.size(); ++i) {\n            while (num >= vs[i]) {\n                num -= vs[i];\n                ans += cs[i];\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) intToRoman(num int) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) intToRoman(num int) string {\n\tcs := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n\tvs := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\tans := &strings.Builder{}\n\tfor i, v := range vs {\n\t\tfor num >= v {\n\t\t\tnum -= v\n\t\t\tans.WriteString(cs[i])\n\t\t}\n\t}\n\treturn ans.String()\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn int_to_roman(num: i32) -> String {\n        let cs = [\n            \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\",\n        ];\n        let vs = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n        let mut num = num;\n        let mut ans = String::new();\n\n        for (i, &v) in vs.iter().enumerate() {\n            while num >= v {\n                num -= v;\n                ans.push_str(cs[i]);\n            }\n        }\n\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def intToRoman(self, num):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    intToRoman(num: number): string  {\n    const cs: string[] = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];\n    const vs: number[] = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    const ans: string[] = [];\n    for (let i = 0; i < vs.length; ++i) {\n        while (num >= vs[i]) {\n            num -= vs[i];\n            ans.push(cs[i]);\n        }\n    }\n    return ans.join('');\n}\n}",
        "initialCode": "class Solution {\n    intToRoman(num: number): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "length-of-last-word": {
    "title": "Length of Last Word",
    "pattern": "String Traversal",
    "patternEmoji": "\ud83d\udccf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Strip trailing spaces, find last space, return len - last_space - 1.",
    "intuition": [
      "\ud83c\udfaf Find length of last word.",
      "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
      "\ud83d\udca1 Or just use split()[-1]."
    ],
    "testCases": [
      {
        "input": "s = \"Hello World\"",
        "output": "5"
      },
      {
        "input": "s = \"   fly me   to   the moon  \"",
        "output": "4"
      },
      {
        "input": "s = \"luffy is still joyboy\"",
        "output": "6"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Trim",
        "visual": "Skip trailing spaces",
        "explanation": "Find word."
      },
      {
        "step": 2,
        "title": "Count",
        "visual": "Count until space",
        "explanation": "Length."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "Length = 5",
        "explanation": "Done."
      }
    ],
    "code": "class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find length of last word.\n        - \ud83e\udde0 Iterate from end, skip trailing spaces, count letters.\n        - \ud83d\udca1 Or just use split()[-1].\n\n        Algorithm:\n        1. Trim - Find word.\n        2. Count - Length.\n        3. Return - Done.\n        \"\"\"\n        return len(s.strip().split()[-1])  # Remove whitespace.",
    "keyInsight": "Python's split() handles multiple spaces elegantly.",
    "visualizationType": "array",
    "initialState": "Hello World",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Length of Last Word",
        "transientMessage": "Input: [H, e, l, l, o,  , W, o...]",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: H",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: e",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: l",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: l",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: o",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          "H",
          "e",
          "l",
          "l",
          "o",
          " ",
          "W",
          "o",
          "r",
          "l",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Strip trailing spaces, find last space, return len - last_space - 1.\n\nFind length of last word.\nIterate from end, skip trailing spaces, count letters.",
    "examples": [
      {
        "input": "s = \"Hello World\"",
        "output": "5"
      },
      {
        "input": "s = \"   fly me   to   the moon  \"",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find length of last word.",
      "Iterate from end, skip trailing spaces, count letters.",
      "Or just use split()[-1]."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "KT9rltZTybQ",
    "problemStatement": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "String Traversal: Strip trailing spaces, find last space, return len - last_space - 1.",
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class Solution:\n    def lengthOfLastWord(self, s):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def lengthOfLastWord(s):\n    # Strip trailing spaces then split\n    words = s.strip().split(' ')\n    if not words: return 0\n    return len(words[-1])"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find length of last word.",
          "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
          "\ud83d\udca1 Or just use split()[-1]."
        ],
        "code": "def lengthOfLastWord(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find length of last word.\n    - \ud83e\udde0 Iterate from end, skip trailing spaces, count letters.\n    - \ud83d\udca1 Or just use split()[-1].\n\n    Algorithm:\n    1. Trim - Find word.\n    2. Count - Length.\n    3. Return - Done.\n    \"\"\"\n    return len(s.strip().split()[-1])  # Remove whitespace."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    lengthOfLastWord(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    lengthOfLastWord(s) {\n        let i = s.length - 1;\n        while (i >= 0 && s[i] === ' ') {\n            --i;\n        }\n        let j = i;\n        while (j >= 0 && s[j] !== ' ') {\n            --j;\n    }\n    return i - j;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int lengthOfLastWord(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int i = s.length() - 1;\n        while (i >= 0 && s.charAt(i) == ' ') {\n            --i;\n        }\n        int j = i;\n        while (j >= 0 && s.charAt(j) != ' ') {\n            --j;\n        }\n        return i - j;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int lengthOfLastWord(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int i = s.size() - 1;\n        while (~i && s[i] == ' ') {\n            --i;\n        }\n        int j = i;\n        while (~j && s[j] != ' ') {\n            --j;\n        }\n        return i - j;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLastWord(s string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLastWord(s string) int {\n\ti := len(s) - 1\n\tfor i >= 0 && s[i] == ' ' {\n\t\ti--\n\t}\n\tj := i\n\tfor j >= 0 && s[j] != ' ' {\n\t\tj--\n\t}\n\treturn i - j\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn length_of_last_word(s: String) -> i32 {\n        let s = s.trim_end();\n        let n = s.len();\n        for (i, c) in s.char_indices().rev() {\n            if c == ' ' {\n                return (n - i - 1) as i32;\n            }\n        }\n        n as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find length of last word.\n        - \ud83e\udde0 Iterate from end, skip trailing spaces, count letters.\n        - \ud83d\udca1 Or just use split()[-1].\n\n        Algorithm:\n        1. Trim - Find word.\n        2. Count - Length.\n        3. Return - Done.\n        \"\"\"\n        return len(s.strip().split()[-1])  # Remove whitespace."
      },
      "typescript": {
        "code": "class Solution {\n    lengthOfLastWord(s: string): number  {\n    let i = s.length - 1;\n    while (i >= 0 && s[i] === ' ') {\n        --i;\n    }\n    let j = i;\n    while (j >= 0 && s[j] !== ' ') {\n        --j;\n    }\n    return i - j;\n}\n}",
        "initialCode": "class Solution {\n    lengthOfLastWord(s: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "valid-parentheses",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "pattern": "Stack"
    }
  },
  "longest-common-prefix": {
    "title": "Longest Common Prefix",
    "pattern": "Horizontal Scan",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(S)",
    "spaceComplexity": "O(1)",
    "oneliner": "Compare characters at same position across all strings.",
    "intuition": [
      "\ud83c\udfaf Find the longest common prefix among all strings.",
      "\ud83e\udde0 Iterate character by character.",
      "\ud83d\udca1 Stop when any string differs or ends."
    ],
    "testCases": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\""
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Zip",
        "visual": "Compare columns",
        "explanation": "Char by char."
      },
      {
        "step": 2,
        "title": "Check",
        "visual": "All same?",
        "explanation": "Continue."
      },
      {
        "step": 3,
        "title": "Stop",
        "visual": "Mismatch found",
        "explanation": "Return prefix."
      }
    ],
    "code": "class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find the longest common prefix among all strings.\n        - \ud83e\udde0 Iterate character by character.\n        - \ud83d\udca1 Stop when any string differs or ends.\n\n        Algorithm:\n        1. Zip - Char by char.\n        2. Check - Continue.\n        3. Stop - Return prefix.\n        \"\"\"\n        if not strs: return ''\n        for i in range(len(strs[0])):  # Iterate through the range.\n            char = strs[0][i]\n            for s in strs[1:]:  # Iterate over elements.\n                if i >= len(s) or s[i] != char:\n                    return strs[0][:i]\n        return strs[0]",
    "keyInsight": "Vertical scanning is more efficient than horizontal pairwise comparison.",
    "visualizationType": "array",
    "initialState": [
      "flower",
      "flow",
      "flight"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Common Prefix",
        "transientMessage": "Input: [flower, flow, flight]",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: flower",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: flow",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: flight",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          "flower",
          "flow",
          "flight"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Compare characters at same position across all strings.\n\nFind the longest common prefix among all strings.\nIterate character by character.",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find the longest common prefix among all strings.",
      "Iterate character by character.",
      "Stop when any string differs or ends."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "0sWShKIJoo4",
    "problemStatement": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Horizontal Scan: Compare characters at same position across all strings.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def longestCommonPrefix(self, strs):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def longestCommonPrefix(strs):\n    if not strs: return \"\"\n    shortest = min(strs, key=len)\n    for i, char in enumerate(shortest):\n        for other in strs:\n            if other[i] != char:\n                return shortest[:i]\n    return shortest"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(S)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find the longest common prefix among all strings.",
          "\ud83e\udde0 Iterate character by character.",
          "\ud83d\udca1 Stop when any string differs or ends."
        ],
        "code": "def longestCommonPrefix(strs):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find the longest common prefix among all strings.\n    - \ud83e\udde0 Iterate character by character.\n    - \ud83d\udca1 Stop when any string differs or ends.\n\n    Algorithm:\n    1. Zip - Char by char.\n    2. Check - Continue.\n    3. Stop - Return prefix.\n    \"\"\"\n    if not strs: return ''\n    for i in range(len(strs[0])):  # Iterate through the range.\n        char = strs[0][i]\n        for s in strs[1:]:  # Iterate over elements.\n            if i >= len(s) or s[i] != char:\n                return strs[0][:i]\n    return strs[0]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    longestCommonPrefix(strs) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string[]} strs\n * @return {string}\n */\nclass Solution {\n    /**\n     * @param {any} strs\n     * @return {any}\n     */\n    longestCommonPrefix(strs) {\n        for (let j = 0; j < strs[0].length; j++) {\n            for (let i = 0; i < strs.length; i++) {\n                if (strs[0][j] !== strs[i][j]) {\n                    return strs[0].substring(0, j);\n                }\n            }\n    }\n    return strs[0];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        int n = strs.length;\n        for (int i = 0; i < strs[0].length(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].length() <= i || strs[j].charAt(i) != strs[0].charAt(i)) {\n                    return strs[0].substring(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string longestCommonPrefix(vector<string>& strs) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n = strs.size();\n        for (int i = 0; i < strs[0].size(); ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (strs[j].size() <= i || strs[j][i] != strs[0][i]) {\n                    return strs[0].substr(0, i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestCommonPrefix(strs []string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestCommonPrefix(strs []string) string {\n\tn := len(strs)\n\tfor i := range strs[0] {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tif len(strs[j]) <= i || strs[j][i] != strs[0][i] {\n\t\t\t\treturn strs[0][:i]\n\t\t\t}\n\t\t}\n\t}\n\treturn strs[0]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_common_prefix(strs: Vec<String>) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn longest_common_prefix(strs: Vec<String>) -> String {\n        let mut len = strs.iter().map(|s| s.len()).min().unwrap();\n        for i in (1..=len).rev() {\n            let mut is_equal = true;\n            let target = strs[0][0..i].to_string();\n            if strs.iter().all(|s| target == s[0..i]) {\n                return target;\n            }\n        }\n        String::new()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def longestCommonPrefix(self, strs):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    longestCommonPrefix(strs: string[]): string  {\n    const len = strs.reduce((r, s) => Math.min(r, s.length), Infinity);\n    for (let i = len; i > 0; i--) {\n        const target = strs[0].slice(0, i);\n        if (strs.every(s => s.slice(0, i) === target)) {\n            return target;\n        }\n    }\n    return '';\n}\n}",
        "initialCode": "class Solution {\n    longestCommonPrefix(strs: string[]): string {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    }
  },
  "reverse-words-in-a-string": {
    "title": "Reverse Words in a String",
    "pattern": "Two Pointers / Split",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Split by spaces, reverse, join with single space.",
    "intuition": [
      "\ud83c\udfaf Reverse the order of words in a string.",
      "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
      "\ud83d\udca1 Handle leading/trailing/multiple spaces."
    ],
    "testCases": [
      {
        "input": "s = \"the sky is blue\"",
        "output": "\"blue is sky the\""
      },
      {
        "input": "s = \"  hello world  \"",
        "output": "\"world hello\""
      },
      {
        "input": "s = \"a good   example\"",
        "output": "\"example good a\""
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Split",
        "visual": "['the', 'sky', 'is', 'blue']",
        "explanation": "Tokenize."
      },
      {
        "step": 2,
        "title": "Reverse",
        "visual": "['blue', 'is', 'sky', 'the']",
        "explanation": "Flip order."
      },
      {
        "step": 3,
        "title": "Join",
        "visual": "'blue is sky the'",
        "explanation": "Combine."
      }
    ],
    "code": "class Solution:\n    def reverseWords(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Reverse the order of words in a string.\n        - \ud83e\udde0 Split removes extra spaces, reverse list, join.\n        - \ud83d\udca1 Handle leading/trailing/multiple spaces.\n\n        Algorithm:\n        1. Split - Tokenize.\n        2. Reverse - Flip order.\n        3. Join - Combine.\n        \"\"\"\n        return ' '.join(s.split()[::-1])  # Split string into list.",
    "keyInsight": "Python's split() without args handles multiple spaces elegantly.",
    "visualizationType": "array",
    "initialState": "the sky is blue",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reverse Words in a String",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = t",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = h",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = e",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] =  ",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = s",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = k",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "t",
          "h",
          "e",
          " ",
          "s",
          "k",
          "y",
          " ",
          "i",
          "s",
          " ",
          "b",
          "l",
          "u",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Split by spaces, reverse, join with single space.\n\nReverse the order of words in a string.\nSplit removes extra spaces, reverse list, join.",
    "examples": [
      {
        "input": "s = \"the sky is blue\"",
        "output": "\"blue is sky the\""
      },
      {
        "input": "s = \"  hello world  \"",
        "output": "\"world hello\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Reverse the order of words in a string.",
      "Split removes extra spaces, reverse list, join.",
      "Handle leading/trailing/multiple spaces."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "vhnRAaJybpA",
    "problemStatement": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Pointers / Split: Split by spaces, reverse, join with single space.",
    "suggestedNextQuestion": {
      "slug": "squares-of-a-sorted-array",
      "title": "Squares of a Sorted Array",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def reverseWords(self, s):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def reverseWords(s):\n    # Split by whitespace and reverse list\n    return \" \".join(s.split()[::-1])"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Reverse the order of words in a string.",
          "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
          "\ud83d\udca1 Handle leading/trailing/multiple spaces."
        ],
        "code": "def reverseWords(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse the order of words in a string.\n    - \ud83e\udde0 Split removes extra spaces, reverse list, join.\n    - \ud83d\udca1 Handle leading/trailing/multiple spaces.\n\n    Algorithm:\n    1. Split - Tokenize.\n    2. Reverse - Flip order.\n    3. Join - Combine.\n    \"\"\"\n    return ' '.join(s.split()[::-1])  # Split string into list."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    reverseWords(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    reverseWords(s) {\n        return s.trim().replace(/\\s+/g, ' ').split(/\\s/).reverse().join(' ');\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String reverseWords(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String reverseWords(String s) {\n        List<String> words = new ArrayList<>();\n        int n = s.length();\n        for (int i = 0; i < n;) {\n            while (i < n && s.charAt(i) == ' ') {\n                ++i;\n            }\n            if (i < n) {\n                StringBuilder t = new StringBuilder();\n                int j = i;\n                while (j < n && s.charAt(j) != ' ') {\n                    t.append(s.charAt(j++));\n                }\n                words.add(t.toString());\n                i = j;\n            }\n        }\n        Collections.reverse(words);\n        return String.join(\" \", words);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string reverseWords(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string reverseWords(string s) {\n        int i = 0;\n        int j = 0;\n        int n = s.size();\n        while (i < n) {\n            while (i < n && s[i] == ' ') {\n                ++i;\n            }\n            if (i < n) {\n                if (j != 0) {\n                    s[j++] = ' ';\n                }\n                int k = i;\n                while (k < n && s[k] != ' ') {\n                    s[j++] = s[k++];\n                }\n                reverse(s.begin() + j - (k - i), s.begin() + j);\n                i = k;\n            }\n        }\n        s.erase(s.begin() + j, s.end());\n        reverse(s.begin(), s.end());\n        return s;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverseWords(s string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) reverseWords(s string) string {\n\twords := []string{}\n\ti, n := 0, len(s)\n\tfor i < n {\n\t\tfor i < n && s[i] == ' ' {\n\t\t\ti++\n\t\t}\n\t\tif i < n {\n\t\t\tj := i\n\t\t\tt := []byte{}\n\t\t\tfor j < n && s[j] != ' ' {\n\t\t\t\tt = append(t, s[j])\n\t\t\t\tj++\n\t\t\t}\n\t\t\twords = append(words, string(t))\n\t\t\ti = j\n\t\t}\n\t}\n\tfor i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n\t\twords[i], words[j] = words[j], words[i]\n\t}\n\treturn strings.Join(words, \" \")\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reverse_words(s: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn reverse_words(s: String) -> String {\n        let mut words = Vec::new();\n        let s: Vec<char> = s.chars().collect();\n        let mut i = 0;\n        let n = s.len();\n\n        while i < n {\n            while i < n && s[i] == ' ' {\n                i += 1;\n            }\n            if i < n {\n                let mut j = i;\n                while j < n && s[j] != ' ' {\n                    j += 1;\n                }\n                words.push(s[i..j].iter().collect::<String>());\n                i = j;\n            }\n        }\n\n        words.reverse();\n        words.join(\" \")\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def reverseWords(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Reverse the order of words in a string.\n        - \ud83e\udde0 Split removes extra spaces, reverse list, join.\n        - \ud83d\udca1 Handle leading/trailing/multiple spaces.\n\n        Algorithm:\n        1. Split - Tokenize.\n        2. Reverse - Flip order.\n        3. Join - Combine.\n        \"\"\"\n        return ' '.join(s.split()[::-1])  # Split string into list."
      },
      "typescript": {
        "code": "class Solution {\n    reverseWords(s: string): string  {\n    const words: string[] = [];\n    const n = s.length;\n    let i = 0;\n    while (i < n) {\n        while (i < n && s[i] === ' ') {\n            i++;\n        }\n        if (i < n) {\n            let j = i;\n            while (j < n && s[j] !== ' ') {\n                j++;\n            }\n            words.push(s.slice(i, j));\n            i = j;\n        }\n    }\n    return words.reverse().join(' ');\n}\n}",
        "initialCode": "class Solution {\n    reverseWords(s: string): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "zigzag-conversion": {
    "title": "Zigzag Conversion",
    "pattern": "Simulation",
    "patternEmoji": "\u26a1",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use row index and direction flag. Toggle direction at bounds.",
    "intuition": [
      "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
      "\ud83e\udde0 Track current row, direction (up/down).",
      "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
    ],
    "testCases": [
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 3",
        "output": "\"PAHNAPLSIIGYIR\""
      },
      {
        "input": "s = \"PAYPALISHIRING\", numRows = 4",
        "output": "\"PINALSIGYAHRPI\""
      },
      {
        "input": "s = \"A\", numRows = 1",
        "output": "\"A\""
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "rows = [''] * numRows",
        "explanation": "Setup."
      },
      {
        "step": 2,
        "title": "Traverse",
        "visual": "Add char to row[i]",
        "explanation": "Fill."
      },
      {
        "step": 3,
        "title": "Direction",
        "visual": "Bounce at edges",
        "explanation": "Zigzag."
      }
    ],
    "code": "class Solution:\n    def convert(self, s, numRows):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Write string in zigzag pattern, read row by row.\n        - \ud83e\udde0 Track current row, direction (up/down).\n        - \ud83d\udca1 Flip direction at row 0 and row numRows-1.\n\n        Algorithm:\n        1. Init - Setup.\n        2. Traverse - Fill.\n        3. Direction - Zigzag.\n        \"\"\"\n        if numRows == 1 or numRows >= len(s): return s\n        rows = [''] * numRows\n        idx, step = 0, 1\n        for c in s:  # Iterate over elements.\n            rows[idx] += c\n            if idx == 0: step = 1\n            elif idx == numRows - 1: step = -1\n            idx += step\n        return ''.join(rows)",
    "keyInsight": "The pattern is: go down until bottom, then go up until top, repeat.",
    "visualizationType": "array",
    "initialState": "PAYPALISHIRING",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Zigzag Conversion",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = P",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = A",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = Y",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = P",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = A",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = L",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "P",
          "A",
          "Y",
          "P",
          "A",
          "L",
          "I",
          "S",
          "H",
          "I",
          "R",
          "I",
          "N",
          "G"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use row index and direction flag. Toggle direction at bounds.\n\nWrite string in zigzag pattern, read row by row.\nTrack current row, direction (up/down).",
    "examples": [
      {
        "input": "s = \"PAYPALISHIRING\"; numRows = 3",
        "output": "\"PAHNAPLSIIGYIR\""
      },
      {
        "input": "s = \"PAYPALISHIRING\"; numRows = 4",
        "output": "\"PINALSIGYAHRPI\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Write string in zigzag pattern, read row by row.",
      "Track current row, direction (up/down).",
      "Flip direction at row 0 and row numRows-1."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Q2Tw6gcVEwc",
    "problemStatement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Simulation: Use row index and direction flag. Toggle direction at bounds.",
    "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
    "initialCode": "class Solution:\n    def convert(self, s, numRows):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def convert(s, numRows):\n    if numRows == 1 or numRows >= len(s):\n        return s\n    \n    L = [''] * numRows\n    index, step = 0, 1\n    for x in s:\n        L[index] += x\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n        \n    return ''.join(L)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
          "\ud83e\udde0 Track current row, direction (up/down).",
          "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
        ],
        "code": "def convert(s, numRows):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Write string in zigzag pattern, read row by row.\n    - \ud83e\udde0 Track current row, direction (up/down).\n    - \ud83d\udca1 Flip direction at row 0 and row numRows-1.\n\n    Algorithm:\n    1. Init - Setup.\n    2. Traverse - Fill.\n    3. Direction - Zigzag.\n    \"\"\"\n    if numRows == 1 or numRows >= len(s): return s\n    rows = [''] * numRows\n    idx, step = 0, 1\n    for c in s:  # Iterate over elements.\n        rows[idx] += c\n        if idx == 0: step = 1\n        elif idx == numRows - 1: step = -1\n        idx += step\n    return ''.join(rows)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    convert(s, numRows) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nclass Solution {\n    /**\n     * @param {any} s, numRows\n     * @return {any}\n     */\n    convert(s, numRows) {\n        if (numRows === 1) {\n            return s;\n        }\n        const g = new Array(numRows).fill(_).map(() => []);\n        let i = 0;\n        let k = -1;\n        for (const c of s) {\n            g[i].push(c);\n            if (i === 0 || i === numRows - 1) {\n                k = -k;\n            }\n            i += k;\n    }\n    return g.flat().join('');\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String convert(String s, int numRows) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        StringBuilder[] g = new StringBuilder[numRows];\n        Arrays.setAll(g, k -> new StringBuilder());\n        int i = 0, k = -1;\n        for (char c : s.toCharArray()) {\n            g[i].append(c);\n            if (i == 0 || i == numRows - 1) {\n                k = -k;\n            }\n            i += k;\n        }\n        return String.join(\"\", g);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string convert(string s, int numRows) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) {\n            return s;\n        }\n        vector<string> g(numRows);\n        int i = 0, k = -1;\n        for (char c : s) {\n            g[i] += c;\n            if (i == 0 || i == numRows - 1) {\n                k = -k;\n            }\n            i += k;\n        }\n        string ans;\n        for (auto& t : g) {\n            ans += t;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) convert(s string, numRows int) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) convert(s string, numRows int) string {\n\tif numRows == 1 {\n\t\treturn s\n\t}\n\tg := make([][]byte, numRows)\n\ti, k := 0, -1\n\tfor _, c := range s {\n\t\tg[i] = append(g[i], byte(c))\n\t\tif i == 0 || i == numRows-1 {\n\t\t\tk = -k\n\t\t}\n\t\ti += k\n\t}\n\treturn string(bytes.Join(g, nil))\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn convert(s: String, num_rows: i32) -> String {\n        if num_rows == 1 {\n            return s;\n        }\n\n        let num_rows = num_rows as usize;\n        let mut g = vec![String::new(); num_rows];\n        let mut i = 0;\n        let mut k = -1;\n\n        for c in s.chars() {\n            g[i].push(c);\n            if i == 0 || i == num_rows - 1 {\n                k = -k;\n            }\n            i = (i as isize + k) as usize;\n        }\n\n        g.concat()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def convert(self, s, numRows):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    convert(s: string, numRows: number): string  {\n    if (numRows === 1) {\n        return s;\n    }\n    const g: string[][] = new Array(numRows).fill(0).map(() => []);\n    let i = 0;\n    let k = -1;\n    for (const c of s) {\n        g[i].push(c);\n        if (i === numRows - 1 || i === 0) {\n            k = -k;\n        }\n        i += k;\n    }\n    return g.flat().join('');\n}\n}",
        "initialCode": "class Solution {\n    convert(s: string, numRows: number): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "multiply-strings",
      "title": "Multiply Strings",
      "difficulty": "Medium",
      "pattern": "Simulation"
    }
  },
  "find-the-index-of-the-first-occurrence-in-a-string": {
    "title": "Find the Index of the First Occurrence in a String",
    "pattern": "KMP / Simple Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)",
    "oneliner": "Slide needle over haystack, check for match.",
    "intuition": [
      "\ud83c\udfaf Find first occurrence of needle in haystack.",
      "\ud83e\udde0 Simple: check each starting position.",
      "\ud83d\udca1 Or use Python's built-in find()."
    ],
    "testCases": [
      {
        "input": "haystack = \"sadbutsad\", needle = \"sad\"",
        "output": "0"
      },
      {
        "input": "haystack = \"leetcode\", needle = \"leeto\"",
        "output": "-1"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Slide",
        "visual": "Check each position",
        "explanation": "Linear scan."
      },
      {
        "step": 2,
        "title": "Match",
        "visual": "Compare substring",
        "explanation": "Check."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "Index or -1",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find first occurrence of needle in haystack.\n        - \ud83e\udde0 Simple: check each starting position.\n        - \ud83d\udca1 Or use Python's built-in find().\n\n        Algorithm:\n        1. Slide - Linear scan.\n        2. Match - Check.\n        3. Return - Result.\n        \"\"\"\n        return haystack.find(needle)  # Find index of substring.",
    "keyInsight": "Python's find() is optimized. For interviews, show manual sliding window.",
    "visualizationType": "array",
    "initialState": "sadbutsad",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find the Index of the First Occurrence in a String",
        "transientMessage": "Input: [s, a, d, b, u, t, s, a...]",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: s",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: a",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: d",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: b",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: u",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          "s",
          "a",
          "d",
          "b",
          "u",
          "t",
          "s",
          "a",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Slide needle over haystack, check for match.\n\nFind first occurrence of needle in haystack.\nSimple: check each starting position.",
    "examples": [
      {
        "input": "haystack = \"sadbutsad\"; needle = \"sad\"",
        "output": "0"
      },
      {
        "input": "haystack = \"leetcode\"; needle = \"leeto\"",
        "output": "-1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find first occurrence of needle in haystack.",
      "Simple: check each starting position.",
      "Or use Python's built-in find()."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "JoF0Z7nVSrA",
    "problemStatement": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "KMP / Simple Search: Slide needle over haystack, check for match.",
    "mentalModel": "Like looking for a needle in a haystack.",
    "initialCode": "class Solution:\n    def strStr(self, haystack, needle):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def strStr(haystack, needle):\n    # Built-in find is brute force optimized or KMP\n    return haystack.find(needle)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n*m)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find first occurrence of needle in haystack.",
          "\ud83e\udde0 Simple: check each starting position.",
          "\ud83d\udca1 Or use Python's built-in find()."
        ],
        "code": "def strStr(haystack, needle):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find first occurrence of needle in haystack.\n    - \ud83e\udde0 Simple: check each starting position.\n    - \ud83d\udca1 Or use Python's built-in find().\n\n    Algorithm:\n    1. Slide - Linear scan.\n    2. Match - Check.\n    3. Return - Result.\n    \"\"\"\n    return haystack.find(needle)  # Find index of substring."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    strStr(haystack, needle) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} haystack, needle\n     * @return {any}\n     */\n    strStr(haystack, needle) {\n        const slen = haystack.length;\n        const plen = needle.length;\n        if (slen == plen) {\n            return haystack == needle ? 0 : -1;\n        }\n        for (let i = 0; i <= slen - plen; i++) {\n            let j;\n            for (j = 0; j < plen; j++) {\n                if (haystack[i + j] != needle[j]) {\n                    break;\n                }\n            }\n            if (j == plen) return i;\n    }\n    return -1;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int strStr(String haystack, String needle) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (\"\".equals(needle)) {\n            return 0;\n        }\n\n        int len1 = haystack.length();\n        int len2 = needle.length();\n        int p = 0;\n        int q = 0;\n        while (p < len1) {\n            if (haystack.charAt(p) == needle.charAt(q)) {\n                if (len2 == 1) {\n                    return p;\n                }\n                ++p;\n                ++q;\n            } else {\n                p -= q - 1;\n                q = 0;\n            }\n\n            if (q == len2) {\n                return p - q;\n            }\n        }\n        return -1;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> Next(string str) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\nprivate:\n    vector<int> Next(string str) {\n        vector<int> n(str.length());\n        n[0] = -1;\n        int i = 0, pre = -1;\n        int len = str.length();\n        while (i < len) {\n            while (pre >= 0 && str[i] != str[pre])\n                pre = n[pre];\n            ++i, ++pre;\n            if (i >= len)\n                break;\n            if (str[i] == str[pre])\n                n[i] = n[pre];\n            else\n                n[i] = pre;\n        }\n        return n;\n    }\n\npublic:\n    int strStr(string haystack, string needle) {\n        if (0 == needle.length())\n            return 0;\n\n        vector<int> n(Next(needle));\n\n        int len = haystack.length() - needle.length() + 1;\n        for (int i = 0; i < len; ++i) {\n            int j = 0, k = i;\n            while (j < needle.length() && k < haystack.length()) {\n                if (haystack[k] != needle[j]) {\n                    if (n[j] >= 0) {\n                        j = n[j];\n                        continue;\n                    } else\n                        break;\n                }\n                ++k, ++j;\n            }\n            if (j >= needle.length())\n                return k - j;\n        }\n\n        return -1;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) strStr(haystack string, needle string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) strStr(haystack string, needle string) int {\n\tn, m := len(haystack), len(needle)\n\tfor i := 0; i <= n-m; i++ {\n\t\tif haystack[i:i+m] == needle {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn str_str(haystack: String, needle: String) -> i32 {\n        let haystack = haystack.as_bytes();\n        let needle = needle.as_bytes();\n        let m = haystack.len();\n        let n = needle.len();\n        let mut next = vec![0; n];\n        let mut j = 0;\n        for i in 1..n {\n            while j > 0 && needle[i] != needle[j] {\n                j = next[j - 1];\n            }\n            if needle[i] == needle[j] {\n                j += 1;\n            }\n            next[i] = j;\n        }\n        j = 0;\n        for i in 0..m {\n            while j > 0 && haystack[i] != needle[j] {\n                j = next[j - 1];\n            }\n            if haystack[i] == needle[j] {\n                j += 1;\n            }\n            if j == n {\n                return (i - n + 1) as i32;\n            }\n        }\n        -1\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find first occurrence of needle in haystack.\n        - \ud83e\udde0 Simple: check each starting position.\n        - \ud83d\udca1 Or use Python's built-in find().\n\n        Algorithm:\n        1. Slide - Linear scan.\n        2. Match - Check.\n        3. Return - Result.\n        \"\"\"\n        return haystack.find(needle)  # Find index of substring."
      },
      "typescript": {
        "code": "class Solution {\n    strStr(haystack: string, needle: string): number  {\n    const m = haystack.length;\n    const n = needle.length;\n    for (let i = 0; i <= m - n; i++) {\n        let isEqual = true;\n        for (let j = 0; j < n; j++) {\n            if (haystack[i + j] !== needle[j]) {\n                isEqual = false;\n                break;\n            }\n        }\n        if (isEqual) {\n            return i;\n        }\n    }\n    return -1;\n}\n}",
        "initialCode": "class Solution {\n    strStr(haystack: string, needle: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "linked-list-cycle",
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "pattern": "Fast & Slow Pointers"
    }
  },
  "text-justification": {
    "title": "Text Justification",
    "pattern": "Greedy + Simulation",
    "patternEmoji": "\ud83d\udcdd",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Greedily pack words, distribute spaces evenly. Left-justify last line.",
    "intuition": [
      "\ud83c\udfaf Fully justify text to maxWidth.",
      "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
      "\ud83d\udca1 Last line: left-justified."
    ],
    "testCases": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
        "output": "[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]"
      },
      {
        "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
        "output": "[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]"
      },
      {
        "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
        "output": "[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Pack",
        "visual": "Greedy word fit",
        "explanation": "Fill line."
      },
      {
        "step": 2,
        "title": "Space",
        "visual": "Distribute evenly",
        "explanation": "Justify."
      },
      {
        "step": 3,
        "title": "Last",
        "visual": "Left align",
        "explanation": "Special case."
      }
    ],
    "code": "class Solution:\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Fully justify text to maxWidth.\n        - \ud83e\udde0 Pack as many words as fit, distribute extra spaces.\n        - \ud83d\udca1 Last line: left-justified.\n\n        Algorithm:\n        1. Pack - Fill line.\n        2. Space - Justify.\n        3. Last - Special case.\n        \"\"\"\n        res, line, width = [], [], 0\n        for w in words:  # Iterate over elements.\n            if width + len(w) + len(line) > maxWidth:\n                for i in range(maxWidth - width):  # Iterate through the range.\n                    line[i % (len(line) - 1 or 1)] += ' '\n                res.append(''.join(line))  # Add to end.\n                line, width = [], 0\n            line.append(w)  # Add to end.\n            width += len(w)\n        return res + [' '.join(line).ljust(maxWidth)]  # Return the final result.",
    "keyInsight": "Distribute extra spaces using modulo for even distribution.",
    "visualizationType": "array",
    "initialState": [
      "This",
      "is",
      "an",
      "example"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Text Justification",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = This",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = is",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = an",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = example",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "This",
          "is",
          "an",
          "example"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Greedily pack words, distribute spaces evenly. Left-justify last line.\n\nFully justify text to maxWidth.\nPack as many words as fit, distribute extra spaces.",
    "examples": [
      {
        "input": "words = [\"This\", \"is\", \"an\", \"example\"]; maxWidth = 16",
        "output": "[\"This    is    an\", \"example         \"]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Fully justify text to maxWidth.",
      "Pack as many words as fit, distribute extra spaces.",
      "Last line: left-justified."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "TzMl4Z7pVh8",
    "problemStatement": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Greedy + Simulation: Greedily pack words, distribute spaces evenly. Left-justify last line.",
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def fullJustify(self, words, maxWidth):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def fullJustify(words, maxWidth):\n    res, cur, num_of_letters = [], [], 0\n    for w in words:\n        if num_of_letters + len(w) + len(cur) > maxWidth:\n            for i in range(maxWidth - num_of_letters):\n                cur[i % (len(cur) - 1 or 1)] += ' '\n            res.append(''.join(cur))\n            cur, num_of_letters = [], 0\n        cur.append(w)\n        num_of_letters += len(w)\n    return res + [' '.join(cur).ljust(maxWidth)]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Fully justify text to maxWidth.",
          "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
          "\ud83d\udca1 Last line: left-justified."
        ],
        "code": "def fullJustify(words, maxWidth):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Fully justify text to maxWidth.\n    - \ud83e\udde0 Pack as many words as fit, distribute extra spaces.\n    - \ud83d\udca1 Last line: left-justified.\n\n    Algorithm:\n    1. Pack - Fill line.\n    2. Space - Justify.\n    3. Last - Special case.\n    \"\"\"\n    res, line, width = [], [], 0\n    for w in words:  # Iterate over elements.\n        if width + len(w) + len(line) > maxWidth:\n            for i in range(maxWidth - width):  # Iterate through the range.\n                line[i % (len(line) - 1 or 1)] += ' '\n            res.append(''.join(line))  # Add to end.\n            line, width = [], 0\n        line.append(w)  # Add to end.\n        width += len(w)\n    return res + [' '.join(line).ljust(maxWidth)]  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    fullJustify(words, maxWidth) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} words, maxWidth\n     * @return {any}\n     */\n    fullJustify(words, maxWidth) {\n        const result = [[]];\n        result[0].count = 0;\n\n        for (const word of words) {\n          let row = result[result.length - 1];\n          if (row.length && row.count + row.length + word.length > maxWidth) {\n            result.push([]);\n            row = result[result.length - 1];\n            row.count = 0;\n          }\n          row.push(word);\n          row.count += word.length;\n        }\n\n        for (let i = 0; i < result.length; i++) {\n          const row = result[i];\n          if (row.length === 1 || i === result.length - 1) {\n            result[i] = row.join(' ') + ' '.repeat(maxWidth - row.count - row.length + 1);\n            continue;\n          }\n\n          const min = ' '.repeat(Math.floor((maxWidth - row.count) / (row.length - 1)));\n          for (let j = 1; j < row.length; j++) {\n            const delimiter = j <= (maxWidth - row.count) % (row.length - 1) ? ' ' : '';\n            row[0] += min + delimiter + row[j];\n          }\n\n          result[i] = row[0];\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        List<String> ans = new ArrayList<>();\n        for (int i = 0, n = words.length; i < n;) {\n            List<String> t = new ArrayList<>();\n            t.add(words[i]);\n            int cnt = words[i].length();\n            ++i;\n            while (i < n && cnt + 1 + words[i].length() <= maxWidth) {\n                cnt += 1 + words[i].length();\n                t.add(words[i++]);\n            }\n            if (i == n || t.size() == 1) {\n                String left = String.join(\" \", t);\n                String right = \" \".repeat(maxWidth - left.length());\n                ans.add(left + right);\n                continue;\n            }\n            int spaceWidth = maxWidth - (cnt - t.size() + 1);\n            int w = spaceWidth / (t.size() - 1);\n            int m = spaceWidth % (t.size() - 1);\n            StringBuilder row = new StringBuilder();\n            for (int j = 0; j < t.size() - 1; ++j) {\n                row.append(t.get(j));\n                row.append(\" \".repeat(w + (j < m ? 1 : 0)));\n            }\n            row.append(t.get(t.size() - 1));\n            ans.add(row.toString());\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        vector<string> ans;\n        for (int i = 0, n = words.size(); i < n;) {\n            vector<string> t = {words[i]};\n            int cnt = words[i].size();\n            ++i;\n            while (i < n && cnt + 1 + words[i].size() <= maxWidth) {\n                cnt += 1 + words[i].size();\n                t.emplace_back(words[i++]);\n            }\n            if (i == n || t.size() == 1) {\n                string left = t[0];\n                for (int j = 1; j < t.size(); ++j) {\n                    left += \" \" + t[j];\n                }\n                string right = string(maxWidth - left.size(), ' ');\n                ans.emplace_back(left + right);\n                continue;\n            }\n            int spaceWidth = maxWidth - (cnt - t.size() + 1);\n            int w = spaceWidth / (t.size() - 1);\n            int m = spaceWidth % (t.size() - 1);\n            string row;\n            for (int j = 0; j < t.size() - 1; ++j) {\n                row += t[j] + string(w + (j < m ? 1 : 0), ' ');\n            }\n            row += t.back();\n            ans.emplace_back(row);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) fullJustify(words []string, maxWidth int) (ans []string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) fullJustify(words []string, maxWidth int) (ans []string) {\n\tfor i, n := 0, len(words); i < n; {\n\t\tt := []string{words[i]}\n\t\tcnt := len(words[i])\n\t\ti++\n\t\tfor i < n && cnt+1+len(words[i]) <= maxWidth {\n\t\t\tcnt += 1 + len(words[i])\n\t\t\tt = append(t, words[i])\n\t\t\ti++\n\t\t}\n\t\tif i == n || len(t) == 1 {\n\t\t\tleft := strings.Join(t, \" \")\n\t\t\tright := strings.Repeat(\" \", maxWidth-len(left))\n\t\t\tans = append(ans, left+right)\n\t\t\tcontinue\n\t\t}\n\t\tspaceWidth := maxWidth - (cnt - len(t) + 1)\n\t\tw := spaceWidth / (len(t) - 1)\n\t\tm := spaceWidth % (len(t) - 1)\n\t\trow := strings.Builder{}\n\t\tfor j, s := range t[:len(t)-1] {\n\t\t\trow.WriteString(s)\n\t\t\trow.WriteString(strings.Repeat(\" \", w))\n\t\t\tif j < m {\n\t\t\t\trow.WriteString(\" \")\n\t\t\t}\n\t\t}\n\t\trow.WriteString(t[len(t)-1])\n\t\tans = append(ans, row.String())\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [68] Text Justification\n *\n * Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n *\n * You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n *\n * Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n *\n * For the last line of text, it should be left justified and no extra space is inserted between words.\n *\n * Note:\n *\n *\n * \tA word is defined as a character sequence consisting of non-space characters only.\n * \tEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\n * \tThe input array words contains at least one word.\n *\n *\n * Example 1:\n *\n *\n * Input:\n * words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n * maxWidth = 16\n * Output:\n * [\n *    \"This    is    an\",\n *    \"example  of text\",\n *    \"justification.  \"\n * ]\n *\n *\n * Example 2:\n *\n *\n * Input:\n * words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n * maxWidth = 16\n * Output:\n * [\n *   \"What   must   be\",\n *   \"acknowledgment  \",\n *   \"shall be        \"\n * ]\n * Explanation: Note that the last line is \"shall be    \" instead of \"shall     be\",\n *              because the last line must be left-justified instead of fully-justified.\n *              Note that the second line is also left-justified becase it contains only one word.\n *\n *\n * Example 3:\n *\n *\n * Input:\n * words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\n *          \"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n * maxWidth = 20\n * Output:\n * [\n *   \"Science  is  what we\",\n *   \"understand      well\",\n *   \"enough to explain to\",\n *   \"a  computer.  Art is\",\n *   \"everything  else  we\",\n *   \"do                  \"\n * ]\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/text-justification/\n// discuss: https://leetcode.com/problems/text-justification/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn full_justify(words: Vec<String>, max_width: i32) -> Vec<String> {\n        let mut res = Vec::new();\n        let max_width = max_width as usize;\n        let mut i = 0;\n        let mut row_len = 0;\n        let mut buf = Vec::new();\n        while i < words.len() {\n            if words[i].len() > max_width {\n                unreachable!()\n            }\n            let old_len = row_len;\n            row_len += words[i].len() + if row_len > 0 { 1 } else { 0 };\n            if row_len > max_width {\n                res.push(Solution::compact(buf, max_width, old_len));\n                buf = Vec::new();\n                row_len = 0;\n            } else {\n                buf.push(words[i].clone());\n                i += 1;\n            }\n        }\n        res.push(Solution::compact_last(buf, max_width));\n        res\n    }\n\n    fn compact(words: Vec<String>, max_width: usize, row_len: usize) -> String {\n        let spaces = max_width - (row_len - words.len() + 1);\n        let avg_spaces = spaces / usize::max(1, words.len() - 1);\n        let mut extra_spaces = spaces - avg_spaces * usize::max(1, words.len() - 1);;\n        let mut res = String::new();\n        for (i, word) in words.iter().enumerate() {\n            res.push_str(word);\n            if words.len() < 2 || (i < words.len() - 1) {\n                res.push_str(&\" \".repeat(avg_spaces));\n                if extra_spaces > 0 {\n                    res.push(' ');\n                    extra_spaces -= 1;\n                }\n            }\n        }\n        res\n    }\n\n    fn compact_last(words: Vec<String>, max_width: usize) -> String {\n        let mut res = String::new();\n        for (i, word) in words.iter().enumerate() {\n            res.push_str(word);\n            if i < words.len() - 1 {\n                res.push(' ');\n            }\n        }\n        res.push_str(&\" \".repeat(max_width - res.len()));\n        res\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_68() {\n        assert_eq!(\n            Solution::full_justify(\n                vec_string![\n                    \"This\",\n                    \"is\",\n                    \"an\",\n                    \"example\",\n                    \"of\",\n                    \"text\",\n                    \"justification.\"\n                ],\n                16\n            ),\n            vec_string![\"This    is    an\", \"example  of text\", \"justification.  \"]\n        );\n\n        assert_eq!(\n            Solution::full_justify(\n                vec_string![\"What\", \"must\", \"be\", \"acknowledgment\", \"shall\", \"be\"],\n                16\n            ),\n            vec_string![\"What   must   be\", \"acknowledgment  \", \"shall be        \"]\n        );\n\n        assert_eq!(\n            Solution::full_justify(\n                vec_string![\n                    \"Science\",\n                    \"is\",\n                    \"what\",\n                    \"we\",\n                    \"understand\",\n                    \"well\",\n                    \"enough\",\n                    \"to\",\n                    \"explain\",\n                    \"to\",\n                    \"a\",\n                    \"computer.\",\n                    \"Art\",\n                    \"is\",\n                    \"everything\",\n                    \"else\",\n                    \"we\",\n                    \"do\"\n                ],\n                20\n            ),\n            vec_string![\n                \"Science  is  what we\",\n                \"understand      well\",\n                \"enough to explain to\",\n                \"a  computer.  Art is\",\n                \"everything  else  we\",\n                \"do                  \",\n            ]\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def fullJustify(self, words, maxWidth):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    fullJustify(words: string[], maxWidth: number): string[]  {\n    const ans: string[] = [];\n    for (let i = 0, n = words.length; i < n; ) {\n        const t: string[] = [words[i]];\n        let cnt = words[i++].length;\n        while (i < n && cnt + 1 + words[i].length <= maxWidth) {\n            t.push(words[i]);\n            cnt += 1 + words[i++].length;\n        }\n        if (i === n || t.length === 1) {\n            const left: string = t.join(' ');\n            const right: string = ' '.repeat(maxWidth - left.length);\n            ans.push(left + right);\n            continue;\n        }\n        const spaceWidth: number = maxWidth - (cnt - t.length + 1);\n        const w: number = Math.floor(spaceWidth / (t.length - 1));\n        const m: number = spaceWidth % (t.length - 1);\n        const row: string[] = [];\n        for (let j = 0; j < t.length - 1; ++j) {\n            row.push(t[j]);\n            row.push(' '.repeat(w + (j < m ? 1 : 0)));\n        }\n        row.push(t[t.length - 1]);\n        ans.push(row.join(''));\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    fullJustify(words: string[], maxWidth: number): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "binary-tree-maximum-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "pattern": "DFS + Global Max"
    }
  },
  "find-all-numbers-disappeared-in-an-array": {
    "title": "Find All Numbers Disappeared in an Array",
    "pattern": "Index Marking",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Mark visited indices negative. Return indices still positive.",
    "intuition": [
      "\ud83c\udfaf Find numbers 1..n missing from array.",
      "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
      "\ud83d\udca1 Positive indices indicate missing numbers."
    ],
    "testCases": [
      {
        "input": "nums = [4,3,2,7,8,2,3,1]",
        "output": "[5,6]"
      },
      {
        "input": "nums = [1,1]",
        "output": "[2]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Mark",
        "visual": "Negate at index",
        "explanation": "Seen."
      },
      {
        "step": 2,
        "title": "Scan",
        "visual": "Find positives",
        "explanation": "Missing."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "[5, 6]",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find numbers 1..n missing from array.\n        - \ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].\n        - \ud83d\udca1 Positive indices indicate missing numbers.\n\n        Algorithm:\n        1. Mark - Seen.\n        2. Scan - Missing.\n        3. Return - Result.\n        \"\"\"\n        for n in nums:  # Iterate over elements.\n            idx = abs(n) - 1\n            nums[idx] = -abs(nums[idx])\n        return [i + 1 for i, n in enumerate(nums) if n > 0]",
    "keyInsight": "Using array indices as a hash set avoids extra space.",
    "visualizationType": "array",
    "initialState": [
      4,
      3,
      2,
      7,
      8,
      2,
      3,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find All Numbers Disappeared in an Array",
        "transientMessage": "Input: [4, 3, 2, 7, 8, 2, 3, 1]",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 4",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 3",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 2",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 7",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 8",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          4,
          3,
          2,
          7,
          8,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Mark visited indices negative. Return indices still positive.\n\nFind numbers 1..n missing from array.\nUse indices as markers: negate nums[nums[i]-1].",
    "examples": [
      {
        "input": "nums = [4,3,2,7,8,2,3,1]",
        "output": "[5,6]"
      },
      {
        "input": "nums = [1,1]",
        "output": "[2]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find numbers 1..n missing from array.",
      "Use indices as markers: negate nums[nums[i]-1].",
      "Positive indices indicate missing numbers."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "8i-f24YFWC4",
    "problemStatement": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Index Marking: Mark visited indices negative. Return indices still positive.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def findDisappearedNumbers(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findDisappearedNumbers(nums):\n    # Mark existing\n    for n in nums:\n        idx = abs(n) - 1\n        if nums[idx] > 0:\n            nums[idx] *= -1\n    return [i + 1 for i, n in enumerate(nums) if n > 0]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find numbers 1..n missing from array.",
          "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
          "\ud83d\udca1 Positive indices indicate missing numbers."
        ],
        "code": "def findDisappearedNumbers(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find numbers 1..n missing from array.\n    - \ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].\n    - \ud83d\udca1 Positive indices indicate missing numbers.\n\n    Algorithm:\n    1. Mark - Seen.\n    2. Scan - Missing.\n    3. Return - Result.\n    \"\"\"\n    for n in nums:  # Iterate over elements.\n        idx = abs(n) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i, n in enumerate(nums) if n > 0]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findDisappearedNumbers(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    findDisappearedNumbers(nums) {\n        const result = [];\n\n        for (let i = 0; i < nums.length;) {\n          if (nums[nums[i] - 1] !== nums[i]) {\n            [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n          } else {\n            i++;\n          }\n        }\n\n        nums.forEach((v, i) => {\n          if (v != i + 1) {\n            result.push(i + 1);\n      }\n    });\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        int n = nums.length;\n        boolean[] s = new boolean[n + 1];\n        for (int x : nums) {\n            s[x] = true;\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (!s[i]) {\n                ans.add(i);\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        bool s[n + 1];\n        memset(s, false, sizeof(s));\n        for (int& x : nums) {\n            s[x] = true;\n        }\n        vector<int> ans;\n        for (int i = 1; i <= n; ++i) {\n            if (!s[i]) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findDisappearedNumbers(nums []int) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findDisappearedNumbers(nums []int) (ans []int) {\n\tn := len(nums)\n\ts := make([]bool, n+1)\n\tfor _, x := range nums {\n\t\ts[x] = true\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif !s[i] {\n\t\t\tans = append(ans, i)\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_disappeared_numbers(nums: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn find_disappeared_numbers(mut nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        for i in 0..n {\n            let index: usize = (nums[i].abs() as usize) - 1;\n            nums[index] = -nums[index].abs();\n        }\n        let mut res: Vec<i32> = vec![];\n        for i in 1..=n {\n            let index = i - 1;\n            if nums[index] > 0 {\n                res.push(i as i32);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums = vec![4, 3, 2, 7, 8, 2, 3, 1];\n    assert_eq!(Solution::find_disappeared_numbers(nums), vec![5, 6]);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findDisappearedNumbers(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findDisappearedNumbers(nums: number[]): number[]  {\n    const n = nums.length;\n    const s: boolean[] = new Array(n + 1).fill(false);\n    for (const x of nums) {\n        s[x] = true;\n    }\n    const ans: number[] = [];\n    for (let i = 1; i <= n; ++i) {\n        if (!s[i]) {\n            ans.push(i);\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    findDisappearedNumbers(nums: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "contains-duplicate",
      "title": "Contains Duplicate",
      "difficulty": "Easy",
      "pattern": "Hash Set"
    }
  },
  "is-subsequence": {
    "title": "Is Subsequence",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc46\ud83d\udc46",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use pointer for s, advance when char matches in t.",
    "intuition": [
      "\ud83c\udfaf Is s a subsequence of t?",
      "\ud83e\udde0 Two pointers: advance s pointer on match.",
      "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
    ],
    "testCases": [
      {
        "input": "s = \"abc\", t = \"ahbgdc\"",
        "output": "true"
      },
      {
        "input": "s = \"axc\", t = \"ahbgdc\"",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "i=0, j=0",
        "explanation": "Pointers."
      },
      {
        "step": 2,
        "title": "Match",
        "visual": "s[i]==t[j]? i++",
        "explanation": "Advance."
      },
      {
        "step": 3,
        "title": "Check",
        "visual": "i == len(s)?",
        "explanation": "Result."
      }
    ],
    "code": "class Solution:\n    def isSubsequence(self, s, t):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Is s a subsequence of t?\n        - \ud83e\udde0 Two pointers: advance s pointer on match.\n        - \ud83d\udca1 If s pointer reaches end, it's a subsequence.\n\n        Algorithm:\n        1. Init - Pointers.\n        2. Match - Advance.\n        3. Check - Result.\n        \"\"\"\n        i = 0\n        for c in t:  # Iterate over elements.\n            if i < len(s) and c == s[i]:\n                i += 1\n        return i == len(s)",
    "keyInsight": "Characters must appear in order but not necessarily contiguous.",
    "visualizationType": "array",
    "initialState": [
      "a",
      "h",
      "b",
      "g",
      "d",
      "c"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "s=\"abc\", t=\"ahbgdc\"",
        "transientMessage": "Two pointer approach",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "s[0]='a' == t[0]='a'",
        "transientMessage": "Match! Move both pointers",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "s",
            "index": 0
          },
          {
            "label": "t",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "s[1]='b' != t[1]='h'",
        "transientMessage": "No match, move t pointer",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "t",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "s[1]='b' == t[2]='b'",
        "transientMessage": "Match! Move both pointers",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "s",
            "index": 1
          },
          {
            "label": "t",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "s[2]='c' != t[3]='g'",
        "transientMessage": "No match, move t pointer",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "t",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "s[2]='c' != t[4]='d'",
        "transientMessage": "No match, move t pointer",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "t",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "s[2]='c' == t[5]='c'",
        "transientMessage": "Match! Move both pointers",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [
          {
            "label": "s",
            "index": 2
          },
          {
            "label": "t",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Result: true",
        "transientMessage": "All chars found!",
        "arrayState": [
          "a",
          "h",
          "b",
          "g",
          "d",
          "c"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use pointer for s, advance when char matches in t.\n\nIs s a subsequence of t?\nTwo pointers: advance s pointer on match.",
    "examples": [
      {
        "input": "s = \"abc\"; t = \"ahbgdc\"",
        "output": "true"
      },
      {
        "input": "s = \"axc\"; t = \"ahbgdc\"",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Is s a subsequence of t?",
      "Two pointers: advance s pointer on match.",
      "If s pointer reaches end, it's a subsequence."
    ],
    "relatedProblems": [
      "two-sum",
      "container-with-most-water",
      "3sum"
    ],
    "videoId": "99RVfqklbCE",
    "problemStatement": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Use pointer for s, advance when char matches in t.",
    "suggestedNextQuestion": {
      "slug": "linked-list-cycle",
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def isSubsequence(self, s, t):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def isSubsequence(s, t):\n    i, j = 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n    return i == len(s)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Is s a subsequence of t?",
          "\ud83e\udde0 Two pointers: advance s pointer on match.",
          "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
        ],
        "code": "def isSubsequence(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is s a subsequence of t?\n    - \ud83e\udde0 Two pointers: advance s pointer on match.\n    - \ud83d\udca1 If s pointer reaches end, it's a subsequence.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Match - Advance.\n    3. Check - Result.\n    \"\"\"\n    i = 0\n    for c in t:  # Iterate over elements.\n        if i < len(s) and c == s[i]:\n            i += 1\n    return i == len(s)"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isSubsequence(s, t) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s, t\n     * @return {any}\n     */\n    isSubsequence(s, t) {\n        if (s.length > t.length) return false;\n        let count = 0;\n        for (let i = 0; i < t.length; i++) {\n          if (s[count] === t[i]) {\n            count++;\n          }\n      }\n    return count === s.length;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int m = s.length(), n = t.length();\n        int i = 0, j = 0;\n        while (i < m && j < n) {\n            if (s.charAt(i) == t.charAt(j)) {\n                ++i;\n            }\n            ++j;\n        }\n        return i == m;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isSubsequence(string s, string t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int m = s.size(), n = t.size();\n        int i = 0, j = 0;\n        for (; i < m && j < n; ++j) {\n            if (s[i] == t[j]) {\n                ++i;\n            }\n        }\n        return i == m;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isSubsequence(s string, t string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isSubsequence(s string, t string) bool {\n\ti, j, m, n := 0, 0, len(s), len(t)\n\tfor i < m && j < n {\n\t\tif s[i] == t[j] {\n\t\t\ti++\n\t\t}\n\t\tj++\n\t}\n\treturn i == m\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_subsequence(s: String, t: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_subsequence(s: String, t: String) -> bool {\n        let (s, t) = (s.as_bytes(), t.as_bytes());\n        let n = t.len();\n        let mut i = 0;\n        for &c in s.iter() {\n            while i < n && t[i] != c {\n                i += 1;\n            }\n            if i == n {\n                return false;\n            }\n            i += 1;\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isSubsequence(self, s, t):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Is s a subsequence of t?\n        - \ud83e\udde0 Two pointers: advance s pointer on match.\n        - \ud83d\udca1 If s pointer reaches end, it's a subsequence.\n\n        Algorithm:\n        1. Init - Pointers.\n        2. Match - Advance.\n        3. Check - Result.\n        \"\"\"\n        i = 0\n        for c in t:  # Iterate over elements.\n            if i < len(s) and c == s[i]:\n                i += 1\n        return i == len(s)"
      },
      "typescript": {
        "code": "class Solution {\n    isSubsequence(s: string, t: string): boolean  {\n    const m = s.length;\n    const n = t.length;\n    let i = 0;\n    for (let j = 0; i < m && j < n; ++j) {\n        if (s[i] === t[j]) {\n            ++i;\n        }\n    }\n    return i === m;\n}\n}",
        "initialCode": "class Solution {\n    isSubsequence(s: string, t: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "container-with-most-water": {
    "title": "Container With Most Water",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udca7",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Two pointers from ends. Move the shorter one inward.",
    "intuition": [
      "\ud83c\udfaf Maximize water container area.",
      "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
      "\ud83d\udca1 Moving shorter line could find taller one."
    ],
    "testCases": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49"
      },
      {
        "input": "height = [1,1]",
        "output": "1"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "l=0, r=n-1",
        "explanation": "Max width."
      },
      {
        "step": 2,
        "title": "Area",
        "visual": "min * width",
        "explanation": "Calculate."
      },
      {
        "step": 3,
        "title": "Move",
        "visual": "Shorter side",
        "explanation": "Optimize."
      }
    ],
    "code": "class Solution:\n    def maxArea(self, height):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Maximize water container area.\n        - \ud83e\udde0 Area = min(height[l], height[r]) * (r - l).\n        - \ud83d\udca1 Moving shorter line could find taller one.\n\n        Algorithm:\n        1. Init - Max width.\n        2. Area - Calculate.\n        3. Move - Optimize.\n        \"\"\"\n        l, r = 0, len(height) - 1  # Initialize two pointers.\n        maxA = 0\n        while l < r:  # Continue until pointers meet.\n            area = min(height[l], height[r]) * (r - l)  # Take the minimum value.\n            maxA = max(maxA, area)  # Take the maximum value.\n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n        return maxA",
    "keyInsight": "Moving the taller line can never increase area (width decreases, height capped).",
    "visualizationType": "array",
    "initialState": [
      1,
      8,
      6,
      2,
      5,
      4,
      8,
      3,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [1, 8, 6, 2, 5, 4, 8, 3, 7]",
        "transientMessage": "Initialize left=0, right=8",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 8
          }
        ],
        "indices": [
          0,
          8
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "height=1, width=8, area=8",
        "transientMessage": "New max area: 8",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 8
          }
        ],
        "indices": [
          0,
          8
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "left[0]=1 < right[8]=7",
        "transientMessage": "Move left pointer right",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 8
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "height=8, width=7, area=49",
        "transientMessage": "New max area: 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 8
          }
        ],
        "indices": [
          1,
          8
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "left[1]=8 >= right[8]=7",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          7
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "height=8, width=6, area=18",
        "transientMessage": "Area 18 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 7
          }
        ],
        "indices": [
          1,
          7
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "left[1]=8 >= right[7]=3",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "height=8, width=5, area=40",
        "transientMessage": "Area 40 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          1,
          6
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "left[1]=8 >= right[6]=8",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "height=8, width=4, area=16",
        "transientMessage": "Area 16 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          1,
          5
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "left[1]=8 >= right[5]=4",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "height=8, width=3, area=15",
        "transientMessage": "Area 15 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 4
          }
        ],
        "indices": [
          1,
          4
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "left[1]=8 >= right[4]=5",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 14,
        "visual": "height=8, width=2, area=4",
        "transientMessage": "Area 4 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 3
          }
        ],
        "indices": [
          1,
          3
        ],
        "color": "accent"
      },
      {
        "step": 15,
        "visual": "left[1]=8 >= right[3]=2",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 16,
        "visual": "height=8, width=1, area=6",
        "transientMessage": "Area 6 < max 49",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 17,
        "visual": "left[1]=8 >= right[2]=6",
        "transientMessage": "Move right pointer left",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 18,
        "visual": "Result: 49",
        "transientMessage": "Pointers crossed - Maximum area found!",
        "arrayState": [
          1,
          8,
          6,
          2,
          5,
          4,
          8,
          3,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Two pointers from ends. Move the shorter one inward.\n\nMaximize water container area.\nArea = min(height[l], height[r]) * (r - l).",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49"
      },
      {
        "input": "height = [1,1]",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Maximize water container area.",
      "Area = min(height[l], height[r]) * (r - l).",
      "Moving shorter line could find taller one."
    ],
    "relatedProblems": [
      "two-sum",
      "3sum"
    ],
    "videoId": "UuiTKBwPgAo",
    "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Two pointers from ends. Move the shorter one inward.",
    "suggestedNextQuestion": {
      "slug": "find-the-duplicate-number",
      "title": "Find The Duplicate Number",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def maxArea(self, height):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def maxArea(height):\n    l, r = 0, len(height) - 1\n    res = 0\n    while l < r:\n        area = (r - l) * min(height[l], height[r])\n        res = max(res, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Maximize water container area.",
          "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
          "\ud83d\udca1 Moving shorter line could find taller one."
        ],
        "code": "def maxArea(height):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize water container area.\n    - \ud83e\udde0 Area = min(height[l], height[r]) * (r - l).\n    - \ud83d\udca1 Moving shorter line could find taller one.\n\n    Algorithm:\n    1. Init - Max width.\n    2. Area - Calculate.\n    3. Move - Optimize.\n    \"\"\"\n    l, r = 0, len(height) - 1  # Initialize two pointers.\n    maxA = 0\n    while l < r:  # Continue until pointers meet.\n        area = min(height[l], height[r]) * (r - l)  # Take the minimum value.\n        maxA = max(maxA, area)  # Take the maximum value.\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return maxA"
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxArea(height) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} height\n     * @return {any}\n     */\n    maxArea(height) {\n        let [l, r] = [0, height.length - 1];\n        let ans = 0;\n        while (l < r) {\n            const t = Math.min(height[l], height[r]) * (r - l);\n            ans = Math.max(ans, t);\n            if (height[l] < height[r]) {\n                ++l;\n            } else {\n                --r;\n            }\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxArea(int[] height) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxArea(int[] height) {\n        int l = 0, r = height.length - 1;\n        int ans = 0;\n        while (l < r) {\n            int t = Math.min(height[l], height[r]) * (r - l);\n            ans = Math.max(ans, t);\n            if (height[l] < height[r]) {\n                ++l;\n            } else {\n                --r;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxArea(vector<int>& height) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int l = 0, r = height.size() - 1;\n        int ans = 0;\n        while (l < r) {\n            int t = min(height[l], height[r]) * (r - l);\n            ans = max(ans, t);\n            if (height[l] < height[r]) {\n                ++l;\n            } else {\n                --r;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxArea(height []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxArea(height []int) (ans int) {\n\tl, r := 0, len(height)-1\n\tfor l < r {\n\t\tt := min(height[l], height[r]) * (r - l)\n\t\tans = max(ans, t)\n\t\tif height[l] < height[r] {\n\t\t\tl++\n\t\t} else {\n\t\t\tr--\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_area(height: Vec<i32>) -> i32 {\n        let mut l = 0;\n        let mut r = height.len() - 1;\n        let mut ans = 0;\n        while l < r {\n            ans = ans.max(height[l].min(height[r]) * ((r - l) as i32));\n            if height[l] < height[r] {\n                l += 1;\n            } else {\n                r -= 1;\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxArea(self, height):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxArea(height: number[]): number  {\n    let [l, r] = [0, height.length - 1];\n    let ans = 0;\n    while (l < r) {\n        const t = Math.min(height[l], height[r]) * (r - l);\n        ans = Math.max(ans, t);\n        if (height[l] < height[r]) {\n            ++l;\n        } else {\n            --r;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxArea(height: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "3sum": {
    "title": "3Sum",
    "pattern": "Two Pointers + Sort",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(1)",
    "oneliner": "Sort, fix one element, two-pointer for remaining two.",
    "intuition": [
      "\ud83c\udfaf Find all triplets summing to 0.",
      "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
      "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
    ],
    "testCases": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]"
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Sort",
        "visual": "[-4,-1,-1,0,1,2]",
        "explanation": "Order matters."
      },
      {
        "step": 2,
        "title": "Fix",
        "visual": "i = 0",
        "explanation": "First element."
      },
      {
        "step": 3,
        "title": "Two Ptr",
        "visual": "l, r narrow",
        "explanation": "Find complement."
      }
    ],
    "code": "class Solution:\n    def threeSum(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find all triplets summing to 0.\n        - \ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].\n        - \ud83d\udca1 Skip duplicates to avoid duplicate triplets.\n\n        Algorithm:\n        1. Sort - Order matters.\n        2. Fix - First element.\n        3. Two Ptr - Find complement.\n        \"\"\"\n        nums.sort()\n        res = []  # Initialize list to store results.\n        for i in range(len(nums) - 2):  # Iterate through the range.\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            l, r = i + 1, len(nums) - 1  # Initialize two pointers.\n            while l < r:  # Continue until pointers meet.\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])  # Add to end.\n                    while l < r and nums[l] == nums[l + 1]: l += 1\n                    while l < r and nums[r] == nums[r - 1]: r -= 1\n                    l, r = l + 1, r - 1  # Initialize two pointers.\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res  # Return the final result.",
    "keyInsight": "Sorting enables two-pointer approach and duplicate skipping.",
    "visualizationType": "array",
    "initialState": [
      -1,
      0,
      1,
      2,
      -1,
      -4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [-1, 0, 1, 2, -1, -4]",
        "transientMessage": "Initialize left=0, right=5",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          5
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Fix arr[0]=-1, left=1, right=5",
        "transientMessage": "Start two-pointer search",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          1,
          5
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "-1 + 0 + -4 = -5",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          1,
          5
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "-1 + 1 + -4 = -4",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          2,
          5
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "-1 + 2 + -4 = -3",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          3,
          5
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "-1 + -1 + -4 = -6",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          },
          {
            "label": "L",
            "index": 4
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          4,
          5
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Fix arr[1]=0, left=2, right=5",
        "transientMessage": "Start two-pointer search",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          1,
          2,
          5
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "0 + 1 + -4 = -3",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "L",
            "index": 2
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          1,
          2,
          5
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "0 + 2 + -4 = -2",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          1,
          3,
          5
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "0 + -1 + -4 = -5",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "L",
            "index": 4
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          1,
          4,
          5
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Fix arr[2]=1, left=3, right=5",
        "transientMessage": "Start two-pointer search",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          },
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          2,
          3,
          5
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "1 + 2 + -4 = -1",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          },
          {
            "label": "L",
            "index": 3
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          2,
          3,
          5
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "1 + -1 + -4 = -4",
        "transientMessage": "Sum < 0, move left right",
        "arrayState": [
          -1,
          0,
          1,
          2,
          -1,
          -4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          },
          {
            "label": "L",
            "index": 4
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          2,
          4,
          5
        ],
        "color": "accent"
      }
    ],
    "description": "Sort, fix one element, two-pointer for remaining two.\n\nFind all triplets summing to 0.\nSort array. For each i, use two pointers on [i+1, n-1].",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]"
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find all triplets summing to 0.",
      "Sort array. For each i, use two pointers on [i+1, n-1].",
      "Skip duplicates to avoid duplicate triplets."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "jzZsG8n2R9A",
    "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Pointers + Sort: Sort, fix one element, two-pointer for remaining two.",
    "suggestedNextQuestion": {
      "slug": "container-with-most-water",
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def threeSum(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def threeSum(nums):\n    res = []\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0:\n                l += 1\n            elif s > 0:\n                r -= 1\n            else:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]:\n                    l += 1\n                while l < r and nums[r] == nums[r-1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find all triplets summing to 0.",
          "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
          "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
        ],
        "code": "def threeSum(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all triplets summing to 0.\n    - \ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].\n    - \ud83d\udca1 Skip duplicates to avoid duplicate triplets.\n\n    Algorithm:\n    1. Sort - Order matters.\n    2. Fix - First element.\n    3. Two Ptr - Find complement.\n    \"\"\"\n    nums.sort()\n    res = []  # Initialize list to store results.\n    for i in range(len(nums) - 2):  # Iterate through the range.\n        if i > 0 and nums[i] == nums[i - 1]: continue\n        l, r = i + 1, len(nums) - 1  # Initialize two pointers.\n        while l < r:  # Continue until pointers meet.\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])  # Add to end.\n                while l < r and nums[l] == nums[l + 1]: l += 1\n                while l < r and nums[r] == nums[r - 1]: r -= 1\n                l, r = l + 1, r - 1  # Initialize two pointers.\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    threeSum(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    threeSum(nums) {\n        const n = nums.length;\n        nums.sort((a, b) => a - b);\n        const ans = [];\n        for (let i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n            if (i > 0 && nums[i] === nums[i - 1]) {\n                continue;\n            }\n            let j = i + 1;\n            let k = n - 1;\n            while (j < k) {\n                const x = nums[i] + nums[j] + nums[k];\n                if (x < 0) {\n                    ++j;\n                } else if (x > 0) {\n                    --k;\n                } else {\n                    ans.push([nums[i], nums[j++], nums[k--]]);\n                    while (j < k && nums[j] === nums[j - 1]) {\n                        ++j;\n                    }\n                    while (j < k && nums[k] === nums[k + 1]) {\n                        --k;\n                    }\n                }\n            }\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = nums.length;\n        for (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int x = nums[i] + nums[j] + nums[k];\n                if (x < 0) {\n                    ++j;\n                } else if (x > 0) {\n                    --k;\n                } else {\n                    ans.add(List.of(nums[i], nums[j++], nums[k--]));\n                    while (j < k && nums[j] == nums[j - 1]) {\n                        ++j;\n                    }\n                    while (j < k && nums[k] == nums[k + 1]) {\n                        --k;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> ans;\n        int n = nums.size();\n        for (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n            if (i && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int x = nums[i] + nums[j] + nums[k];\n                if (x < 0) {\n                    ++j;\n                } else if (x > 0) {\n                    --k;\n                } else {\n                    ans.push_back({nums[i], nums[j++], nums[k--]});\n                    while (j < k && nums[j] == nums[j - 1]) {\n                        ++j;\n                    }\n                    while (j < k && nums[k] == nums[k + 1]) {\n                        --k;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) threeSum(nums []int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) threeSum(nums []int) (ans [][]int) {\n\tsort.Ints(nums)\n\tn := len(nums)\n\tfor i := 0; i < n-2 && nums[i] <= 0; i++ {\n\t\tif i > 0 && nums[i] == nums[i-1] {\n\t\t\tcontinue\n\t\t}\n\t\tj, k := i+1, n-1\n\t\tfor j < k {\n\t\t\tx := nums[i] + nums[j] + nums[k]\n\t\t\tif x < 0 {\n\t\t\t\tj++\n\t\t\t} else if x > 0 {\n\t\t\t\tk--\n\t\t\t} else {\n\t\t\t\tans = append(ans, []int{nums[i], nums[j], nums[k]})\n\t\t\t\tj, k = j+1, k-1\n\t\t\t\tfor j < k && nums[j] == nums[j-1] {\n\t\t\t\t\tj++\n\t\t\t\t}\n\t\t\t\tfor j < k && nums[k] == nums[k+1] {\n\t\t\t\t\tk--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::cmp::Ordering;\n\nimpl Solution {\n    pub fn three_sum(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\n        nums.sort();\n        let n = nums.len();\n        let mut res = vec![];\n        let mut i = 0;\n        while i < n - 2 && nums[i] <= 0 {\n            let mut l = i + 1;\n            let mut r = n - 1;\n            while l < r {\n                match (nums[i] + nums[l] + nums[r]).cmp(&0) {\n                    Ordering::Less => {\n                        l += 1;\n                    }\n                    Ordering::Greater => {\n                        r -= 1;\n                    }\n                    Ordering::Equal => {\n                        res.push(vec![nums[i], nums[l], nums[r]]);\n                        l += 1;\n                        r -= 1;\n                        while l < n && nums[l] == nums[l - 1] {\n                            l += 1;\n                        }\n                        while r > 0 && nums[r] == nums[r + 1] {\n                            r -= 1;\n                        }\n                    }\n                }\n            }\n            i += 1;\n            while i < n - 2 && nums[i] == nums[i - 1] {\n                i += 1;\n            }\n        }\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def threeSum(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    threeSum(nums: number[]): number[][]  {\n    nums.sort((a, b) => a - b);\n    const ans: number[][] = [];\n    const n = nums.length;\n    for (let i = 0; i < n - 2 && nums[i] <= 0; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        let j = i + 1;\n        let k = n - 1;\n        while (j < k) {\n            const x = nums[i] + nums[j] + nums[k];\n            if (x < 0) {\n                ++j;\n            } else if (x > 0) {\n                --k;\n            } else {\n                ans.push([nums[i], nums[j++], nums[k--]]);\n                while (j < k && nums[j] === nums[j - 1]) {\n                    ++j;\n                }\n                while (j < k && nums[k] === nums[k + 1]) {\n                    --k;\n                }\n            }\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    threeSum(nums: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "squares-of-a-sorted-array": {
    "title": "Squares of a Sorted Array",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udcd0",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Compare absolute values at ends, place larger square at end of result.",
    "intuition": [
      "\ud83c\udfaf Square each element, return sorted array.",
      "\ud83e\udde0 Largest squares at ends (negative or positive).",
      "\ud83d\udca1 Two pointers from ends, fill result from back."
    ],
    "testCases": [
      {
        "input": "nums = [-4,-1,0,3,10]",
        "output": "[0,1,9,16,100]"
      },
      {
        "input": "nums = [-7,-3,2,3,11]",
        "output": "[4,9,9,49,121]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Init",
        "visual": "l=0, r=n-1, pos=n-1",
        "explanation": "Pointers."
      },
      {
        "step": 2,
        "title": "Compare",
        "visual": "|nums[l]| vs |nums[r]|",
        "explanation": "Larger abs."
      },
      {
        "step": 3,
        "title": "Fill",
        "visual": "res[pos] = square",
        "explanation": "From back."
      }
    ],
    "code": "class Solution:\n    def sortedSquares(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Square each element, return sorted array.\n        - \ud83e\udde0 Largest squares at ends (negative or positive).\n        - \ud83d\udca1 Two pointers from ends, fill result from back.\n\n        Algorithm:\n        1. Init - Pointers.\n        2. Compare - Larger abs.\n        3. Fill - From back.\n        \"\"\"\n        n = len(nums)\n        res = [0] * n\n        l, r = 0, n - 1  # Initialize two pointers.\n        pos = n - 1\n        while l <= r:\n            if abs(nums[l]) > abs(nums[r]):\n                res[pos] = nums[l] ** 2\n                l += 1\n            else:\n                res[pos] = nums[r] ** 2\n                r -= 1\n            pos -= 1\n        return res  # Return the final result.",
    "keyInsight": "The largest absolute value is always at one of the ends.",
    "visualizationType": "array",
    "initialState": [
      -4,
      -1,
      0,
      3,
      10
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Squares of a Sorted Array",
        "transientMessage": "Input: [-4, -1, 0, 3, 10]",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: -4",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: -1",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 0",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 3",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 10",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          -4,
          -1,
          0,
          3,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Compare absolute values at ends, place larger square at end of result.\n\nSquare each element, return sorted array.\nLargest squares at ends (negative or positive).",
    "examples": [
      {
        "input": "nums = [-4,-1,0,3,10]",
        "output": "[0,1,9,16,100]"
      },
      {
        "input": "nums = [-7,-3,2,3,11]",
        "output": "[4,9,9,49,121]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Square each element, return sorted array.",
      "Largest squares at ends (negative or positive).",
      "Two pointers from ends, fill result from back."
    ],
    "relatedProblems": [
      "two-sum",
      "container-with-most-water",
      "3sum"
    ],
    "videoId": "FPCZsG_AkUg",
    "problemStatement": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Compare absolute values at ends, place larger square at end of result.",
    "suggestedNextQuestion": {
      "slug": "time-needed-to-buy-tickets",
      "title": "Time Needed to Buy Tickets",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def sortedSquares(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def sortedSquares(nums):\n    return sorted(x*x for x in nums)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Square each element, return sorted array.",
          "\ud83e\udde0 Largest squares at ends (negative or positive).",
          "\ud83d\udca1 Two pointers from ends, fill result from back."
        ],
        "code": "def sortedSquares(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Square each element, return sorted array.\n    - \ud83e\udde0 Largest squares at ends (negative or positive).\n    - \ud83d\udca1 Two pointers from ends, fill result from back.\n\n    Algorithm:\n    1. Init - Pointers.\n    2. Compare - Larger abs.\n    3. Fill - From back.\n    \"\"\"\n    n = len(nums)\n    res = [0] * n\n    l, r = 0, n - 1  # Initialize two pointers.\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            res[pos] = nums[l] ** 2\n            l += 1\n        else:\n            res[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    sortedSquares(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    sortedSquares(nums) {\n        const n = nums.length;\n        const ans = Array(n).fill(0);\n        for (let i = 0, j = n - 1, k = n - 1; i <= j; --k) {\n            const [a, b] = [nums[i] * nums[i], nums[j] * nums[j]];\n            if (a > b) {\n                ans[k] = a;\n                ++i;\n            } else {\n                ans[k] = b;\n                --j;\n            }\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0, j = n - 1, k = n - 1; i <= j; --k) {\n            int a = nums[i] * nums[i];\n            int b = nums[j] * nums[j];\n            if (a > b) {\n                ans[k] = a;\n                ++i;\n            } else {\n                ans[k] = b;\n                --j;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> sortedSquares(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0, j = n - 1, k = n - 1; i <= j; --k) {\n            int a = nums[i] * nums[i];\n            int b = nums[j] * nums[j];\n            if (a > b) {\n                ans[k] = a;\n                ++i;\n            } else {\n                ans[k] = b;\n                --j;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) sortedSquares(nums []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) sortedSquares(nums []int) []int {\n\tn := len(nums)\n\tans := make([]int, n)\n\tfor i, j, k := 0, n-1, n-1; i <= j; k-- {\n\t\ta := nums[i] * nums[i]\n\t\tb := nums[j] * nums[j]\n\t\tif a > b {\n\t\t\tans[k] = a\n\t\t\ti++\n\t\t} else {\n\t\t\tans[k] = b\n\t\t\tj--\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\n        let n = nums.len();\n        let mut ans = vec![0; n];\n        let (mut i, mut j) = (0, n - 1);\n        for k in (0..n).rev() {\n            let a = nums[i] * nums[i];\n            let b = nums[j] * nums[j];\n            if a > b {\n                ans[k] = a;\n                i += 1;\n            } else {\n                ans[k] = b;\n                j -= 1;\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def sortedSquares(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    sortedSquares(nums: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    sortedSquares(nums: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "longest-mountain-in-array": {
    "title": "Longest Mountain in Array",
    "pattern": "Two Pointers / Expand",
    "patternEmoji": "\ud83c\udfd4\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
    "intuition": [
      "\ud83c\udfaf Find longest mountain subarray (up then down).",
      "\ud83e\udde0 At each peak, extend left and right.",
      "\ud83d\udca1 Mountain needs at least 3 elements."
    ],
    "testCases": [
      {
        "input": "arr = [2,1,4,7,3,2,5]",
        "output": "5"
      },
      {
        "input": "arr = [2,2,2]",
        "output": "0"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Find Peak",
        "visual": "arr[i-1] < arr[i] > arr[i+1]",
        "explanation": "Locate."
      },
      {
        "step": 2,
        "title": "Expand",
        "visual": "Left and right",
        "explanation": "Extend."
      },
      {
        "step": 3,
        "title": "Length",
        "visual": "right - left + 1",
        "explanation": "Calculate."
      }
    ],
    "code": "class Solution:\n    def longestMountain(self, arr):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find longest mountain subarray (up then down).\n        - \ud83e\udde0 At each peak, extend left and right.\n        - \ud83d\udca1 Mountain needs at least 3 elements.\n\n        Algorithm:\n        1. Find Peak - Locate.\n        2. Expand - Extend.\n        3. Length - Calculate.\n        \"\"\"\n        n = len(arr)\n        res = 0  # Initialize result variable.\n        i = 1\n        while i < n - 1:\n            if arr[i - 1] < arr[i] > arr[i + 1]:\n                l = i - 1\n                while l > 0 and arr[l - 1] < arr[l]: l -= 1\n                r = i + 1\n                while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n                res = max(res, r - l + 1)  # Take the maximum value.\n                i = r\n            else:\n                i += 1\n        return res  # Return the final result.",
    "keyInsight": "After finding a mountain, skip to the end of the downhill.",
    "visualizationType": "array",
    "initialState": [
      2,
      1,
      4,
      7,
      3,
      2,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Mountain in Array",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          2,
          1,
          4,
          7,
          3,
          2,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 2",
        "arrayState": [
          2,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 1",
        "arrayState": [
          2,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          1,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 4",
        "arrayState": [
          2,
          1,
          4,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          2,
          1,
          4,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 7",
        "arrayState": [
          2,
          1,
          4,
          7,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          2,
          1,
          4,
          7,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 3",
        "arrayState": [
          2,
          1,
          4,
          7,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          2,
          1,
          4,
          7,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          2,
          1,
          4,
          7,
          3,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          1,
          4,
          7,
          3,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).\n\nFind longest mountain subarray (up then down).\nAt each peak, extend left and right.",
    "examples": [
      {
        "input": "arr = [2,1,4,7,3,2,5]",
        "output": "5"
      },
      {
        "input": "arr = [2,2,2]",
        "output": "0"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find longest mountain subarray (up then down).",
      "At each peak, extend left and right.",
      "Mountain needs at least 3 elements."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "rh2Bkul2zzQ",
    "problemStatement": "You may recall that an array arr is a mountain array if and only if:\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Pointers / Expand: Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
    "suggestedNextQuestion": {
      "slug": "meeting-rooms-ii",
      "title": "Meeting Rooms II",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def longestMountain(self, arr):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def longestMountain(arr):\n    res = 0\n    up = down = 0\n    for i in range(1, len(arr)):\n        if down and arr[i-1] < arr[i] or arr[i-1] == arr[i]:\n            up = down = 0\n        if arr[i-1] < arr[i]:\n            up += 1\n        if arr[i-1] > arr[i]:\n            down += 1\n        if up and down:\n            res = max(res, up + down + 1)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find longest mountain subarray (up then down).",
          "\ud83e\udde0 At each peak, extend left and right.",
          "\ud83d\udca1 Mountain needs at least 3 elements."
        ],
        "code": "def longestMountain(arr):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest mountain subarray (up then down).\n    - \ud83e\udde0 At each peak, extend left and right.\n    - \ud83d\udca1 Mountain needs at least 3 elements.\n\n    Algorithm:\n    1. Find Peak - Locate.\n    2. Expand - Extend.\n    3. Length - Calculate.\n    \"\"\"\n    n = len(arr)\n    res = 0  # Initialize result variable.\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            l = i - 1\n            while l > 0 and arr[l - 1] < arr[l]: l -= 1\n            r = i + 1\n            while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n            res = max(res, r - l + 1)  # Take the maximum value.\n            i = r\n        else:\n            i += 1\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    longestMountain(arr) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} arr\n     * @return {any}\n     */\n    longestMountain(arr) {\n        const n = arr.length;\n        if (n < 3) return 0;\n\n        let maxLength = 0;\n        let i = 1;\n\n        while (i < n - 1) {\n          const isPeak = arr[i] > arr[i - 1] && arr[i] > arr[i + 1];\n          if (!isPeak) {\n            i++;\n            continue;\n          }\n          let leftBound = i - 1;\n          while (leftBound > 0 && arr[leftBound - 1] < arr[leftBound]) {\n            leftBound--;\n          }\n          let rightBound = i + 1;\n          while (rightBound < n - 1 && arr[rightBound] > arr[rightBound + 1]) {\n            rightBound++;\n          }\n          const mountainLength = rightBound - leftBound + 1;\n          maxLength = Math.max(maxLength, mountainLength);\n          i = rightBound + 1;\n      }\n\n    return maxLength;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int longestMountain(int[] arr) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int longestMountain(int[] arr) {\n        int n = arr.length;\n        int[] f = new int[n];\n        int[] g = new int[n];\n        Arrays.fill(f, 1);\n        Arrays.fill(g, 1);\n        for (int i = 1; i < n; ++i) {\n            if (arr[i] > arr[i - 1]) {\n                f[i] = f[i - 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = n - 2; i >= 0; --i) {\n            if (arr[i] > arr[i + 1]) {\n                g[i] = g[i + 1] + 1;\n                if (f[i] > 1) {\n                    ans = Math.max(ans, f[i] + g[i] - 1);\n                }\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int longestMountain(vector<int>& arr) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int longestMountain(vector<int>& arr) {\n        int n = arr.size();\n        int f[n];\n        int g[n];\n        fill(f, f + n, 1);\n        fill(g, g + n, 1);\n        for (int i = 1; i < n; ++i) {\n            if (arr[i] > arr[i - 1]) {\n                f[i] = f[i - 1] + 1;\n            }\n        }\n        int ans = 0;\n        for (int i = n - 2; ~i; --i) {\n            if (arr[i] > arr[i + 1]) {\n                g[i] = g[i + 1] + 1;\n                if (f[i] > 1) {\n                    ans = max(ans, f[i] + g[i] - 1);\n                }\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestMountain(arr []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestMountain(arr []int) (ans int) {\n\tn := len(arr)\n\tf := make([]int, n)\n\tg := make([]int, n)\n\tfor i := range f {\n\t\tf[i] = 1\n\t\tg[i] = 1\n\t}\n\tfor i := 1; i < n; i++ {\n\t\tif arr[i] > arr[i-1] {\n\t\t\tf[i] = f[i-1] + 1\n\t\t}\n\t}\n\tfor i := n - 2; i >= 0; i-- {\n\t\tif arr[i] > arr[i+1] {\n\t\t\tg[i] = g[i+1] + 1\n\t\t\tif f[i] > 1 {\n\t\t\t\tans = max(ans, f[i]+g[i]-1)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_mountain(arr: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn longest_mountain(a: Vec<i32>) -> i32 {\n        let n = a.len();\n        if n == 0 {\n            return 0;\n        }\n        let mut left = vec![0; n];\n        let mut right = vec![0; n];\n        for i in 1..n {\n            if a[i] > a[i - 1] {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        for i in (0..n - 1).rev() {\n            if a[i] > a[i + 1] {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        let mut res = 0;\n        for i in 0..n {\n            if left[i] > 0 && right[i] > 0 {\n                res = res.max(left[i] + right[i] + 1);\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![2, 1, 4, 7, 3, 2, 5];\n    let res = 5;\n    assert_eq!(Solution::longest_mountain(a), res);\n    let a = vec![2, 2, 2];\n    let res = 0;\n    assert_eq!(Solution::longest_mountain(a), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def longestMountain(self, arr):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    longestMountain(arr: number[]): number  {\n    const n = arr.length;\n    const f: number[] = Array(n).fill(1);\n    const g: number[] = Array(n).fill(1);\n    for (let i = 1; i < n; ++i) {\n        if (arr[i] > arr[i - 1]) {\n            f[i] = f[i - 1] + 1;\n        }\n    }\n    let ans = 0;\n    for (let i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[i + 1]) {\n            g[i] = g[i + 1] + 1;\n            if (f[i] > 1) {\n                ans = Math.max(ans, f[i] + g[i] - 1);\n            }\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    longestMountain(arr: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "delete-node-in-a-bst": {
    "title": "Delete Node in a BST",
    "pattern": "BST Traversal",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(h)",
    "oneliner": "Find node, replace with successor (leftmost in right subtree).",
    "intuition": [
      "\ud83c\udfaf Delete node with given key from BST.",
      "\ud83e\udde0 Three cases: leaf, one child, two children.",
      "\ud83d\udca1 Two children: replace with inorder successor."
    ],
    "testCases": [
      {
        "input": "root = [5,3,6,2,4,null,7], key = 3",
        "output": "[5,4,6,2,null,null,7]"
      },
      {
        "input": "root = [5,3,6,2,4,null,7], key = 0",
        "output": "[5,3,6,2,4,null,7]"
      },
      {
        "input": "root = [], key = 0",
        "output": "[]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Find",
        "visual": "BST search",
        "explanation": "Locate node."
      },
      {
        "step": 2,
        "title": "Delete",
        "visual": "Handle cases",
        "explanation": "Remove."
      },
      {
        "step": 3,
        "title": "Replace",
        "visual": "Successor",
        "explanation": "Maintain BST."
      }
    ],
    "code": "class Solution:\n    def deleteNode(self, root, key):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Delete node with given key from BST.\n        - \ud83e\udde0 Three cases: leaf, one child, two children.\n        - \ud83d\udca1 Two children: replace with inorder successor.\n\n        Algorithm:\n        1. Find - Locate node.\n        2. Delete - Remove.\n        3. Replace - Maintain BST.\n        \"\"\"\n        if not root: return None  # Base case: Check if tree is empty.\n        if key < root.val:\n            root.left = deleteNode(root.left, key)\n        elif key > root.val:\n            root.right = deleteNode(root.right, key)\n        else:\n            if not root.left: return root.right\n            if not root.right: return root.left\n            # Find successor\n            succ = root.right\n            while succ.left: succ = succ.left\n            root.val = succ.val\n            root.right = deleteNode(root.right, succ.val)\n        return root",
    "keyInsight": "The successor is the leftmost node in the right subtree.",
    "visualizationType": "tree",
    "initialState": [
      5,
      3,
      6,
      2,
      4,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Delete Node in a BST",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Find node, replace with successor (leftmost in right subtree).\n\nDelete node with given key from BST.\nThree cases: leaf, one child, two children.",
    "examples": [
      {
        "input": "root = [5,3,6,2,4,null,7]; key = 3",
        "output": "[5,4,6,2,null,null,7]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Delete node with given key from BST.",
      "Three cases: leaf, one child, two children.",
      "Two children: replace with inorder successor."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "LFzAoJJt92M",
    "problemStatement": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BST Traversal: Find node, replace with successor (leftmost in right subtree).",
    "suggestedNextQuestion": {
      "slug": "flatten-binary-tree-to-linked-list",
      "title": "Flatten Binary Tree to Linked List",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def deleteNode(self, root, key):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def deleteNode(root, key):\n    if not root: return None\n    if key > root.val:\n        root.right = deleteNode(root.right, key)\n    elif key < root.val:\n        root.left = deleteNode(root.left, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Min from right subtree\n        curr = root.right\n        while curr.left:\n            curr = curr.left\n        root.val = curr.val\n        root.right = deleteNode(root.right, root.val)\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Delete node with given key from BST.",
          "\ud83e\udde0 Three cases: leaf, one child, two children.",
          "\ud83d\udca1 Two children: replace with inorder successor."
        ],
        "code": "def deleteNode(root, key):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Delete node with given key from BST.\n    - \ud83e\udde0 Three cases: leaf, one child, two children.\n    - \ud83d\udca1 Two children: replace with inorder successor.\n\n    Algorithm:\n    1. Find - Locate node.\n    2. Delete - Remove.\n    3. Replace - Maintain BST.\n    \"\"\"\n    if not root: return None  # Base case: Check if tree is empty.\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Find successor\n        succ = root.right\n        while succ.left: succ = succ.left\n        root.val = succ.val\n        root.right = deleteNode(root.right, succ.val)\n    return root"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // Constructor implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) deleteNode(root *TreeNode, key int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) deleteNode(root *TreeNode, key int) *TreeNode {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tif root.Val > key {\n\t\troot.Left = deleteNode(root.Left, key)\n\t\treturn root\n\t}\n\tif root.Val < key {\n\t\troot.Right = deleteNode(root.Right, key)\n\t\treturn root\n\t}\n\tif root.Left == nil {\n\t\treturn root.Right\n\t}\n\tif root.Right == nil {\n\t\treturn root.Left\n\t}\n\tnode := root.Right\n\tfor node.Left != nil {\n\t\tnode = node.Left\n\t}\n\tnode.Left = root.Left\n\troot = root.Right\n\treturn root\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let node = root.as_ref().unwrap().borrow();\n        if node.left.is_none() {\n            return node.val;\n        }\n        Self::dfs(&node.left)\n    }\n\n    pub fn delete_node(\n        mut root: Option<Rc<RefCell<TreeNode>>>,\n        key: i32,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if root.is_some() {\n            let mut node = root.as_mut().unwrap().borrow_mut();\n            match node.val.cmp(&key) {\n                std::cmp::Ordering::Less => {\n                    node.right = Self::delete_node(node.right.take(), key);\n                }\n                std::cmp::Ordering::Greater => {\n                    node.left = Self::delete_node(node.left.take(), key);\n                }\n                std::cmp::Ordering::Equal => {\n                    match (node.left.is_some(), node.right.is_some()) {\n                        (false, false) => {\n                            return None;\n                        }\n                        (true, false) => {\n                            return node.left.take();\n                        }\n                        (false, true) => {\n                            return node.right.take();\n                        }\n                        (true, true) => {\n                            if node.right.as_ref().unwrap().borrow().left.is_none() {\n                                let mut r = node.right.take();\n                                r.as_mut().unwrap().borrow_mut().left = node.left.take();\n                                return r;\n                            } else {\n                                let val = Self::dfs(&node.right);\n                                node.val = val;\n                                node.right = Self::delete_node(node.right.take(), val);\n                            }\n                        }\n                    };\n                }\n            }\n        }\n        root\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def deleteNode(self, root, key):\n        pass\n"
      },
      "typescript": {
        "code": "class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val)\n        this.left = (left===undefined ? null : left)\n        this.right = (right===undefined ? null : right)\n    }\n}\n\nclass Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n\n    deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "insert-into-a-binary-search-tree": {
    "title": "Insert into a Binary Search Tree",
    "videoUrl": "https://www.youtube.com/watch?v=K0Yl_uI-H0w",
    "pattern": "BST Traversal",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(h)",
    "oneliner": "Navigate BST, insert at null position.",
    "intuition": [
      "\ud83c\udfaf Insert value into BST maintaining property.",
      "\ud83e\udde0 Go left if val < root, right otherwise.",
      "\ud83d\udca1 Insert at the first null spot found."
    ],
    "testCases": [
      {
        "input": "root = [4,2,7,1,3], val = 5",
        "output": "[4,2,7,1,3,5]"
      },
      {
        "input": "root = [40,20,60,10,30,50,70], val = 25",
        "output": "[40,20,60,10,30,50,70,null,null,25]"
      },
      {
        "input": "root = [4,2,7,1,3,null,null,null,null,null,null], val = 5",
        "output": "[4,2,7,1,3,5]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Navigate",
        "visual": "Compare values",
        "explanation": "BST property."
      },
      {
        "step": 2,
        "title": "Insert",
        "visual": "At null",
        "explanation": "Add node."
      },
      {
        "step": 3,
        "title": "Return",
        "visual": "Root",
        "explanation": "Done."
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Insert value into BST maintaining property.\n        - \ud83e\udde0 Go left if val < root, right otherwise.\n        - \ud83d\udca1 Insert at the first null spot found.\n    \n        Algorithm:\n        1. Navigate - BST property.\n        2. Insert - Add node.\n        3. Return - Done.\n        \"\"\"\n        if not root: return TreeNode(val)  # Base case: Check if tree is empty.\n        if val < root.val:\n            root.left = insertIntoBST(root.left, val)\n        else:\n            root.right = insertIntoBST(root.right, val)\n        return root",
    "keyInsight": "Always insert as a leaf node at the correct position.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Insert into a Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Navigate BST, insert at null position.\n\nInsert value into BST maintaining property.\nGo left if val < root, right otherwise.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3]; val = 5",
        "output": "[4,2,7,1,3,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Insert value into BST maintaining property.",
      "Go left if val < root, right otherwise.",
      "Insert at the first null spot found."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Cpg8f79luEA",
    "problemStatement": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BST Traversal: Navigate BST, insert at null position.",
    "suggestedNextQuestion": {
      "slug": "kth-smallest-element-in-a-bst",
      "title": "Kth Smallest Element in a BST",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def insertIntoBST(root, val):\n    if not root:\n        return TreeNode(val)\n    if val > root.val:\n        root.right = insertIntoBST(root.right, val)\n    else:\n        root.left = insertIntoBST(root.left, val)\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Insert value into BST maintaining property.",
          "\ud83e\udde0 Go left if val < root, right otherwise.",
          "\ud83d\udca1 Insert at the first null spot found."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef insertIntoBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert value into BST maintaining property.\n    - \ud83e\udde0 Go left if val < root, right otherwise.\n    - \ud83d\udca1 Insert at the first null spot found.\n\n    Algorithm:\n    1. Navigate - BST property.\n    2. Insert - Add node.\n    3. Return - Done.\n    \"\"\"\n    if not root: return TreeNode(val)  # Base case: Check if tree is empty.\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        this.root = root;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) insertIntoBST(root *TreeNode, val int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) insertIntoBST(root *TreeNode, val int) *TreeNode {\n\tif root == nil {\n\t\treturn &TreeNode{Val: val}\n\t}\n\tif root.Val > val {\n\t\troot.Left = insertIntoBST(root.Left, val)\n\t} else {\n\t\troot.Right = insertIntoBST(root.Right, val)\n\t}\n\treturn root\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\ntrait Postorder {\n    fn insert(self, val: i32) -> Self;\n}\n\nimpl Postorder for TreeLink {\n    fn insert(self, val: i32) -> Self {\n        if let Some(node) = self {\n            let node_val = node.borrow().val;\n            let left = node.borrow_mut().left.take();\n            let right = node.borrow_mut().right.take();\n            if node_val < val {\n                tree!(node_val, left, right.insert(val))\n            } else {\n                tree!(node_val, left.insert(val), right)\n            }\n        } else {\n            tree!(val)\n        }\n    }\n}\n\nimpl Solution {\n    fn insert_into_bst(root: TreeLink, val: i32) -> TreeLink {\n        root.insert(val)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(4, tree!(2, tree!(1), tree!(3)), tree!(7));\n    let val = 5;\n    let res = tree!(4, tree!(2, tree!(1), tree!(3)), tree!(7, tree!(5), None));\n    assert_eq!(Solution::insert_into_bst(root, val), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Constructor implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "palindrome-linked-list": {
    "title": "Palindrome Linked List",
    "pattern": "Fast/Slow + Reverse",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Find middle, reverse second half, compare.",
    "intuition": [
      "\ud83c\udfaf Check if linked list is a palindrome.",
      "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
      "\ud83d\udca1 Compare first and second halves."
    ],
    "testCases": [
      {
        "input": "head = [1,2,2,1]",
        "output": "true"
      },
      {
        "input": "head = [1,2]",
        "output": "false"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Middle",
        "visual": "Slow at center",
        "explanation": "Fast/slow."
      },
      {
        "step": 2,
        "title": "Reverse",
        "visual": "Flip second half",
        "explanation": "In-place."
      },
      {
        "step": 3,
        "title": "Compare",
        "visual": "Match values",
        "explanation": "Check."
      }
    ],
    "code": "class Solution:\n    def isPalindrome(self, head):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Check if linked list is a palindrome.\n        - \ud83e\udde0 Fast/slow to find middle, reverse second half.\n        - \ud83d\udca1 Compare first and second halves.\n\n        Algorithm:\n        1. Middle - Fast/slow.\n        2. Reverse - In-place.\n        3. Compare - Check.\n        \"\"\"\n        slow = fast = head  # Initialize cycle detection pointers.\n        while fast and fast.next:  # Traverse until end of list.\n            slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n        # Reverse second half\n        prev = None\n        while slow:\n            slow.next, prev, slow = prev, slow, slow.next\n        # Compare\n        while prev:\n            if head.val != prev.val:\n                return False  # Condition not met.\n            head, prev = head.next, prev.next\n        return True  # Condition satisfied.",
    "keyInsight": "O(1) space by reversing half in-place rather than using a stack.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      2,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Palindrome Linked List",
        "transientMessage": "Input: [1, 2, 2, 1]",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 4",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 4",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 2",
        "transientMessage": "Step 3 of 4",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 1",
        "transientMessage": "Step 4 of 4",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          2,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Find middle, reverse second half, compare.\n\nCheck if linked list is a palindrome.\nFast/slow to find middle, reverse second half.",
    "examples": [
      {
        "input": "head = [1,2,2,1]",
        "output": "true"
      },
      {
        "input": "head = [1,2]",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Check if linked list is a palindrome.",
      "Fast/slow to find middle, reverse second half.",
      "Compare first and second halves."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "yOzXms1J6Nk",
    "problemStatement": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Fast/Slow + Reverse: Find middle, reverse second half, compare.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isPalindrome(self, head):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isPalindrome(head):\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    return vals == vals[::-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Check if linked list is a palindrome.",
          "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
          "\ud83d\udca1 Compare first and second halves."
        ],
        "code": "def isPalindrome(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if linked list is a palindrome.\n    - \ud83e\udde0 Fast/slow to find middle, reverse second half.\n    - \ud83d\udca1 Compare first and second halves.\n\n    Algorithm:\n    1. Middle - Fast/slow.\n    2. Reverse - In-place.\n    3. Compare - Check.\n    \"\"\"\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    # Reverse second half\n    prev = None\n    while slow:\n        slow.next, prev, slow = prev, slow, slow.next\n    # Compare\n    while prev:\n        if head.val != prev.val:\n            return False  # Condition not met.\n        head, prev = head.next, prev.next\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__() {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isPalindrome(head *ListNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) isPalindrome(head *ListNode) bool {\n\tslow, fast := head, head.Next\n\tfor fast != nil && fast.Next != nil {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\tvar pre *ListNode\n\tcur := slow.Next\n\tfor cur != nil {\n\t\tt := cur.Next\n\t\tcur.Next = pre\n\t\tpre = cur\n\t\tcur = t\n\t}\n\tfor pre != nil {\n\t\tif pre.Val != head.Val {\n\t\t\treturn false\n\t\t}\n\t\tpre, head = pre.Next, head.Next\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\nstruct List {\n    head: ListLink,\n}\n\nimpl List {\n    fn new(head: ListLink) -> Self {\n        List { head }\n    }\n\n    fn pop(&mut self) -> Option<i32> {\n        if let Some(node) = self.head.take() {\n            self.head = node.next;\n            Some(node.val)\n        } else {\n            None\n        }\n    }\n\n    fn into_iter(self) -> IntoIter {\n        IntoIter { list: self }\n    }\n}\n\nstruct IntoIter {\n    list: List,\n}\n\nimpl Iterator for IntoIter {\n    type Item = i32;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.list.pop()\n    }\n}\n\nimpl Solution {\n    fn is_palindrome(head: ListLink) -> bool {\n        let list = List::new(head);\n        let vec: Vec<i32> = list.into_iter().collect();\n        for (i, &v) in vec.iter().rev().enumerate() {\n            if v != vec[i] {\n                return false;\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let head = list!(1, 2, 3);\n    assert_eq!(Solution::is_palindrome(head), false);\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def isPalindrome(self, head):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n    \n    isPalindrome(head: ListNode | null): boolean {\n        return false;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "best-time-to-buy-and-sell-stock",
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "pattern": "Track Minimum"
    }
  },
  "gfg---reverse-first-k-elements-of-a-queue": {
    "title": "GFG - Reverse first K elements of a Queue",
    "pattern": "Stack + Queue",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(k)",
    "oneliner": "Use stack to reverse first k, then cycle remaining elements.",
    "intuition": [
      "\ud83c\udfaf Reverse first k elements of a queue.",
      "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
      "\ud83d\udca1 Stack reverses order naturally."
    ],
    "testCases": [
      {
        "input": "k = 3, queue = [10, 20, 30, 40, 50]",
        "output": "[30, 20, 10, 40, 50]"
      },
      {
        "input": "k = 4, queue = [10, 20, 30, 40, 50]",
        "output": "[40, 30, 20, 10, 50]"
      }
    ],
    "steps": [
      {
        "step": 1,
        "title": "Stack",
        "visual": "Push k elements",
        "explanation": "Reverse."
      },
      {
        "step": 2,
        "title": "Push",
        "visual": "Pop stack to queue",
        "explanation": "Reversed."
      },
      {
        "step": 3,
        "title": "Cycle",
        "visual": "Move n-k to back",
        "explanation": "Reorder."
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def reverseFirstK(self, queue, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Reverse first k elements of a queue.\n        - \ud83e\udde0 Pop k to stack, push back, cycle n-k elements.\n        - \ud83d\udca1 Stack reverses order naturally.\n    \n        Algorithm:\n        1. Stack - Reverse.\n        2. Push - Reversed.\n        3. Cycle - Reorder.\n        \"\"\"\n        queue = deque(queue)\n        if not queue or k <= 0 or k > len(queue):\n            return list(queue)\n        stack = []  # Initialize stack for tracking.\n        for _ in range(k):  # Iterate through the range.\n            stack.append(queue.popleft())  # Add to end.\n        while stack:\n            queue.append(stack.pop())  # Add to end.\n        for _ in range(len(queue) - k):  # Iterate through the range.\n            queue.append(queue.popleft())  # Add to end.\n        return list(queue)",
    "keyInsight": "Use a stack to reverse order, then cycle the remaining elements.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: GFG - Reverse first K elements of a Queue",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use stack to reverse first k, then cycle remaining elements.\n\nReverse first k elements of a queue.\nPop k to stack, push back, cycle n-k elements.",
    "examples": [
      {
        "input": "queue = [1,2,3,4,5]; k = 3",
        "output": "[3,2,1,4,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Reverse first k elements of a queue.",
      "Pop k to stack, push back, cycle n-k elements.",
      "Stack reverses order naturally."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "VAZkSMoNHik",
    "problemStatement": "Given an integer K and a queue of integers, we need to reverse the order of the first K elements of the queue, leaving the other elements in the same relative order.",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Stack + Queue: Use stack to reverse first k, then cycle remaining elements.",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "difficulty": "Medium",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def reverseFirstK_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Reverse first k elements of a queue.",
          "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
          "\ud83d\udca1 Stack reverses order naturally."
        ],
        "code": "from collections import deque\n\ndef reverseFirstK(queue, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse first k elements of a queue.\n    - \ud83e\udde0 Pop k to stack, push back, cycle n-k elements.\n    - \ud83d\udca1 Stack reverses order naturally.\n\n    Algorithm:\n    1. Stack - Reverse.\n    2. Push - Reversed.\n    3. Cycle - Reorder.\n    \"\"\"\n    queue = deque(queue)\n    if not queue or k <= 0 or k > len(queue):\n        return list(queue)\n    stack = []  # Initialize stack for tracking.\n    for _ in range(k):  # Iterate through the range.\n        stack.append(queue.popleft())  # Add to end.\n    while stack:\n        queue.append(stack.pop())  # Add to end.\n    for _ in range(len(queue) - k):  # Iterate through the range.\n        queue.append(queue.popleft())  # Add to end.\n    return list(queue)"
      }
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    modifyQueue(q, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    modifyQueue(q, k) {\n        let s = [];\n        for(let i=0; i<k; i++) s.push(q.shift());\n        while(s.length > 0) q.push(s.pop());\n        for(let i=0; i<q.length-k; i++) q.push(q.shift());\n        return q;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Queue<Integer> solve(Queue<Integer> queue, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n    public Queue<Integer> solve(Queue<Integer> queue, int k) {\n        return new LinkedList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    queue<int> solve(queue<int> q, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    queue<int> solve(queue<int> q, int k) {\n        return q;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) modifyQueue(q []int, k int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\npackage main\nfunc (s *Solution) modifyQueue(q []int, k int) []int {\n    s := []int{}\n    for i := 0; i < k; i++ {\n        s = append(s, q[0])\n        q = q[1:]\n    }\n    for len(s) > 0 {\n        q = append(q, s[len(s)-1])\n        s = s[:len(s)-1]\n    }\n    for i := 0; i < len(q)-k; i++ {\n        val := q[0]\n        q = q[1:]\n        q = append(q, val)\n    }\n    return q\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn modify_queue(mut q: Vec<i32>, k: usize) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn modify_queue(mut q: Vec<i32>, k: usize) -> Vec<i32> {\n        let mut s = Vec::new();\n        for _ in 0..k { s.push(q.remove(0)); }\n        while let Some(val) = s.pop() { q.push(val); }\n        let n = q.len();\n        for _ in 0..(n - k) {\n            let val = q.remove(0);\n            q.push(val);\n        }\n        q\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "min-stack",
      "title": "Min Stack",
      "difficulty": "Medium",
      "pattern": "Stack (Two Stacks)"
    }
  },
  "minimum-size-subarray-sum": {
    "title": "Minimum Size Subarray Sum",
    "pattern": "Sliding Window",
    "patternEmoji": "\ud83e\ude9f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Expand right until sum >= target, shrink left while valid.",
    "intuition": [
      "\ud83c\udfaf Find minimal length subarray with sum >= target.",
      "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
      "\ud83d\udca1 Track minimum length when sum >= target."
    ],
    "testCases": [
      {
        "input": "target = 7, nums = [2,3,1,2,4,3]",
        "output": "2"
      },
      {
        "input": "target = 4, nums = [1,4,4]",
        "output": "1"
      },
      {
        "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def minSubArrayLen(self, target, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find minimal length subarray with sum >= target.\n        - \ud83e\udde0 Sliding window: expand right, shrink left when valid.\n        - \ud83d\udca1 Track minimum length when sum >= target.\n        \"\"\"\n        left = 0\n        total = 0\n        minLen = float('inf')\n        for right in range(len(nums)):  # Iterate through the range.\n            total += nums[right]\n            while total >= target:\n                minLen = min(minLen, right - left + 1)  # Take the minimum value.\n                total -= nums[left]\n                left += 1\n        return minLen if minLen != float('inf') else 0",
    "keyInsight": "Shrink window while maintaining validity to find minimum.",
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      1,
      2,
      4,
      3
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Initialize pointers and total sum",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 1,
            "label": "right"
          }
        ],
        "transientMessage": "Add nums[1] to total",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 2,
            "label": "right"
          }
        ],
        "transientMessage": "Total >= target, check window size",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 2,
            "label": "right"
          }
        ],
        "transientMessage": "Move left pointer to reduce total",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Add nums[3] to total",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 4,
            "label": "right"
          }
        ],
        "transientMessage": "Total >= target, check window size",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Add nums[5] to total",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3,
          5
        ],
        "color": "success",
        "pointers": [
          {
            "index": 3,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Minimum window size found",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 4,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Total >= target, check window size",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 5,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "No more elements to process",
        "arrayState": [
          2,
          3,
          1,
          2,
          4,
          3
        ]
      }
    ],
    "description": "Expand right until sum >= target, shrink left while valid.\n\nFind minimal length subarray with sum >= target.\nSliding window: expand right, shrink left when valid.",
    "examples": [
      {
        "input": "target = 7; nums = [2,3,1,2,4,3]",
        "output": "2"
      },
      {
        "input": "target = 4; nums = [1,4,4]",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find minimal length subarray with sum >= target.",
      "Sliding window: expand right, shrink left when valid.",
      "Track minimum length when sum >= target."
    ],
    "relatedProblems": [
      "longest-substring-without-repeating-characters",
      "minimum-window-substring"
    ],
    "videoId": "aYqYMIqZx5s",
    "problemStatement": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize window boundaries (left, right)",
      "Expand window by moving right pointer",
      "Update window state with new element",
      "Shrink window when condition violated",
      "Track optimal result throughout"
    ],
    "approach": "Sliding Window: Expand right until sum >= target, shrink left while valid.",
    "suggestedNextQuestion": {
      "slug": "permutation-in-string",
      "title": "Permutation In String",
      "difficulty": "Medium",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class Solution:\n    def minSubArrayLen(self, target, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def minSubArrayLen_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find minimal length subarray with sum >= target.",
          "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
          "\ud83d\udca1 Track minimum length when sum >= target."
        ],
        "code": "def minSubArrayLen(target, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimal length subarray with sum >= target.\n    - \ud83e\udde0 Sliding window: expand right, shrink left when valid.\n    - \ud83d\udca1 Track minimum length when sum >= target.\n    \"\"\"\n    left = 0\n    total = 0\n    minLen = float('inf')\n    for right in range(len(nums)):  # Iterate through the range.\n        total += nums[right]\n        while total >= target:\n            minLen = min(minLen, right - left + 1)  # Take the minimum value.\n            total -= nums[left]\n            left += 1\n    return minLen if minLen != float('inf') else 0"
      }
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minSubArrayLen(target, nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} target, nums\n     * @return {any}\n     */\n    minSubArrayLen(target, nums) {\n        let result = Infinity;\n\n        for (let right = 0, sum = 0, left = 0; right < nums.length; right++) {\n          sum += nums[right];\n          while (sum >= target) {\n            result = Math.min(result, right - left + 1);\n            sum -= nums[left];\n            left++;\n          }\n      }\n\n    return result === Infinity ? 0 : result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        long[] s = new long[n + 1];\n        for (int i = 0; i < n; ++i) {\n            s[i + 1] = s[i] + nums[i];\n        }\n        int ans = n + 1;\n        for (int i = 0; i <= n; ++i) {\n            int j = search(s, s[i] + target);\n            if (j <= n) {\n                ans = Math.min(ans, j - i);\n            }\n        }\n        return ans <= n ? ans : 0;\n    }\n\n    private int search(long[] nums, long x) {\n        int l = 0, r = nums.length;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minSubArrayLen(int target, vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int n = nums.size();\n        vector<long long> s(n + 1);\n        for (int i = 0; i < n; ++i) {\n            s[i + 1] = s[i] + nums[i];\n        }\n        int ans = n + 1;\n        for (int i = 0; i <= n; ++i) {\n            int j = lower_bound(s.begin(), s.end(), s[i] + target) - s.begin();\n            if (j <= n) {\n                ans = min(ans, j - i);\n            }\n        }\n        return ans <= n ? ans : 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minSubArrayLen(target int, nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minSubArrayLen(target int, nums []int) int {\n\tn := len(nums)\n\ts := make([]int, n+1)\n\tfor i, x := range nums {\n\t\ts[i+1] = s[i] + x\n\t}\n\tans := n + 1\n\tfor i, x := range s {\n\t\tj := sort.SearchInts(s, x+target)\n\t\tif j <= n {\n\t\t\tans = min(ans, j-i)\n\t\t}\n\t}\n\tif ans == n+1 {\n\t\treturn 0\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_sub_array_len(target: i32, nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut res = n + 1;\n        let mut sum = 0;\n        let mut i = 0;\n        for j in 0..n {\n            sum += nums[j];\n\n            while sum >= target {\n                res = res.min(j - i + 1);\n                sum -= nums[i];\n                i += 1;\n            }\n        }\n        if res == n + 1 {\n            return 0;\n        }\n        res as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minSubArrayLen(self, target, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minSubArrayLen(target: number, nums: number[]): number  {\n    const n = nums.length;\n    const s: number[] = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; ++i) {\n        s[i + 1] = s[i] + nums[i];\n    }\n    let ans = n + 1;\n    const search = (x: number) => {\n        let l = 0;\n        let r = n + 1;\n        while (l < r) {\n            const mid = (l + r) >>> 1;\n            if (s[mid] >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    };\n    for (let i = 0; i <= n; ++i) {\n        const j = search(s[i] + target);\n        if (j <= n) {\n            ans = Math.min(ans, j - i);\n        }\n    }\n    return ans === n + 1 ? 0 : ans;\n}\n}",
        "initialCode": "class Solution {\n    minSubArrayLen(target: number, nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "longest-substring-without-repeating-characters": {
    "title": "Longest Substring Without Repeating Characters",
    "pattern": "Sliding Window + Hash Set",
    "patternEmoji": "\ud83e\ude9f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(min(n,m))",
    "oneliner": "Expand right, shrink left when duplicate found.",
    "intuition": [
      "\ud83c\udfaf Find longest substring with all unique characters.",
      "\ud83e\udde0 Use set to track current window characters.",
      "\ud83d\udca1 Remove from left when duplicate encountered."
    ],
    "testCases": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3"
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1"
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3"
      }
    ],
    "code": "class Solution:\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find longest substring with all unique characters.\n        - \ud83e\udde0 Use set to track current window characters.\n        - \ud83d\udca1 Remove from left when duplicate encountered.\n        \"\"\"\n        seen = set()  # Keep track of visited elements.\n        left = 0\n        maxLen = 0\n        for right in range(len(s)):  # Iterate through the range.\n            while s[right] in seen:\n                seen.remove(s[left])\n                left += 1\n            seen.add(s[right])\n            maxLen = max(maxLen, right - left + 1)  # Take the maximum value.\n        return maxLen",
    "keyInsight": "Use a hash set/map to detect duplicates in O(1).",
    "visualizationType": "tree",
    "initialState": "abcabcbb",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Initialize 'seen' set and pointers 'left' and 'right' at 0",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 1,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 1, add 'b' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 2,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 2, add 'c' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 3, 'a' is in 'seen', remove 'b' and move 'left' to 1",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 3, add 'a' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 4,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 4, 'b' is in 'seen', remove 'c' and move 'left' to 2",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 4,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 4, add 'b' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 5, 'c' is in 'seen', remove 'a' and move 'left' to 3",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 5, add 'c' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          6
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "left"
          },
          {
            "index": 6,
            "label": "right"
          }
        ],
        "transientMessage": "Move 'right' to index 6, add 'b' to 'seen'",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "color": "success",
        "transientMessage": "Final result: Length of the longest substring without repeating characters is 3",
        "arrayState": [
          "a",
          "b",
          "c",
          "a",
          "b",
          "c",
          "b",
          "b"
        ]
      }
    ],
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is 'abc', with length 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is 'b', with length 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is 'wke', with length 3."
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols and spaces."
    ],
    "hints": [
      "Use the sliding window technique.",
      "Maintain a set of characters in current window.",
      "When you see a duplicate, shrink window from left."
    ],
    "relatedProblems": [
      "longest-repeating-character-replacement",
      "minimum-window-substring",
      "substring-with-concatenation-of-all-words"
    ],
    "videoId": "wiGpQwVHdE0",
    "problemStatement": "Given a string s, find the length of the longest substring without duplicate characters.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Sliding Window + Hash Set: Expand right, shrink left when duplicate found.",
    "suggestedNextQuestion": {
      "slug": "minimum-size-subarray-sum",
      "title": "Minimum Size Subarray Sum",
      "difficulty": "Medium",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def lengthOfLongestSubstring_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(min(n,m))",
        "intuition": [
          "\ud83c\udfaf Find longest substring with all unique characters.",
          "\ud83e\udde0 Use set to track current window characters.",
          "\ud83d\udca1 Remove from left when duplicate encountered."
        ],
        "code": "def lengthOfLongestSubstring(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest substring with all unique characters.\n    - \ud83e\udde0 Use set to track current window characters.\n    - \ud83d\udca1 Remove from left when duplicate encountered.\n    \"\"\"\n    seen = set()  # Keep track of visited elements.\n    left = 0\n    maxLen = 0\n    for right in range(len(s)):  # Iterate through the range.\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        maxLen = max(maxLen, right - left + 1)  # Take the maximum value.\n    return maxLen"
      }
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLongestSubstring(s string) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLongestSubstring(s string) (ans int) {\n\tcnt := [128]int{}\n\tl := 0\n\tfor r, c := range s {\n\t\tcnt[c]++\n\t\tfor cnt[c] > 1 {\n\t\t\tcnt[s[l]]--\n\t\t\tl++\n\t\t}\n\t\tans = max(ans, r-l+1)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn length_of_longest_substring(s: String) -> i32 {\n        let mut cnt = [0; 128];\n        let mut ans = 0;\n        let mut l = 0;\n        let chars: Vec<char> = s.chars().collect();\n        let n = chars.len();\n        for (r, &c) in chars.iter().enumerate() {\n            cnt[c as usize] += 1;\n            while cnt[c as usize] > 1 {\n                cnt[chars[l] as usize] -= 1;\n                l += 1;\n            }\n            ans = ans.max((r - l + 1) as i32);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lengthOfLongestSubstring(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) {\n        // Method body will be implemented later\n    }\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "substring-with-concatenation-of-all-words": {
    "title": "Substring with Concatenation of All Words",
    "pattern": "Sliding Window + Hash Map",
    "patternEmoji": "\ud83e\ude9f",
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(m)",
    "oneliner": "Sliding window of size wordLen*numWords, check if all words match.",
    "intuition": [
      "\ud83c\udfaf Find all starting indices of concatenated substrings.",
      "\ud83e\udde0 All words have same length, total window = len*count.",
      "\ud83d\udca1 Slide window, compare word frequency maps."
    ],
    "testCases": [
      {
        "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
        "output": "[0,9]"
      },
      {
        "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
        "output": "[]"
      },
      {
        "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
        "output": "[6,9,12]"
      }
    ],
    "code": "class Solution:\n    from collections import Counter\n    \n    def findSubstring(self, s, words):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find all starting indices of concatenated substrings.\n        - \ud83e\udde0 All words have same length, total window = len*count.\n        - \ud83d\udca1 Slide window, compare word frequency maps.\n        \"\"\"\n        if not s or not words: return []\n        wordLen = len(words[0])\n        numWords = len(words)\n        totalLen = wordLen * numWords\n        wordCount = Counter(words)\n        res = []  # Initialize list to store results.\n        for i in range(len(s) - totalLen + 1):  # Iterate through the range.\n            seen = Counter()\n            for j in range(numWords):  # Iterate through the range.\n                word = s[i + j * wordLen : i + (j + 1) * wordLen]\n                if word not in wordCount:\n                    break\n                seen[word] += 1\n                if seen[word] > wordCount[word]:\n                    break\n            else:\n                res.append(i)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "Fixed word length simplifies the sliding window logic.",
    "visualizationType": "tree",
    "initialState": "barfoothefoobarman",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Substring with Concatenation of All Words",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Sliding window of size wordLen*numWords, check if all words match.\n\nFind all starting indices of concatenated substrings.\nAll words have same length, total window = len*count.",
    "examples": [
      {
        "input": "s = \"barfoothefoobarman\"; words = [\"foo\",\"bar\"]",
        "output": "[0,9]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find all starting indices of concatenated substrings.",
      "All words have same length, total window = len*count.",
      "Slide window, compare word frequency maps."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "-wlDdMmaYwI",
    "problemStatement": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Sliding Window + Hash Map: Sliding window of size wordLen*numWords, check if all words match.",
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def findSubstring_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n*m)",
        "spaceComplexity": "O(m)",
        "intuition": [
          "\ud83c\udfaf Find all starting indices of concatenated substrings.",
          "\ud83e\udde0 All words have same length, total window = len*count.",
          "\ud83d\udca1 Slide window, compare word frequency maps."
        ],
        "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find all starting indices of concatenated substrings.\n    - \ud83e\udde0 All words have same length, total window = len*count.\n    - \ud83d\udca1 Slide window, compare word frequency maps.\n    \"\"\"\n    if not s or not words: return []\n    wordLen = len(words[0])\n    numWords = len(words)\n    totalLen = wordLen * numWords\n    wordCount = Counter(words)\n    res = []  # Initialize list to store results.\n    for i in range(len(s) - totalLen + 1):  # Iterate through the range.\n        seen = Counter()\n        for j in range(numWords):  # Iterate through the range.\n            word = s[i + j * wordLen : i + (j + 1) * wordLen]\n            if word not in wordCount:\n                break\n            seen[word] += 1\n            if seen[word] > wordCount[word]:\n                break\n        else:\n            res.append(i)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Integer> __init__(String s, String[] words) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "import java.util.HashMap;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> __init__(String s, String[] words) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> __init__(string s, vector<string>& words) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> __init__(string s, vector<string>& words) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findSubstring(s string, words []string) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findSubstring(s string, words []string) (ans []int) {\n\tcnt := make(map[string]int)\n\tfor _, w := range words {\n\t\tcnt[w]++\n\t}\n\tm, n, k := len(s), len(words), len(words[0])\n\tfor i := 0; i < k; i++ {\n\t\tl, r := i, i\n\t\tcnt1 := make(map[string]int)\n\t\tfor r+k <= m {\n\t\t\tt := s[r : r+k]\n\t\t\tr += k\n\n\t\t\tif _, exists := cnt[t]; !exists {\n\t\t\t\tcnt1 = make(map[string]int)\n\t\t\t\tl = r\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcnt1[t]++\n\t\t\tfor cnt1[t] > cnt[t] {\n\t\t\t\tw := s[l : l+k]\n\t\t\t\tcnt1[w]--\n\t\t\t\tif cnt1[w] == 0 {\n\t\t\t\t\tdelete(cnt1, w)\n\t\t\t\t}\n\t\t\t\tl += k\n\t\t\t}\n\t\t\tif r-l == n*k {\n\t\t\t\tans = append(ans, l)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [30] Substring with Concatenation of All Words\n *\n * You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n *\n * Example 1:\n *\n *\n * Input:\n *   s = \"barfoothefoobarman\",\n *   words = [\"foo\",\"bar\"]\n * Output: [0,9]\n * Explanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.\n * The output order does not matter, returning [9,0] is fine too.\n *\n *\n * Example 2:\n *\n *\n * Input:\n *   s = \"wordgoodgoodgoodbestword\",\n *   words = [\"word\",\"good\",\"best\",\"word\"]\n * Output: []\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/substring-with-concatenation-of-all-words/\n// discuss: https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\nstruct Term {\n    expect: i32,\n    count: i32,\n}\nimpl Term {\n    fn new(expect: i32, count: i32) -> Self {\n        Term { expect, count }\n    }\n    fn inc_expect(&mut self) {\n        self.expect += 1;\n    }\n    fn inc(&mut self) {\n        self.count += 1;\n    }\n    fn dec(&mut self) {\n        self.count -= 1;\n    }\n    fn exhausted(&self) -> bool {\n        self.count > self.expect\n    }\n    fn reset(&mut self) {\n        self.count = 0;\n    }\n}\n\nuse std::collections::hash_map::Entry;\nuse std::collections::HashMap;\n\nimpl Solution {\n    pub fn find_substring(s: String, words: Vec<String>) -> Vec<i32> {\n        if words.len() < 1 {\n            return vec![];\n        }\n        let word_len = words[0].len();\n        if word_len < 1 {\n            return vec![];\n        }\n        let substr_len = word_len * words.len();\n        let mut map: HashMap<&str, Term> = HashMap::with_capacity(words.len());\n        for word in words.iter() {\n            map.entry(word).or_insert(Term::new(0, 0)).inc_expect();\n        }\n        let mut result: Vec<i32> = Vec::new();\n        // we can split terms in N ways, where N = word_len\n        for shift in 0..word_len {\n            let mut i = shift;\n            let mut j = shift;\n            // we do a sliding window for each round\n            while j + word_len - 1 < s.len() {\n                match map.entry(&s[j..j + word_len]) {\n                    Entry::Occupied(mut entry) => {\n                        entry.get_mut().inc();\n                        // term exhausted, shrink the window to release\n                        if entry.get().exhausted() {\n                            while i < j {\n                                let term = &s[i..i + word_len];\n                                map.entry(term).and_modify(|t| t.dec());\n                                i += word_len;\n                                if term == &s[j..j + word_len] {\n                                    break;\n                                }\n                            }\n                            j += word_len;\n                        } else {\n                            if j - i < (words.len() - 1) * word_len {\n                                j += word_len;\n                            } else {\n                                // matched!\n                                result.push(i as i32);\n                                // move the whole window, release the dropped term\n                                map.entry(&s[i..i + word_len]).and_modify(|t| t.dec());\n                                j += word_len;\n                                i += word_len;\n                            }\n                        }\n                    }\n                    // bad term, move over and do a reset\n                    Entry::Vacant(entry) => {\n                        map.iter_mut().for_each(|(_, v)| v.reset());\n                        j += word_len;\n                        i = j;\n                    }\n                }\n            }\n            map.iter_mut().for_each(|(_, v)| v.reset())\n        }\n        result\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_30() {\n        assert_eq!(\n            Solution::find_substring(\n                \"barfoothefoobarman\".to_string(),\n                vec![\"foo\".to_string(), \"bar\".to_string()]\n            ),\n            vec![0, 9]\n        );\n        assert_eq!(\n            Solution::find_substring(\n                \"wordgoodgoodgoodbestword\".to_string(),\n                vec![\n                    \"word\".to_string(),\n                    \"good\".to_string(),\n                    \"best\".to_string(),\n                    \"word\".to_string()\n                ]\n            ),\n            vec![]\n        );\n        assert_eq!(\n            Solution::find_substring(\n                \"wordgoodgoodgoodbestword\".to_string(),\n                vec![\n                    \"word\".to_string(),\n                    \"good\".to_string(),\n                    \"best\".to_string(),\n                    \"good\".to_string()\n                ]\n            ),\n            vec![8]\n        );\n        assert_eq!(\n            Solution::find_substring(\n                \"xxwordgoodgoodgoodbestword\".to_string(),\n                vec![\n                    \"word\".to_string(),\n                    \"good\".to_string(),\n                    \"best\".to_string(),\n                    \"good\".to_string()\n                ]\n            ),\n            vec![10]\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n    \n    __init__(s: string, words: string[]): number[] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "pattern": "Sliding Window + Hash Map"
    }
  },
  "minimum-window-substring": {
    "title": "Minimum Window Substring",
    "pattern": "Sliding Window + Hash Map",
    "patternEmoji": "\ud83e\ude9f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(m)",
    "oneliner": "Expand right to include all t chars, shrink left to minimize.",
    "intuition": [
      "\ud83c\udfaf Find minimum window in s containing all chars of t.",
      "\ud83e\udde0 Count required chars, expand right until all satisfied.",
      "\ud83d\udca1 Shrink left while still valid, track minimum."
    ],
    "testCases": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\""
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\""
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\""
      }
    ],
    "code": "class Solution:\n    from collections import Counter\n    \n    def minWindow(self, s, t):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find minimum window in s containing all chars of t.\n        - \ud83e\udde0 Count required chars, expand right until all satisfied.\n        - \ud83d\udca1 Shrink left while still valid, track minimum.\n        \"\"\"\n        if not t or not s: return ''\n        need = Counter(t)\n        have = {}\n        required = len(need)\n        formed = 0\n        left = 0\n        res = (float('inf'), 0, 0)\n        for right, c in enumerate(s):  # Iterate over elements.\n            have[c] = have.get(c, 0) + 1\n            if c in need and have[c] == need[c]:\n                formed += 1\n            while formed == required:\n                if right - left + 1 < res[0]:\n                    res = (right - left + 1, left, right + 1)\n                have[s[left]] -= 1\n                if s[left] in need and have[s[left]] < need[s[left]]:\n                    formed -= 1\n                left += 1\n        return '' if res[0] == float('inf') else s[res[1]:res[2]]",
    "keyInsight": "Track 'formed' count to know when all required chars are satisfied.",
    "visualizationType": "tree",
    "initialState": "ADOBECODEBANC",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Initializing pointers and counters",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'A' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'D' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'O' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'B' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'E' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Processing character 'C' at right pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "success",
        "pointers": [
          {
            "index": 5,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Minimum window found: 'BANC'",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 6,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Shrinking window by moving left pointer",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          7,
          8,
          9,
          10,
          11
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 7,
            "label": "left"
          },
          {
            "index": 11,
            "label": "right"
          }
        ],
        "transientMessage": "Final minimum window: 'BANC'",
        "arrayState": [
          "A",
          "D",
          "O",
          "B",
          "E",
          "C",
          "O",
          "D",
          "E",
          "B",
          "A",
          "N",
          "C"
        ]
      }
    ],
    "description": "Expand right to include all t chars, shrink left to minimize.\n\nFind minimum window in s containing all chars of t.\nCount required chars, expand right until all satisfied.",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\"; t = \"ABC\"",
        "output": "\"BANC\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find minimum window in s containing all chars of t.",
      "Count required chars, expand right until all satisfied.",
      "Shrink left while still valid, track minimum."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "jSto0O4AJbM",
    "problemStatement": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Sliding Window + Hash Map: Expand right to include all t chars, shrink left to minimize.",
    "suggestedNextQuestion": {
      "slug": "substring-with-concatenation-of-all-words",
      "title": "Substring with Concatenation of All Words",
      "difficulty": "Hard",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def minWindow_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(m)",
        "intuition": [
          "\ud83c\udfaf Find minimum window in s containing all chars of t.",
          "\ud83e\udde0 Count required chars, expand right until all satisfied.",
          "\ud83d\udca1 Shrink left while still valid, track minimum."
        ],
        "code": "from collections import Counter\n\ndef minWindow(s, t):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum window in s containing all chars of t.\n    - \ud83e\udde0 Count required chars, expand right until all satisfied.\n    - \ud83d\udca1 Shrink left while still valid, track minimum.\n    \"\"\"\n    if not t or not s: return ''\n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    left = 0\n    res = (float('inf'), 0, 0)\n    for right, c in enumerate(s):  # Iterate over elements.\n        have[c] = have.get(c, 0) + 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while formed == required:\n            if right - left + 1 < res[0]:\n                res = (right - left + 1, left, right + 1)\n            have[s[left]] -= 1\n            if s[left] in need and have[s[left]] < need[s[left]]:\n                formed -= 1\n            left += 1\n    return '' if res[0] == float('inf') else s[res[1]:res[2]]"
      }
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) {\n        // Initialization logic here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String minWindow(String s, String t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String minWindow(String s, String t) {\n        return \"\";\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string minWindow(string s, string t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        return \"\";\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minWindow(s string, t string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minWindow(s string, t string) string {\n\tneed := make([]int, 128)\n\twindow := make([]int, 128)\n\tfor i := 0; i < len(t); i++ {\n\t\tneed[t[i]]++\n\t}\n\n\tm, n := len(s), len(t)\n\tk, mi, cnt := -1, m+1, 0\n\n\tfor l, r := 0, 0; r < m; r++ {\n\t\tc := s[r]\n\t\tif window[c]++; window[c] <= need[c] {\n\t\t\tcnt++\n\t\t}\n\t\tfor cnt == n {\n\t\t\tif r-l+1 < mi {\n\t\t\t\tmi = r - l + 1\n\t\t\t\tk = l\n\t\t\t}\n\n\t\t\tc = s[l]\n\t\t\tif window[c] <= need[c] {\n\t\t\t\tcnt--\n\t\t\t}\n\t\t\twindow[c]--\n\t\t\tl++\n\t\t}\n\t}\n\tif k < 0 {\n\t\treturn \"\"\n\t}\n\treturn s[k : k+mi]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\nimpl Solution {\n    pub fn min_window(s: String, t: String) -> String {\n        let mut need: HashMap<char, usize> = HashMap::new();\n        let mut window: HashMap<char, usize> = HashMap::new();\n        for c in t.chars() {\n            *need.entry(c).or_insert(0) += 1;\n        }\n        let m = s.len();\n        let n = t.len();\n        let mut k = -1;\n        let mut mi = m + 1;\n        let mut cnt = 0;\n\n        let s_bytes = s.as_bytes();\n        let mut l = 0;\n        for r in 0..m {\n            let c = s_bytes[r] as char;\n            *window.entry(c).or_insert(0) += 1;\n            if window[&c] <= *need.get(&c).unwrap_or(&0) {\n                cnt += 1;\n            }\n            while cnt == n {\n                if r - l + 1 < mi {\n                    mi = r - l + 1;\n                    k = l as i32;\n                }\n\n                let c = s_bytes[l] as char;\n                if window[&c] <= *need.get(&c).unwrap_or(&0) {\n                    cnt -= 1;\n                }\n                *window.entry(c).or_insert(0) -= 1;\n                l += 1;\n            }\n        }\n        if k < 0 {\n            return String::new();\n        }\n        s[k as usize..(k as usize + mi)].to_string()\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    minWindow(s: string, t: string): string {\n        return \"\";\n    }\n}",
        "initialCode": "class Solution {\n    minWindow(s: string, t: string): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "valid-sudoku": {
    "title": "Valid Sudoku",
    "pattern": "Hash Set per Row/Col/Box",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(81)",
    "spaceComplexity": "O(81)",
    "oneliner": "Check each row, column, and 3x3 box for duplicates.",
    "intuition": [
      "\ud83c\udfaf Validate a partially filled Sudoku board.",
      "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
      "\ud83d\udca1 Box index = (row//3, col//3)."
    ],
    "testCases": [
      {
        "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "true"
      },
      {
        "input": "board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def isValidSudoku(self, board):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Validate a partially filled Sudoku board.\n        - \ud83e\udde0 Use sets for each row, column, and 3x3 box.\n        - \ud83d\udca1 Box index = (row//3, col//3).\n        \"\"\"\n        rows = [set() for _ in range(9)]  # Iterate through the range.\n        cols = [set() for _ in range(9)]  # Iterate through the range.\n        boxes = [set() for _ in range(9)]  # Iterate through the range.\n        for r in range(9):  # Iterate through the range.\n            for c in range(9):  # Iterate through the range.\n                val = board[r][c]\n                if val == '.': continue\n                box_idx = (r // 3) * 3 + (c // 3)\n                if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                    return False  # Condition not met.\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[box_idx].add(val)\n        return True  # Condition satisfied.",
    "keyInsight": "The box index formula (r//3)*3 + (c//3) maps to 0-8.",
    "visualizationType": "matrix",
    "initialState": [
      5,
      3,
      ".",
      ".",
      7,
      ".",
      ".",
      ".",
      "."
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Valid Sudoku",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Check each row, column, and 3x3 box for duplicates.\n\nValidate a partially filled Sudoku board.\nUse sets for each row, column, and 3x3 box.",
    "examples": [
      {
        "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Validate a partially filled Sudoku board.",
      "Use sets for each row, column, and 3x3 box.",
      "Box index = (row//3, col//3)."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "TjFXEUCMqI8",
    "problemStatement": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nNote:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Set per Row/Col/Box: Check each row, column, and 3x3 box for duplicates.",
    "suggestedNextQuestion": {
      "slug": "max-points-on-a-line",
      "title": "Max Points on a Line",
      "difficulty": "Hard",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "class Solution:\n    def isValidSudoku(self, board):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.': continue\n            \n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False\n            \n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(81)",
        "spaceComplexity": "O(81)",
        "intuition": [
          "\ud83c\udfaf Validate a partially filled Sudoku board.",
          "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
          "\ud83d\udca1 Box index = (row//3, col//3)."
        ],
        "code": "def isValidSudoku(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Validate a partially filled Sudoku board.\n    - \ud83e\udde0 Use sets for each row, column, and 3x3 box.\n    - \ud83d\udca1 Box index = (row//3, col//3).\n    \"\"\"\n    rows = [set() for _ in range(9)]  # Iterate through the range.\n    cols = [set() for _ in range(9)]  # Iterate through the range.\n    boxes = [set() for _ in range(9)]  # Iterate through the range.\n    for r in range(9):  # Iterate through the range.\n        for c in range(9):  # Iterate through the range.\n            val = board[r][c]\n            if val == '.': continue\n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False  # Condition not met.\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isValidSudoku(board) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} board\n     * @return {any}\n     */\n    isValidSudoku(board) {\n        const row = [...Array(9)].map(() => Array(9).fill(false));\n        const col = [...Array(9)].map(() => Array(9).fill(false));\n        const sub = [...Array(9)].map(() => Array(9).fill(false));\n        for (let i = 0; i < 9; ++i) {\n            for (let j = 0; j < 9; ++j) {\n                const num = board[i][j].charCodeAt() - '1'.charCodeAt();\n                if (num < 0 || num > 8) {\n                    continue;\n                }\n                const k = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n                if (row[i][num] || col[j][num] || sub[k][num]) {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n    }\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        boolean[][] row = new boolean[9][9];\n        boolean[][] col = new boolean[9][9];\n        boolean[][] sub = new boolean[9][9];\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                char c = board[i][j];\n                if (c == '.') {\n                    continue;\n                }\n                int num = c - '0' - 1;\n                int k = i / 3 * 3 + j / 3;\n                if (row[i][num] || col[j][num] || sub[k][num]) {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isValidSudoku(vector<vector<char>>& board) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        vector<vector<bool>> row(9, vector<bool>(9, false));\n        vector<vector<bool>> col(9, vector<bool>(9, false));\n        vector<vector<bool>> sub(9, vector<bool>(9, false));\n        for (int i = 0; i < 9; ++i) {\n            for (int j = 0; j < 9; ++j) {\n                char c = board[i][j];\n                if (c == '.') continue;\n                int num = c - '0' - 1;\n                int k = i / 3 * 3 + j / 3;\n                if (row[i][num] || col[j][num] || sub[k][num]) {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isValidSudoku(board [][]byte) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isValidSudoku(board [][]byte) bool {\n\trow, col, sub := [9][9]bool{}, [9][9]bool{}, [9][9]bool{}\n\tfor i := 0; i < 9; i++ {\n\t\tfor j := 0; j < 9; j++ {\n\t\t\tnum := board[i][j] - byte('1')\n\t\t\tif num < 0 || num > 9 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tk := i/3*3 + j/3\n\t\t\tif row[i][num] || col[j][num] || sub[k][num] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\trow[i][num] = true\n\t\t\tcol[j][num] = true\n\t\t\tsub[k][num] = true\n\t\t}\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\n        let mut row = vec![vec![false; 9]; 9];\n        let mut col = vec![vec![false; 9]; 9];\n        let mut sub = vec![vec![false; 9]; 9];\n\n        for i in 0..9 {\n            for j in 0..9 {\n                let c = board[i][j];\n                if c == '.' {\n                    continue;\n                }\n                let num = (c as u8 - b'0' - 1) as usize;\n                let k = i / 3 * 3 + j / 3;\n                if row[i][num] || col[j][num] || sub[k][num] {\n                    return false;\n                }\n                row[i][num] = true;\n                col[j][num] = true;\n                sub[k][num] = true;\n            }\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isValidSudoku(self, board):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isValidSudoku(board: string[][]): boolean  {\n    const row: boolean[][] = Array.from({ length: 9 }, () =>\n        Array.from({ length: 9 }, () => false),\n    );\n    const col: boolean[][] = Array.from({ length: 9 }, () =>\n        Array.from({ length: 9 }, () => false),\n    );\n    const sub: boolean[][] = Array.from({ length: 9 }, () =>\n        Array.from({ length: 9 }, () => false),\n    );\n    for (let i = 0; i < 9; ++i) {\n        for (let j = 0; j < 9; ++j) {\n            const num = board[i][j].charCodeAt(0) - '1'.charCodeAt(0);\n            if (num < 0 || num > 8) {\n                continue;\n            }\n            const k = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n            if (row[i][num] || col[j][num] || sub[k][num]) {\n                return false;\n            }\n            row[i][num] = true;\n            col[j][num] = true;\n            sub[k][num] = true;\n        }\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    isValidSudoku(board: string[][]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "spiral-matrix": {
    "title": "Spiral Matrix",
    "pattern": "Layer by Layer",
    "patternEmoji": "\ud83c\udf00",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Process layer by layer: right, down, left, up, shrink bounds.",
    "intuition": [
      "\ud83c\udfaf Return matrix elements in spiral order.",
      "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
      "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
    ],
    "testCases": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]"
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
      }
    ],
    "code": "class Solution:\n    def spiralOrder(self, matrix):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Return matrix elements in spiral order.\n        - \ud83e\udde0 Maintain top/bottom/left/right boundaries.\n        - \ud83d\udca1 Traverse each direction, shrink boundary, repeat.\n        \"\"\"\n        if not matrix: return []\n        res = []  # Initialize list to store results.\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n        while top <= bottom and left <= right:\n            for c in range(left, right + 1): res.append(matrix[top][c])  # Iterate through the range.\n            top += 1\n            for r in range(top, bottom + 1): res.append(matrix[r][right])  # Iterate through the range.\n            right -= 1\n            if top <= bottom:\n                for c in range(right, left - 1, -1): res.append(matrix[bottom][c])  # Iterate through the range.\n                bottom -= 1\n            if left <= right:\n                for r in range(bottom, top - 1, -1): res.append(matrix[r][left])  # Iterate through the range.\n                left += 1\n        return res  # Return the final result.",
    "keyInsight": "After going right and down, check bounds before going left and up.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        2,
        3
      ],
      [
        4,
        5,
        6
      ],
      [
        7,
        8,
        9
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Spiral Matrix",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 2",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 4",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 5",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Process layer by layer: right, down, left, up, shrink bounds.\n\nReturn matrix elements in spiral order.\nMaintain top/bottom/left/right boundaries.",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Return matrix elements in spiral order.",
      "Maintain top/bottom/left/right boundaries.",
      "Traverse each direction, shrink boundary, repeat."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "BJnMZNwUk1M",
    "problemStatement": "Given an m x n matrix, return all elements of the matrix in spiral order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Layer by Layer: Process layer by layer: right, down, left, up, shrink bounds.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def spiralOrder(self, matrix):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def spiralOrder(matrix):\n    res = []\n    while matrix:\n        res += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                res.append(row.pop())\n        if matrix:\n            res += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                res.append(row.pop(0))\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Return matrix elements in spiral order.",
          "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
          "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
        ],
        "code": "def spiralOrder(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return matrix elements in spiral order.\n    - \ud83e\udde0 Maintain top/bottom/left/right boundaries.\n    - \ud83d\udca1 Traverse each direction, shrink boundary, repeat.\n    \"\"\"\n    if not matrix: return []\n    res = []  # Initialize list to store results.\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1): res.append(matrix[top][c])  # Iterate through the range.\n        top += 1\n        for r in range(top, bottom + 1): res.append(matrix[r][right])  # Iterate through the range.\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1): res.append(matrix[bottom][c])  # Iterate through the range.\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1): res.append(matrix[r][left])  # Iterate through the range.\n            left += 1\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    spiralOrder(matrix) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} matrix\n     * @return {any}\n     */\n    spiralOrder(matrix) {\n        const m = matrix.length;\n        const n = matrix[0].length;\n        const ans = [];\n        const vis = Array.from({ length: m }, () => Array(n).fill(false));\n        const dirs = [0, 1, 0, -1, 0];\n        for (let h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\n            ans.push(matrix[i][j]);\n            vis[i][j] = true;\n            const x = i + dirs[k];\n            const y = j + dirs[k + 1];\n            if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n                k = (k + 1) % 4;\n            }\n            i += dirs[k];\n            j += dirs[k + 1];\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[] dirs = {0, 1, 0, -1, 0};\n        int i = 0, j = 0, k = 0;\n        List<Integer> ans = new ArrayList<>();\n        boolean[][] vis = new boolean[m][n];\n        for (int h = m * n; h > 0; --h) {\n            ans.add(matrix[i][j]);\n            vis[i][j] = true;\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n                k = (k + 1) % 4;\n            }\n            i += dirs[k];\n            j += dirs[k + 1];\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        int dirs[5] = {0, 1, 0, -1, 0};\n        int i = 0, j = 0, k = 0;\n        vector<int> ans;\n        bool vis[m][n];\n        memset(vis, false, sizeof(vis));\n        for (int h = m * n; h; --h) {\n            ans.push_back(matrix[i][j]);\n            vis[i][j] = true;\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n                k = (k + 1) % 4;\n            }\n            i += dirs[k];\n            j += dirs[k + 1];\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) spiralOrder(matrix [][]int) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) spiralOrder(matrix [][]int) (ans []int) {\n\tm, n := len(matrix), len(matrix[0])\n\tvis := make([][]bool, m)\n\tfor i := range vis {\n\t\tvis[i] = make([]bool, n)\n\t}\n\tdirs := [5]int{0, 1, 0, -1, 0}\n\ti, j, k := 0, 0, 0\n\tfor h := m * n; h > 0; h-- {\n\t\tans = append(ans, matrix[i][j])\n\t\tvis[i][j] = true\n\t\tx, y := i+dirs[k], j+dirs[k+1]\n\t\tif x < 0 || x >= m || y < 0 || y >= n || vis[x][y] {\n\t\t\tk = (k + 1) % 4\n\t\t}\n\t\ti, j = i+dirs[k], j+dirs[k+1]\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        let mut dirs = vec![0, 1, 0, -1, 0];\n        let mut vis = vec![vec![false; n]; m];\n        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n        let mut ans = Vec::new();\n\n        for _ in 0..(m * n) {\n            ans.push(matrix[i][j]);\n            vis[i][j] = true;\n            let x = i as i32 + dirs[k] as i32;\n            let y = j as i32 + dirs[k + 1] as i32;\n\n            if x < 0 || x >= m as i32 || y < 0 || y >= n as i32 || vis[x as usize][y as usize] {\n                k = (k + 1) % 4;\n            }\n\n            i = (i as i32 + dirs[k] as i32) as usize;\n            j = (j as i32 + dirs[k + 1] as i32) as usize;\n        }\n\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def spiralOrder(self, matrix):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    spiralOrder(matrix: number[][]): number[]  {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const ans: number[] = [];\n    const vis: boolean[][] = Array.from({ length: m }, () => Array(n).fill(false));\n    const dirs = [0, 1, 0, -1, 0];\n    for (let h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\n        ans.push(matrix[i][j]);\n        vis[i][j] = true;\n        const x = i + dirs[k];\n        const y = j + dirs[k + 1];\n        if (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\n            k = (k + 1) % 4;\n        }\n        i += dirs[k];\n        j += dirs[k + 1];\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    spiralOrder(matrix: number[][]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "min-stack",
      "title": "Min Stack",
      "difficulty": "Medium",
      "pattern": "Stack (Two Stacks)"
    }
  },
  "rotate-image": {
    "title": "Rotate Image",
    "pattern": "Transpose + Reverse",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(1)",
    "oneliner": "Transpose matrix, then reverse each row.",
    "intuition": [
      "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
      "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
      "\ud83d\udca1 Reverse each row."
    ],
    "testCases": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]"
      },
      {
        "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
        "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
      }
    ],
    "code": "class Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.\n        - \ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].\n        - \ud83d\udca1 Reverse each row.\n        \"\"\"\n        n = len(matrix)\n        # Transpose\n        for i in range(n):  # Iterate through the range.\n            for j in range(i + 1, n):  # Iterate through the range.\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        # Reverse rows\n        for row in matrix:  # Iterate over elements.\n            row.reverse()\n        return matrix",
    "keyInsight": "Transpose + reverse = 90\u00b0 clockwise rotation.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        2,
        3
      ],
      [
        4,
        5,
        6
      ],
      [
        7,
        8,
        9
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Rotate Image",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 2",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 4",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 5",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            2,
            3
          ],
          [
            4,
            5,
            6
          ],
          [
            7,
            8,
            9
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Transpose matrix, then reverse each row.\n\nRotate matrix 90\u00b0 clockwise in-place.\nTranspose: swap matrix[i][j] with matrix[j][i].",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[[7,4,1],[8,5,2],[9,6,3]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Rotate matrix 90\u00b0 clockwise in-place.",
      "Transpose: swap matrix[i][j] with matrix[j][i].",
      "Reverse each row."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "fMSJSS7eO1w",
    "problemStatement": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Transpose + Reverse: Transpose matrix, then reverse each row.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def rotate(self, matrix):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rotate(matrix):\n    # Transpose then reverse rows\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for i in range(n):\n        matrix[i].reverse()"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
          "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
          "\ud83d\udca1 Reverse each row."
        ],
        "code": "def rotate(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.\n    - \ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].\n    - \ud83d\udca1 Reverse each row.\n    \"\"\"\n    n = len(matrix)\n    # Transpose\n    for i in range(n):  # Iterate through the range.\n        for j in range(i + 1, n):  # Iterate through the range.\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse rows\n    for row in matrix:  # Iterate over elements.\n        row.reverse()\n    return matrix"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    rotate(matrix) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nclass Solution {\n    /**\n     * @param {any} matrix\n     * @return {any}\n     */\n    rotate(matrix) {\n        matrix.reverse();\n        for (let i = 0; i < matrix.length; ++i) {\n            for (let j = 0; j < i; ++j) {\n                [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n            }\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void rotate(int[][] matrix) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n >> 1; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = t;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                int t = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = t;\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void rotate(vector<vector<int>>& matrix) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        for (int i = 0; i < n >> 1; ++i) {\n            for (int j = 0; j < n; ++j) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rotate(matrix [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) rotate(matrix [][]int) {\n\tn := len(matrix)\n\tfor i := 0; i < n>>1; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tmatrix[i][j], matrix[n-i-1][j] = matrix[n-i-1][j], matrix[i][j]\n\t\t}\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tmatrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn rotate(matrix: &mut Vec<Vec<i32>>) {\n        let n = matrix.len();\n        for i in 0..n / 2 {\n            for j in 0..n {\n                let t = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = t;\n            }\n        }\n        for i in 0..n {\n            for j in 0..i {\n                let t = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = t;\n            }\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def rotate(self, matrix):\n        pass\n"
      },
      "typescript": {
        "code": "/**\n Do not return anything, modify matrix in-place instead.\n */\nclass Solution {\n    rotate(matrix: number[][]): void  {\n    matrix.reverse();\n    for (let i = 0; i < matrix.length; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const t = matrix[i][j];\n            matrix[i][j] = matrix[j][i];\n            matrix[j][i] = t;\n        }\n    }\n}\n}",
        "initialCode": "class Solution {\n    rotate(matrix: number[][]): void {\n        // Your code here\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "maximum-subarray",
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "pattern": "Kadane's Algorithm"
    }
  },
  "set-matrix-zeroes": {
    "title": "Set Matrix Zeroes",
    "pattern": "First Row/Col as Markers",
    "patternEmoji": "0\ufe0f\u20e3",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use first row/col as markers. Track if they need zeroing separately.",
    "intuition": [
      "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
      "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
      "\ud83d\udca1 Handle first row/col separately."
    ],
    "testCases": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]"
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
      }
    ],
    "code": "class Solution:\n    def setZeroes(self, matrix):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf If cell is 0, set entire row and column to 0.\n        - \ud83e\udde0 Use first row/col to mark which rows/cols to zero.\n        - \ud83d\udca1 Handle first row/col separately.\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        firstRow = firstCol = False\n        for r in range(m):  # Iterate through the range.\n            for c in range(n):  # Iterate through the range.\n                if matrix[r][c] == 0:\n                    if r == 0: firstRow = True\n                    if c == 0: firstCol = True\n                    matrix[r][0] = matrix[0][c] = 0\n        for r in range(1, m):  # Iterate through the range.\n            for c in range(1, n):  # Iterate through the range.\n                if matrix[r][0] == 0 or matrix[0][c] == 0:\n                    matrix[r][c] = 0\n        if firstRow:\n            for c in range(n): matrix[0][c] = 0  # Iterate through the range.\n        if firstCol:\n            for r in range(m): matrix[r][0] = 0  # Iterate through the range.\n        return matrix",
    "keyInsight": "First row/col store markers; use separate flags for their own zeroing.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        1,
        1
      ],
      [
        1,
        0,
        1
      ],
      [
        1,
        1,
        1
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Set Matrix Zeroes",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            0,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use first row/col as markers. Track if they need zeroing separately.\n\nIf cell is 0, set entire row and column to 0.\nUse first row/col to mark which rows/cols to zero.",
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "If cell is 0, set entire row and column to 0.",
      "Use first row/col to mark which rows/cols to zero.",
      "Handle first row/col separately."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "T41rL0L3Pnw",
    "problemStatement": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "First Row/Col as Markers: Use first row/col as markers. Track if they need zeroing separately.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def setZeroes(self, matrix):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def setZeroes(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    row_zero = False\n    \n    for r in range(rows):\n        for c in range(cols):\n            if matrix[r][c] == 0:\n                matrix[0][c] = 0\n                if r > 0:\n                    matrix[r][0] = 0\n                else:\n                    row_zero = True\n                    \n    for r in range(1, rows):\n        for c in range(1, cols):\n            if matrix[0][c] == 0 or matrix[r][0] == 0:\n                matrix[r][c] = 0\n                \n    if matrix[0][0] == 0:\n        for r in range(rows): matrix[r][0] = 0\n    if row_zero:\n        for c in range(cols): matrix[0][c] = 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
          "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
          "\ud83d\udca1 Handle first row/col separately."
        ],
        "code": "def setZeroes(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf If cell is 0, set entire row and column to 0.\n    - \ud83e\udde0 Use first row/col to mark which rows/cols to zero.\n    - \ud83d\udca1 Handle first row/col separately.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    firstRow = firstCol = False\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            if matrix[r][c] == 0:\n                if r == 0: firstRow = True\n                if c == 0: firstCol = True\n                matrix[r][0] = matrix[0][c] = 0\n    for r in range(1, m):  # Iterate through the range.\n        for c in range(1, n):  # Iterate through the range.\n            if matrix[r][0] == 0 or matrix[0][c] == 0:\n                matrix[r][c] = 0\n    if firstRow:\n        for c in range(n): matrix[0][c] = 0  # Iterate through the range.\n    if firstCol:\n        for r in range(m): matrix[r][0] = 0  # Iterate through the range.\n    return matrix"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    setZeroes(matrix) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nclass Solution {\n    /**\n     * @param {any} matrix\n     * @return {any}\n     */\n    setZeroes(matrix) {\n        const m = matrix.length;\n        const n = matrix[0].length;\n        const row = Array(m).fill(false);\n        const col = Array(n).fill(false);\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (matrix[i][j] === 0) {\n                    row[i] = col[j] = true;\n                }\n            }\n        }\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (row[i] || col[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    row[i] = col[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (row[i] || col[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void setZeroes(vector<vector<int>>& matrix) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<bool> row(m);\n        vector<bool> col(n);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    row[i] = col[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (row[i] || col[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) setZeroes(matrix [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) setZeroes(matrix [][]int) {\n\trow := make([]bool, len(matrix))\n\tcol := make([]bool, len(matrix[0]))\n\tfor i := range matrix {\n\t\tfor j, x := range matrix[i] {\n\t\t\tif x == 0 {\n\t\t\t\trow[i] = true\n\t\t\t\tcol[j] = true\n\t\t\t}\n\t\t}\n\t}\n\tfor i := range matrix {\n\t\tfor j := range matrix[i] {\n\t\t\tif row[i] || col[j] {\n\t\t\t\tmatrix[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn set_zeroes(matrix: &mut Vec<Vec<i32>>) {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        let mut row = vec![false; m];\n        let mut col = vec![false; n];\n        for i in 0..m {\n            for j in 0..n {\n                if matrix[i][j] == 0 {\n                    row[i] = true;\n                    col[j] = true;\n                }\n            }\n        }\n        for i in 0..m {\n            for j in 0..n {\n                if row[i] || col[j] {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def setZeroes(self, matrix):\n        pass\n"
      },
      "typescript": {
        "code": "/**\n Do not return anything, modify matrix in-place instead.\n */\nclass Solution {\n    setZeroes(matrix: number[][]): void  {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const row: boolean[] = Array(m).fill(false);\n    const col: boolean[] = Array(n).fill(false);\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (matrix[i][j] === 0) {\n                row[i] = col[j] = true;\n            }\n        }\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (row[i] || col[j]) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n}\n}",
        "initialCode": "class Solution {\n    setZeroes(matrix: number[][]): void {\n        // Your code here\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "insert-delete-getrandom-o1",
      "title": "Insert Delete GetRandom O(1)",
      "difficulty": "Medium",
      "pattern": "Hash Map + Dynamic Array"
    }
  },
  "game-of-life": {
    "title": "Game of Life",
    "pattern": "State Encoding",
    "patternEmoji": "\ud83c\udfae",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
    "intuition": [
      "\ud83c\udfaf Apply Conway's Game of Life rules.",
      "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
      "\ud83d\udca1 Second pass: decode to 0/1."
    ],
    "testCases": [
      {
        "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
        "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
      },
      {
        "input": "board = [[1,1],[1,0]]",
        "output": "[[1,1],[1,1]]"
      }
    ],
    "code": "class Solution:\n    def gameOfLife(self, board):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Apply Conway's Game of Life rules.\n        - \ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.\n        - \ud83d\udca1 Second pass: decode to 0/1.\n        \"\"\"\n        m, n = len(board), len(board[0])\n        def countLive(r, c):\n            live = 0\n            for dr in [-1, 0, 1]:  # Iterate over elements.\n                for dc in [-1, 0, 1]:  # Iterate over elements.\n                    if dr == 0 and dc == 0: continue\n                    nr, nc = r + dr, c + dc\n                    if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                        live += 1\n            return live\n        for r in range(m):  # Iterate through the range.\n            for c in range(n):  # Iterate through the range.\n                live = countLive(r, c)\n                if board[r][c] == 1:\n                    if live < 2 or live > 3: board[r][c] = 2  # dies\n                else:\n                    if live == 3: board[r][c] = 3  # becomes live\n        for r in range(m):  # Iterate through the range.\n            for c in range(n):  # Iterate through the range.\n                board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n        return board",
    "keyInsight": "Encode transitions to update in-place without auxiliary space.",
    "visualizationType": "matrix",
    "initialState": [
      [
        0,
        1,
        0
      ],
      [
        0,
        0,
        1
      ],
      [
        1,
        1,
        1
      ],
      [
        0,
        0,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Game of Life",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.\n\nApply Conway's Game of Life rules.\nUse extra states to encode old->new: 2=was live, 3=was dead now live.",
    "examples": [
      {
        "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
        "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Apply Conway's Game of Life rules.",
      "Use extra states to encode old->new: 2=was live, 3=was dead now live.",
      "Second pass: decode to 0/1."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "fei4bJQdBUQ",
    "problemStatement": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "State Encoding: Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def gameOfLife(self, board):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def gameOfLife(board):\n    # 0->0=0, 1->1=1, 0->1=2, 1->0=3\n    rows, cols = len(board), len(board[0])\n    for r in range(rows):\n        for c in range(cols):\n            nei = 0\n            for i in range(max(0, r-1), min(rows, r+2)):\n                for j in range(max(0, c-1), min(cols, c+2)):\n                    if (i, j) != (r, c) and (board[i][j] in [1, 3]):\n                        nei += 1\n            if board[r][c] == 1:\n                if nei < 2 or nei > 3: board[r][c] = 3\n            else:\n                if nei == 3: board[r][c] = 2\n                \n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] in [2, 3]:\n                board[r][c] = 1 if board[r][c] == 2 else 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Apply Conway's Game of Life rules.",
          "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
          "\ud83d\udca1 Second pass: decode to 0/1."
        ],
        "code": "def gameOfLife(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Apply Conway's Game of Life rules.\n    - \ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.\n    - \ud83d\udca1 Second pass: decode to 0/1.\n    \"\"\"\n    m, n = len(board), len(board[0])\n    def countLive(r, c):\n        live = 0\n        for dr in [-1, 0, 1]:  # Iterate over elements.\n            for dc in [-1, 0, 1]:  # Iterate over elements.\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                    live += 1\n        return live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            live = countLive(r, c)\n            if board[r][c] == 1:\n                if live < 2 or live > 3: board[r][c] = 2  # dies\n            else:\n                if live == 3: board[r][c] = 3  # becomes live\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n    return board"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    gameOfLife(board) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} board\n     * @return {any}\n     */\n    gameOfLife(board) {\n        const directions = [[1, -1], [1, 0], [1, 1], [0, -1], [0, 1], [-1, -1], [-1, 0], [-1, 1]];\n        const r = board.length;\n        const c = board[0].length;\n\n        for (let i = 0; i < r; i++) {\n          for (let j = 0; j < c; j++) {\n            let lives = 0;\n            for (const d of directions) {\n              if (d[0] + i < 0 || d[0] + i >= r || d[1] + j < 0 || d[1] + j >= c) {\n                continue;\n              } else if (board[d[0] + i][d[1] + j] === 1 || board[d[0] + i][d[1] + j] === 2) {\n                lives++;\n              }\n            }\n            if (board[i][j] === 0 && lives === 3) {\n              board[i][j] = 3;\n            } else if (board[i][j] === 1 && (lives < 2 || lives > 3)) {\n              board[i][j] = 2;\n            }\n          }\n        }\n\n        for (let i = 0; i < r; i++) {\n          for (let j = 0; j < c; j++) {\n            board[i][j] %= 2;\n          }\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void gameOfLife(int[][] board) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void gameOfLife(int[][] board) {\n        int m = board.length, n = board[0].length;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int live = -board[i][j];\n                for (int x = i - 1; x <= i + 1; ++x) {\n                    for (int y = j - 1; y <= j + 1; ++y) {\n                        if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] > 0) {\n                            ++live;\n                        }\n                    }\n                }\n                if (board[i][j] == 1 && (live < 2 || live > 3)) {\n                    board[i][j] = 2;\n                }\n                if (board[i][j] == 0 && live == 3) {\n                    board[i][j] = -1;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == 2) {\n                    board[i][j] = 0;\n                } else if (board[i][j] == -1) {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void gameOfLife(vector<vector<int>>& board) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void gameOfLife(vector<vector<int>>& board) {\n        int m = board.size(), n = board[0].size();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int live = -board[i][j];\n                for (int x = i - 1; x <= i + 1; ++x) {\n                    for (int y = j - 1; y <= j + 1; ++y) {\n                        if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] > 0) {\n                            ++live;\n                        }\n                    }\n                }\n                if (board[i][j] == 1 && (live < 2 || live > 3)) {\n                    board[i][j] = 2;\n                }\n                if (board[i][j] == 0 && live == 3) {\n                    board[i][j] = -1;\n                }\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == 2) {\n                    board[i][j] = 0;\n                } else if (board[i][j] == -1) {\n                    board[i][j] = 1;\n                }\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) gameOfLife(board [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) gameOfLife(board [][]int) {\n\tm, n := len(board), len(board[0])\n\tfor i := 0; i < m; i++ {\n\t\tfor j, v := range board[i] {\n\t\t\tlive := -v\n\t\t\tfor x := i - 1; x <= i+1; x++ {\n\t\t\t\tfor y := j - 1; y <= j+1; y++ {\n\t\t\t\t\tif x >= 0 && x < m && y >= 0 && y < n && board[x][y] > 0 {\n\t\t\t\t\t\tlive++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif v == 1 && (live < 2 || live > 3) {\n\t\t\t\tboard[i][j] = 2\n\t\t\t}\n\t\t\tif v == 0 && live == 3 {\n\t\t\t\tboard[i][j] = -1\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j, v := range board[i] {\n\t\t\tif v == 2 {\n\t\t\t\tboard[i][j] = 0\n\t\t\t}\n\t\t\tif v == -1 {\n\t\t\t\tboard[i][j] = 1\n\t\t\t}\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn game_of_life(board: &mut Vec<Vec<i32>>) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "const DIR: [(i32, i32); 8] = [\n    (-1, 0),\n    (1, 0),\n    (0, -1),\n    (0, 1),\n    (-1, -1),\n    (-1, 1),\n    (1, -1),\n    (1, 1),\n];\n\nimpl Solution {\n    #[allow(dead_code)]\n    pub fn game_of_life(board: &mut Vec<Vec<i32>>) {\n        let n = board.len();\n        let m = board[0].len();\n        let mut weight_vec: Vec<Vec<i32>> = vec![vec![0; m]; n];\n\n        // Initialize the weight vector\n        for i in 0..n {\n            for j in 0..m {\n                if board[i][j] == 0 {\n                    continue;\n                }\n                for (dx, dy) in DIR {\n                    let x = (i as i32) + dx;\n                    let y = (j as i32) + dy;\n                    if Self::check_bounds(x, y, n as i32, m as i32) {\n                        weight_vec[x as usize][y as usize] += 1;\n                    }\n                }\n            }\n        }\n\n        // Update the board\n        for i in 0..n {\n            for j in 0..m {\n                if weight_vec[i][j] < 2 {\n                    board[i][j] = 0;\n                } else if weight_vec[i][j] <= 3 {\n                    if board[i][j] == 0 && weight_vec[i][j] == 3 {\n                        board[i][j] = 1;\n                    }\n                } else {\n                    board[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    #[allow(dead_code)]\n    fn check_bounds(i: i32, j: i32, n: i32, m: i32) -> bool {\n        i >= 0 && i < n && j >= 0 && j < m\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def gameOfLife(self, board):\n        pass\n"
      },
      "typescript": {
        "code": "/**\n Do not return anything, modify board in-place instead.\n */\nclass Solution {\n    gameOfLife(board: number[][]): void  {\n    const m = board.length;\n    const n = board[0].length;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            let live = -board[i][j];\n            for (let x = i - 1; x <= i + 1; ++x) {\n                for (let y = j - 1; y <= j + 1; ++y) {\n                    if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] > 0) {\n                        ++live;\n                    }\n                }\n            }\n            if (board[i][j] === 1 && (live < 2 || live > 3)) {\n                board[i][j] = 2;\n            }\n            if (board[i][j] === 0 && live === 3) {\n                board[i][j] = -1;\n            }\n        }\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (board[i][j] === 2) {\n                board[i][j] = 0;\n            }\n            if (board[i][j] === -1) {\n                board[i][j] = 1;\n            }\n        }\n    }\n}\n}",
        "initialCode": "class Solution {\n    gameOfLife(board: number[][]): void {\n        // Your code here\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    }
  },
  "summary-ranges": {
    "title": "Summary Ranges",
    "pattern": "Linear Scan",
    "patternEmoji": "\ud83d\udccb",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track start, extend while consecutive, format range.",
    "intuition": [
      "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
      "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
      "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
    ],
    "testCases": [
      {
        "input": "nums = [0,1,2,4,5,7]",
        "output": "[\"0->2\",\"4->5\",\"7\"]"
      },
      {
        "input": "nums = [0,2,3,4,6,8,9]",
        "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
      }
    ],
    "code": "class Solution:\n    def summaryRanges(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Return smallest sorted list of ranges covering all numbers.\n        - \ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].\n        - \ud83d\udca1 Format as 'a->b' or just 'a' if single.\n        \"\"\"\n        if not nums: return []\n        res = []  # Initialize list to store results.\n        start = nums[0]\n        for i in range(1, len(nums) + 1):  # Iterate through the range.\n            if i == len(nums) or nums[i] != nums[i - 1] + 1:\n                if start == nums[i - 1]:\n                    res.append(str(start))  # Add to end.\n                else:\n                    res.append(f'{start}->{nums[i - 1]}')  # Add to end.\n                if i < len(nums):\n                    start = nums[i]\n        return res  # Return the final result.",
    "keyInsight": "Use index i-1 for end of range when gap detected.",
    "visualizationType": "array",
    "initialState": [
      0,
      1,
      2,
      4,
      5,
      7
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          }
        ],
        "transientMessage": "Initialization: start = nums[0] = 0",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Checking if nums[1] == nums[0] + 1 (1 == 0 + 1)",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 2,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Checking if nums[2] == nums[1] + 1 (2 == 1 + 1)",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 3,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Checking if nums[3] == nums[2] + 1 (4 != 2 + 1)",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 2,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Appending range '0->2' to result",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 3,
            "label": "nums[i]"
          }
        ],
        "transientMessage": "Updating start to nums[3] = 4",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 4,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Checking if nums[4] == nums[3] + 1 (5 == 4 + 1)",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 5,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Checking if nums[5] == nums[4] + 1 (7 != 5 + 1)",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4,
          5
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 4,
            "label": "nums[i-1]"
          }
        ],
        "transientMessage": "Appending range '4->5' to result",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 5,
            "label": "nums[i]"
          }
        ],
        "transientMessage": "Updating start to nums[5] = 7",
        "arrayState": [
          0,
          1,
          2,
          4,
          5,
          7
        ]
      }
    ],
    "description": "Track start, extend while consecutive, format range.\n\nReturn smallest sorted list of ranges covering all numbers.\nStart a range, extend while nums[i]+1 == nums[i+1].",
    "examples": [
      {
        "input": "nums = [0,1,2,4,5,7]",
        "output": "[\"0->2\",\"4->5\",\"7\"]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Return smallest sorted list of ranges covering all numbers.",
      "Start a range, extend while nums[i]+1 == nums[i+1].",
      "Format as 'a->b' or just 'a' if single."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "ZHJDwbfqoa8",
    "problemStatement": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Linear Scan: Track start, extend while consecutive, format range.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def summaryRanges(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def summaryRanges(nums):\n    res = []\n    i = 0\n    while i < len(nums):\n        start = nums[i]\n        while i + 1 < len(nums) and nums[i+1] == nums[i] + 1:\n            i += 1\n        if start != nums[i]:\n            res.append(str(start) + \"->\" + str(nums[i]))\n        else:\n            res.append(str(start))\n        i += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
          "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
          "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
        ],
        "code": "def summaryRanges(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return smallest sorted list of ranges covering all numbers.\n    - \ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].\n    - \ud83d\udca1 Format as 'a->b' or just 'a' if single.\n    \"\"\"\n    if not nums: return []\n    res = []  # Initialize list to store results.\n    start = nums[0]\n    for i in range(1, len(nums) + 1):  # Iterate through the range.\n        if i == len(nums) or nums[i] != nums[i - 1] + 1:\n            if start == nums[i - 1]:\n                res.append(str(start))  # Add to end.\n            else:\n                res.append(f'{start}->{nums[i - 1]}')  # Add to end.\n            if i < len(nums):\n                start = nums[i]\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    summaryRanges(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    summaryRanges(nums) {\n        const result = [];\n        for (let i = 0, n = nums[0]; i < nums.length; i++) {\n          if (nums[i] + 1 !== nums[i + 1]) {\n            result.push(nums[i] === n ? `${n}` : `${n}->${nums[i]}`);\n            n = nums[i + 1];\n          }\n      }\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> ans = new ArrayList<>();\n        for (int i = 0, j, n = nums.length; i < n; i = j + 1) {\n            j = i;\n            while (j + 1 < n && nums[j + 1] == nums[j] + 1) {\n                ++j;\n            }\n            ans.add(f(nums, i, j));\n        }\n        return ans;\n    }\n\n    private String f(int[] nums, int i, int j) {\n        return i == j ? nums[i] + \"\" : String.format(\"%d->%d\", nums[i], nums[j]);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> summaryRanges(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> ans;\n        auto f = [&](int i, int j) {\n            return i == j ? to_string(nums[i]) : to_string(nums[i]) + \"->\" + to_string(nums[j]);\n        };\n        for (int i = 0, j, n = nums.size(); i < n; i = j + 1) {\n            j = i;\n            while (j + 1 < n && nums[j + 1] == nums[j] + 1) {\n                ++j;\n            }\n            ans.emplace_back(f(i, j));\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) summaryRanges(nums []int) (ans []string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) summaryRanges(nums []int) (ans []string) {\n\tf := func(i, j int) string {\n\t\tif i == j {\n\t\t\treturn strconv.Itoa(nums[i])\n\t\t}\n\t\treturn strconv.Itoa(nums[i]) + \"->\" + strconv.Itoa(nums[j])\n\t}\n\tfor i, j, n := 0, 0, len(nums); i < n; i = j + 1 {\n\t\tj = i\n\t\tfor j+1 < n && nums[j+1] == nums[j]+1 {\n\t\t\tj++\n\t\t}\n\t\tans = append(ans, f(i, j))\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n        if nums.is_empty() {\n            return vec![];\n        }\n\n        let mut ret = Vec::new();\n        let mut start = nums[0];\n        let mut prev = nums[0];\n        let mut current = 0;\n        let n = nums.len();\n\n        for i in 1..n {\n            current = nums[i];\n            if current != prev + 1 {\n                if start == prev {\n                    ret.push(start.to_string());\n                } else {\n                    ret.push(start.to_string() + \"->\" + &prev.to_string());\n                }\n                start = current;\n                prev = current;\n            } else {\n                prev = current;\n            }\n        }\n\n        if start == prev {\n            ret.push(start.to_string());\n        } else {\n            ret.push(start.to_string() + \"->\" + &prev.to_string());\n        }\n\n        ret\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def summaryRanges(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    summaryRanges(nums: number[]): string[]  {\n    const f = (i: number, j: number): string => {\n        return i === j ? `${nums[i]}` : `${nums[i]}->${nums[j]}`;\n    };\n    const n = nums.length;\n    const ans: string[] = [];\n    for (let i = 0, j = 0; i < n; i = j + 1) {\n        j = i;\n        while (j + 1 < n && nums[j + 1] === nums[j] + 1) {\n            ++j;\n        }\n        ans.push(f(i, j));\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    summaryRanges(nums: number[]): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "contains-duplicate",
      "title": "Contains Duplicate",
      "difficulty": "Easy",
      "pattern": "Hash Set"
    }
  },
  "merge-intervals": {
    "title": "Merge Intervals",
    "pattern": "Sort + Merge",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Sort by start, merge overlaps into result.",
    "intuition": [
      "\ud83c\udfaf Merge all overlapping intervals.",
      "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
      "\ud83d\udca1 Otherwise, add as new interval."
    ],
    "testCases": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]"
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]"
      }
    ],
    "code": "class Solution:\n    def merge(self, intervals):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Merge all overlapping intervals.\n        - \ud83e\udde0 Sort by start. If current overlaps last, extend end.\n        - \ud83d\udca1 Otherwise, add as new interval.\n        \"\"\"\n        intervals.sort(key=lambda x: x[0])\n        res = []  # Initialize list to store results.\n        for interval in intervals:  # Iterate over elements.\n            if res and res[-1][1] >= interval[0]:\n                res[-1][1] = max(res[-1][1], interval[1])  # Take the maximum value.\n            else:\n                res.append(interval)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "After sorting, overlapping intervals are adjacent.",
    "visualizationType": "array",
    "initialState": [
      1,
      3,
      2,
      6,
      8,
      10,
      15,
      18
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Merge Intervals",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 2",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 6",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 8",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 10",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          3,
          2,
          6,
          8,
          10,
          15,
          18
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Sort by start, merge overlaps into result.\n\nMerge all overlapping intervals.\nSort by start. If current overlaps last, extend end.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Merge all overlapping intervals.",
      "Sort by start. If current overlaps last, extend end.",
      "Otherwise, add as new interval."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "44H3cEC2fFM",
    "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Sort + Merge: Sort by start, merge overlaps into result.",
    "mentalModel": "Like arranging a hand of cards by rank and suit.",
    "initialCode": "class Solution:\n    def merge(self, intervals):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_end = res[-1][1]\n        if start <= last_end:\n            res[-1][1] = max(last_end, end)\n        else:\n            res.append([start, end])\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Merge all overlapping intervals.",
          "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
          "\ud83d\udca1 Otherwise, add as new interval."
        ],
        "code": "def merge(intervals):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge all overlapping intervals.\n    - \ud83e\udde0 Sort by start. If current overlaps last, extend end.\n    - \ud83d\udca1 Otherwise, add as new interval.\n    \"\"\"\n    intervals.sort(key=lambda x: x[0])\n    res = []  # Initialize list to store results.\n    for interval in intervals:  # Iterate over elements.\n        if res and res[-1][1] >= interval[0]:\n            res[-1][1] = max(res[-1][1], interval[1])  # Take the maximum value.\n        else:\n            res.append(interval)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    merge(intervals) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nclass Solution {\n    /**\n     * @param {any} intervals\n     * @return {any}\n     */\n    merge(intervals) {\n        intervals.sort((a, b) => a[0] - b[0]);\n        const result = [];\n        const n = intervals.length;\n        let i = 0;\n        while (i < n) {\n            const left = intervals[i][0];\n            let right = intervals[i][1];\n            while (true) {\n                i++;\n                if (i < n && right >= intervals[i][0]) {\n                    right = Math.max(right, intervals[i][1]);\n                } else {\n                    result.push([left, right]);\n                    break;\n                }\n            }\n    }\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n        int st = intervals[0][0], ed = intervals[0][1];\n        List<int[]> ans = new ArrayList<>();\n        for (int i = 1; i < intervals.length; ++i) {\n            int s = intervals[i][0], e = intervals[i][1];\n            if (ed < s) {\n                ans.add(new int[] {st, ed});\n                st = s;\n                ed = e;\n            } else {\n                ed = Math.max(ed, e);\n            }\n        }\n        ans.add(new int[] {st, ed});\n        return ans.toArray(new int[ans.size()][]);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        int st = intervals[0][0], ed = intervals[0][1];\n        vector<vector<int>> ans;\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (ed < intervals[i][0]) {\n                ans.push_back({st, ed});\n                st = intervals[i][0];\n                ed = intervals[i][1];\n            } else {\n                ed = max(ed, intervals[i][1]);\n            }\n        }\n        ans.push_back({st, ed});\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) merge(intervals [][]int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) merge(intervals [][]int) (ans [][]int) {\n\tsort.Slice(intervals, func(i, j int) bool {\n\t\treturn intervals[i][0] < intervals[j][0]\n\t})\n\tst, ed := intervals[0][0], intervals[0][1]\n\tfor _, e := range intervals[1:] {\n\t\tif ed < e[0] {\n\t\t\tans = append(ans, []int{st, ed})\n\t\t\tst, ed = e[0], e[1]\n\t\t} else if ed < e[1] {\n\t\t\ted = e[1]\n\t\t}\n\t}\n\tans = append(ans, []int{st, ed})\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        intervals.sort_unstable_by(|a, b| a[0].cmp(&b[0]));\n        let n = intervals.len();\n        let mut res = vec![];\n        let mut i = 0;\n        while i < n {\n            let l = intervals[i][0];\n            let mut r = intervals[i][1];\n            i += 1;\n            while i < n && r >= intervals[i][0] {\n                r = r.max(intervals[i][1]);\n                i += 1;\n            }\n            res.push(vec![l, r]);\n        }\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def merge(self, intervals):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    merge(intervals: number[][]): number[][]  {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const ans: number[][] = [];\n    let [st, ed] = intervals[0];\n    for (const [s, e] of intervals.slice(1)) {\n        if (ed < s) {\n            ans.push([st, ed]);\n            [st, ed] = [s, e];\n        } else {\n            ed = Math.max(ed, e);\n        }\n    }\n    ans.push([st, ed]);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    merge(intervals: number[][]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "simplify-path",
      "title": "Simplify Path",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "insert-interval": {
    "title": "Insert Interval",
    "pattern": "Merge on Insert",
    "patternEmoji": "\u2795",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Add all before, merge overlaps, add all after.",
    "intuition": [
      "\ud83c\udfaf Insert and merge new interval into sorted list.",
      "\ud83e\udde0 Three phases: before, during overlap, after.",
      "\ud83d\udca1 Merge during overlap by extending bounds."
    ],
    "testCases": [
      {
        "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
        "output": "[[1,5],[6,9]]"
      },
      {
        "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
        "output": "[[1,2],[3,10],[12,16]]"
      }
    ],
    "code": "class Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Insert and merge new interval into sorted list.\n        - \ud83e\udde0 Three phases: before, during overlap, after.\n        - \ud83d\udca1 Merge during overlap by extending bounds.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        for i, intv in enumerate(intervals):  # Iterate over elements.\n            if newInterval[1] < intv[0]:\n                res.append(newInterval)  # Add to end.\n                return res + intervals[i:]  # Return the final result.\n            elif newInterval[0] > intv[1]:\n                res.append(intv)  # Add to end.\n            else:\n                newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]  # Take the maximum value.\n        res.append(newInterval)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "Keep merging into newInterval until no more overlap.",
    "visualizationType": "array",
    "initialState": [
      1,
      3,
      6,
      9
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Insert Interval",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 9",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          3,
          6,
          9
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Add all before, merge overlaps, add all after.\n\nInsert and merge new interval into sorted list.\nThree phases: before, during overlap, after.",
    "examples": [
      {
        "input": "intervals = [[1,3],[6,9]]; newInterval = [2,5]",
        "output": "[[1,5],[6,9]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Insert and merge new interval into sorted list.",
      "Three phases: before, during overlap, after.",
      "Merge during overlap by extending bounds."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "A8NUOmlwOlM",
    "problemStatement": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Merge on Insert: Add all before, merge overlaps, add all after.",
    "mentalModel": "Like combining two sorted piles of papers into one sorted stack.",
    "initialCode": "class Solution:\n    def insert(self, intervals, newInterval):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def insert(intervals, newInterval):\n    res = []\n    for i in range(len(intervals)):\n        if newInterval[1] < intervals[i][0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intervals[i][1]:\n            res.append(intervals[i])\n        else:\n            newInterval = [min(newInterval[0], intervals[i][0]),\n                           max(newInterval[1], intervals[i][1])]\n    res.append(newInterval)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Insert and merge new interval into sorted list.",
          "\ud83e\udde0 Three phases: before, during overlap, after.",
          "\ud83d\udca1 Merge during overlap by extending bounds."
        ],
        "code": "def insert(intervals, newInterval):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Insert and merge new interval into sorted list.\n    - \ud83e\udde0 Three phases: before, during overlap, after.\n    - \ud83d\udca1 Merge during overlap by extending bounds.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    for i, intv in enumerate(intervals):  # Iterate over elements.\n        if newInterval[1] < intv[0]:\n            res.append(newInterval)  # Add to end.\n            return res + intervals[i:]  # Return the final result.\n        elif newInterval[0] > intv[1]:\n            res.append(intv)  # Add to end.\n        else:\n            newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]  # Take the maximum value.\n    res.append(newInterval)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    insert(intervals, newInterval) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} intervals, newInterval\n     * @return {any}\n     */\n    insert(intervals, newInterval) {\n        const result = [];\n\n        for (let i = 0; i < intervals.length; i++) {\n          if (newInterval[1] < intervals[i][0]) {\n            result.push(newInterval);\n            return [...result, ...intervals.slice(i)];\n          } else if (newInterval[0] > intervals[i][1]) {\n            result.push(intervals[i]);\n          } else {\n            newInterval = [\n              Math.min(newInterval[0], intervals[i][0]),\n              Math.max(newInterval[1], intervals[i][1]),\n            ];\n          }\n      }\n\n    result.push(newInterval);\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        int[][] newIntervals = new int[intervals.length + 1][2];\n        for (int i = 0; i < intervals.length; ++i) {\n            newIntervals[i] = intervals[i];\n        }\n        newIntervals[intervals.length] = newInterval;\n        return merge(newIntervals);\n    }\n\n    private int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        List<int[]> ans = new ArrayList<>();\n        ans.add(intervals[0]);\n        for (int i = 1; i < intervals.length; ++i) {\n            int s = intervals[i][0], e = intervals[i][1];\n            if (ans.get(ans.size() - 1)[1] < s) {\n                ans.add(intervals[i]);\n            } else {\n                ans.get(ans.size() - 1)[1] = Math.max(ans.get(ans.size() - 1)[1], e);\n            }\n        }\n        return ans.toArray(new int[ans.size()][]);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        intervals.emplace_back(newInterval);\n        return merge(intervals);\n    }\n\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> ans;\n        ans.emplace_back(intervals[0]);\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (ans.back()[1] < intervals[i][0]) {\n                ans.emplace_back(intervals[i]);\n            } else {\n                ans.back()[1] = max(ans.back()[1], intervals[i][1]);\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) insert(intervals [][]int, newInterval []int) [][]int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) insert(intervals [][]int, newInterval []int) [][]int {\n\tmerge := func(intervals [][]int) (ans [][]int) {\n\t\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\t\tans = append(ans, intervals[0])\n\t\tfor _, e := range intervals[1:] {\n\t\t\tif ans[len(ans)-1][1] < e[0] {\n\t\t\t\tans = append(ans, e)\n\t\t\t} else {\n\t\t\t\tans[len(ans)-1][1] = max(ans[len(ans)-1][1], e[1])\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\tintervals = append(intervals, newInterval)\n\treturn merge(intervals)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut merged_intervals = intervals.clone();\n        merged_intervals.push(vec![new_interval[0], new_interval[1]]);\n        // sort by elem[0]\n        merged_intervals.sort_by_key(|elem| elem[0]);\n        // merge interval\n        let mut result = vec![];\n\n        for interval in merged_intervals {\n            if result.is_empty() {\n                result.push(interval);\n                continue;\n            }\n\n            let last_elem = result.last_mut().unwrap();\n            if interval[0] > last_elem[1] {\n                result.push(interval);\n            } else {\n                last_elem[1] = last_elem[1].max(interval[1]);\n            }\n        }\n        result\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def insert(self, intervals, newInterval):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    insert(intervals: number[][], newInterval: number[]): number[][]  {\n    const merge = (intervals: number[][]): number[][] => {\n        intervals.sort((a, b) => a[0] - b[0]);\n        const ans: number[][] = [intervals[0]];\n        for (let i = 1; i < intervals.length; ++i) {\n            if (ans.at(-1)[1] < intervals[i][0]) {\n                ans.push(intervals[i]);\n            } else {\n                ans.at(-1)[1] = Math.max(ans.at(-1)[1], intervals[i][1]);\n            }\n        }\n        return ans;\n    };\n\n    intervals.push(newInterval);\n    return merge(intervals);\n}\n}",
        "initialCode": "class Solution {\n    insert(intervals: number[][], newInterval: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "maximum-subarray",
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "pattern": "Kadane's Algorithm"
    }
  },
  "minimum-number-of-arrows-to-burst-balloons": {
    "title": "Minimum Number of Arrows to Burst Balloons",
    "pattern": "Greedy Interval",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Sort by end. Shoot at end of first, skip all overlapping.",
    "intuition": [
      "\ud83c\udfaf Minimum arrows to burst all balloons.",
      "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
      "\ud83d\udca1 Greedy: shoot as late as possible within current set."
    ],
    "testCases": [
      {
        "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
        "output": "2"
      },
      {
        "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
        "output": "4"
      },
      {
        "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    def findMinArrowPoints(self, points):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Minimum arrows to burst all balloons.\n        - \ud83e\udde0 Sort by end point. Each arrow at end pops all touching.\n        - \ud83d\udca1 Greedy: shoot as late as possible within current set.\n        \"\"\"\n        if not points: return 0\n        points.sort(key=lambda x: x[1])\n        arrows = 1\n        end = points[0][1]\n        for start, e in points[1:]:  # Iterate over elements.\n            if start > end:\n                arrows += 1\n                end = e\n        return arrows",
    "keyInsight": "Sorting by end allows greedy selection of arrow positions.",
    "visualizationType": "array",
    "initialState": [
      [
        10,
        16
      ],
      [
        2,
        8
      ],
      [
        1,
        6
      ],
      [
        7,
        12
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Number of Arrows to Burst Balloons",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 10,16",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2,8",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1,6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 7,12",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            10,
            16
          ],
          [
            2,
            8
          ],
          [
            1,
            6
          ],
          [
            7,
            12
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Sort by end. Shoot at end of first, skip all overlapping.\n\nMinimum arrows to burst all balloons.\nSort by end point. Each arrow at end pops all touching.",
    "examples": [
      {
        "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Minimum arrows to burst all balloons.",
      "Sort by end point. Each arrow at end pops all touching.",
      "Greedy: shoot as late as possible within current set."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "lPmkKnvNPrw",
    "problemStatement": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Greedy Interval: Sort by end. Shoot at end of first, skip all overlapping.",
    "suggestedNextQuestion": {
      "slug": "non-overlapping-intervals",
      "title": "Non Overlapping Intervals",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def findMinArrowPoints(self, points):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findMinArrowShots(points):\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for i in range(1, len(points)):\n        if points[i][0] > end:\n            arrows += 1\n            end = points[i][1]\n    return arrows"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Minimum arrows to burst all balloons.",
          "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
          "\ud83d\udca1 Greedy: shoot as late as possible within current set."
        ],
        "code": "def findMinArrowPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum arrows to burst all balloons.\n    - \ud83e\udde0 Sort by end point. Each arrow at end pops all touching.\n    - \ud83d\udca1 Greedy: shoot as late as possible within current set.\n    \"\"\"\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for start, e in points[1:]:  # Iterate over elements.\n        if start > end:\n            arrows += 1\n            end = e\n    return arrows"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findMinArrowShots(points) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} points\n     * @return {any}\n     */\n    findMinArrowShots(points) {\n        let result = 0;\n        let i = 0;\n\n        points.sort(([a], [b]) => a - b);\n\n        while (i < points.length) {\n          let [left, right] = points[i];\n          i++;\n          while (i < points.length && points[i][0] <= right && points[i][1] >= left) {\n            left = Math.max(left, points[i][0]);\n            right = Math.min(right, points[i][1]);\n            i++;\n          }\n          result++;\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        // \u76f4\u63a5 a[1] - b[1] \u53ef\u80fd\u4f1a\u6ea2\u51fa\n        Arrays.sort(points, Comparator.comparingInt(a -> a[1]));\n        int ans = 0;\n        long last = -(1L << 60);\n        for (var p : points) {\n            int a = p[0], b = p[1];\n            if (a > last) {\n                ++ans;\n                last = b;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findMinArrowShots(vector<vector<int>>& points) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b) {\n            return a[1] < b[1];\n        });\n        int ans = 0;\n        long long last = -(1LL << 60);\n        for (auto& p : points) {\n            int a = p[0], b = p[1];\n            if (a > last) {\n                ++ans;\n                last = b;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findMinArrowShots(points [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findMinArrowShots(points [][]int) (ans int) {\n\tsort.Slice(points, func(i, j int) bool { return points[i][1] < points[j][1] })\n\tlast := -(1 << 60)\n\tfor _, p := range points {\n\t\ta, b := p[0], p[1]\n\t\tif a > last {\n\t\t\tans++\n\t\t\tlast = b\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {\n        if points.is_empty() { return 0; }\n        points.sort_by_key(|k| k[1]);\n        let mut arrows = 1;\n        let mut end = points[0][1];\n        for i in 1..points.len() {\n            if points[i][0] > end {\n                arrows += 1;\n                end = points[i][1];\n            }\n        }\n        arrows\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findMinArrowPoints(self, points):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findMinArrowPoints(points: number[][]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    findMinArrowPoints(points: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "reverse-nodes-in-k-group": {
    "title": "Reverse Nodes in k-Group",
    "pattern": "Iterative Reversal",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Reverse k nodes at a time, connect reversed groups.",
    "intuition": [
      "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
      "\ud83e\udde0 Find kth node, reverse that segment, connect.",
      "\ud83d\udca1 Use dummy head for cleaner edge case handling."
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[2,1,4,3,5]"
      },
      {
        "input": "head = [1,2,3,4,5], k = 3",
        "output": "[3,2,1,4,5]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Reverse every k nodes, leave remainder as-is.\n        - \ud83e\udde0 Find kth node, reverse that segment, connect.\n        - \ud83d\udca1 Use dummy head for cleaner edge case handling.\n        \"\"\"\n        dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n        prevGroup = dummy\n        while True:\n            kth = prevGroup\n            for _ in range(k):  # Iterate through the range.\n                kth = kth.next\n                if not kth:\n                    return dummy.next  # Return head of the new list.\n            nextGroup = kth.next\n            prev, curr = kth.next, prevGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n            tmp = prevGroup.next\n            prevGroup.next = kth\n            prevGroup = tmp\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "Track prevGroup to connect reversed segments.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reverse Nodes in k-Group",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Reverse k nodes at a time, connect reversed groups.\n\nReverse every k nodes, leave remainder as-is.\nFind kth node, reverse that segment, connect.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]; k = 2",
        "output": "[2,1,4,3,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Reverse every k nodes, leave remainder as-is.",
      "Find kth node, reverse that segment, connect.",
      "Use dummy head for cleaner edge case handling."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "1UOPsfP85V4",
    "problemStatement": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Iterative Reversal: Reverse k nodes at a time, connect reversed groups.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def reverseKGroup(head, k):\n    dummy = ListNode(0, head)\n    groupPrev = dummy\n    \n    while True:\n        kth = groupPrev\n        for i in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        \n        groupNext = kth.next\n        \n        # Reverse group\n        prev, curr = kth.next, groupPrev.next\n        while curr != groupNext:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n            \n        tmp = groupPrev.next\n        groupPrev.next = kth\n        groupPrev = tmp"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
          "\ud83e\udde0 Find kth node, reverse that segment, connect.",
          "\ud83d\udca1 Use dummy head for cleaner edge case handling."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseKGroup(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse every k nodes, leave remainder as-is.\n    - \ud83e\udde0 Find kth node, reverse that segment, connect.\n    - \ud83d\udca1 Use dummy head for cleaner edge case handling.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prevGroup = dummy\n    while True:\n        kth = prevGroup\n        for _ in range(k):  # Iterate through the range.\n            kth = kth.next\n            if not kth:\n                return dummy.next  # Return head of the new list.\n        nextGroup = kth.next\n        prev, curr = kth.next, prevGroup.next\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        tmp = prevGroup.next\n        prevGroup.next = kth\n        prevGroup = tmp\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverseKGroup(head *ListNode, k int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) reverseKGroup(head *ListNode, k int) *ListNode {\n\tdummy := &ListNode{Next: head}\n\tpre := dummy\n\n\tfor pre != nil {\n\t\tcur := pre\n\t\tfor i := 0; i < k; i++ {\n\t\t\tcur = cur.Next\n\t\t\tif cur == nil {\n\t\t\t\treturn dummy.Next\n\t\t\t}\n\t\t}\n\n\t\tnode := pre.Next\n\t\tnxt := cur.Next\n\t\tcur.Next = nil\n\t\tpre.Next = reverse(node)\n\t\tnode.Next = nxt\n\t\tpre = node\n\t}\n\treturn dummy.Next\n}\n\nfunc reverse(head *ListNode) *ListNode {\n\tvar dummy *ListNode\n\tcur := head\n\tfor cur != nil {\n\t\tnxt := cur.Next\n\t\tcur.Next = dummy\n\t\tdummy = cur\n\t\tcur = nxt\n\t}\n\treturn dummy\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {\n        fn reverse(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n            let mut head = head;\n            let mut pre = None;\n            while let Some(mut node) = head {\n                head = node.next.take();\n                node.next = pre.take();\n                pre = Some(node);\n            }\n            pre\n        }\n\n        let mut dummy = Some(Box::new(ListNode::new(0)));\n        let mut pre = &mut dummy;\n        let mut cur = head;\n        while cur.is_some() {\n            let mut q = &mut cur;\n            for _ in 0..k - 1 {\n                if q.is_none() {\n                    break;\n                }\n                q = &mut q.as_mut().unwrap().next;\n            }\n            if q.is_none() {\n                pre.as_mut().unwrap().next = cur;\n                return dummy.unwrap().next;\n            }\n\n            let b = q.as_mut().unwrap().next.take();\n            pre.as_mut().unwrap().next = reverse(cur);\n            while pre.is_some() && pre.as_mut().unwrap().next.is_some() {\n                pre = &mut pre.as_mut().unwrap().next;\n            }\n            cur = b;\n        }\n        dummy.unwrap().next\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) { }\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "text-justification",
      "title": "Text Justification",
      "difficulty": "Hard",
      "pattern": "Greedy + Simulation"
    }
  },
  "remove-nth-node-from-end-of-list": {
    "title": "Remove Nth Node From End of List",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc46\ud83d\udc46",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Advance fast by n, then move both until fast reaches end.",
    "intuition": [
      "\ud83c\udfaf Remove nth node from end in one pass.",
      "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
      "\ud83d\udca1 Use dummy to handle removing head."
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], n = 2",
        "output": "[1,2,3,5]"
      },
      {
        "input": "head = [1], n = 1",
        "output": "[]"
      },
      {
        "input": "head = [1,2], n = 1",
        "output": "[1]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Remove nth node from end in one pass.\n        - \ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.\n        - \ud83d\udca1 Use dummy to handle removing head.\n        \"\"\"\n        dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n        slow = fast = dummy\n        for _ in range(n + 1):  # Iterate through the range.\n            fast = fast.next\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "Dummy node simplifies removing the head case.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Remove Nth Node From End of List",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Advance fast by n, then move both until fast reaches end.\n\nRemove nth node from end in one pass.\nFast pointer leads by n. When fast ends, slow is at target.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]; n = 2",
        "output": "[1,2,3,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Remove nth node from end in one pass.",
      "Fast pointer leads by n. When fast ends, slow is at target.",
      "Use dummy to handle removing head."
    ],
    "relatedProblems": [
      "two-sum",
      "container-with-most-water",
      "3sum"
    ],
    "videoId": "XVuQxVej6y8",
    "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Advance fast by n, then move both until fast reaches end.",
    "suggestedNextQuestion": {
      "slug": "reverse-words-in-a-string",
      "title": "Reverse Words in a String",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    left = right = dummy\n    for _ in range(n + 1):\n        right = right.next\n    while right:\n        left = left.next\n        right = right.next\n    left.next = left.next.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Remove nth node from end in one pass.",
          "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
          "\ud83d\udca1 Use dummy to handle removing head."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeNthFromEnd(head, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove nth node from end in one pass.\n    - \ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.\n    - \ud83d\udca1 Use dummy to handle removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    slow = fast = dummy\n    for _ in range(n + 1):  # Iterate through the range.\n        fast = fast.next\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    slow.next = slow.next.next\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head: ListNode | null, n: number) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head: ListNode | null, n: number) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) removeNthFromEnd(head *ListNode, n int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) removeNthFromEnd(head *ListNode, n int) *ListNode {\n\tdummy := &ListNode{0, head}\n\tfast, slow := dummy, dummy\n\tfor ; n > 0; n-- {\n\t\tfast = fast.Next\n\t}\n\tfor fast.Next != nil {\n\t\tslow, fast = slow.Next, fast.Next\n\t}\n\tslow.Next = slow.Next.Next\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {\n        let mut dummy = Some(Box::new(ListNode { val: 0, next: head }));\n        let mut slow = &mut dummy;\n        let mut fast = &slow.clone();\n        for _ in 0..=n {\n            fast = &fast.as_ref().unwrap().next;\n        }\n        while fast.is_some() {\n            fast = &fast.as_ref().unwrap().next;\n            slow = &mut slow.as_mut().unwrap().next;\n        }\n        slow.as_mut().unwrap().next = slow.as_mut().unwrap().next.as_mut().unwrap().next.take();\n        dummy.unwrap().next\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null, n: number): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null, n: number): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "remove-duplicates-from-sorted-list-ii": {
    "title": "Remove Duplicates from Sorted List II",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Skip all nodes with duplicate values, keep only unique.",
    "intuition": [
      "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
      "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
      "\ud83d\udca1 Dummy head handles removing head."
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,3,4,4,5]",
        "output": "[1,2,5]"
      },
      {
        "input": "head = [1,1,1,2,3]",
        "output": "[2,3]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def deleteDuplicates(self, head):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Remove all duplicated nodes (not just extra copies).\n        - \ud83e\udde0 If cur.val == cur.next.val, skip all with that value.\n        - \ud83d\udca1 Dummy head handles removing head.\n        \"\"\"\n        dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n        prev = dummy  # Initialize previous pointer.\n        while head:\n            if head.next and head.val == head.next.val:\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                prev.next = head.next\n            else:\n                prev = prev.next\n            head = head.next\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "Skip entire duplicate sequences, not just individual copies.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      3,
      4,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Remove Duplicates from Sorted List II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 3",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 4",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 4",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          3,
          4,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Skip all nodes with duplicate values, keep only unique.\n\nRemove all duplicated nodes (not just extra copies).\nIf cur.val == cur.next.val, skip all with that value.",
    "examples": [
      {
        "input": "head = [1,2,3,3,4,4,5]",
        "output": "[1,2,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Remove all duplicated nodes (not just extra copies).",
      "If cur.val == cur.next.val, skip all with that value.",
      "Dummy head handles removing head."
    ],
    "relatedProblems": [
      "two-sum",
      "container-with-most-water",
      "3sum"
    ],
    "videoId": "ycAq8iqh0TI",
    "problemStatement": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "approach": "Two Pointers: Skip all nodes with duplicate values, keep only unique.",
    "suggestedNextQuestion": {
      "slug": "remove-nth-node-from-end-of-list",
      "title": "Remove Nth Node From End of List",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def deleteDuplicates(head):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
          "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
          "\ud83d\udca1 Dummy head handles removing head."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef deleteDuplicates(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all duplicated nodes (not just extra copies).\n    - \ud83e\udde0 If cur.val == cur.next.val, skip all with that value.\n    - \ud83d\udca1 Dummy head handles removing head.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to simplify edge cases.\n    prev = dummy  # Initialize previous pointer.\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* deleteDuplicates(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) deleteDuplicates(head *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) deleteDuplicates(head *ListNode) *ListNode {\n\tdummy := &ListNode{Next: head}\n\tpre, cur := dummy, head\n\tfor cur != nil {\n\t\tfor cur.Next != nil && cur.Next.Val == cur.Val {\n\t\t\tcur = cur.Next\n\t\t}\n\t\tif pre.Next == cur {\n\t\t\tpre = cur\n\t\t} else {\n\t\t\tpre.Next = cur.Next\n\t\t}\n\t\tcur = cur.Next\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn delete_duplicates(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut dummy = Some(Box::new(ListNode::new(101)));\n        let mut pev = dummy.as_mut().unwrap();\n        let mut cur = head;\n        let mut pre = 101;\n        while let Some(mut node) = cur {\n            cur = node.next.take();\n            if node.val == pre || (cur.is_some() && cur.as_ref().unwrap().val == node.val) {\n                pre = node.val;\n            } else {\n                pre = node.val;\n                pev.next = Some(node);\n                pev = pev.next.as_mut().unwrap();\n            }\n        }\n        dummy.unwrap().next\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null) {\n        // No implementation\n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "rotate-list": {
    "title": "Rotate List",
    "pattern": "Cycle + Break",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Make cycle, find new tail at (len - k % len - 1), break.",
    "intuition": [
      "\ud83c\udfaf Rotate list right by k places.",
      "\ud83e\udde0 Connect tail to head, find new tail, break there.",
      "\ud83d\udca1 k % len handles k > len."
    ],
    "testCases": [
      {
        "input": "head = [1,2,3,4,5], k = 2",
        "output": "[4,5,1,2,3]"
      },
      {
        "input": "head = [0,1,2], k = 4",
        "output": "[2,0,1]"
      }
    ],
    "code": "class Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Rotate list right by k places.\n        - \ud83e\udde0 Connect tail to head, find new tail, break there.\n        - \ud83d\udca1 k % len handles k > len.\n        \"\"\"\n        if not head or not head.next or k == 0:\n            return head\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n        k %= length\n        if k == 0:\n            return head\n        tail.next = head  # Make cycle\n        steps = length - k\n        newTail = head\n        for _ in range(steps - 1):  # Iterate through the range.\n            newTail = newTail.next\n        newHead = newTail.next\n        newTail.next = None\n        return newHead",
    "keyInsight": "Creating a cycle simplifies finding the new head/tail.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Rotate List",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Make cycle, find new tail at (len - k % len - 1), break.\n\nRotate list right by k places.\nConnect tail to head, find new tail, break there.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]; k = 2",
        "output": "[4,5,1,2,3]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Rotate list right by k places.",
      "Connect tail to head, find new tail, break there.",
      "k % len handles k > len."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "UcGtPs2LE_c",
    "problemStatement": "Given the head of a linked list, rotate the list to the right by k places.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Cycle + Break: Make cycle, find new tail at (len - k % len - 1), break.",
    "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def rotateRight(self, head, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rotateRight(head, k):\n    if not head: return None\n    if not head.next: return head\n    \n    # Close ring\n    old_tail = head\n    n = 1\n    while old_tail.next:\n        old_tail = old_tail.next\n        n += 1\n    old_tail.next = head\n    \n    # New tail\n    new_tail = head\n    for i in range(n - k % n - 1):\n        new_tail = new_tail.next\n    new_head = new_tail.next\n    \n    # Break ring\n    new_tail.next = None\n    return new_head"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Rotate list right by k places.",
          "\ud83e\udde0 Connect tail to head, find new tail, break there.",
          "\ud83d\udca1 k % len handles k > len."
        ],
        "code": "def rotateRight(head, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Rotate list right by k places.\n    - \ud83e\udde0 Connect tail to head, find new tail, break there.\n    - \ud83d\udca1 k % len handles k > len.\n    \"\"\"\n    if not head or not head.next or k == 0:\n        return head\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    k %= length\n    if k == 0:\n        return head\n    tail.next = head  # Make cycle\n    steps = length - k\n    newTail = head\n    for _ in range(steps - 1):  # Iterate through the range.\n        newTail = newTail.next\n    newHead = newTail.next\n    newTail.next = None\n    return newHead"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head: ListNode | null, k: number): void {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head: ListNode | null, k: number): void {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* rotateRight(ListNode* head, int k) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rotateRight(head *ListNode, k int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\tcur := head\n\tn := 0\n\tfor cur != nil {\n\t\tcur = cur.Next\n\t\tn++\n\t}\n\tk %= n\n\tif k == 0 {\n\t\treturn head\n\t}\n\tfast, slow := head, head\n\tfor i := 0; i < k; i++ {\n\t\tfast = fast.Next\n\t}\n\tfor fast.Next != nil {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\tans := slow.Next\n\tslow.Next = nil\n\tfast.Next = head\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn rotate_right(mut head: Option<Box<ListNode>>, mut k: i32) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn rotate_right(mut head: Option<Box<ListNode>>, mut k: i32) -> Option<Box<ListNode>> {\n        if head.is_none() || k == 0 {\n            return head;\n        }\n        let n = {\n            let mut cur = &head;\n            let mut res = 0;\n            while cur.is_some() {\n                cur = &cur.as_ref().unwrap().next;\n                res += 1;\n            }\n            res\n        };\n        k = k % n;\n        if k == 0 {\n            return head;\n        }\n\n        let mut cur = &mut head;\n        for _ in 0..n - k - 1 {\n            cur = &mut cur.as_mut().unwrap().next;\n        }\n        let mut res = cur.as_mut().unwrap().next.take();\n        cur = &mut res;\n        while cur.is_some() {\n            cur = &mut cur.as_mut().unwrap().next;\n        }\n        *cur = head.take();\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def rotateRight(self, head, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    }
  },
  "partition-list": {
    "title": "Partition List",
    "pattern": "Two Dummy Lists",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Build two lists: less than x, greater or equal. Concatenate.",
    "intuition": [
      "\ud83c\udfaf Partition around x, preserving relative order.",
      "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
      "\ud83d\udca1 Connect them at the end."
    ],
    "testCases": [
      {
        "input": "head = [1,4,3,2,5,2], x = 3",
        "output": "[1,2,2,4,3,5]"
      },
      {
        "input": "head = [2,1], x = 2",
        "output": "[1,2]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def partition(self, head, x):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Partition around x, preserving relative order.\n        - \ud83e\udde0 Two dummy heads for less and greater-or-equal lists.\n        - \ud83d\udca1 Connect them at the end.\n        \"\"\"\n        before = beforeHead = ListNode(0)  # Initialize two lists for partitioning.\n        after = afterHead = ListNode(0)\n        while head:\n            if head.val < x:  # Check logic for partition.\n                before.next = head\n                before = before.next\n            else:\n                after.next = head\n                after = after.next\n            head = head.next\n        after.next = None\n        before.next = afterHead.next\n        return beforeHead.next",
    "keyInsight": "Two lists avoid in-place reordering complexity.",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      4,
      3,
      2,
      5,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Partition List",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 2",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          4,
          3,
          2,
          5,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Build two lists: less than x, greater or equal. Concatenate.\n\nPartition around x, preserving relative order.\nTwo dummy heads for less and greater-or-equal lists.",
    "examples": [
      {
        "input": "head = [1,4,3,2,5,2]; x = 3",
        "output": "[1,2,2,4,3,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Partition around x, preserving relative order.",
      "Two dummy heads for less and greater-or-equal lists.",
      "Connect them at the end."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "KT1iUciJr4g",
    "problemStatement": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Dummy Lists: Build two lists: less than x, greater or equal. Concatenate.",
    "mentalModel": "Like a scavenger hunt. Each clue points to the location of the next clue.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def partition(head, x):\n    before = before_head = ListNode(0)\n    after = after_head = ListNode(0)\n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = after_head.next\n    return before_head.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Partition around x, preserving relative order.",
          "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
          "\ud83d\udca1 Connect them at the end."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef partition(head, x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Partition around x, preserving relative order.\n    - \ud83e\udde0 Two dummy heads for less and greater-or-equal lists.\n    - \ud83d\udca1 Connect them at the end.\n    \"\"\"\n    before = beforeHead = ListNode(0)  # Initialize two lists for partitioning.\n    after = afterHead = ListNode(0)\n    while head:\n        if head.val < x:  # Check logic for partition.\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = afterHead.next\n    return beforeHead.next"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head) {\n        // Your implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode partition(ListNode head, int x) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* partition(ListNode* head, int x) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) partition(head *ListNode, x int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) partition(head *ListNode, x int) *ListNode {\n\tl, r := &ListNode{}, &ListNode{}\n\ttl, tr := l, r\n\tfor ; head != nil; head = head.Next {\n\t\tif head.Val < x {\n\t\t\ttl.Next = head\n\t\t\ttl = tl.Next\n\t\t} else {\n\t\t\ttr.Next = head\n\t\t\ttr = tr.Next\n\t\t}\n\t}\n\ttr.Next = nil\n\ttl.Next = r.Next\n\treturn l.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn partition(head: Option<Box<ListNode>>, x: i32) -> Option<Box<ListNode>> {\n        let mut l = ListNode::new(0);\n        let mut r = ListNode::new(0);\n        let mut tl = &mut l;\n        let mut tr = &mut r;\n        let mut current = head;\n        while let Some(mut node) = current {\n            current = node.next.take();\n            if node.val < x {\n                tl.next = Some(node);\n                tl = tl.next.as_mut().unwrap();\n            } else {\n                tr.next = Some(node);\n                tr = tr.next.as_mut().unwrap();\n            }\n        }\n        tr.next = None;\n        tl.next = r.next;\n        l.next\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    __init__(head: ListNode | null): ListNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "simplify-path",
      "title": "Simplify Path",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "sort-list": {
    "title": "Sort List",
    "pattern": "Merge Sort",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(log n)",
    "oneliner": "Find middle, split, recursively sort, merge.",
    "intuition": [
      "\ud83c\udfaf Sort linked list in O(n log n) time.",
      "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
      "\ud83d\udca1 Fast/slow to find middle."
    ],
    "testCases": [
      {
        "input": "head = [4,2,1,3]",
        "output": "[1,2,3,4]"
      },
      {
        "input": "head = [-1,5,3,4,0]",
        "output": "[-1,0,3,4,5]"
      },
      {
        "input": "head = []",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def sortList(self, head):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Sort linked list in O(n log n) time.\n        - \ud83e\udde0 Merge sort: split at middle, recurse, merge.\n        - \ud83d\udca1 Fast/slow to find middle.\n        \"\"\"\n        if not head or not head.next:\n            return head\n        slow, fast = head, head.next  # Initialize slow and fast pointers.\n        while fast and fast.next:  # Traverse until end of list.\n            slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n        mid = slow.next\n        slow.next = None\n        left = sortList(head)\n        right = sortList(mid)\n        return merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = tail = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next, l1 = l1, l1.next\n            else:\n                tail.next, l2 = l2, l2.next\n            tail = tail.next\n        tail.next = l1 or l2\n        return dummy.next  # Return head of the new list.",
    "keyInsight": "Merge sort is ideal for linked lists due to O(1) merge.",
    "visualizationType": "linkedlist",
    "initialState": [
      4,
      2,
      1,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Sort List",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 4",
        "transientMessage": "Iteration 1",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 3",
        "transientMessage": "Iteration 4",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          4,
          2,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Find middle, split, recursively sort, merge.\n\nSort linked list in O(n log n) time.\nMerge sort: split at middle, recurse, merge.",
    "examples": [
      {
        "input": "head = [4,2,1,3]",
        "output": "[1,2,3,4]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Sort linked list in O(n log n) time.",
      "Merge sort: split at middle, recurse, merge.",
      "Fast/slow to find middle."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "TGveA1oFhrc",
    "problemStatement": "Given the head of a linked list, return the list after sorting it in ascending order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Merge Sort: Find middle, split, recursively sort, merge.",
    "mentalModel": "Like arranging a hand of cards by rank and suit.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def sortList(head):\n    if not head or not head.next: return head\n    \n    # Split\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    mid = slow.next\n    slow.next = None\n    \n    # Sort\n    left = sortList(head)\n    right = sortList(mid)\n    \n    # Merge\n    dummy = ListNode(0)\n    curr = dummy\n    while left and right:\n        if left.val < right.val:\n            curr.next = left\n            left = left.next\n        else:\n            curr.next = right\n            right = right.next\n        curr = curr.next\n    curr.next = left or right\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(log n)",
        "intuition": [
          "\ud83c\udfaf Sort linked list in O(n log n) time.",
          "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
          "\ud83d\udca1 Fast/slow to find middle."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef sortList(head):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sort linked list in O(n log n) time.\n    - \ud83e\udde0 Merge sort: split at middle, recurse, merge.\n    - \ud83d\udca1 Fast/slow to find middle.\n    \"\"\"\n    if not head or not head.next:\n        return head\n    slow, fast = head, head.next  # Initialize slow and fast pointers.\n    while fast and fast.next:  # Traverse until end of list.\n        slow, fast = slow.next, fast.next.next  # Initialize slow and fast pointers.\n    mid = slow.next\n    slow.next = None\n    left = sortList(head)\n    right = sortList(mid)\n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next  # Return head of the new list."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head) {\n        // Your code here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode sortList(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode sortList(ListNode head) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* __init__(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* __init__(ListNode* head) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) sortList(head *ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) sortList(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\tslow, fast := head, head.Next\n\tfor fast != nil && fast.Next != nil {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\tl1 := head\n\tl2 := slow.Next\n\tslow.Next = nil\n\tl1 = sortList(l1)\n\tl2 = sortList(l2)\n\tdummy := &ListNode{}\n\ttail := dummy\n\tfor l1 != nil && l2 != nil {\n\t\tif l1.Val <= l2.Val {\n\t\t\ttail.Next = l1\n\t\t\tl1 = l1.Next\n\t\t} else {\n\t\t\ttail.Next = l2\n\t\t\tl2 = l2.Next\n\t\t}\n\t\ttail = tail.Next\n\t}\n\tif l1 != nil {\n\t\ttail.Next = l1\n\t} else {\n\t\ttail.Next = l2\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        fn merge(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n            match (l1, l2) {\n                (None, Some(node)) | (Some(node), None) => Some(node),\n                (Some(mut node1), Some(mut node2)) => {\n                    if node1.val < node2.val {\n                        node1.next = merge(node1.next.take(), Some(node2));\n                        Some(node1)\n                    } else {\n                        node2.next = merge(Some(node1), node2.next.take());\n                        Some(node2)\n                    }\n                }\n                _ => None,\n            }\n        }\n\n        fn sort(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n            if head.is_none() || head.as_ref().unwrap().next.is_none() {\n                return head;\n            }\n            let mut head = head;\n            let mut length = 0;\n            let mut cur = &head;\n            while cur.is_some() {\n                length += 1;\n                cur = &cur.as_ref().unwrap().next;\n            }\n            let mut cur = &mut head;\n            for _ in 0..length / 2 - 1 {\n                cur = &mut cur.as_mut().unwrap().next;\n            }\n            let right = cur.as_mut().unwrap().next.take();\n\n            merge(sort(head), sort(right))\n        }\n        sort(head)\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__() {}\n}",
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "coin-change",
      "title": "Coin Change",
      "difficulty": "Medium",
      "pattern": "1D DP"
    }
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "pattern": "Divide and Conquer",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Preorder first is root. Find it in inorder to split left/right.",
    "intuition": [
      "\ud83c\udfaf Build tree from preorder and inorder.",
      "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
      "\ud83d\udca1 Use hashmap for O(1) index lookup."
    ],
    "testCases": [
      {
        "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
        "output": "[3,9,20,null,null,15,7]"
      },
      {
        "input": "preorder = [-1], inorder = [-1]",
        "output": "[-1]"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Build tree from preorder and inorder.\n        - \ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.\n        - \ud83d\udca1 Use hashmap for O(1) index lookup.\n        \"\"\"\n        if not preorder:\n            return None\n        idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n        def build(self, preL, preR, inL, inR):\n            if preL > preR:\n                return None\n            root = TreeNode(preorder[preL])  # Create a new Tree Node.\n            mid = idx_map[preorder[preL]]\n            leftSize = mid - inL\n            root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n            root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n            return root\n        return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
    "keyInsight": "Preorder gives root, inorder gives subtree boundaries.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Construct Binary Tree from Preorder and Inorder Traversal",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Preorder first is root. Find it in inorder to split left/right.\n\nBuild tree from preorder and inorder.\nPreorder[0] = root. Find in inorder to know left/right sizes.",
    "examples": [
      {
        "input": "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]",
        "output": "[3,9,20,null,null,15,7]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Build tree from preorder and inorder.",
      "Preorder[0] = root. Find in inorder to know left/right sizes.",
      "Use hashmap for O(1) index lookup."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "ihj4IQGZ2zc",
    "problemStatement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Divide and Conquer: Preorder first is root. Find it in inorder to split left/right.",
    "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def buildTree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    root = TreeNode(preorder[0])\n    mid = inorder.index(preorder[0])\n    root.left = buildTree(preorder[1:mid+1], inorder[:mid])\n    root.right = buildTree(preorder[mid+1:], inorder[mid+1:])\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Build tree from preorder and inorder.",
          "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
          "\ud83d\udca1 Use hashmap for O(1) index lookup."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(preorder, inorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from preorder and inorder.\n    - \ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.\n    - \ud83d\udca1 Use hashmap for O(1) index lookup.\n    \"\"\"\n    if not preorder:\n        return None\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    def build(preL, preR, inL, inR):\n        if preL > preR:\n            return None\n        root = TreeNode(preorder[preL])  # Create a new Tree Node.\n        mid = idx_map[preorder[preL]]\n        leftSize = mid - inL\n        root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n        root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n\n    __init__(preorder: number[], inorder: number[]): TreeNode | null {\n        return null;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) buildTree(preorder []int, inorder []int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) buildTree(preorder []int, inorder []int) *TreeNode {\n\td := map[int]int{}\n\tfor i, x := range inorder {\n\t\td[x] = i\n\t}\n\tvar dfs func(i, j, n int) *TreeNode\n\tdfs = func(i, j, n int) *TreeNode {\n\t\tif n <= 0 {\n\t\t\treturn nil\n\t\t}\n\t\tv := preorder[i]\n\t\tk := d[v]\n\t\tl := dfs(i+1, j, k-j)\n\t\tr := dfs(i+1+k-j, k+1, n-1-(k-j))\n\t\treturn &TreeNode{v, l, r}\n\t}\n\treturn dfs(0, 0, len(preorder))\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn build_tree(preorder: Vec<i32>, inorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut d = HashMap::new();\n        for (i, &x) in inorder.iter().enumerate() {\n            d.insert(x, i);\n        }\n        Self::dfs(&preorder, &d, 0, 0, preorder.len())\n    }\n\n    pub fn dfs(\n        preorder: &Vec<i32>,\n        d: &HashMap<i32, usize>,\n        i: usize,\n        j: usize,\n        n: usize,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if n <= 0 {\n            return None;\n        }\n        let v = preorder[i];\n        let k = d[&v];\n        let mut root = TreeNode::new(v);\n        root.left = Self::dfs(preorder, d, i + 1, j, k - j);\n        root.right = Self::dfs(preorder, d, i + k - j + 1, k + 1, n - k + j - 1);\n        Some(Rc::new(RefCell::new(root)))\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    buildTree(preorder: number[], inorder: number[]): TreeNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "construct-quad-tree",
      "title": "Construct Quad Tree",
      "difficulty": "Medium",
      "pattern": "Divide and Conquer"
    }
  },
  "construct-binary-tree-from-inorder-and-postorder-traversal": {
    "title": "Construct Binary Tree from Inorder and Postorder Traversal",
    "pattern": "Divide and Conquer",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Postorder last is root. Build right subtree first (reverse postorder).",
    "intuition": [
      "\ud83c\udfaf Build tree from inorder and postorder.",
      "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
      "\ud83d\udca1 Use hashmap for inorder index lookup."
    ],
    "testCases": [
      {
        "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
        "output": "[3,9,20,null,null,15,7]"
      },
      {
        "input": "inorder = [-1], postorder = [-1]",
        "output": "[-1]"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Build tree from inorder and postorder.\n        - \ud83e\udde0 Postorder[-1] = root. Process right subtree first.\n        - \ud83d\udca1 Use hashmap for inorder index lookup.\n        \"\"\"\n        idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n        self_idx = [len(postorder) - 1]\n        def build(self, inL, inR):\n            if inL > inR:\n                return None\n            root = TreeNode(postorder[self_idx[0]])  # Create a new Tree Node.\n            mid = idx_map[postorder[self_idx[0]]]\n            self_idx[0] -= 1\n            root.right = build(mid + 1, inR)\n            root.left = build(inL, mid - 1)\n            return root\n        return build(0, len(inorder) - 1)",
    "keyInsight": "Build right subtree first since postorder is left-right-root.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Construct Binary Tree from Inorder and Postorder Traversal",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Postorder last is root. Build right subtree first (reverse postorder).\n\nBuild tree from inorder and postorder.\nPostorder[-1] = root. Process right subtree first.",
    "examples": [
      {
        "input": "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]",
        "output": "[3,9,20,null,null,15,7]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Build tree from inorder and postorder.",
      "Postorder[-1] = root. Process right subtree first.",
      "Use hashmap for inorder index lookup."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "vm63HuIU7kw",
    "problemStatement": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Divide and Conquer: Postorder last is root. Build right subtree first (reverse postorder).",
    "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def buildTree(inorder, postorder):\n    if not inorder or not postorder:\n        return None\n    root = TreeNode(postorder.pop())\n    mid = inorder.index(root.val)\n    root.right = buildTree(inorder[mid+1:], postorder)\n    root.left = buildTree(inorder[:mid], postorder)\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Build tree from inorder and postorder.",
          "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
          "\ud83d\udca1 Use hashmap for inorder index lookup."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef buildTree(inorder, postorder):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build tree from inorder and postorder.\n    - \ud83e\udde0 Postorder[-1] = root. Process right subtree first.\n    - \ud83d\udca1 Use hashmap for inorder index lookup.\n    \"\"\"\n    idx_map = {v: i for i, v in enumerate(inorder)}  # Map values to indices for O(1) lookup.\n    self_idx = [len(postorder) - 1]\n    def build(inL, inR):\n        if inL > inR:\n            return None\n        root = TreeNode(postorder[self_idx[0]])  # Create a new Tree Node.\n        mid = idx_map[postorder[self_idx[0]]]\n        self_idx[0] -= 1\n        root.right = build(mid + 1, inR)\n        root.left = build(inL, mid - 1)\n        return root\n    return build(0, len(inorder) - 1)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n\n    __init__(inorder: number[], postorder: number[]): TreeNode | null {\n        return null;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode __init__(int[] inorder, int[] postorder) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode __init__(int[] inorder, int[] postorder) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* __init__(vector<int>& inorder, vector<int>& postorder) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* __init__(vector<int>& inorder, vector<int>& postorder) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) buildTree(inorder []int, postorder []int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) buildTree(inorder []int, postorder []int) *TreeNode {\n\td := map[int]int{}\n\tfor i, v := range inorder {\n\t\td[v] = i\n\t}\n\tvar dfs func(i, j, n int) *TreeNode\n\tdfs = func(i, j, n int) *TreeNode {\n\t\tif n <= 0 {\n\t\t\treturn nil\n\t\t}\n\t\tv := postorder[j+n-1]\n\t\tk := d[v]\n\t\tl := dfs(i, j, k-i)\n\t\tr := dfs(k+1, j+k-i, n-k+i-1)\n\t\treturn &TreeNode{v, l, r}\n\t}\n\treturn dfs(0, 0, len(inorder))\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        let n = inorder.len();\n        let mut d: HashMap<i32, usize> = HashMap::new();\n        for i in 0..n {\n            d.insert(inorder[i], i);\n        }\n        fn dfs(\n            postorder: &[i32],\n            d: &HashMap<i32, usize>,\n            i: usize,\n            j: usize,\n            n: usize,\n        ) -> Option<Rc<RefCell<TreeNode>>> {\n            if n <= 0 {\n                return None;\n            }\n            let val = postorder[j + n - 1];\n            let k = *d.get(&val).unwrap();\n            let left = dfs(postorder, d, i, j, k - i);\n            let right = dfs(postorder, d, k + 1, j + k - i, n - 1 - (k - i));\n            Some(Rc::new(RefCell::new(TreeNode { val, left, right })))\n        }\n        dfs(&postorder, &d, 0, 0, n)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    __init__(inorder: number[], postorder: number[]): TreeNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "difficulty": "Medium",
      "pattern": "Divide and Conquer"
    }
  },
  "flatten-binary-tree-to-linked-list": {
    "title": "Flatten Binary Tree to Linked List",
    "pattern": "Preorder + Pointer Manipulation",
    "patternEmoji": "\ud83d\udccb",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Find rightmost of left subtree, connect to right, move left to right.",
    "intuition": [
      "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
      "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
      "\ud83d\udca1 Then move left subtree to right, nullify left."
    ],
    "testCases": [
      {
        "input": "root = [1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]"
      },
      {
        "input": "root = []",
        "output": "[]"
      },
      {
        "input": "root = [0]",
        "output": "[0]"
      }
    ],
    "code": "class Solution:\n    def flatten(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Flatten tree to right-skewed linked list (preorder).\n        - \ud83e\udde0 For each node: find rightmost of left, connect to right.\n        - \ud83d\udca1 Then move left subtree to right, nullify left.\n        \"\"\"\n        curr = root\n        while curr:\n            if curr.left:  # Check if left child exists.\n                prev = curr.left\n                while prev.right:\n                    prev = prev.right\n                prev.right = curr.right\n                curr.right = curr.left\n                curr.left = None\n            curr = curr.right\n        return root",
    "keyInsight": "Morris-like traversal without recursion or stack.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      5,
      3,
      4,
      6
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Flatten Binary Tree to Linked List",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Find rightmost of left subtree, connect to right, move left to right.\n\nFlatten tree to right-skewed linked list (preorder).\nFor each node: find rightmost of left, connect to right.",
    "examples": [
      {
        "input": "root = [1,2,5,3,4,null,6]",
        "output": "[1,null,2,null,3,null,4,null,5,null,6]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Flatten tree to right-skewed linked list (preorder).",
      "For each node: find rightmost of left, connect to right.",
      "Then move left subtree to right, nullify left."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "rKnD7rLT0lI",
    "problemStatement": "Given the root of a binary tree, flatten the tree into a \"linked list\":",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Preorder + Pointer Manipulation: Find rightmost of left subtree, connect to right, move left to right.",
    "suggestedNextQuestion": {
      "slug": "insert-into-a-binary-search-tree",
      "title": "Insert into a Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like using your fingers to track two different positions in a book at once.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def flatten(self, root):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def flatten(root):\n    def dfs(node):\n        if not node: return None\n        leftTail = dfs(node.left)\n        rightTail = dfs(node.right)\n        \n        if leftTail:\n            leftTail.right = node.right\n            node.right = node.left\n            node.left = None\n        return rightTail or leftTail or node\n    dfs(root)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
          "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
          "\ud83d\udca1 Then move left subtree to right, nullify left."
        ],
        "code": "def flatten(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flatten tree to right-skewed linked list (preorder).\n    - \ud83e\udde0 For each node: find rightmost of left, connect to right.\n    - \ud83d\udca1 Then move left subtree to right, nullify left.\n    \"\"\"\n    curr = root\n    while curr:\n        if curr.left:  # Check if left child exists.\n            prev = curr.left\n            while prev.right:\n                prev = prev.right\n            prev.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n        curr = curr.right\n    return root"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void __init__(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public void __init__(TreeNode root) {\n        // No implementation required\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void __init__() {\n        // Your code here\n    }\n}",
        "code": "class Solution {\npublic:\n    void __init__() {\n        // Constructor implementation goes here\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) flatten(root *TreeNode) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) flatten(root *TreeNode) {\n\tfor root != nil {\n\t\tif root.Left != nil {\n\t\t\tpre := root.Left\n\t\t\tfor pre.Right != nil {\n\t\t\t\tpre = pre.Right\n\t\t\t}\n\t\t\tpre.Right = root.Right\n\t\t\troot.Right = root.Left\n\t\t\troot.Left = nil\n\t\t}\n\t\troot = root.Right\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    #[allow(dead_code)]\n    pub fn flatten(root: &mut Option<Rc<RefCell<TreeNode>>>) {\n        if root.is_none() {\n            return;\n        }\n        let mut v: Vec<Option<Rc<RefCell<TreeNode>>>> = Vec::new();\n        // Initialize the vector\n        Self::pre_order_traverse(&mut v, root);\n        // Traverse the vector\n        let n = v.len();\n        for i in 0..n - 1 {\n            v[i].as_ref().unwrap().borrow_mut().left = None;\n            v[i].as_ref().unwrap().borrow_mut().right = v[i + 1].clone();\n        }\n    }\n\n    #[allow(dead_code)]\n    fn pre_order_traverse(\n        v: &mut Vec<Option<Rc<RefCell<TreeNode>>>>,\n        root: &Option<Rc<RefCell<TreeNode>>>,\n    ) {\n        if root.is_none() {\n            return;\n        }\n        v.push(root.clone());\n        let left = root.as_ref().unwrap().borrow().left.clone();\n        let right = root.as_ref().unwrap().borrow().right.clone();\n        Self::pre_order_traverse(v, &left);\n        Self::pre_order_traverse(v, &right);\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def flatten(self, root):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "path-sum": {
    "title": "Path Sum",
    "pattern": "DFS",
    "patternEmoji": "\ud83d\udee4\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "DFS, subtract node value, check leaf with remaining 0.",
    "intuition": [
      "\ud83c\udfaf Does any root-to-leaf path sum to target?",
      "\ud83e\udde0 DFS: subtract current value, recurse.",
      "\ud83d\udca1 At leaf, check if remaining == 0."
    ],
    "testCases": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
        "output": "true"
      },
      {
        "input": "root = [1,2,3], targetSum = 5",
        "output": "false"
      },
      {
        "input": "root = [], targetSum = 0",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Does any root-to-leaf path sum to target?\n        - \ud83e\udde0 DFS: subtract current value, recurse.\n        - \ud83d\udca1 At leaf, check if remaining == 0.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return False  # Condition not met.\n        if not root.left and not root.right:\n            return targetSum == root.val\n        return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)",
    "keyInsight": "Check leaf condition: no left AND no right child.",
    "visualizationType": "tree",
    "initialState": [
      5,
      4,
      8,
      11,
      13,
      4,
      7,
      2,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "root = 5, targetSum = 22",
        "transientMessage": "Start DFS at root (5). Rem: 22 - 5 = 17",
        "arrayState": [
          5,
          4,
          8,
          11,
          13,
          4,
          7,
          2,
          1
        ],
        "pointers": [
          {
            "label": "curr",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Go Left: node 4. Rem: 17 - 4 = 13",
        "transientMessage": "Traverse left child",
        "arrayState": [
          5,
          4,
          8,
          11,
          13,
          4,
          7,
          2,
          1
        ],
        "pointers": [
          {
            "label": "curr",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Go Left: node 11. Rem: 13 - 11 = 2",
        "transientMessage": "Traverse left child",
        "arrayState": [
          5,
          4,
          8,
          11,
          13,
          4,
          7,
          2,
          1
        ],
        "pointers": [
          {
            "label": "curr",
            "index": 3
          }
        ],
        "indices": [
          0,
          1,
          3
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Go Right: node 2. Rem: 2 - 2 = 0",
        "transientMessage": "Leaf node reached! Sum matches!",
        "arrayState": [
          5,
          4,
          8,
          11,
          13,
          4,
          7,
          2,
          1
        ],
        "pointers": [
          {
            "label": "curr",
            "index": 8
          }
        ],
        "indices": [
          0,
          1,
          3,
          8
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "True",
        "transientMessage": "Path found! \u2705",
        "arrayState": [
          5,
          4,
          8,
          11,
          13,
          4,
          7,
          2,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          3,
          8
        ],
        "color": "success"
      }
    ],
    "description": "DFS, subtract node value, check leaf with remaining 0.\n\nDoes any root-to-leaf path sum to target?\nDFS: subtract current value, recurse.",
    "examples": [
      {
        "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1]; targetSum = 22",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Does any root-to-leaf path sum to target?",
      "DFS: subtract current value, recurse.",
      "At leaf, check if remaining == 0."
    ],
    "relatedProblems": [
      "number-of-islands",
      "clone-graph",
      "course-schedule"
    ],
    "videoId": "LSKQyOz_P8I",
    "problemStatement": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.",
    "difficulty": "Easy",
    "walkthrough": [
      "Start DFS from root/starting node",
      "Mark current node as visited",
      "Recursively explore all neighbors/children",
      "Backtrack when path exhausted",
      "Return result after full traversal"
    ],
    "approach": "DFS: DFS, subtract node value, check leaf with remaining 0.",
    "suggestedNextQuestion": {
      "slug": "same-tree",
      "title": "Same Tree",
      "difficulty": "Easy",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def hasPathSum(self, root, targetSum):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def hasPathSum(root, targetSum):\n    if not root: return False\n    targetSum -= root.val\n    if not root.left and not root.right:\n        return targetSum == 0\n    return hasPathSum(root.left, targetSum) or hasPathSum(root.right, targetSum)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Does any root-to-leaf path sum to target?",
          "\ud83e\udde0 DFS: subtract current value, recurse.",
          "\ud83d\udca1 At leaf, check if remaining == 0."
        ],
        "code": "def hasPathSum(root, targetSum):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Does any root-to-leaf path sum to target?\n    - \ud83e\udde0 DFS: subtract current value, recurse.\n    - \ud83d\udca1 At leaf, check if remaining == 0.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if not root.left and not root.right:\n        return targetSum == root.val\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null, targetSum: number) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root: TreeNode | null, targetSum: number) { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__(TreeNode root, int sum) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__(TreeNode root, int sum) {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) hasPathSum(root *TreeNode, targetSum int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) hasPathSum(root *TreeNode, targetSum int) bool {\n\tvar dfs func(*TreeNode, int) bool\n\tdfs = func(root *TreeNode, s int) bool {\n\t\tif root == nil {\n\t\t\treturn false\n\t\t}\n\t\ts += root.Val\n\t\tif root.Left == nil && root.Right == nil && s == targetSum {\n\t\t\treturn true\n\t\t}\n\t\treturn dfs(root.Left, s) || dfs(root.Right, s)\n\t}\n\treturn dfs(root, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn has_path_sum(root: Option<Rc<RefCell<TreeNode>>>, target_sum: i32) -> bool {\n        match root {\n            None => false,\n            Some(node) => {\n                let mut node = node.borrow_mut();\n                // \u786e\u5b9a\u53f6\u7ed3\u70b9\u8eab\u4efd\n                if node.left.is_none() && node.right.is_none() {\n                    return target_sum - node.val == 0;\n                }\n                let val = node.val;\n                Self::has_path_sum(node.left.take(), target_sum - val)\n                    || Self::has_path_sum(node.right.take(), target_sum - val)\n            }\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def hasPathSum(self, root, targetSum):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null, targetSum: number) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null, targetSum: number) {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "sum-root-to-leaf-numbers": {
    "title": "Sum Root to Leaf Numbers",
    "pattern": "DFS",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "DFS carrying current number. At leaf, add to sum.",
    "intuition": [
      "\ud83c\udfaf Sum all root-to-leaf numbers.",
      "\ud83e\udde0 Pass current number * 10 + node.val down.",
      "\ud83d\udca1 At leaf, return current number."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3]",
        "output": "25"
      },
      {
        "input": "root = [4,9,0,5,1]",
        "output": "1026"
      }
    ],
    "code": "class Solution:\n    def sumNumbers(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Sum all root-to-leaf numbers.\n        - \ud83e\udde0 Pass current number * 10 + node.val down.\n        - \ud83d\udca1 At leaf, return current number.\n        \"\"\"\n        def dfs(node, curr):\n            if not node:\n                return 0\n            curr = curr * 10 + node.val  # Append digit to current number.\n            if not node.left and not node.right:\n                return curr\n            return dfs(node.left, curr) + dfs(node.right, curr)\n        return dfs(root, 0)",
    "keyInsight": "Build number digit by digit as you traverse.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Sum Root to Leaf Numbers",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "DFS carrying current number. At leaf, add to sum.\n\nSum all root-to-leaf numbers.\nPass current number * 10 + node.val down.",
    "examples": [
      {
        "input": "root = [1,2,3]",
        "output": "25"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Sum all root-to-leaf numbers.",
      "Pass current number * 10 + node.val down.",
      "At leaf, return current number."
    ],
    "relatedProblems": [
      "number-of-islands",
      "clone-graph",
      "course-schedule"
    ],
    "videoId": "Jk16lZGFWxE",
    "problemStatement": "You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.",
    "difficulty": "Medium",
    "walkthrough": [
      "Start DFS from root/starting node",
      "Mark current node as visited",
      "Recursively explore all neighbors/children",
      "Backtrack when path exhausted",
      "Return result after full traversal"
    ],
    "approach": "DFS: DFS carrying current number. At leaf, add to sum.",
    "suggestedNextQuestion": {
      "slug": "surrounded-regions",
      "title": "Surrounded Regions",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sumNumbers(self, root):\n        pass\n\n        def dfs(node, curr):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def sumNumbers(root):\n    def dfs(node, num):\n        if not node: return 0\n        num = num * 10 + node.val\n        if not node.left and not node.right:\n            return num\n        return dfs(node.left, num) + dfs(node.right, num)\n    return dfs(root, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Sum all root-to-leaf numbers.",
          "\ud83e\udde0 Pass current number * 10 + node.val down.",
          "\ud83d\udca1 At leaf, return current number."
        ],
        "code": "def sumNumbers(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum all root-to-leaf numbers.\n    - \ud83e\udde0 Pass current number * 10 + node.val down.\n    - \ud83d\udca1 At leaf, return current number.\n    \"\"\"\n    def dfs(node, curr):\n        if not node:\n            return 0\n        curr = curr * 10 + node.val  # Append digit to current number.\n        if not node.left and not node.right:\n            return curr\n        return dfs(node.left, curr) + dfs(node.right, curr)\n    return dfs(root, 0)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int sumNumbers(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public int sumNumbers(TreeNode root) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int sumNumbers(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) sumNumbers(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) sumNumbers(root *TreeNode) int {\n\tvar dfs func(*TreeNode, int) int\n\tdfs = func(root *TreeNode, s int) int {\n\t\tif root == nil {\n\t\t\treturn 0\n\t\t}\n\t\ts = s*10 + root.Val\n\t\tif root.Left == nil && root.Right == nil {\n\t\t\treturn s\n\t\t}\n\t\treturn dfs(root.Left, s) + dfs(root.Right, s)\n\t}\n\treturn dfs(root, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(node: &Option<Rc<RefCell<TreeNode>>>, mut num: i32) -> i32 {\n        if node.is_none() {\n            return 0;\n        }\n        let node = node.as_ref().unwrap().borrow();\n        num = num * 10 + node.val;\n        if node.left.is_none() && node.right.is_none() {\n            return num;\n        }\n        Self::dfs(&node.left, num) + Self::dfs(&node.right, num)\n    }\n\n    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        Self::dfs(&root, 0)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sumNumbers(self, root):\n        pass\n\n        def dfs(node, curr):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) {}\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "binary-tree-maximum-path-sum": {
    "title": "Binary Tree Maximum Path Sum",
    "pattern": "DFS + Global Max",
    "patternEmoji": "\ud83c\udfc6",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "For each node, compute max path through it. Update global max.",
    "intuition": [
      "\ud83c\udfaf Find max path sum (any path in tree).",
      "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
      "\ud83d\udca1 Use global variable to track overall max."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3]",
        "output": "6"
      },
      {
        "input": "root = [-10,9,20,null,null,15,7]",
        "output": "42"
      }
    ],
    "code": "class Solution:\n    def maxPathSum(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find max path sum (any path in tree).\n        - \ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).\n        - \ud83d\udca1 Use global variable to track overall max.\n        \"\"\"\n        maxSum = [float('-inf')]\n        def dfs(node):\n            if not node:\n                return 0\n            left = max(0, dfs(node.left))  # Take the maximum value.\n            right = max(0, dfs(node.right))  # Take the maximum value.\n            maxSum[0] = max(maxSum[0], node.val + left + right)  # Take the maximum value.\n            return node.val + max(left, right)  # Take the maximum value.\n        dfs(root)\n        return maxSum[0]",
    "keyInsight": "Return single branch max, but compute cross-node max internally.",
    "visualizationType": "tree",
    "initialState": [
      -10,
      9,
      20,
      15,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Binary Tree Maximum Path Sum",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "For each node, compute max path through it. Update global max.\n\nFind max path sum (any path in tree).\nAt each node: max = node + left + right. Return node + max(left, right).",
    "examples": [
      {
        "input": "root = [-10,9,20,null,null,15,7]",
        "output": "42"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find max path sum (any path in tree).",
      "At each node: max = node + left + right. Return node + max(left, right).",
      "Use global variable to track overall max."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Hr5cWUld4vU",
    "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS + Global Max: For each node, compute max path through it. Update global max.",
    "suggestedNextQuestion": {
      "slug": "reconstruct-itinerary",
      "title": "Reconstruct Itinerary",
      "difficulty": "Hard",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxPathSum(self, root):\n        pass\n\n        def dfs(node):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxPathSum(root):\n    res = [root.val]\n    def dfs(root):\n        if not root: return 0\n        leftMax = max(dfs(root.left), 0)\n        rightMax = max(dfs(root.right), 0)\n        \n        res[0] = max(res[0], root.val + leftMax + rightMax)\n        return root.val + max(leftMax, rightMax)\n    dfs(root)\n    return res[0]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Find max path sum (any path in tree).",
          "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
          "\ud83d\udca1 Use global variable to track overall max."
        ],
        "code": "def maxPathSum(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find max path sum (any path in tree).\n    - \ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).\n    - \ud83d\udca1 Use global variable to track overall max.\n    \"\"\"\n    maxSum = [float('-inf')]\n    def dfs(node):\n        if not node:\n            return 0\n        left = max(0, dfs(node.left))  # Take the maximum value.\n        right = max(0, dfs(node.right))  # Take the maximum value.\n        maxSum[0] = max(maxSum[0], node.val + left + right)  # Take the maximum value.\n        return node.val + max(left, right)  # Take the maximum value.\n    dfs(root)\n    return maxSum[0]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxPathSum(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public int maxPathSum(TreeNode root) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxPathSum(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) maxPathSum(root *TreeNode) int {\n\tans := -1001\n\tvar dfs func(*TreeNode) int\n\tdfs = func(root *TreeNode) int {\n\t\tif root == nil {\n\t\t\treturn 0\n\t\t}\n\t\tleft := max(0, dfs(root.Left))\n\t\tright := max(0, dfs(root.Right))\n\t\tans = max(ans, left+right+root.Val)\n\t\treturn max(left, right) + root.Val\n\t}\n\tdfs(root)\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32) -> i32 {\n        if root.is_none() {\n            return 0;\n        }\n        let node = root.as_ref().unwrap().borrow();\n        let left = (0).max(Self::dfs(&node.left, res));\n        let right = (0).max(Self::dfs(&node.right, res));\n        *res = (node.val + left + right).max(*res);\n        node.val + left.max(right)\n    }\n\n    pub fn max_path_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut res = -1000;\n        Self::dfs(&root, &mut res);\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxPathSum(self, root):\n        pass\n\n        def dfs(node):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "count-complete-tree-nodes": {
    "title": "Count Complete Tree Nodes",
    "pattern": "Binary Search on Tree",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(log\u00b2 n)",
    "spaceComplexity": "O(log n)",
    "oneliner": "Compare left/right depths. If equal, left is perfect. Otherwise right is.",
    "intuition": [
      "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
      "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
      "\ud83d\udca1 Recurse on the other side."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,4,5,6]",
        "output": "6"
      },
      {
        "input": "root = []",
        "output": "0"
      },
      {
        "input": "root = [1]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def countNodes(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count nodes in complete binary tree efficiently.\n        - \ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).\n        - \ud83d\udca1 Recurse on the other side.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return 0\n        leftD = rightD = 0\n        l, r = root, root  # Initialize two pointers.\n        while l:\n            leftD += 1\n            l = l.left\n        while r:\n            rightD += 1\n            r = r.right\n        if leftD == rightD:\n            return (1 << leftD) - 1\n        return 1 + countNodes(root.left) + countNodes(root.right)",
    "keyInsight": "Complete tree allows O(log\u00b2 n) instead of O(n).",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Count Complete Tree Nodes",
        "transientMessage": "Input: [1, 2, 3, 4, 5, 6]",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 3",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 4",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 5",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Compare left/right depths. If equal, left is perfect. Otherwise right is.\n\nCount nodes in complete binary tree efficiently.\nIf left depth == right depth, left is perfect (2^d - 1 nodes).",
    "examples": [
      {
        "input": "root = [1,2,3,4,5,6]",
        "output": "6"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count nodes in complete binary tree efficiently.",
      "If left depth == right depth, left is perfect (2^d - 1 nodes).",
      "Recurse on the other side."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "u-yWemKGWO0",
    "problemStatement": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less than O(n) time complexity.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Binary Search on Tree: Compare left/right depths. If equal, left is perfect. Otherwise right is.",
    "suggestedNextQuestion": {
      "slug": "minimum-absolute-difference-in-bst",
      "title": "Minimum Absolute Difference in BST",
      "difficulty": "Easy",
      "pattern": "Trees"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def __init___brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log\u00b2 n)",
        "spaceComplexity": "O(log n)",
        "intuition": [
          "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
          "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
          "\ud83d\udca1 Recurse on the other side."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef countNodes(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count nodes in complete binary tree efficiently.\n    - \ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).\n    - \ud83d\udca1 Recurse on the other side.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    leftD = rightD = 0\n    l, r = root, root  # Initialize two pointers.\n    while l:\n        leftD += 1\n        l = l.left\n    while r:\n        rightD += 1\n        r = r.right\n    if leftD == rightD:\n        return (1 << leftD) - 1\n    return 1 + countNodes(root.left) + countNodes(root.right)"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int countNodes(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) countNodes(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) countNodes(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\treturn 1 + countNodes(root.Left) + countNodes(root.Right)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::cell::RefCell;\nuse std::rc::Rc;\n\nimpl Solution {\n    pub fn count_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        if let Some(node) = root {\n            let node = node.borrow();\n            let left = Self::depth(&node.left);\n            let right = Self::depth(&node.right);\n            if left == right {\n                Self::count_nodes(node.right.clone()) + (1 << left)\n            } else {\n                Self::count_nodes(node.left.clone()) + (1 << right)\n            }\n        } else {\n            0\n        }\n    }\n\n    fn depth(root: &Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        if let Some(node) = root {\n            Self::depth(&node.borrow().left) + 1\n        } else {\n            0\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    countCompleteTreeNodes(root: TreeNode | null): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "binary-tree-right-side-view": {
    "title": "Binary Tree Right Side View",
    "pattern": "BFS",
    "patternEmoji": "\ud83d\udc41\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "BFS level by level, take last node of each level.",
    "intuition": [
      "\ud83c\udfaf Return rightmost node at each level.",
      "\ud83e\udde0 BFS: at each level, record last node.",
      "\ud83d\udca1 Or DFS with level tracking, process right first."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,null,5,null,4]",
        "output": "[1,3,4]"
      },
      {
        "input": "root = [1,2,3,4,null,null,null,5]",
        "output": "[1,3,4,5]"
      },
      {
        "input": "root = [1,null,3]",
        "output": "[1,3]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def rightSideView(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Return rightmost node at each level.\n        - \ud83e\udde0 BFS: at each level, record last node.\n        - \ud83d\udca1 Or DFS with level tracking, process right first.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return []\n        res = []  # Initialize list to store results.\n        q = deque([root])  # Initialize queue for BFS.\n        while q:\n            size = len(q)\n            for i in range(size):  # Iterate through the range.\n                node = q.popleft()  # Remove from front of queue.\n                if i == size - 1:\n                    res.append(node.val)  # Add to end.\n                if node.left:\n                    q.append(node.left)  # Add to end.\n                if node.right:\n                    q.append(node.right)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "Take the last node at each level during BFS.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Binary Tree Right Side View",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "BFS level by level, take last node of each level.\n\nReturn rightmost node at each level.\nBFS: at each level, record last node.",
    "examples": [
      {
        "input": "root = [1,2,3,null,5,null,4]",
        "output": "[1,3,4]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Return rightmost node at each level.",
      "BFS: at each level, record last node.",
      "Or DFS with level tracking, process right first."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "word-ladder",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "d4zLyf32e3I",
    "problemStatement": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS level by level, take last node of each level.",
    "suggestedNextQuestion": {
      "slug": "binary-tree-zigzag-level-order-traversal",
      "title": "Binary Tree Zigzag Level Order Traversal",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rightSideView(root):\n    if not root: return []\n    res = []\n    q = [root]\n    while q:\n        rightSide = None\n        for i in range(len(q)):\n            node = q.pop(0)\n            if node:\n                rightSide = node\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n        if rightSide: res.append(rightSide.val)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Return rightmost node at each level.",
          "\ud83e\udde0 BFS: at each level, record last node.",
          "\ud83d\udca1 Or DFS with level tracking, process right first."
        ],
        "code": "from collections import deque\n\ndef rightSideView(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return rightmost node at each level.\n    - \ud83e\udde0 BFS: at each level, record last node.\n    - \ud83d\udca1 Or DFS with level tracking, process right first.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i == size - 1:\n                res.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // JavaScript implementation\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Integer> __init__(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public List<Integer> __init__(TreeNode root) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> __init__(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> __init__(TreeNode* root) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rightSideView(root *TreeNode) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) rightSideView(root *TreeNode) (ans []int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tq := []*TreeNode{root}\n\tfor len(q) > 0 {\n\t\tans = append(ans, q[0].Val)\n\t\tfor k := len(q); k > 0; k-- {\n\t\t\tnode := q[0]\n\t\t\tq = q[1:]\n\t\t\tif node.Right != nil {\n\t\t\t\tq = append(q, node.Right)\n\t\t\t}\n\t\t\tif node.Left != nil {\n\t\t\t\tq = append(q, node.Left)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn right_side_view(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n        let mut ans = vec![];\n        if root.is_none() {\n            return ans;\n        }\n        let mut q = VecDeque::new();\n        q.push_back(root);\n        while !q.is_empty() {\n            let k = q.len();\n            ans.push(q[0].as_ref().unwrap().borrow().val);\n            for _ in 0..k {\n                if let Some(node) = q.pop_front().unwrap() {\n                    let mut node = node.borrow_mut();\n                    if node.right.is_some() {\n                        q.push_back(node.right.take());\n                    }\n                    if node.left.is_some() {\n                        q.push_back(node.left.take());\n                    }\n                }\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "average-of-levels-in-binary-tree": {
    "title": "Average of Levels in Binary Tree",
    "pattern": "BFS",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "BFS level by level, compute average per level.",
    "intuition": [
      "\ud83c\udfaf Return average value at each level.",
      "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
      "\ud83d\udca1 Process level by level with queue."
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[3.00000,14.50000,11.00000]"
      },
      {
        "input": "root = [3,9,20,15,7]",
        "output": "[3.00000,14.50000,11.00000]"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def averageOfLevels(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Return average value at each level.\n        - \ud83e\udde0 BFS: sum nodes at each level, divide by count.\n        - \ud83d\udca1 Process level by level with queue.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return []\n        res = []  # Initialize list to store results.\n        q = deque([root])  # Initialize queue for BFS.\n        while q:\n            size = len(q)\n            total = 0\n            for _ in range(size):  # Iterate through the range.\n                node = q.popleft()  # Remove from front of queue.\n                total += node.val\n                if node.left:\n                    q.append(node.left)  # Add to end.\n                if node.right:\n                    q.append(node.right)  # Add to end.\n            res.append(total / size)  # Add to end.\n        return res  # Return the final result.",
    "keyInsight": "Sum all nodes at each level and divide by count.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Average of Levels in Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "BFS level by level, compute average per level.\n\nReturn average value at each level.\nBFS: sum nodes at each level, divide by count.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[3.0,14.5,11.0]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Return average value at each level.",
      "BFS: sum nodes at each level, divide by count.",
      "Process level by level with queue."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "word-ladder",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "115txA-rS5s",
    "problemStatement": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10^-5 of the actual answer will be accepted.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS level by level, compute average per level.",
    "suggestedNextQuestion": {
      "slug": "invert-binary-tree",
      "title": "Invert Binary Tree",
      "difficulty": "Easy",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def averageOfLevels(root):\n    q = [root]\n    res = []\n    while q:\n        qlen = len(q)\n        row = 0\n        for i in range(qlen):\n            node = q.pop(0)\n            row += node.val\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        res.append(row / qlen)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Return average value at each level.",
          "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
          "\ud83d\udca1 Process level by level with queue."
        ],
        "code": "from collections import deque\n\ndef averageOfLevels(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return average value at each level.\n    - \ud83e\udde0 BFS: sum nodes at each level, divide by count.\n    - \ud83d\udca1 Process level by level with queue.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    while q:\n        size = len(q)\n        total = 0\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            total += node.val\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(total / size)  # Add to end.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Double> __init__(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public List<Double> __init__(TreeNode root) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<double> averageOfLevels(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) averageOfLevels(root *TreeNode) []float64 {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) averageOfLevels(root *TreeNode) []float64 {\n\tq := []*TreeNode{root}\n\tans := []float64{}\n\tfor len(q) > 0 {\n\t\tn := len(q)\n\t\ts := 0\n\t\tfor i := 0; i < n; i++ {\n\t\t\troot = q[0]\n\t\t\tq = q[1:]\n\t\t\ts += root.Val\n\t\t\tif root.Left != nil {\n\t\t\t\tq = append(q, root.Left)\n\t\t\t}\n\t\t\tif root.Right != nil {\n\t\t\t\tq = append(q, root.Right)\n\t\t\t}\n\t\t}\n\t\tans = append(ans, float64(s)/float64(n))\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\n\nimpl Solution {\n    pub fn average_of_levels(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<f64> {\n        let mut ans = vec![];\n        let mut q = VecDeque::new();\n        if let Some(root_node) = root {\n            q.push_back(root_node);\n        }\n        while !q.is_empty() {\n            let n = q.len();\n            let mut s: i64 = 0;\n            for _ in 0..n {\n                if let Some(node) = q.pop_front() {\n                    let node_borrow = node.borrow();\n                    s += node_borrow.val as i64;\n                    if let Some(left) = node_borrow.left.clone() {\n                        q.push_back(left);\n                    }\n                    if let Some(right) = node_borrow.right.clone() {\n                        q.push_back(right);\n                    }\n                }\n            }\n            ans.push((s as f64) / (n as f64));\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n    \n    averageOfLevels(root: TreeNode | null): number[] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "binary-tree-zigzag-level-order-traversal": {
    "title": "Binary Tree Zigzag Level Order Traversal",
    "pattern": "BFS + Direction Flag",
    "patternEmoji": "\u26a1",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "BFS, alternate direction each level (reverse odd levels).",
    "intuition": [
      "\ud83c\udfaf Level order but alternating left-right direction.",
      "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
      "\ud83d\udca1 Or use deque to add from different ends."
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]"
      },
      {
        "input": "root = [1]",
        "output": "[[1]]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Level order but alternating left-right direction.\n        - \ud83e\udde0 BFS with direction flag. Reverse level if needed.\n        - \ud83d\udca1 Or use deque to add from different ends.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return []\n        res = []  # Initialize list to store results.\n        q = deque([root])  # Initialize queue for BFS.\n        leftToRight = True\n        while q:\n            size = len(q)\n            level = deque()\n            for _ in range(size):  # Iterate through the range.\n                node = q.popleft()  # Remove from front of queue.\n                if leftToRight:\n                    level.append(node.val)  # Add to end.\n                else:\n                    level.appendleft(node.val)\n                if node.left:\n                    q.append(node.left)  # Add to end.\n                if node.right:\n                    q.append(node.right)  # Add to end.\n            res.append(list(level))  # Add to end.\n            leftToRight = not leftToRight\n        return res  # Return the final result.",
    "keyInsight": "Use deque's appendleft for reverse direction.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Binary Tree Zigzag Level Order Traversal",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "BFS, alternate direction each level (reverse odd levels).\n\nLevel order but alternating left-right direction.\nBFS with direction flag. Reverse level if needed.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[20,9],[15,7]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Level order but alternating left-right direction.",
      "BFS with direction flag. Reverse level if needed.",
      "Or use deque to add from different ends."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "igbboQbiwqw",
    "problemStatement": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BFS + Direction Flag: BFS, alternate direction each level (reverse odd levels).",
    "suggestedNextQuestion": {
      "slug": "cheapest-flights-within-k-stops",
      "title": "Cheapest Flights Within K Stops",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def zigzagLevelOrder(root):\n    if not root: return []\n    res = []\n    q = [root]\n    leftToRight = True\n    while q:\n        level = []\n        for i in range(len(q)):\n            node = q.pop(0)\n            level.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        if not leftToRight:\n            level.reverse()\n        res.append(level)\n        leftToRight = not leftToRight\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Level order but alternating left-right direction.",
          "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
          "\ud83d\udca1 Or use deque to add from different ends."
        ],
        "code": "from collections import deque\n\ndef zigzagLevelOrder(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Level order but alternating left-right direction.\n    - \ud83e\udde0 BFS with direction flag. Reverse level if needed.\n    - \ud83d\udca1 Or use deque to add from different ends.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    res = []  # Initialize list to store results.\n    q = deque([root])  # Initialize queue for BFS.\n    leftToRight = True\n    while q:\n        size = len(q)\n        level = deque()\n        for _ in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if leftToRight:\n                level.append(node.val)  # Add to end.\n            else:\n                level.appendleft(node.val)\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        res.append(list(level))  # Add to end.\n        leftToRight = not leftToRight\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n\n    zigzagLevelOrder(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) zigzagLevelOrder(root *TreeNode) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) zigzagLevelOrder(root *TreeNode) (ans [][]int) {\n\tif root == nil {\n\t\treturn\n\t}\n\tq := []*TreeNode{root}\n\tleft := true\n\tfor len(q) > 0 {\n\t\tt := []int{}\n\t\tfor n := len(q); n > 0; n-- {\n\t\t\tnode := q[0]\n\t\t\tq = q[1:]\n\t\t\tt = append(t, node.Val)\n\t\t\tif node.Left != nil {\n\t\t\t\tq = append(q, node.Left)\n\t\t\t}\n\t\t\tif node.Right != nil {\n\t\t\t\tq = append(q, node.Right)\n\t\t\t}\n\t\t}\n\t\tif !left {\n\t\t\tfor i, j := 0, len(t)-1; i < j; i, j = i+1, j-1 {\n\t\t\t\tt[i], t[j] = t[j], t[i]\n\t\t\t}\n\t\t}\n\t\tans = append(ans, t)\n\t\tleft = !left\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn zigzag_level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {\n        let mut ans = Vec::new();\n        let mut left = true;\n        if let Some(root_node) = root {\n            let mut q = VecDeque::new();\n            q.push_back(root_node);\n            while !q.is_empty() {\n                let mut t = Vec::new();\n                for _ in 0..q.len() {\n                    if let Some(node) = q.pop_front() {\n                        let node_ref = node.borrow();\n                        t.push(node_ref.val);\n                        if let Some(ref left) = node_ref.left {\n                            q.push_back(Rc::clone(left));\n                        }\n                        if let Some(ref right) = node_ref.right {\n                            q.push_back(Rc::clone(right));\n                        }\n                    }\n                }\n                if !left {\n                    t.reverse();\n                }\n                ans.push(t);\n                left = !left;\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "minimum-absolute-difference-in-bst": {
    "title": "Minimum Absolute Difference in BST",
    "pattern": "Inorder Traversal",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Inorder gives sorted order. Track prev, compare adjacent.",
    "intuition": [
      "\ud83c\udfaf Find min diff between any two nodes.",
      "\ud83e\udde0 Inorder traversal gives sorted values.",
      "\ud83d\udca1 Min diff is between adjacent sorted values."
    ],
    "testCases": [
      {
        "input": "root = [4,2,6,1,3]",
        "output": "1"
      },
      {
        "input": "root = [1,0,48,null,null,12,49]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def getMinimumDifference(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find min diff between any two nodes.\n        - \ud83e\udde0 Inorder traversal gives sorted values.\n        - \ud83d\udca1 Min diff is between adjacent sorted values.\n        \"\"\"\n        prev = [None]\n        minDiff = [float('inf')]\n        def inorder(node):  # Recursive inorder traversal.\n            if not node: return\n            inorder(node.left)  # Recursive inorder traversal.\n            if prev[0] is not None:\n                minDiff[0] = min(minDiff[0], node.val - prev[0])  # Take the minimum value.\n            prev[0] = node.val\n            inorder(node.right)  # Recursive inorder traversal.\n        inorder(root)  # Recursive inorder traversal.\n        return minDiff[0]",
    "keyInsight": "Inorder on BST is sorted, so min diff is between adjacent.",
    "visualizationType": "tree",
    "initialState": [
      4,
      2,
      6,
      1,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Absolute Difference in BST",
        "transientMessage": "Input: [4, 2, 6, 1, 3]",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 4",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 6",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 1",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 3",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          4,
          2,
          6,
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Inorder gives sorted order. Track prev, compare adjacent.\n\nFind min diff between any two nodes.\nInorder traversal gives sorted values.",
    "examples": [
      {
        "input": "root = [4,2,6,1,3]",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find min diff between any two nodes.",
      "Inorder traversal gives sorted values.",
      "Min diff is between adjacent sorted values."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "NttA_NC_ZhI",
    "problemStatement": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Inorder Traversal: Inorder gives sorted order. Track prev, compare adjacent.",
    "suggestedNextQuestion": {
      "slug": "subtree-of-another-tree",
      "title": "Subtree of Another Tree",
      "difficulty": "Easy",
      "pattern": "Trees"
    },
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def getMinimumDifference(self, root):\n        pass\n\n        def inorder(node):  # Recursive inorder traversal.\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def getMinimumDifference(root):\n    prev = [None]\n    min_diff = [float('inf')]\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        if prev[0] is not None:\n             min_diff[0] = min(min_diff[0], node.val - prev[0])\n        prev[0] = node.val\n        inorder(node.right)\n    inorder(root)\n    return min_diff[0]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Find min diff between any two nodes.",
          "\ud83e\udde0 Inorder traversal gives sorted values.",
          "\ud83d\udca1 Min diff is between adjacent sorted values."
        ],
        "code": "def getMinimumDifference(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find min diff between any two nodes.\n    - \ud83e\udde0 Inorder traversal gives sorted values.\n    - \ud83d\udca1 Min diff is between adjacent sorted values.\n    \"\"\"\n    prev = [None]\n    minDiff = [float('inf')]\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        if prev[0] is not None:\n            minDiff[0] = min(minDiff[0], node.val - prev[0])  # Take the minimum value.\n        prev[0] = node.val\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    return minDiff[0]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) getMinimumDifference(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) getMinimumDifference(root *TreeNode) int {\n\tconst inf int = 1 << 30\n\tans, pre := inf, -inf\n\tvar dfs func(*TreeNode)\n\tdfs = func(root *TreeNode) {\n\t\tif root == nil {\n\t\t\treturn\n\t\t}\n\t\tdfs(root.Left)\n\t\tans = min(ans, root.Val-pre)\n\t\tpre = root.Val\n\t\tdfs(root.Right)\n\t}\n\tdfs(root)\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn get_minimum_difference(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        const inf: i32 = 1 << 30;\n        let mut ans = inf;\n        let mut pre = -inf;\n\n        fn dfs(node: Option<Rc<RefCell<TreeNode>>>, ans: &mut i32, pre: &mut i32) {\n            if let Some(n) = node {\n                let n = n.borrow();\n                dfs(n.left.clone(), ans, pre);\n                *ans = (*ans).min(n.val - *pre);\n                *pre = n.val;\n                dfs(n.right.clone(), ans, pre);\n            }\n        }\n\n        dfs(root, &mut ans, &mut pre);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def getMinimumDifference(self, root):\n        pass\n\n        def inorder(node):  # Recursive inorder traversal.\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "kth-smallest-element-in-a-bst": {
    "title": "Kth Smallest Element in a BST",
    "pattern": "Inorder Traversal",
    "patternEmoji": "\ud83c\udfc6",
    "timeComplexity": "O(h + k)",
    "spaceComplexity": "O(h)",
    "oneliner": "Inorder traversal, return kth element.",
    "intuition": [
      "\ud83c\udfaf Find kth smallest element in BST.",
      "\ud83e\udde0 Inorder = sorted order. Count until k.",
      "\ud83d\udca1 Use iterative inorder with stack."
    ],
    "testCases": [
      {
        "input": "root = [3,1,4,null,2], k = 1",
        "output": "1"
      },
      {
        "input": "root = [5,3,6,2,4,null,null,1], k = 3",
        "output": "3"
      }
    ],
    "code": "class Solution:\n    def kthSmallest(self, root, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find kth smallest element in BST.\n        - \ud83e\udde0 Inorder = sorted order. Count until k.\n        - \ud83d\udca1 Use iterative inorder with stack.\n        \"\"\"\n        stack = []  # Initialize stack for tracking.\n        while True:\n            while root:\n                stack.append(root)  # Add to end.\n                root = root.left\n            root = stack.pop()  # Remove and return last element.\n            k -= 1\n            if k == 0:\n                return root.val\n            root = root.right",
    "keyInsight": "Iterative inorder avoids full traversal for small k.",
    "visualizationType": "tree",
    "initialState": [
      3,
      1,
      4,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Kth Smallest Element in a BST",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Inorder traversal, return kth element.\n\nFind kth smallest element in BST.\nInorder = sorted order. Count until k.",
    "examples": [
      {
        "input": "root = [3,1,4,null,2]; k = 1",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find kth smallest element in BST.",
      "Inorder = sorted order. Count until k.",
      "Use iterative inorder with stack."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "5LUXSvjmGCw",
    "problemStatement": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Inorder Traversal: Inorder traversal, return kth element.",
    "suggestedNextQuestion": {
      "slug": "lowest-common-ancestor-of-a-binary-search-tree",
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def kthSmallest(self, root, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def kthSmallest(root, k):\n    stack = []\n    curr = root\n    while stack or curr:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        k -= 1\n        if k == 0:\n            return curr.val\n        curr = curr.right"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h + k)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Find kth smallest element in BST.",
          "\ud83e\udde0 Inorder = sorted order. Count until k.",
          "\ud83d\udca1 Use iterative inorder with stack."
        ],
        "code": "def kthSmallest(root, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find kth smallest element in BST.\n    - \ud83e\udde0 Inorder = sorted order. Count until k.\n    - \ud83d\udca1 Use iterative inorder with stack.\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    while True:\n        while root:\n            stack.append(root)  # Add to end.\n            root = root.left\n        root = stack.pop()  # Remove and return last element.\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // No implementation\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int kthSmallest(TreeNode* root, int k) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) kthSmallest(root *TreeNode, k int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) kthSmallest(root *TreeNode, k int) int {\n\tstk := []*TreeNode{}\n\tfor root != nil || len(stk) > 0 {\n\t\tif root != nil {\n\t\t\tstk = append(stk, root)\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\troot = stk[len(stk)-1]\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\tk--\n\t\t\tif k == 0 {\n\t\t\t\treturn root.Val\n\t\t\t}\n\t\t\troot = root.Right\n\t\t}\n\t}\n\treturn 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>, k: usize) {\n        if let Some(node) = root {\n            let mut node = node.borrow_mut();\n            Self::dfs(node.left.take(), res, k);\n            res.push(node.val);\n            if res.len() >= k {\n                return;\n            }\n            Self::dfs(node.right.take(), res, k);\n        }\n    }\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\n        let k = k as usize;\n        let mut res: Vec<i32> = Vec::with_capacity(k);\n        Self::dfs(root, &mut res, k);\n        res[k - 1]\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def kthSmallest(self, root, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    kthSmallest(root: TreeNode | null, k: number): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "validate-binary-search-tree": {
    "title": "Validate Binary Search Tree",
    "pattern": "DFS with Range",
    "patternEmoji": "\u2705",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "DFS with min/max bounds. Node must be in (min, max).",
    "intuition": [
      "\ud83c\udfaf Is this a valid BST?",
      "\ud83e\udde0 Each node has a valid range (min, max).",
      "\ud83d\udca1 Left: update max. Right: update min."
    ],
    "testCases": [
      {
        "input": "root = [2,1,3]",
        "output": "true"
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def isValidBST(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Is this a valid BST?\n        - \ud83e\udde0 Each node has a valid range (min, max).\n        - \ud83d\udca1 Left: update max. Right: update min.\n        \"\"\"\n        def validate(node, lo, hi):\n            if not node:\n                return True  # Condition satisfied.\n            if not (lo < node.val < hi):\n                return False  # Condition not met.\n            return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n        return validate(root, float('-inf'), float('inf'))",
    "keyInsight": "Each node must satisfy min < node.val < max constraint.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Validate Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "DFS with min/max bounds. Node must be in (min, max).\n\nIs this a valid BST?\nEach node has a valid range (min, max).",
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true"
      },
      {
        "input": "root = [5,1,4,null,null,3,6]",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Is this a valid BST?",
      "Each node has a valid range (min, max).",
      "Left: update max. Right: update min."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "s6ATEkipzow",
    "problemStatement": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS with Range: DFS with min/max bounds. Node must be in (min, max).",
    "suggestedNextQuestion": {
      "slug": "walls-and-gates",
      "title": "Walls And Gates",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isValidBST(self, root):\n        pass\n\n        def validate(node, lo, hi):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isValidBST(root):\n    def valid(node, left, right):\n        if not node: return True\n        if not (left < node.val < right):\n            return False\n        return valid(node.left, left, node.val) and                valid(node.right, node.val, right)\n    return valid(root, float('-inf'), float('inf'))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Is this a valid BST?",
          "\ud83e\udde0 Each node has a valid range (min, max).",
          "\ud83d\udca1 Left: update max. Right: update min."
        ],
        "code": "def isValidBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Is this a valid BST?\n    - \ud83e\udde0 Each node has a valid range (min, max).\n    - \ud83d\udca1 Left: update max. Right: update min.\n    \"\"\"\n    def validate(node, lo, hi):\n        if not node:\n            return True  # Condition satisfied.\n        if not (lo < node.val < hi):\n            return False  # Condition not met.\n        return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n    return validate(root, float('-inf'), float('inf'))"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__() {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isValidBST(root *TreeNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) isValidBST(root *TreeNode) bool {\n\tvar prev *TreeNode\n\tvar dfs func(*TreeNode) bool\n\tdfs = func(root *TreeNode) bool {\n\t\tif root == nil {\n\t\t\treturn true\n\t\t}\n\t\tif !dfs(root.Left) {\n\t\t\treturn false\n\t\t}\n\t\tif prev != nil && prev.Val >= root.Val {\n\t\t\treturn false\n\t\t}\n\t\tprev = root\n\t\treturn dfs(root.Right)\n\t}\n\treturn dfs(root)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>, prev: &mut Option<i32>) -> bool {\n        if root.is_none() {\n            return true;\n        }\n        let root = root.as_ref().unwrap().borrow();\n        if !Self::dfs(&root.left, prev) {\n            return false;\n        }\n        if prev.is_some() && prev.unwrap() >= root.val {\n            return false;\n        }\n        *prev = Some(root.val);\n        Self::dfs(&root.right, prev)\n    }\n\n    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        Self::dfs(&root, &mut None)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isValidBST(self, root):\n        pass\n\n        def validate(node, lo, hi):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "lowest-common-ancestor-of-a-bst": {
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "pattern": "BST Property",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(1)",
    "oneliner": "If both p,q < node, go left. If both > node, go right. Else LCA.",
    "intuition": [
      "\ud83c\udfaf Find LCA in BST (not general tree).",
      "\ud83e\udde0 Use BST property: p < node < q means split.",
      "\ud83d\udca1 First node where p and q split is LCA."
    ],
    "testCases": [
      {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
        "output": "6"
      },
      {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
        "output": "2"
      },
      {
        "input": "root = [2,1], p = 2, q = 1",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find LCA in BST (not general tree).\n        - \ud83e\udde0 Use BST property: p < node < q means split.\n        - \ud83d\udca1 First node where p and q split is LCA.\n        \"\"\"\n        while root:\n            if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root.val\n        return None",
    "keyInsight": "BST structure lets us decide direction without full search.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Lowest Common Ancestor of a Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "If both p,q < node, go left. If both > node, go right. Else LCA.\n\nFind LCA in BST (not general tree).\nUse BST property: p < node < q means split.",
    "examples": [
      {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5]; p = 2; q = 8",
        "output": "6"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find LCA in BST (not general tree).",
      "Use BST property: p < node < q means split.",
      "First node where p and q split is LCA."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "gs2LMfuOR9k",
    "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
    "difficulty": "Medium",
    "walkthrough": [
      "Start at root node",
      "Compare p.val and q.val with root.val",
      "If both less than root.val, move to left subtree",
      "If both greater than root.val, move to right subtree",
      "Otherwise, current node is the LCA (split point)",
      "Return the current node's value"
    ],
    "approach": "BST Property: If both p,q < node, go left. If both > node, go right. Else LCA.",
    "suggestedNextQuestion": {
      "slug": "min-cost-to-connect-all-points",
      "title": "Min Cost to Connect All Points",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    curr = root\n    while curr:\n        if p.val > curr.val and q.val > curr.val:\n            curr = curr.right\n        elif p.val < curr.val and q.val < curr.val:\n            curr = curr.left\n        else:\n            return curr"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find LCA in BST (not general tree).",
          "\ud83e\udde0 Use BST property: p < node < q means split.",
          "\ud83d\udca1 First node where p and q split is LCA."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA in BST (not general tree).\n    - \ud83e\udde0 Use BST property: p < node < q means split.\n    - \ud83d\udca1 First node where p and q split is LCA.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root.val\n    return None"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val   int\n *     Left  *TreeNode\n *     Right *TreeNode\n * }\n */\n\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tfor {\n\t\tif root.Val < min(p.Val, q.Val) {\n\t\t\troot = root.Right\n\t\t} else if root.Val > max(p.Val, q.Val) {\n\t\t\troot = root.Left\n\t\t} else {\n\t\t\treturn root\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\nimpl Solution {\n    fn lowest_common_ancestor(mut root: TreeLink, p: TreeLink, q: TreeLink) -> TreeLink {\n        let p_val = p.unwrap().borrow().val;\n        let q_val = q.unwrap().borrow().val;\n        while let Some(node) = root.clone() {\n            let mut node = node.borrow_mut();\n            let val = node.val;\n            if val > p_val && val > q_val {\n                root = node.left.take();\n                continue;\n            }\n            if val < p_val && val < q_val {\n                root = node.right.take();\n                continue;\n            }\n            node.left.take();\n            node.right.take();\n            break;\n        }\n        root\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(\n        6,\n        tree!(2, tree!(0), tree!(4, tree!(3), tree!(5))),\n        tree!(8, tree!(7), tree!(9))\n    );\n    let p = tree!(2);\n    let q = tree!(8);\n    let res = tree!(6);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(\n        6,\n        tree!(2, tree!(0), tree!(4, tree!(3), tree!(5))),\n        tree!(8, tree!(7), tree!(9))\n    );\n    let p = tree!(2);\n    let q = tree!(4);\n    let res = tree!(2);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n    let root = tree!(2, tree!(1), None);\n    let p = tree!(2);\n    let q = tree!(1);\n    let res = tree!(2);\n    assert_eq!(Solution::lowest_common_ancestor(root, p, q), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "balance-a-binary-search-tree": {
    "title": "Balance a Binary Search Tree",
    "pattern": "Inorder + Rebuild",
    "patternEmoji": "\u2696\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Inorder to sorted array. Build balanced BST from array.",
    "intuition": [
      "\ud83c\udfaf Convert BST to balanced BST.",
      "\ud83e\udde0 Extract sorted array via inorder.",
      "\ud83d\udca1 Recursively build from middle element."
    ],
    "testCases": [
      {
        "input": "root = [1,null,2,null,3,null,4,null,null]",
        "output": "[2,1,3,null,null,null,4]"
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,1,3]"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def balanceBST(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Convert BST to balanced BST.\n        - \ud83e\udde0 Extract sorted array via inorder.\n        - \ud83d\udca1 Recursively build from middle element.\n        \"\"\"\n        vals = []\n        def inorder(self, node):\n            if not node: return\n            inorder(node.left)  # Recursive inorder traversal.\n            vals.append(node.val)  # Add to end.\n            inorder(node.right)  # Recursive inorder traversal.\n        inorder(root)  # Recursive inorder traversal.\n        def build(self, l, r):\n            if l > r: return None\n            mid = (l + r) // 2\n            node = TreeNode(vals[mid])  # Create a new Tree Node.\n            node.left = build(l, mid - 1)\n            node.right = build(mid + 1, r)\n            return node\n        return build(0, len(vals) - 1)",
    "keyInsight": "Middle element as root gives balanced tree.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Balance a Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Inorder to sorted array. Build balanced BST from array.\n\nConvert BST to balanced BST.\nExtract sorted array via inorder.",
    "examples": [
      {
        "input": "root = [1,null,2,null,3,null,4]",
        "output": "[2,1,3,null,null,null,4]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Convert BST to balanced BST.",
      "Extract sorted array via inorder.",
      "Recursively build from middle element."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "fqx8z3VepMA",
    "problemStatement": "Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Inorder + Rebuild: Inorder to sorted array. Build balanced BST from array.",
    "suggestedNextQuestion": {
      "slug": "binary-search-tree-iterator",
      "title": "Binary Search Tree Iterator",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def balanceBST(root):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    \n    def build(l, r):\n        if l > r: return None\n        m = (l + r) // 2\n        node = TreeNode(vals[m])\n        node.left = build(l, m - 1)\n        node.right = build(m + 1, r)\n        return node\n    return build(0, len(vals) - 1)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Convert BST to balanced BST.",
          "\ud83e\udde0 Extract sorted array via inorder.",
          "\ud83d\udca1 Recursively build from middle element."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef balanceBST(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert BST to balanced BST.\n    - \ud83e\udde0 Extract sorted array via inorder.\n    - \ud83d\udca1 Recursively build from middle element.\n    \"\"\"\n    vals = []\n    def inorder(node):  # Recursive inorder traversal.\n        if not node: return\n        inorder(node.left)  # Recursive inorder traversal.\n        vals.append(node.val)  # Add to end.\n        inorder(node.right)  # Recursive inorder traversal.\n    inorder(root)  # Recursive inorder traversal.\n    def build(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        node = TreeNode(vals[mid])  # Create a new Tree Node.\n        node.left = build(l, mid - 1)\n        node.right = build(mid + 1, r)\n        return node\n    return build(0, len(vals) - 1)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* balanceBST(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* balanceBST(TreeNode* root) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) balanceBST(root *TreeNode) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) balanceBST(root *TreeNode) *TreeNode {\n\tans := []int{}\n\tvar dfs func(*TreeNode)\n\tdfs = func(root *TreeNode) {\n\t\tif root == nil {\n\t\t\treturn\n\t\t}\n\t\tdfs(root.Left)\n\t\tans = append(ans, root.Val)\n\t\tdfs(root.Right)\n\t}\n\tvar build func(i, j int) *TreeNode\n\tbuild = func(i, j int) *TreeNode {\n\t\tif i > j {\n\t\t\treturn nil\n\t\t}\n\t\tmid := (i + j) >> 1\n\t\tleft := build(i, mid-1)\n\t\tright := build(mid+1, j)\n\t\treturn &TreeNode{Val: ans[mid], Left: left, Right: right}\n\t}\n\tdfs(root)\n\treturn build(0, len(ans)-1)\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\ntrait Inorder {\n    fn inorder(self, nodes: &mut Vec<i32>);\n    fn build(nodes: &[i32]) -> TreeLink;\n}\n\nimpl Inorder for TreeLink {\n    fn inorder(self, nodes: &mut Vec<i32>) {\n        if let Some(node) = self {\n            let mut node = node.borrow_mut();\n            let val = node.val;\n            let left = node.left.take();\n            let right = node.right.take();\n            left.inorder(nodes);\n            nodes.push(val);\n            right.inorder(nodes);\n        }\n    }\n    fn build(nodes: &[i32]) -> TreeLink {\n        let n = nodes.len();\n        if n == 0 {\n            None\n        } else {\n            let m = n / 2;\n            tree!(\n                nodes[m],\n                TreeLink::build(&nodes[..m]),\n                TreeLink::build(&nodes[m + 1..])\n            )\n        }\n    }\n}\n\nimpl Solution {\n    fn balance_bst(root: TreeLink) -> TreeLink {\n        let mut nodes: Vec<i32> = vec![];\n        root.inorder(&mut nodes);\n        TreeLink::build(&nodes)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(1, None, tree!(2, None, tree!(3, None, tree!(4))));\n    let res = tree!(3, tree!(2, tree!(1), None), tree!(4));\n    assert_eq!(Solution::balance_bst(root), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "surrounded-regions": {
    "title": "Surrounded Regions",
    "pattern": "DFS from Border",
    "patternEmoji": "\ud83d\uddfa\ufe0f",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "oneliner": "DFS from border Os to mark safe. Flip remaining Os to Xs.",
    "intuition": [
      "\ud83c\udfaf Flip all O regions NOT connected to border.",
      "\ud83e\udde0 Mark border-connected Os as safe.",
      "\ud83d\udca1 Flip remaining Os, restore safe ones."
    ],
    "testCases": [
      {
        "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
        "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
      },
      {
        "input": "board = [[\"X\"]]",
        "output": "[[\"X\"]]"
      }
    ],
    "code": "class Solution:\n    def solve(self, board):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Flip all O regions NOT connected to border.\n        - \ud83e\udde0 Mark border-connected Os as safe.\n        - \ud83d\udca1 Flip remaining Os, restore safe ones.\n        \"\"\"\n        if not board: return board\n        m, n = len(board), len(board[0])\n        def dfs(r, c):\n            if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n                return\n            board[r][c] = 'S'\n            dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n        for r in range(m):  # Iterate through the range.\n            dfs(r, 0); dfs(r, n-1)\n        for c in range(n):  # Iterate through the range.\n            dfs(0, c); dfs(m-1, c)\n        for r in range(m):  # Iterate through the range.\n            for c in range(n):  # Iterate through the range.\n                board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n        return board",
    "keyInsight": "Work from border inward to identify safe regions.",
    "visualizationType": "grid",
    "initialState": [
      [
        "X",
        "X",
        "X",
        "X"
      ],
      [
        "X",
        "O",
        "O",
        "X"
      ],
      [
        "X",
        "X",
        "O",
        "X"
      ],
      [
        "X",
        "O",
        "X",
        "X"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Surrounded Regions",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: X",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: X",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: X",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: O",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "X",
            "X",
            "X",
            "X"
          ],
          [
            "X",
            "O",
            "O",
            "X"
          ],
          [
            "X",
            "X",
            "O",
            "X"
          ],
          [
            "X",
            "O",
            "X",
            "X"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "DFS from border Os to mark safe. Flip remaining Os to Xs.\n\nFlip all O regions NOT connected to border.\nMark border-connected Os as safe.",
    "examples": [
      {
        "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
        "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Flip all O regions NOT connected to border.",
      "Mark border-connected Os as safe.",
      "Flip remaining Os, restore safe ones."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "9z2BunfoZ5Y",
    "problemStatement": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded:\nTo capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS from Border: DFS from border Os to mark safe. Flip remaining Os to Xs.",
    "suggestedNextQuestion": {
      "slug": "validate-binary-search-tree",
      "title": "Validate Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def solve(self, board):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def solve(board):\n    if not board: return\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or c < 0 or r == rows or c == cols or board[r][c] != 'O':\n            return\n        board[r][c] = 'T'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n        \n    # Capture unsurrounded regions (O -> T)\n    for r in range(rows):\n        for c in range(cols):\n            if (board[r][c] == 'O' and \n                (r in [0, rows-1] or c in [0, cols-1])):\n                dfs(r, c)\n                \n    # Capture surrounded regions (O -> X, T -> O)\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O': \n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)",
        "intuition": [
          "\ud83c\udfaf Flip all O regions NOT connected to border.",
          "\ud83e\udde0 Mark border-connected Os as safe.",
          "\ud83d\udca1 Flip remaining Os, restore safe ones."
        ],
        "code": "def solve(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Flip all O regions NOT connected to border.\n    - \ud83e\udde0 Mark border-connected Os as safe.\n    - \ud83d\udca1 Flip remaining Os, restore safe ones.\n    \"\"\"\n    if not board: return board\n    m, n = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n            return\n        board[r][c] = 'S'\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    for r in range(m):  # Iterate through the range.\n        dfs(r, 0); dfs(r, n-1)\n    for c in range(n):  # Iterate through the range.\n        dfs(0, c); dfs(m-1, c)\n    for r in range(m):  # Iterate through the range.\n        for c in range(n):  # Iterate through the range.\n            board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n    return board"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    solve(board) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} board\n     * @return {any}\n     */\n    solve(board) {\n        for (let i = 0; i < board.length; i++) {\n          for (let j = 0; j < board[0].length; j++) {\n            if (board[i][j] === 'O'\n                && (!i || !j || i === board.length - 1 || j === board[0].length - 1)) {\n              dfs(i, j);\n            }\n          }\n        }\n\n        for (let i = 0; i < board.length; i++) {\n          for (let j = 0; j < board[0].length; j++) {\n            if (board[i][j] === '-') {\n              board[i][j] = 'O';\n            } else {\n              board[i][j] = 'X';\n            }\n          }\n        }\n\n        class Solution {\n          /**\n           * @param {any} i, j\n           * @return {any}\n           */\n          dfs(i, j) {\n          if (i < 0 || i >= board.length || j < 0 || j >= board[i].length\n              || board[i][j] === '-' || board[i][j] === 'X') {\n            return;\n          }\n\n          board[i][j] = '-';\n          dfs(i - 1, j);\n          dfs(i + 1, j);\n          dfs(i, j - 1);\n          dfs(i, j + 1);\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void solve(char[][] board) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    private final int[] dirs = {-1, 0, 1, 0, -1};\n    private char[][] board;\n    private int m;\n    private int n;\n\n    public void solve(char[][] board) {\n        m = board.length;\n        n = board[0].length;\n        this.board = board;\n        for (int i = 0; i < m; ++i) {\n            dfs(i, 0);\n            dfs(i, n - 1);\n        }\n        for (int j = 0; j < n; ++j) {\n            dfs(0, j);\n            dfs(m - 1, j);\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == '.') {\n                    board[i][j] = 'O';\n                } else if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n\n    private void dfs(int i, int j) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O') {\n            return;\n        }\n        board[i][j] = '.';\n        for (int k = 0; k < 4; ++k) {\n            dfs(i + dirs[k], j + dirs[k + 1]);\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void solve(vector<vector<char>>& board) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        int m = board.size(), n = board[0].size();\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        function<void(int, int)> dfs = [&](int i, int j) {\n            if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O') {\n                return;\n            }\n            board[i][j] = '.';\n            for (int k = 0; k < 4; ++k) {\n                dfs(i + dirs[k], j + dirs[k + 1]);\n            }\n        };\n        for (int i = 0; i < m; ++i) {\n            dfs(i, 0);\n            dfs(i, n - 1);\n        }\n        for (int j = 1; j < n - 1; ++j) {\n            dfs(0, j);\n            dfs(m - 1, j);\n        }\n        for (auto& row : board) {\n            for (auto& c : row) {\n                if (c == '.') {\n                    c = 'O';\n                } else if (c == 'O') {\n                    c = 'X';\n                }\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) solve(board [][]byte) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) solve(board [][]byte) {\n\tm, n := len(board), len(board[0])\n\tdirs := [5]int{-1, 0, 1, 0, -1}\n\tvar dfs func(i, j int)\n\tdfs = func(i, j int) {\n\t\tif i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O' {\n\t\t\treturn\n\t\t}\n\t\tboard[i][j] = '.'\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tdfs(i+dirs[k], j+dirs[k+1])\n\t\t}\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tdfs(i, 0)\n\t\tdfs(i, n-1)\n\t}\n\tfor j := 0; j < n; j++ {\n\t\tdfs(0, j)\n\t\tdfs(m-1, j)\n\t}\n\tfor i, row := range board {\n\t\tfor j, c := range row {\n\t\t\tif c == '.' {\n\t\t\t\tboard[i][j] = 'O'\n\t\t\t} else if c == 'O' {\n\t\t\t\tboard[i][j] = 'X'\n\t\t\t}\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn solve(board: &mut Vec<Vec<char>>) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn solve(board: &mut Vec<Vec<char>>) {\n        let m = board.len();\n        let n = board[0].len();\n        let dirs = vec![-1, 0, 1, 0, -1];\n\n        fn dfs(\n            board: &mut Vec<Vec<char>>,\n            i: usize,\n            j: usize,\n            dirs: &Vec<i32>,\n            m: usize,\n            n: usize,\n        ) {\n            if i >= 0 && i < m && j >= 0 && j < n && board[i][j] == 'O' {\n                board[i][j] = '.';\n                for k in 0..4 {\n                    dfs(\n                        board,\n                        ((i as i32) + dirs[k]) as usize,\n                        ((j as i32) + dirs[k + 1]) as usize,\n                        dirs,\n                        m,\n                        n,\n                    );\n                }\n            }\n        }\n\n        for i in 0..m {\n            dfs(board, i, 0, &dirs, m, n);\n            dfs(board, i, n - 1, &dirs, m, n);\n        }\n        for j in 0..n {\n            dfs(board, 0, j, &dirs, m, n);\n            dfs(board, m - 1, j, &dirs, m, n);\n        }\n\n        for i in 0..m {\n            for j in 0..n {\n                if board[i][j] == '.' {\n                    board[i][j] = 'O';\n                } else if board[i][j] == 'O' {\n                    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self, board):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(board: string[][]): void  {\n    const m = board.length;\n    const n = board[0].length;\n    const dirs: number[] = [-1, 0, 1, 0, -1];\n    const dfs = (i: number, j: number): void => {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== 'O') {\n            return;\n        }\n        board[i][j] = '.';\n        for (let k = 0; k < 4; ++k) {\n            dfs(i + dirs[k], j + dirs[k + 1]);\n        }\n    };\n    for (let i = 0; i < m; ++i) {\n        dfs(i, 0);\n        dfs(i, n - 1);\n    }\n    for (let j = 0; j < n; ++j) {\n        dfs(0, j);\n        dfs(m - 1, j);\n    }\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (board[i][j] === '.') {\n                board[i][j] = 'O';\n            } else if (board[i][j] === 'O') {\n                board[i][j] = 'X';\n            }\n        }\n    }\n}\n}",
        "initialCode": "class Solution {\n    solve(board: string[][]): void {\n        // Your code here\n    }\n}"
      }
    }
  },
  "evaluate-division": {
    "title": "Evaluate Division",
    "pattern": "Graph BFS/DFS",
    "patternEmoji": "\u2797",
    "timeComplexity": "O(Q*(V+E))",
    "spaceComplexity": "O(V+E)",
    "oneliner": "Build graph of ratios. DFS/BFS to find path and multiply.",
    "intuition": [
      "\ud83c\udfaf Evaluate queries given equations with values.",
      "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
      "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
    ],
    "testCases": [
      {
        "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
        "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
      },
      {
        "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
        "output": "[3.75000,0.40000,5.00000,0.20000]"
      },
      {
        "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
        "output": "[0.50000,2.00000,-1.00000,-1.00000]"
      }
    ],
    "code": "class Solution:\n    from collections import defaultdict\n    \n    def calcEquation(self, equations, values, queries):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Evaluate queries given equations with values.\n        - \ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.\n        - \ud83d\udca1 Query a/c = path from a to c, multiply weights.\n        \"\"\"\n        graph = defaultdict(dict)\n        for (a, b), v in zip(equations, values):  # Iterate over elements.\n            graph[a][b] = v\n            graph[b][a] = 1 / v\n        \n        def dfs(self, start, end, visited):\n            if start not in graph or end not in graph:\n                return -1.0\n            if start == end:\n                return 1.0\n            visited.add(start)\n            for nei, val in graph[start].items():  # Iterate over elements.\n                if nei not in visited:\n                    res = dfs(nei, end, visited)\n                    if res != -1.0:\n                        return val * res\n            return -1.0\n        \n        return [dfs(a, b, set()) for a, b in queries]",
    "keyInsight": "Weighted graph where edge weight represents the ratio.",
    "visualizationType": "graph",
    "initialState": [
      [
        "a",
        "b"
      ],
      [
        "b",
        "c"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Build Graph from Equations",
        "transientMessage": "equations = [[a,b],[b,c]], values = [2.0, 3.0]",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150
            }
          ],
          "edges": []
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Add edge: a \u2192 b = 2.0",
        "transientMessage": "a / b = 2.0 means graph[a][b] = 2.0",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150,
              "highlight": true
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2,
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Add reverse: b \u2192 a = 0.5",
        "transientMessage": "Also store inverse: graph[b][a] = 1/2.0 = 0.5",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150,
              "highlight": true
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5,
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Add edge: b \u2192 c = 3.0",
        "transientMessage": "b / c = 3.0 means graph[b][c] = 3.0",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150,
              "highlight": true
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3,
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Add reverse: c \u2192 b = 0.33",
        "transientMessage": "graph[c][b] = 1/3.0 \u2248 0.33",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3
            },
            {
              "from": "c",
              "to": "b",
              "weight": 0.33,
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Query: a / c = ?",
        "transientMessage": "Find path from 'a' to 'c', multiply weights",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a (start)",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150
            },
            {
              "id": "c",
              "label": "c (goal)",
              "x": 400,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3
            },
            {
              "from": "c",
              "to": "b",
              "weight": 0.33
            }
          ]
        },
        "pointers": [
          {
            "label": "DFS",
            "node": "a"
          }
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "DFS: Start at 'a'",
        "transientMessage": "visited = {a}, result = 1.0",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3
            },
            {
              "from": "c",
              "to": "b",
              "weight": 0.33
            }
          ]
        },
        "pointers": [
          {
            "label": "curr",
            "node": "a"
          }
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "DFS: a \u2192 b (\u00d72.0)",
        "transientMessage": "Traverse edge a\u2192b, multiply: 1.0 \u00d7 2.0 = 2.0",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "b",
              "label": "b \u2713",
              "x": 250,
              "y": 150,
              "visited": true,
              "highlight": true
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2,
              "highlight": true
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3
            },
            {
              "from": "c",
              "to": "b",
              "weight": 0.33
            }
          ]
        },
        "pointers": [
          {
            "label": "curr",
            "node": "b"
          },
          {
            "label": "result",
            "value": "2.0"
          }
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "DFS: b \u2192 c (\u00d73.0)",
        "transientMessage": "Traverse edge b\u2192c, multiply: 2.0 \u00d7 3.0 = 6.0",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "b",
              "label": "b \u2713",
              "x": 250,
              "y": 150,
              "visited": true
            },
            {
              "id": "c",
              "label": "c \u2713",
              "x": 400,
              "y": 150,
              "visited": true,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2,
              "highlight": true
            },
            {
              "from": "b",
              "to": "a",
              "weight": 0.5
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3,
              "highlight": true
            },
            {
              "from": "c",
              "to": "b",
              "weight": 0.33
            }
          ]
        },
        "pointers": [
          {
            "label": "curr",
            "node": "c"
          },
          {
            "label": "result",
            "value": "6.0"
          }
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Found: a / c = 6.0",
        "transientMessage": "Path: a \u2192 b \u2192 c = 2.0 \u00d7 3.0 = 6.0 \u2713",
        "graphState": {
          "nodes": [
            {
              "id": "a",
              "label": "a",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "b",
              "label": "b",
              "x": 250,
              "y": 150,
              "highlight": true
            },
            {
              "id": "c",
              "label": "c",
              "x": 400,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "a",
              "to": "b",
              "weight": 2,
              "highlight": true
            },
            {
              "from": "b",
              "to": "c",
              "weight": 3,
              "highlight": true
            }
          ]
        },
        "pointers": [
          {
            "label": "result",
            "value": "6.0"
          }
        ],
        "result": 6,
        "color": "success"
      }
    ],
    "description": "Build graph of ratios. DFS/BFS to find path and multiply.\n\nEvaluate queries given equations with values.\nBuild weighted graph: a/b = k means edge a->b with weight k.",
    "examples": [
      {
        "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]]; values = [2.0,3.0]; queries = [[\"a\",\"c\"]]",
        "output": "[6.0]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Evaluate queries given equations with values.",
      "Build weighted graph: a/b = k means edge a->b with weight k.",
      "Query a/c = path from a to c, multiply weights."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Uei1fwDoyKk",
    "problemStatement": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Graph BFS/DFS: Build graph of ratios. DFS/BFS to find path and multiply.",
    "suggestedNextQuestion": {
      "slug": "graph-valid-tree",
      "title": "Graph Valid Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(V * E) or O(V!)",
        "spaceComplexity": "O(V)",
        "intuition": [
          "Explore all possible paths.",
          "Use DFS/BFS without optimization."
        ],
        "code": "def calcEquation_brute(graph, start, end):\n    # DFS all paths\n    def dfs(node, visited):\n        if node == end:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    return dfs(start, set())"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(Q*(V+E))",
        "spaceComplexity": "O(V+E)",
        "intuition": [
          "\ud83c\udfaf Evaluate queries given equations with values.",
          "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
          "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
        ],
        "code": "from collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Evaluate queries given equations with values.\n    - \ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.\n    - \ud83d\udca1 Query a/c = path from a to c, multiply weights.\n    \"\"\"\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):  # Iterate over elements.\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n    \n    def dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        visited.add(start)\n        for nei, val in graph[start].items():  # Iterate over elements.\n            if nei not in visited:\n                res = dfs(nei, end, visited)\n                if res != -1.0:\n                    return val * res\n        return -1.0\n    \n    return [dfs(a, b, set()) for a, b in queries]"
      }
    ],
    "commonMistakes": [
      "Forgetting to mark nodes as visited",
      "Not handling disconnected components",
      "Wrong initialization of distance array"
    ],
    "interviewTip": "Clarify: directed/undirected, weighted/unweighted. Mention BFS for shortest path.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(...args) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(...args) { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public double[] solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public double[] solve() {\n        return new double[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    double solve(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    double solve(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {\n        return 0.0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {\n\tp := make(map[string]string)\n\tw := make(map[string]float64)\n\tfor _, e := range equations {\n\t\ta, b := e[0], e[1]\n\t\tp[a], p[b] = a, b\n\t\tw[a], w[b] = 1.0, 1.0\n\t}\n\n\tvar find func(x string) string\n\tfind = func(x string) string {\n\t\tif p[x] != x {\n\t\t\torigin := p[x]\n\t\t\tp[x] = find(p[x])\n\t\t\tw[x] *= w[origin]\n\t\t}\n\t\treturn p[x]\n\t}\n\n\tfor i, v := range values {\n\t\ta, b := equations[i][0], equations[i][1]\n\t\tpa, pb := find(a), find(b)\n\t\tif pa == pb {\n\t\t\tcontinue\n\t\t}\n\t\tp[pa] = pb\n\t\tw[pa] = w[b] * v / w[a]\n\t}\n\tvar ans []float64\n\tfor _, e := range queries {\n\t\tc, d := e[0], e[1]\n\t\tif p[c] == \"\" || p[d] == \"\" || find(c) != find(d) {\n\t\t\tans = append(ans, -1.0)\n\t\t} else {\n\t\t\tans = append(ans, w[c]/w[d])\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(equations: &Vec<Vec<String>>) -> DisjointSetUnion {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\n#[derive(Debug)]\npub struct DSUNode {\n    parent: String,\n    weight: f64,\n}\n\npub struct DisjointSetUnion {\n    nodes: HashMap<String, DSUNode>,\n}\n\nimpl DisjointSetUnion {\n    pub fn new(equations: &Vec<Vec<String>>) -> DisjointSetUnion {\n        let mut nodes = HashMap::new();\n        for equation in equations.iter() {\n            for iter in equation.iter() {\n                nodes.insert(\n                    iter.clone(),\n                    DSUNode {\n                        parent: iter.clone(),\n                        weight: 1.0,\n                    },\n                );\n            }\n        }\n        DisjointSetUnion { nodes }\n    }\n\n    pub fn find(&mut self, v: &String) -> String {\n        let origin = self.nodes[v].parent.clone();\n        if origin == *v {\n            return origin;\n        }\n\n        let root = self.find(&origin);\n        self.nodes.get_mut(v).unwrap().parent = root.clone();\n        self.nodes.get_mut(v).unwrap().weight *= self.nodes[&origin].weight;\n        root\n    }\n\n    pub fn union(&mut self, a: &String, b: &String, v: f64) {\n        let pa = self.find(a);\n        let pb = self.find(b);\n        if pa == pb {\n            return;\n        }\n        let (wa, wb) = (self.nodes[a].weight, self.nodes[b].weight);\n        self.nodes.get_mut(&pa).unwrap().parent = pb;\n        self.nodes.get_mut(&pa).unwrap().weight = (wb * v) / wa;\n    }\n\n    pub fn exist(&mut self, k: &String) -> bool {\n        self.nodes.contains_key(k)\n    }\n\n    pub fn calc_value(&mut self, a: &String, b: &String) -> f64 {\n        if !self.exist(a) || !self.exist(b) || self.find(a) != self.find(b) {\n            -1.0\n        } else {\n            let wa = self.nodes[a].weight;\n            let wb = self.nodes[b].weight;\n            wa / wb\n        }\n    }\n}\n\nimpl Solution {\n    pub fn calc_equation(\n        equations: Vec<Vec<String>>,\n        values: Vec<f64>,\n        queries: Vec<Vec<String>>,\n    ) -> Vec<f64> {\n        let mut dsu = DisjointSetUnion::new(&equations);\n        for (i, &v) in values.iter().enumerate() {\n            let (a, b) = (&equations[i][0], &equations[i][1]);\n            dsu.union(a, b, v);\n        }\n\n        let mut ans = vec![];\n        for querie in queries {\n            let (c, d) = (&querie[0], &querie[1]);\n            ans.push(dsu.calc_value(c, d));\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(...args: any[]): any {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    solve(...args: any[]): any {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "course-schedule-ii": {
    "title": "Course Schedule II",
    "pattern": "Topological Sort",
    "patternEmoji": "\ud83d\udcda",
    "timeComplexity": "O(V+E)",
    "spaceComplexity": "O(V+E)",
    "oneliner": "Kahn's algorithm: BFS with indegree. Return order or [].",
    "intuition": [
      "\ud83c\udfaf Return valid course order or [] if impossible.",
      "\ud83e\udde0 Topological sort using indegree.",
      "\ud83d\udca1 If all courses processed, return order."
    ],
    "testCases": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "[0,1]"
      },
      {
        "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0, 1, 2, 3]"
      },
      {
        "input": "numCourses = 1, prerequisites = []",
        "output": "[0]"
      }
    ],
    "code": "class Solution:\n    from collections import deque, defaultdict\n    \n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Return valid course order or [] if impossible.\n        - \ud83e\udde0 Topological sort using indegree.\n        - \ud83d\udca1 If all courses processed, return order.\n        \"\"\"\n        graph = defaultdict(list)\n        indegree = [0] * numCourses\n        for a, b in prerequisites:  # Iterate over elements.\n            graph[b].append(a)  # Add to end.\n            indegree[a] += 1\n        q = deque([i for i in range(numCourses) if indegree[i] == 0])  # Initialize queue for BFS.\n        order = []\n        while q:\n            course = q.popleft()  # Remove from front of queue.\n            order.append(course)  # Add to end.\n            for nei in graph[course]:  # Iterate over elements.\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)  # Add to end.\n        return order if len(order) == numCourses else []",
    "keyInsight": "Topological sort returns empty if cycle exists.",
    "visualizationType": "graph",
    "initialState": [
      0,
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Build DAG",
        "transientMessage": "prereqs define order",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0",
              "x": 200,
              "y": 50
            },
            {
              "id": "1",
              "label": "1",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Kahn's: Start 0",
        "transientMessage": "order = [0]",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "1",
              "label": "1",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "highlight": true
            },
            {
              "from": "0",
              "to": "2",
              "highlight": true
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [
          {
            "label": "order",
            "value": "[0]"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Take 1, 2",
        "transientMessage": "order = [0,1,2]",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 150,
              "visited": true
            },
            {
              "id": "3",
              "label": "3",
              "x": 200,
              "y": 250,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [
          {
            "label": "order",
            "value": "[0,1,2]"
          }
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Result: [0,1,2,3]",
        "transientMessage": "Valid topological order",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 200,
              "y": 50
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 150
            },
            {
              "id": "3",
              "label": "3 \u2713",
              "x": 200,
              "y": 250
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "0",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3"
            }
          ]
        },
        "pointers": [
          {
            "label": "order",
            "value": "[0,1,2,3]"
          }
        ],
        "color": "success"
      }
    ],
    "description": "Kahn's algorithm: BFS with indegree. Return order or [].\n\nReturn valid course order or [] if impossible.\nTopological sort using indegree.",
    "examples": [
      {
        "input": "numCourses = 4; prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
        "output": "[0,1,2,3]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Return valid course order or [] if impossible.",
      "Topological sort using indegree.",
      "If all courses processed, return order."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Akt3glAwyfY",
    "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Topological Sort: Kahn's algorithm: BFS with indegree. Return order or [].",
    "graphNodes": [
      {
        "id": 0,
        "label": "0"
      },
      {
        "id": 1,
        "label": "1"
      },
      {
        "id": 2,
        "label": "2"
      },
      {
        "id": 3,
        "label": "3"
      }
    ],
    "graphEdges": [
      {
        "from": 1,
        "to": 0
      },
      {
        "from": 2,
        "to": 0
      },
      {
        "from": 3,
        "to": 1
      },
      {
        "from": 3,
        "to": 2
      }
    ],
    "suggestedNextQuestion": {
      "slug": "diameter-of-binary-tree",
      "title": "Diameter of Binary Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like putting on clothes. Socks before shoes. Order matters based on dependencies.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findOrder(numCourses, prerequisites):\n    prereq = { c:[] for c in range(numCourses) }\n    for crs, pre in prerequisites:\n        prereq[crs].append(pre)\n        \n    output = []\n    visit, cycle = set(), set()\n    def dfs(crs):\n        if crs in cycle: return False\n        if crs in visit: return True\n        \n        cycle.add(crs)\n        for pre in prereq[crs]:\n            if not dfs(pre): return False\n        cycle.remove(crs)\n        visit.add(crs)\n        output.append(crs)\n        return True\n        \n    for c in range(numCourses):\n        if not dfs(c): return []\n    return output"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(V+E)",
        "spaceComplexity": "O(V+E)",
        "intuition": [
          "\ud83c\udfaf Return valid course order or [] if impossible.",
          "\ud83e\udde0 Topological sort using indegree.",
          "\ud83d\udca1 If all courses processed, return order."
        ],
        "code": "from collections import deque, defaultdict\n\ndef findOrder(numCourses, prerequisites):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Return valid course order or [] if impossible.\n    - \ud83e\udde0 Topological sort using indegree.\n    - \ud83d\udca1 If all courses processed, return order.\n    \"\"\"\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for a, b in prerequisites:  # Iterate over elements.\n        graph[b].append(a)  # Add to end.\n        indegree[a] += 1\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])  # Initialize queue for BFS.\n    order = []\n    while q:\n        course = q.popleft()  # Remove from front of queue.\n        order.append(course)  # Add to end.\n        for nei in graph[course]:  # Iterate over elements.\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                q.append(nei)  # Add to end.\n    return order if len(order) == numCourses else []"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(numCourses: number, prerequisites: number[][]): number[] {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(numCourses: number, prerequisites: number[][]): number[] {\n        return [];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] solve() {\n        return new int[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> solve(int numCourses, vector<vector<int>>& prerequisites) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> solve(int numCourses, vector<vector<int>>& prerequisites) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findOrder(numCourses int, prerequisites [][]int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findOrder(numCourses int, prerequisites [][]int) []int {\n\tg := make([][]int, numCourses)\n\tindeg := make([]int, numCourses)\n\tfor _, p := range prerequisites {\n\t\ta, b := p[0], p[1]\n\t\tg[b] = append(g[b], a)\n\t\tindeg[a]++\n\t}\n\tq := []int{}\n\tfor i, x := range indeg {\n\t\tif x == 0 {\n\t\t\tq = append(q, i)\n\t\t}\n\t}\n\tans := []int{}\n\tfor len(q) > 0 {\n\t\ti := q[0]\n\t\tq = q[1:]\n\t\tans = append(ans, i)\n\t\tfor _, j := range g[i] {\n\t\t\tindeg[j]--\n\t\t\tif indeg[j] == 0 {\n\t\t\t\tq = append(q, j)\n\t\t\t}\n\t\t}\n\t}\n\tif len(ans) == numCourses {\n\t\treturn ans\n\t}\n\treturn []int{}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_order(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = num_courses as usize;\n        let mut adjacency = vec![vec![]; n];\n        let mut entry = vec![0; n];\n        // init\n        for iter in prerequisites.iter() {\n            let (a, b) = (iter[0], iter[1]);\n            adjacency[b as usize].push(a);\n            entry[a as usize] += 1;\n        }\n        // construct deque & reslut\n        let mut deque = std::collections::VecDeque::new();\n        for index in 0..n {\n            if entry[index] == 0 {\n                deque.push_back(index);\n            }\n        }\n        let mut result = vec![];\n        // bfs\n        while !deque.is_empty() {\n            let head = deque.pop_front().unwrap();\n            result.push(head as i32);\n            // update degree of entry\n            for &out_entry in adjacency[head].iter() {\n                entry[out_entry as usize] -= 1;\n                if entry[out_entry as usize] == 0 {\n                    deque.push_back(out_entry as usize);\n                }\n            }\n        }\n        if result.len() == n {\n            result\n        } else {\n            vec![]\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(numCourses: number, prerequisites: number[][]): number[] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    solve(numCourses: number, prerequisites: number[][]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "diameter-of-binary-tree": {
    "title": "Diameter of Binary Tree",
    "pattern": "DFS + Global Max",
    "patternEmoji": "\ud83d\udccf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "For each node, diameter through it = left_height + right_height.",
    "intuition": [
      "\ud83c\udfaf Longest path between any two nodes.",
      "\ud83e\udde0 At each node: path through it = left + right heights.",
      "\ud83d\udca1 Return height, but track max diameter."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,4,5]",
        "output": "3"
      },
      {
        "input": "root = [1,2]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Longest path between any two nodes.\n        - \ud83e\udde0 At each node: path through it = left + right heights.\n        - \ud83d\udca1 Return height, but track max diameter.\n        \"\"\"\n        diameter = [0]\n        def height(node):\n            if not node:\n                return 0\n            left = height(node.left)\n            right = height(node.right)\n            diameter[0] = max(diameter[0], left + right)  # Take the maximum value.\n            return 1 + max(left, right)  # Take the maximum value.\n        height(root)\n        return diameter[0]",
    "keyInsight": "Diameter through node = sum of left and right subtree heights.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Diameter of Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "For each node, diameter through it = left_height + right_height.\n\nLongest path between any two nodes.\nAt each node: path through it = left + right heights.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5]",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Longest path between any two nodes.",
      "At each node: path through it = left + right heights.",
      "Return height, but track max diameter."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "bkxqA8Rfv04",
    "problemStatement": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DFS + Global Max: For each node, diameter through it = left_height + right_height.",
    "suggestedNextQuestion": {
      "slug": "evaluate-division",
      "title": "Evaluate Division",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root):\n        pass\n\n        def height(node):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def diameterOfBinaryTree(root):\n    res = [0]\n    def dfs(root):\n        if not root: return -1\n        left = dfs(root.left)\n        right = dfs(root.right)\n        res[0] = max(res[0], 2 + left + right)\n        return 1 + max(left, right)\n    dfs(root)\n    return res[0]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Longest path between any two nodes.",
          "\ud83e\udde0 At each node: path through it = left + right heights.",
          "\ud83d\udca1 Return height, but track max diameter."
        ],
        "code": "def diameterOfBinaryTree(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Longest path between any two nodes.\n    - \ud83e\udde0 At each node: path through it = left + right heights.\n    - \ud83d\udca1 Return height, but track max diameter.\n    \"\"\"\n    diameter = [0]\n    def height(node):\n        if not node:\n            return 0\n        left = height(node.left)\n        right = height(node.right)\n        diameter[0] = max(diameter[0], left + right)  # Take the maximum value.\n        return 1 + max(left, right)  # Take the maximum value.\n    height(root)\n    return diameter[0]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__(TreeNode* root) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) diameterOfBinaryTree(root *TreeNode) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) diameterOfBinaryTree(root *TreeNode) (ans int) {\n\tvar dfs func(root *TreeNode) int\n\tdfs = func(root *TreeNode) int {\n\t\tif root == nil {\n\t\t\treturn 0\n\t\t}\n\t\tl, r := dfs(root.Left), dfs(root.Right)\n\t\tans = max(ans, l+r)\n\t\treturn 1 + max(l, r)\n\t}\n\tdfs(root)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut ans = 0;\n        fn dfs(root: Option<Rc<RefCell<TreeNode>>>, ans: &mut i32) -> i32 {\n            match root {\n                Some(node) => {\n                    let node = node.borrow();\n                    let l = dfs(node.left.clone(), ans);\n                    let r = dfs(node.right.clone(), ans);\n\n                    *ans = (*ans).max(l + r);\n\n                    1 + l.max(r)\n                }\n                None => 0,\n            }\n        }\n        dfs(root, &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root):\n        pass\n\n        def height(node):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "cheapest-flights-within-k-stops": {
    "title": "Cheapest Flights Within K Stops",
    "pattern": "BFS / Bellman-Ford",
    "patternEmoji": "\u2708\ufe0f",
    "timeComplexity": "O(K*E)",
    "spaceComplexity": "O(V)",
    "oneliner": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
    "intuition": [
      "\ud83c\udfaf Cheapest flight with at most k stops.",
      "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
      "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
    ],
    "testCases": [
      {
        "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
        "output": "700"
      },
      {
        "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
        "output": "200"
      },
      {
        "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0",
        "output": "500"
      }
    ],
    "code": "class Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Cheapest flight with at most k stops.\n        - \ud83e\udde0 Bellman-Ford with k+1 relaxations.\n        - \ud83d\udca1 Use copy of distances to avoid this-iteration dependency.\n        \"\"\"\n        prices = [float('inf')] * n\n        prices[src] = 0\n        for _ in range(k + 1):  # Iterate through the range.\n            temp = prices[:]\n            for s, d, p in flights:  # Iterate over elements.\n                if prices[s] != float('inf'):\n                    temp[d] = min(temp[d], prices[s] + p)  # Take the minimum value.\n            prices = temp\n        return prices[dst] if prices[dst] != float('inf') else -1",
    "keyInsight": "Use copy of prices array to ensure correct iteration count.",
    "visualizationType": "graph",
    "initialState": [
      0,
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Flight Graph",
        "transientMessage": "src=0, dst=2, k=1",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0",
              "x": 100,
              "y": 100
            },
            {
              "id": "1",
              "label": "1",
              "x": 250,
              "y": 50
            },
            {
              "id": "2",
              "label": "2",
              "x": 400,
              "y": 100
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "weight": 100
            },
            {
              "from": "1",
              "to": "2",
              "weight": 100
            },
            {
              "from": "0",
              "to": "2",
              "weight": 500
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "BFS: Start 0",
        "transientMessage": "cost=0",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 ($0)",
              "x": 100,
              "y": 100,
              "highlight": true
            },
            {
              "id": "1",
              "label": "1 (\u221e)",
              "x": 250,
              "y": 50
            },
            {
              "id": "2",
              "label": "2 (\u221e)",
              "x": 400,
              "y": 100
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "weight": 100
            },
            {
              "from": "1",
              "to": "2",
              "weight": 100
            },
            {
              "from": "0",
              "to": "2",
              "weight": 500
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "0\u21921: $100",
        "transientMessage": "0\u21922: $500",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 ($0)",
              "x": 100,
              "y": 100,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 ($100)",
              "x": 250,
              "y": 50,
              "highlight": true
            },
            {
              "id": "2",
              "label": "2 ($500)",
              "x": 400,
              "y": 100
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "weight": 100,
              "highlight": true
            },
            {
              "from": "1",
              "to": "2",
              "weight": 100
            },
            {
              "from": "0",
              "to": "2",
              "weight": 500
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "1\u21922: $200",
        "transientMessage": "Better than $500!",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0",
              "x": 100,
              "y": 100
            },
            {
              "id": "1",
              "label": "1",
              "x": 250,
              "y": 50
            },
            {
              "id": "2",
              "label": "2",
              "x": 400,
              "y": 100
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "weight": 100,
              "highlight": true
            },
            {
              "from": "1",
              "to": "2",
              "weight": 100,
              "highlight": true
            },
            {
              "from": "0",
              "to": "2",
              "weight": 500
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "200"
          }
        ],
        "color": "success"
      }
    ],
    "description": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.\n\nCheapest flight with at most k stops.\nBellman-Ford with k+1 relaxations.",
    "examples": [
      {
        "input": "n = 4; flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]; src = 0; dst = 3; k = 1",
        "output": "700"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Cheapest flight with at most k stops.",
      "Bellman-Ford with k+1 relaxations.",
      "Use copy of distances to avoid this-iteration dependency."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "5eIK3zUdYmE",
    "problemStatement": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BFS / Bellman-Ford: Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
    "suggestedNextQuestion": {
      "slug": "clone-graph",
      "title": "Clone Graph",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findCheapestPrice(n, flights, src, dst, k):\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    for i in range(k + 1):\n        tmpPrices = prices[:]\n        for s, d, p in flights:\n            if prices[s] == float('inf'): continue\n            if prices[s] + p < tmpPrices[d]:\n                tmpPrices[d] = prices[s] + p\n        prices = tmpPrices\n    return -1 if prices[dst] == float('inf') else prices[dst]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(K*E)",
        "spaceComplexity": "O(V)",
        "intuition": [
          "\ud83c\udfaf Cheapest flight with at most k stops.",
          "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
          "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
        ],
        "code": "def findCheapestPrice(n, flights, src, dst, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Cheapest flight with at most k stops.\n    - \ud83e\udde0 Bellman-Ford with k+1 relaxations.\n    - \ud83d\udca1 Use copy of distances to avoid this-iteration dependency.\n    \"\"\"\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for _ in range(k + 1):  # Iterate through the range.\n        temp = prices[:]\n        for s, d, p in flights:  # Iterate over elements.\n            if prices[s] != float('inf'):\n                temp[d] = min(temp[d], prices[s] + p)  # Take the minimum value.\n        prices = temp\n    return prices[dst] if prices[dst] != float('inf') else -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findCheapestPrice(n, flights, src, dst, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n, flights, src, dst, k\n     * @return {any}\n     */\n    findCheapestPrice(n, flights, src, dst, k) {\n        const MAX_INT = Number.MAX_SAFE_INTEGER;\n        let prices = new Array(n).fill(MAX_INT);\n        prices[src] = 0;\n\n        for (let i = 0; i <= k; i++) {\n          const tempPrices = [...prices];\n\n          for (const [from, to, price] of flights) {\n            if (prices[from] === MAX_INT) continue;\n\n            const newPrice = prices[from] + price;\n            if (newPrice < tempPrices[to]) {\n              tempPrices[to] = newPrice;\n            }\n          }\n\n          prices = tempPrices;\n      }\n\n    return prices[dst] === MAX_INT ? -1 : prices[dst];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private static final int INF = 0x3f3f3f3f;\n\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        int[] dist = new int[n];\n        int[] backup = new int[n];\n        Arrays.fill(dist, INF);\n        dist[src] = 0;\n        for (int i = 0; i < k + 1; ++i) {\n            System.arraycopy(dist, 0, backup, 0, n);\n            for (int[] e : flights) {\n                int f = e[0], t = e[1], p = e[2];\n                dist[t] = Math.min(dist[t], backup[f] + p);\n            }\n        }\n        return dist[dst] == INF ? -1 : dist[dst];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        const int inf = 0x3f3f3f3f;\n        vector<int> dist(n, inf);\n        vector<int> backup;\n        dist[src] = 0;\n        for (int i = 0; i < k + 1; ++i) {\n            backup = dist;\n            for (auto& e : flights) {\n                int f = e[0], t = e[1], p = e[2];\n                dist[t] = min(dist[t], backup[f] + p);\n            }\n        }\n        return dist[dst] == inf ? -1 : dist[dst];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\n\tconst inf = 0x3f3f3f3f\n\tdist := make([]int, n)\n\tbackup := make([]int, n)\n\tfor i := range dist {\n\t\tdist[i] = inf\n\t}\n\tdist[src] = 0\n\tfor i := 0; i < k+1; i++ {\n\t\tcopy(backup, dist)\n\t\tfor _, e := range flights {\n\t\t\tf, t, p := e[0], e[1], e[2]\n\t\t\tdist[t] = min(dist[t], backup[f]+p)\n\t\t}\n\t}\n\tif dist[dst] == inf {\n\t\treturn -1\n\t}\n\treturn dist[dst]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_cheapest_price(n: i32, flights: i32, src: i32, dst: i32, k: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::i32;\n\n#[derive(Eq, Debug)]\nstruct State {\n    position: usize,\n    stop: usize,\n    cost: i32,\n}\n\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.cost.cmp(&self.cost)\n    }\n}\n\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl PartialEq for State {\n    fn eq(&self, other: &Self) -> bool {\n        self.cost == other.cost\n    }\n}\n\n#[derive(Copy, Clone)]\nstruct Edge {\n    u: usize,\n    v: usize,\n    cost: i32,\n}\n\nimpl Solution {\n    fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {\n        let n = n as usize;\n        let src = src as usize;\n        let dst = dst as usize;\n        let k = k as usize;\n        let mut prices = vec![i32::MAX; n];\n        prices[src] = 0;\n        let mut edges: Vec<Vec<Edge>> = vec![vec![]; n];\n        for f in flights {\n            let u = f[0] as usize;\n            let v = f[1] as usize;\n            let cost = f[2];\n            edges[u].push(Edge { u, v, cost });\n        }\n        let mut pq: BinaryHeap<State> = BinaryHeap::new();\n        pq.push(State {\n            position: src,\n            stop: 0,\n            cost: 0,\n        });\n        while let Some(s) = pq.pop() {\n            if s.position == dst {\n                return s.cost;\n            }\n            prices[s.position] = i32::min(s.cost, prices[s.position]);\n            if s.stop <= k {\n                for e in &edges[s.position] {\n                    pq.push(State {\n                        position: e.v,\n                        cost: s.cost + e.cost,\n                        stop: s.stop + 1,\n                    });\n                }\n            }\n        }\n        if prices[dst] == i32::MAX {\n            -1\n        } else {\n            prices[dst]\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let n = 3;\n    let flights = vec![vec![0, 1, 100], vec![1, 2, 100], vec![0, 2, 500]];\n    let src = 0;\n    let dst = 2;\n    let k = 1;\n    assert_eq!(Solution::find_cheapest_price(n, flights, src, dst, k), 200);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findCheapestPrice(n: any, flights: any, src: any, dst: any, k: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    findCheapestPrice(n: any, flights: any, src: any, dst: any, k: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "snakes-and-ladders": {
    "title": "Snakes and Ladders",
    "pattern": "BFS",
    "patternEmoji": "\ud83d\udc0d",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n\u00b2)",
    "oneliner": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
    "intuition": [
      "\ud83c\udfaf Min dice rolls to reach last square.",
      "\ud83e\udde0 BFS level = number of moves.",
      "\ud83d\udca1 Handle boustrophedon numbering."
    ],
    "testCases": [
      {
        "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
        "output": "4"
      },
      {
        "input": "board = [[-1,-1],[-1,3]]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def snakesAndLadders(self, board):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min dice rolls to reach last square.\n        - \ud83e\udde0 BFS level = number of moves.\n        - \ud83d\udca1 Handle boustrophedon numbering.\n        \"\"\"\n        n = len(board)\n        def getPos(self, sq):\n            r, c = divmod(sq - 1, n)\n            if r % 2 == 1:\n                c = n - 1 - c\n            return n - 1 - r, c\n        \n        q = deque([(1, 0)])  # Initialize queue for BFS.\n        visited = {1}\n        while q:\n            sq, moves = q.popleft()  # Remove from front of queue.\n            for i in range(1, 7):  # Iterate through the range.\n                nxt = sq + i\n                if nxt > n * n:\n                    continue\n                r, c = getPos(nxt)\n                if board[r][c] != -1:\n                    nxt = board[r][c]\n                if nxt == n * n:\n                    return moves + 1\n                if nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, moves + 1))  # Add to end.\n        return -1",
    "keyInsight": "Convert 1D square number to 2D board coordinates carefully.",
    "visualizationType": "matrix",
    "initialState": [
      [
        "-1",
        "-1"
      ],
      [
        "36",
        "25"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Snakes and Ladders",
        "transientMessage": "Grid-based algorithm",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Step 1",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Step 2",
        "transientMessage": "Processing cell (0, 0)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Step 3",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Step 4",
        "transientMessage": "Processing cell (0, 0)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Step 5",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Step 6",
        "transientMessage": "Processing cell (0, 0)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Step 7",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Step 8",
        "transientMessage": "Processing cell (0, 0)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Step 9",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Step 10",
        "transientMessage": "Processing cell (0, 0)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Step 11",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "-1",
            "-1"
          ],
          [
            "36",
            "25"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "success"
      }
    ],
    "description": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.\n\nMin dice rolls to reach last square.\nBFS level = number of moves.",
    "examples": [
      {
        "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min dice rolls to reach last square.",
      "BFS level = number of moves.",
      "Handle boustrophedon numbering."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "word-ladder",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "6lH4nO3JfLk",
    "problemStatement": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 are not the starting points of any snake or ladder.\nNote that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\nReturn the least number of dice rolls required to reach the square n2. If it is not possible to reach the square, return -1.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
    "suggestedNextQuestion": {
      "slug": "sum-root-to-leaf-numbers",
      "title": "Sum Root to Leaf Numbers",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def snakesAndLadders(board):\n    length = len(board)\n    board.reverse()\n    def intToPos(square):\n        r = (square - 1) // length\n        c = (square - 1) % length\n        if r % 2: c = length - 1 - c\n        return [r, c]\n        \n    q = [(1, 0)] # [square, moves]\n    visit = set()\n    while q:\n        square, moves = q.pop(0)\n        for i in range(1, 7):\n            nextSquare = square + i\n            r, c = intToPos(nextSquare)\n            if board[r][c] != -1:\n                nextSquare = board[r][c]\n            if nextSquare == length*length:\n                return moves + 1\n            if nextSquare not in visit:\n                visit.add(nextSquare)\n                q.append((nextSquare, moves + 1))\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(n\u00b2)",
        "intuition": [
          "\ud83c\udfaf Min dice rolls to reach last square.",
          "\ud83e\udde0 BFS level = number of moves.",
          "\ud83d\udca1 Handle boustrophedon numbering."
        ],
        "code": "from collections import deque\n\ndef snakesAndLadders(board):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min dice rolls to reach last square.\n    - \ud83e\udde0 BFS level = number of moves.\n    - \ud83d\udca1 Handle boustrophedon numbering.\n    \"\"\"\n    n = len(board)\n    def getPos(sq):\n        r, c = divmod(sq - 1, n)\n        if r % 2 == 1:\n            c = n - 1 - c\n        return n - 1 - r, c\n    \n    q = deque([(1, 0)])  # Initialize queue for BFS.\n    visited = {1}\n    while q:\n        sq, moves = q.popleft()  # Remove from front of queue.\n        for i in range(1, 7):  # Iterate through the range.\n            nxt = sq + i\n            if nxt > n * n:\n                continue\n            r, c = getPos(nxt)\n            if board[r][c] != -1:\n                nxt = board[r][c]\n            if nxt == n * n:\n                return moves + 1\n            if nxt not in visited:\n                visited.add(nxt)\n                q.append((nxt, moves + 1))  # Add to end.\n    return -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(int[][] board) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int solve(int[][] board) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(vector<vector<int>>& board) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(vector<vector<int>>& board) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) snakesAndLadders(board [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) snakesAndLadders(board [][]int) int {\n\tn := len(board)\n\tq := []int{1}\n\tm := n * n\n\tvis := make([]bool, m+1)\n\tvis[1] = true\n\n\tfor ans := 0; len(q) > 0; ans++ {\n\t\tfor k := len(q); k > 0; k-- {\n\t\t\tx := q[0]\n\t\t\tq = q[1:]\n\t\t\tif x == m {\n\t\t\t\treturn ans\n\t\t\t}\n\t\t\tfor y := x + 1; y <= min(x+6, m); y++ {\n\t\t\t\ti, j := (y-1)/n, (y-1)%n\n\t\t\t\tif i%2 == 1 {\n\t\t\t\t\tj = n - j - 1\n\t\t\t\t}\n\t\t\t\ti = n - i - 1\n\t\t\t\tz := y\n\t\t\t\tif board[i][j] != -1 {\n\t\t\t\t\tz = board[i][j]\n\t\t\t\t}\n\t\t\t\tif !vis[z] {\n\t\t\t\t\tvis[z] = true\n\t\t\t\t\tq = append(q, z)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::{HashSet, VecDeque};\n\nimpl Solution {\n    pub fn snakes_and_ladders(board: Vec<Vec<i32>>) -> i32 {\n        let n = board.len();\n        let m = (n * n) as i32;\n        let mut q = VecDeque::new();\n        q.push_back(1);\n        let mut vis = HashSet::new();\n        vis.insert(1);\n        let mut ans = 0;\n\n        while !q.is_empty() {\n            for _ in 0..q.len() {\n                let x = q.pop_front().unwrap();\n                if x == m {\n                    return ans;\n                }\n                for y in x + 1..=i32::min(x + 6, m) {\n                    let (mut i, mut j) = ((y - 1) / n as i32, (y - 1) % n as i32);\n                    if i % 2 == 1 {\n                        j = (n as i32 - 1) - j;\n                    }\n                    i = (n as i32 - 1) - i;\n                    let z = if board[i as usize][j as usize] == -1 {\n                        y\n                    } else {\n                        board[i as usize][j as usize]\n                    };\n                    if !vis.contains(&z) {\n                        vis.insert(z);\n                        q.push_back(z);\n                    }\n                }\n            }\n            ans += 1;\n        }\n\n        -1\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(board: number[][]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    solve(board: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "minimum-genetic-mutation": {
    "title": "Minimum Genetic Mutation",
    "pattern": "BFS",
    "patternEmoji": "\ud83e\uddec",
    "timeComplexity": "O(B*8*4)",
    "spaceComplexity": "O(B)",
    "oneliner": "BFS from startGene. Each level = 1 mutation. Valid if in bank.",
    "intuition": [
      "\ud83c\udfaf Min mutations to reach endGene.",
      "\ud83e\udde0 BFS where edges are single char changes in bank.",
      "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
    ],
    "testCases": [
      {
        "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
        "output": "1"
      },
      {
        "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def minMutation(self, startGene, endGene, bank):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min mutations to reach endGene.\n        - \ud83e\udde0 BFS where edges are single char changes in bank.\n        - \ud83d\udca1 Each mutation changes one character to A/C/G/T.\n        \"\"\"\n        bank = set(bank)\n        if endGene not in bank:\n            return -1\n        q = deque([(startGene, 0)])  # Initialize queue for BFS.\n        visited = {startGene}\n        while q:\n            gene, mutations = q.popleft()  # Remove from front of queue.\n            if gene == endGene:\n                return mutations\n            for i in range(8):  # Iterate through the range.\n                for c in 'ACGT':  # Iterate over elements.\n                    nxt = gene[:i] + c + gene[i+1:]\n                    if nxt in bank and nxt not in visited:\n                        visited.add(nxt)\n                        q.append((nxt, mutations + 1))  # Add to end.\n        return -1",
    "keyInsight": "Try all single-character mutations, check if in bank.",
    "visualizationType": "array",
    "initialState": "AACCGGTT",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Genetic Mutation",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = A",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = A",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = C",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = C",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = G",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = G",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "A",
          "A",
          "C",
          "C",
          "G",
          "G",
          "T",
          "T"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "BFS from startGene. Each level = 1 mutation. Valid if in bank.\n\nMin mutations to reach endGene.\nBFS where edges are single char changes in bank.",
    "examples": [
      {
        "input": "startGene = \"AACCGGTT\"; endGene = \"AAACGGTA\"; bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min mutations to reach endGene.",
      "BFS where edges are single char changes in bank.",
      "Each mutation changes one character to A/C/G/T."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "word-ladder",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "9lkn3rHCSLg",
    "problemStatement": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS from startGene. Each level = 1 mutation. Valid if in bank.",
    "suggestedNextQuestion": {
      "slug": "network-delay-time",
      "title": "Network Delay Time",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def minMutation(start, end, bank):\n    q = [(start, 0)]\n    visit = set([start])\n    bank = set(bank)\n    \n    while q:\n        curr, moves = q.pop(0)\n        if curr == end: return moves\n        \n        for i in range(8):\n            for c in \"ACGT\":\n                nei = curr[:i] + c + curr[i+1:]\n                if nei in bank and nei not in visit:\n                    visit.add(nei)\n                    q.append((nei, moves + 1))\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(B*8*4)",
        "spaceComplexity": "O(B)",
        "intuition": [
          "\ud83c\udfaf Min mutations to reach endGene.",
          "\ud83e\udde0 BFS where edges are single char changes in bank.",
          "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
        ],
        "code": "from collections import deque\n\ndef minMutation(startGene, endGene, bank):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min mutations to reach endGene.\n    - \ud83e\udde0 BFS where edges are single char changes in bank.\n    - \ud83d\udca1 Each mutation changes one character to A/C/G/T.\n    \"\"\"\n    bank = set(bank)\n    if endGene not in bank:\n        return -1\n    q = deque([(startGene, 0)])  # Initialize queue for BFS.\n    visited = {startGene}\n    while q:\n        gene, mutations = q.popleft()  # Remove from front of queue.\n        if gene == endGene:\n            return mutations\n        for i in range(8):  # Iterate through the range.\n            for c in 'ACGT':  # Iterate over elements.\n                nxt = gene[:i] + c + gene[i+1:]\n                if nxt in bank and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, mutations + 1))  # Add to end.\n    return -1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(...) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(String start, String end, List<String> bank) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public int solve(String start, String end, List<String> bank) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(...) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(...) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minMutation(startGene string, endGene string, bank []string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minMutation(startGene string, endGene string, bank []string) int {\n\ttype pair struct {\n\t\ts     string\n\t\tdepth int\n\t}\n\tq := []pair{pair{startGene, 0}}\n\tvis := map[string]bool{startGene: true}\n\tfor len(q) > 0 {\n\t\tp := q[0]\n\t\tq = q[1:]\n\t\tif p.s == endGene {\n\t\t\treturn p.depth\n\t\t}\n\t\tfor _, next := range bank {\n\t\t\tdiff := 0\n\t\t\tfor i := 0; i < len(startGene); i++ {\n\t\t\t\tif p.s[i] != next[i] {\n\t\t\t\t\tdiff++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif diff == 1 && !vis[next] {\n\t\t\t\tvis[next] = true\n\t\t\t\tq = append(q, pair{next, p.depth + 1})\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_mutation(start_gene: String, end_gene: String, bank: Vec<String>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::{HashSet, VecDeque};\n\nimpl Solution {\n    pub fn min_mutation(start_gene: String, end_gene: String, bank: Vec<String>) -> i32 {\n        let mut q = VecDeque::new();\n        q.push_back((start_gene.clone(), 0));\n        let mut vis = HashSet::new();\n        vis.insert(start_gene);\n\n        while let Some((gene, depth)) = q.pop_front() {\n            if gene == end_gene {\n                return depth;\n            }\n            for next in &bank {\n                let mut c = 2;\n                for k in 0..8 {\n                    if gene.as_bytes()[k] != next.as_bytes()[k] {\n                        c -= 1;\n                    }\n                    if c == 0 {\n                        break;\n                    }\n                }\n                if c > 0 && !vis.contains(next) {\n                    vis.insert(next.clone());\n                    q.push_back((next.clone(), depth + 1));\n                }\n            }\n        }\n        -1\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(...args: any[]): any {\n        \n    }\n}",
        "initialCode": "class Solution {\n    solve(...args: any[]): any {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "word-ladder": {
    "title": "Word Ladder",
    "pattern": "BFS",
    "patternEmoji": "\ud83d\udd20",
    "timeComplexity": "O(M\u00b2*N)",
    "spaceComplexity": "O(M*N)",
    "oneliner": "BFS from beginWord. Valid moves = 1 char diff in wordList.",
    "intuition": [
      "\ud83c\udfaf Min transformations to endWord.",
      "\ud83e\udde0 BFS where each level = 1 transformation.",
      "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
    ],
    "testCases": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5"
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    from collections import deque, defaultdict\n    \n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min transformations to endWord.\n        - \ud83e\udde0 BFS where each level = 1 transformation.\n        - \ud83d\udca1 Use wildcard patterns for O(M) adjacency.\n        \"\"\"\n        if endWord not in wordList:\n            return 0\n        wordList = set(wordList)\n        q = deque([(beginWord, 1)])  # Initialize queue for BFS.\n        visited = {beginWord}\n        while q:\n            word, length = q.popleft()  # Remove from front of queue.\n            if word == endWord:\n                return length\n            for i in range(len(word)):  # Iterate through the range.\n                for c in 'abcdefghijklmnopqrstuvwxyz':  # Iterate over elements.\n                    nxt = word[:i] + c + word[i+1:]\n                    if nxt in wordList and nxt not in visited:\n                        visited.add(nxt)\n                        q.append((nxt, length + 1))  # Add to end.\n        return 0",
    "keyInsight": "BFS guarantees minimum transformation sequence.",
    "visualizationType": "array",
    "initialState": "hit",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "transientMessage": "Starting BFS with initial word 'hit'",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "word"
          },
          {
            "index": 1,
            "label": "length"
          }
        ],
        "transientMessage": "Processing word 'hit' with length 1",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "transientMessage": "Generating neighbors for 'hit'",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "success",
        "transientMessage": "Found valid neighbor 'hot' and added to queue",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4
        ],
        "color": "accent",
        "transientMessage": "Processing word 'hot' with length 2",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "success",
        "transientMessage": "Found valid neighbor 'dot' and added to queue",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          6
        ],
        "color": "accent",
        "transientMessage": "Processing word 'dot' with length 3",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          7
        ],
        "color": "success",
        "transientMessage": "Found valid neighbor 'dog' and added to queue",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          8
        ],
        "color": "accent",
        "transientMessage": "Processing word 'dog' with length 4",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          9
        ],
        "color": "success",
        "transientMessage": "Found valid neighbor 'cog' and added to queue",
        "arrayState": [
          "h",
          "i",
          "t"
        ]
      }
    ],
    "description": "BFS from beginWord. Valid moves = 1 char diff in wordList.\n\nMin transformations to endWord.\nBFS where each level = 1 transformation.",
    "examples": [
      {
        "input": "beginWord = \"hit\"; endWord = \"cog\"; wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min transformations to endWord.",
      "BFS where each level = 1 transformation.",
      "Use wildcard patterns for O(M) adjacency."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "h9iTnkgv05E",
    "problemStatement": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "difficulty": "Hard",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS from beginWord. Valid moves = 1 char diff in wordList.",
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList: return 0\n    nei = {}\n    wordList.append(beginWord)\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            nei.setdefault(pattern, []).append(word)\n            \n    visit = set([beginWord])\n    q = [(beginWord, 1)]\n    while q:\n        word, dist = q.pop(0)\n        if word == endWord: return dist\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j+1:]\n            for neiWord in nei.get(pattern, []):\n                if neiWord not in visit:\n                    visit.add(neiWord)\n                    q.append((neiWord, dist + 1))\n    return 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(M\u00b2*N)",
        "spaceComplexity": "O(M*N)",
        "intuition": [
          "\ud83c\udfaf Min transformations to endWord.",
          "\ud83e\udde0 BFS where each level = 1 transformation.",
          "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
        ],
        "code": "from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min transformations to endWord.\n    - \ud83e\udde0 BFS where each level = 1 transformation.\n    - \ud83d\udca1 Use wildcard patterns for O(M) adjacency.\n    \"\"\"\n    if endWord not in wordList:\n        return 0\n    wordList = set(wordList)\n    q = deque([(beginWord, 1)])  # Initialize queue for BFS.\n    visited = {beginWord}\n    while q:\n        word, length = q.popleft()  # Remove from front of queue.\n        if word == endWord:\n            return length\n        for i in range(len(word)):  # Iterate through the range.\n            for c in 'abcdefghijklmnopqrstuvwxyz':  # Iterate over elements.\n                nxt = word[:i] + c + word[i+1:]\n                if nxt in wordList and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, length + 1))  # Add to end.\n    return 0"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(String beginWord, String endWord, List<String> wordList) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "import java.util.*;\n\nclass Solution {\n    public int solve(String beginWord, String endWord, List<String> wordList) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) ladderLength(beginWord string, endWord string, wordList []string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) ladderLength(beginWord string, endWord string, wordList []string) int {\n\twords := make(map[string]bool)\n\tfor _, word := range wordList {\n\t\twords[word] = true\n\t}\n\tq := []string{beginWord}\n\tans := 1\n\tfor len(q) > 0 {\n\t\tans++\n\t\tfor i := len(q); i > 0; i-- {\n\t\t\ts := q[0]\n\t\t\tq = q[1:]\n\t\t\tchars := []byte(s)\n\t\t\tfor j := 0; j < len(chars); j++ {\n\t\t\t\tch := chars[j]\n\t\t\t\tfor k := 'a'; k <= 'z'; k++ {\n\t\t\t\t\tchars[j] = byte(k)\n\t\t\t\t\tt := string(chars)\n\t\t\t\t\tif !words[t] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif t == endWord {\n\t\t\t\t\t\treturn ans\n\t\t\t\t\t}\n\t\t\t\t\tq = append(q, t)\n\t\t\t\t\twords[t] = false\n\t\t\t\t}\n\t\t\t\tchars[j] = ch\n\t\t\t}\n\t\t}\n\t}\n\treturn 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [127] Word Ladder\n *\n * Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n *\n * <ol>\n * \tOnly one letter can be changed at a time.\n * \tEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\n * </ol>\n *\n * Note:\n *\n *\n * \tReturn 0 if there is no such transformation sequence.\n * \tAll words have the same length.\n * \tAll words contain only lowercase alphabetic characters.\n * \tYou may assume no duplicates in the word list.\n * \tYou may assume beginWord and endWord are non-empty and are not the same.\n *\n *\n * Example 1:\n *\n *\n * Input:\n * beginWord = \"hit\",\n * endWord = \"cog\",\n * wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n *\n * Output: 5\n *\n * Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\n * return its length 5.\n *\n *\n * Example 2:\n *\n *\n * Input:\n * beginWord = \"hit\"\n * endWord = \"cog\"\n * wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n *\n * Output: 0\n *\n * Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/word-ladder/\n// discuss: https://leetcode.com/problems/word-ladder/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nuse std::collections::HashSet;\nuse std::collections::VecDeque;\nimpl Solution {\n    pub fn ladder_length(begin_word: String, end_word: String, word_list: Vec<String>) -> i32 {\n        let len = word_list.len();\n        let target = word_list.iter().position(|s| s == &end_word);\n        if target.is_none() {\n            return 0;\n        }\n        let target = target.unwrap();\n        let mut deq = VecDeque::new();\n        let mut distance = vec![0; len];\n        let mut remain = (0..len).collect::<HashSet<_>>();\n        deq.push_back(target);\n        remain.remove(&target);\n        while let Some(i) = deq.pop_front() {\n            if Solution::connect(&begin_word, &word_list[i]) {\n                return distance[i] + 2;\n            }\n            remain.retain(|&j| {\n                if Solution::connect(&word_list[i], &word_list[j]) {\n                    distance[j] = distance[i] + 1;\n                    deq.push_back(j);\n                    false\n                } else {\n                    true\n                }\n            });\n        }\n        0\n    }\n\n    #[inline(always)]\n    fn connect(s1: &str, s2: &str) -> bool {\n        if s1.len() != s2.len() {\n            return false;\n        }\n        let mut iter1 = s1.chars().into_iter();\n        let mut iter2 = s2.chars().into_iter();\n        let mut diff = 0;\n        while let (Some(c1), Some(c2)) = (iter1.next(), iter2.next()) {\n            if c1 != c2 {\n                diff += 1;\n                if diff >= 2 {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_127() {\n        assert_eq!(\n            Solution::ladder_length(\n                \"hit\".to_owned(),\n                \"cog\".to_owned(),\n                vec_string![\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\n            ),\n            5\n        );\n        assert_eq!(\n            Solution::ladder_length(\n                \"hit\".to_owned(),\n                \"cog\".to_owned(),\n                vec_string![\"hot\", \"dot\", \"dog\", \"lot\", \"log\"]\n            ),\n            0\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(beginWord: string, endWord: string, wordList: string[]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    solve(beginWord: string, endWord: string, wordList: string[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "rotting-oranges",
      "title": "Rotting Oranges",
      "difficulty": "Medium",
      "pattern": "BFS"
    }
  },
  "minimum-depth-of-binary-tree": {
    "title": "Minimum Depth of Binary Tree",
    "pattern": "BFS",
    "patternEmoji": "\ud83d\udccf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "BFS level by level. Return level when first leaf found.",
    "intuition": [
      "\ud83c\udfaf Min depth to a leaf node.",
      "\ud83e\udde0 BFS finds closest leaf first.",
      "\ud83d\udca1 Better than DFS for unbalanced trees."
    ],
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "2"
      },
      {
        "input": "root = [2,null,3,null,4,null,5,null,6]",
        "output": "5"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def minDepth(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min depth to a leaf node.\n        - \ud83e\udde0 BFS finds closest leaf first.\n        - \ud83d\udca1 Better than DFS for unbalanced trees.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return 0\n        q = deque([(root, 1)])  # Initialize queue for BFS.\n        while q:\n            node, depth = q.popleft()  # Remove from front of queue.\n            if not node.left and not node.right:\n                return depth\n            if node.left:\n                q.append((node.left, depth + 1))  # Add to end.\n            if node.right:\n                q.append((node.right, depth + 1))  # Add to end.\n        return 0",
    "keyInsight": "BFS stops early when first leaf is found.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Depth of Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "BFS level by level. Return level when first leaf found.\n\nMin depth to a leaf node.\nBFS finds closest leaf first.",
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min depth to a leaf node.",
      "BFS finds closest leaf first.",
      "Better than DFS for unbalanced trees."
    ],
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "word-ladder",
      "shortest-path-in-binary-matrix"
    ],
    "videoId": "tZS4VHtbYoo",
    "problemStatement": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "approach": "BFS: BFS level by level. Return level when first leaf found.",
    "suggestedNextQuestion": {
      "slug": "minimum-genetic-mutation",
      "title": "Minimum Genetic Mutation",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def minDepth(root):\n    if not root: return 0\n    if not root.left: return 1 + minDepth(root.right)\n    if not root.right: return 1 + minDepth(root.left)\n    return 1 + min(minDepth(root.left), minDepth(root.right))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Min depth to a leaf node.",
          "\ud83e\udde0 BFS finds closest leaf first.",
          "\ud83d\udca1 Better than DFS for unbalanced trees."
        ],
        "code": "from collections import deque\n\ndef minDepth(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min depth to a leaf node.\n    - \ud83e\udde0 BFS finds closest leaf first.\n    - \ud83d\udca1 Better than DFS for unbalanced trees.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return 0\n    q = deque([(root, 1)])  # Initialize queue for BFS.\n    while q:\n        node, depth = q.popleft()  # Remove from front of queue.\n        if not node.left and not node.right:\n            return depth\n        if node.left:\n            q.append((node.left, depth + 1))  # Add to end.\n        if node.right:\n            q.append((node.right, depth + 1))  # Add to end.\n    return 0"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // Constructor logic here\n    }\n\n    minDepth(root) {\n        // Method implementation goes here\n        return 0;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public int __init__(TreeNode root) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minDepth(TreeNode* root) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minDepth(root *TreeNode) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\tif root.Left == nil {\n\t\treturn 1 + minDepth(root.Right)\n\t}\n\tif root.Right == nil {\n\t\treturn 1 + minDepth(root.Left)\n\t}\n\treturn 1 + min(minDepth(root.Left), minDepth(root.Right))\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        if root.is_none() {\n            return 0;\n        }\n        let node = root.as_ref().unwrap().borrow();\n        if node.left.is_none() {\n            return 1 + Self::dfs(&node.right);\n        }\n        if node.right.is_none() {\n            return 1 + Self::dfs(&node.left);\n        }\n        1 + Self::dfs(&node.left).min(Self::dfs(&node.right))\n    }\n\n    pub fn min_depth(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        Self::dfs(&root)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    minDepth(root: TreeNode | null): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    minDepth(root: TreeNode | null): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "letter-combinations-of-a-phone-number": {
    "title": "Letter Combinations of a Phone Number",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udcf1",
    "timeComplexity": "O(4^n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Map digits to letters. Backtrack all combinations.",
    "intuition": [
      "\ud83c\udfaf All letter combinations from digits.",
      "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
      "\ud83d\udca1 Each digit adds multiple branches."
    ],
    "testCases": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
      },
      {
        "input": "digits = \"\"",
        "output": "[]"
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]"
      }
    ],
    "code": "class Solution:\n    def letterCombinations(self, digits):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf All letter combinations from digits.\n        - \ud83e\udde0 Digit -> letters mapping. Backtrack choices.\n        - \ud83d\udca1 Each digit adds multiple branches.\n        \"\"\"\n        if not digits:\n            return []\n        phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n                 '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        res = []  # Initialize list to store results.\n        def backtrack(i, path):\n            if i == len(digits):\n                res.append(''.join(path))  # Add to end.\n                return\n            for c in phone[digits[i]]:  # Iterate over elements.\n                path.append(c)  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n        backtrack(0, [])\n        return res  # Return the final result.",
    "keyInsight": "Standard backtracking with fixed choices per position.",
    "visualizationType": "array",
    "initialState": [
      "2",
      "3"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Digits: \"23\"",
        "transientMessage": "2\u2192abc, 3\u2192def",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Digit 2 \u2192 'a'",
        "transientMessage": "Path: \"a\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "a",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Digit 3 \u2192 'd'",
        "transientMessage": "Path: \"ad\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "d",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Found: \"ad\"",
        "transientMessage": "1 combination(s)",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Digit 3 \u2192 'e'",
        "transientMessage": "Path: \"ae\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "e",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found: \"ae\"",
        "transientMessage": "2 combination(s)",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Digit 3 \u2192 'f'",
        "transientMessage": "Path: \"af\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "f",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Found: \"af\"",
        "transientMessage": "3 combination(s)",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Digit 2 \u2192 'b'",
        "transientMessage": "Path: \"b\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "b",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Digit 3 \u2192 'd'",
        "transientMessage": "Path: \"bd\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "d",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Found: \"bd\"",
        "transientMessage": "4 combination(s)",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Digit 3 \u2192 'e'",
        "transientMessage": "Path: \"be\"",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [
          {
            "label": "e",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "Found: \"be\"",
        "transientMessage": "5 combination(s)",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "5 combinations",
        "transientMessage": "Complete!",
        "arrayState": [
          "2",
          "3"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Map digits to letters. Backtrack all combinations.\n\nAll letter combinations from digits.\nDigit -> letters mapping. Backtrack choices.",
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "All letter combinations from digits.",
      "Digit -> letters mapping. Backtrack choices.",
      "Each digit adds multiple branches."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum",
      "subsets"
    ],
    "videoId": "0snEunUacZY",
    "problemStatement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Map digits to letters. Backtrack all combinations.",
    "suggestedNextQuestion": {
      "slug": "palindrome-partitioning",
      "title": "Palindrome Partitioning",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def letterCombinations(self, digits):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def letterCombinations_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(4^n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf All letter combinations from digits.",
          "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
          "\ud83d\udca1 Each digit adds multiple branches."
        ],
        "code": "def letterCombinations(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All letter combinations from digits.\n    - \ud83e\udde0 Digit -> letters mapping. Backtrack choices.\n    - \ud83d\udca1 Each digit adds multiple branches.\n    \"\"\"\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(digits):\n            res.append(''.join(path))  # Add to end.\n            return\n        for c in phone[digits[i]]:  # Iterate over elements.\n            path.append(c)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    letterCombinations(digits) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} digits\n * @return {string[]}\n */\nclass Solution {\n    /**\n     * @param {any} digits\n     * @return {any}\n     */\n    letterCombinations(digits) {\n        if (digits.length === 0) {\n            return [];\n        }\n        const ans = [''];\n        const d = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\n        for (const i of digits) {\n            const s = d[+i - 2];\n            const t = [];\n            for (const a of ans) {\n                for (const b of s) {\n                    t.push(a + b);\n                }\n            }\n            ans.splice(0, ans.length, ...t);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        List<String> ans = new ArrayList<>();\n        if (digits.length() == 0) {\n            return ans;\n        }\n        ans.add(\"\");\n        String[] d = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        for (char i : digits.toCharArray()) {\n            String s = d[i - '2'];\n            List<String> t = new ArrayList<>();\n            for (String a : ans) {\n                for (String b : s.split(\"\")) {\n                    t.add(a + b);\n                }\n            }\n            ans = t;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> letterCombinations(string digits) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        if (digits.empty()) {\n            return {};\n        }\n        vector<string> d = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        vector<string> ans = {\"\"};\n        for (auto& i : digits) {\n            string s = d[i - '2'];\n            vector<string> t;\n            for (auto& a : ans) {\n                for (auto& b : s) {\n                    t.push_back(a + b);\n                }\n            }\n            ans = move(t);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) letterCombinations(digits string) []string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) letterCombinations(digits string) []string {\n\tans := []string{}\n\tif len(digits) == 0 {\n\t\treturn ans\n\t}\n\tans = append(ans, \"\")\n\td := []string{\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}\n\tfor _, i := range digits {\n\t\ts := d[i-'2']\n\t\tt := []string{}\n\t\tfor _, a := range ans {\n\t\t\tfor _, b := range s {\n\t\t\t\tt = append(t, a+string(b))\n\t\t\t}\n\t\t}\n\t\tans = t\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn letter_combinations(digits: String) -> Vec<String> {\n        let mut ans: Vec<String> = Vec::new();\n        if digits.is_empty() {\n            return ans;\n        }\n        ans.push(\"\".to_string());\n        let d = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n        for i in digits.chars() {\n            let s = &d[((i as u8) - b'2') as usize];\n            let mut t: Vec<String> = Vec::new();\n            for a in &ans {\n                for b in s.chars() {\n                    t.push(format!(\"{}{}\", a, b));\n                }\n            }\n            ans = t;\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def letterCombinations(self, digits):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    letterCombinations(digits: string): string[]  {\n    if (digits.length === 0) {\n        return [];\n    }\n    const ans: string[] = [''];\n    const d = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\n    for (const i of digits) {\n        const s = d[+i - 2];\n        const t: string[] = [];\n        for (const a of ans) {\n            for (const b of s) {\n                t.push(a + b);\n            }\n        }\n        ans.splice(0, ans.length, ...t);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    letterCombinations(digits: string): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "combinations": {
    "title": "Combinations",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(C(n,k))",
    "spaceComplexity": "O(k)",
    "oneliner": "Backtrack choosing k elements from 1 to n.",
    "intuition": [
      "\ud83c\udfaf All combinations of k numbers from 1 to n.",
      "\ud83e\udde0 Backtrack: pick or skip each number.",
      "\ud83d\udca1 Start from current to avoid duplicates."
    ],
    "testCases": [
      {
        "input": "n = 4, k = 2",
        "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
      },
      {
        "input": "n = 1, k = 1",
        "output": "[[1]]"
      }
    ],
    "code": "class Solution:\n    def combine(self, n, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf All combinations of k numbers from 1 to n.\n        - \ud83e\udde0 Backtrack: pick or skip each number.\n        - \ud83d\udca1 Start from current to avoid duplicates.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        def backtrack(start, path):\n            if len(path) == k:\n                res.append(path[:])  # Add to end.\n                return\n            for i in range(start, n + 1):  # Iterate through the range.\n                path.append(i)  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n        backtrack(1, [])\n        return res  # Return the final result.",
    "keyInsight": "Start from 'start' index to avoid duplicate combinations.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Combinations",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [1]",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 2 to path",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try 3 instead",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Backtrack choosing k elements from 1 to n.\n\nAll combinations of k numbers from 1 to n.\nBacktrack: pick or skip each number.",
    "examples": [
      {
        "input": "n = 4; k = 2",
        "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "All combinations of k numbers from 1 to n.",
      "Backtrack: pick or skip each number.",
      "Start from current to avoid duplicates."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum",
      "subsets"
    ],
    "videoId": "q0s6m7AiM7o",
    "problemStatement": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Backtrack choosing k elements from 1 to n.",
    "suggestedNextQuestion": {
      "slug": "generate-parentheses",
      "title": "Generate Parentheses",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def combine(self, n, k):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def combine_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(C(n,k))",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf All combinations of k numbers from 1 to n.",
          "\ud83e\udde0 Backtrack: pick or skip each number.",
          "\ud83d\udca1 Start from current to avoid duplicates."
        ],
        "code": "def combine(n, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All combinations of k numbers from 1 to n.\n    - \ud83e\udde0 Backtrack: pick or skip each number.\n    - \ud83d\udca1 Start from current to avoid duplicates.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])  # Add to end.\n            return\n        for i in range(start, n + 1):  # Iterate through the range.\n            path.append(i)  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(1, [])\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    combine(n, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n, k\n     * @return {any}\n     */\n    combine(n, k) {\n        const result = [];\n        backtrack(result, n, k);\n        return result;\n      };\n\n      class Solution {\n          /**\n           * @param {any} result, n, k, combination = [], offset = 1\n           * @return {any}\n           */\n          backtrack(result, n, k, combination = [], offset = 1) {\n        if (combination.length === k) {\n          result.push(combination);\n        } else {\n          while (offset <= n) {\n            backtrack(result, n, k, [...combination, offset], ++offset);\n          }\n        }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int n;\n    private int k;\n\n    public List<List<Integer>> combine(int n, int k) {\n        this.n = n;\n        this.k = k;\n        dfs(1);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (t.size() == k) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        if (i > n) {\n            return;\n        }\n        t.add(i);\n        dfs(i + 1);\n        t.remove(t.size() - 1);\n        dfs(i + 1);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> combine(int n, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int)> dfs = [&](int i) {\n            if (t.size() == k) {\n                ans.emplace_back(t);\n                return;\n            }\n            if (i > n) {\n                return;\n            }\n            t.emplace_back(i);\n            dfs(i + 1);\n            t.pop_back();\n            dfs(i + 1);\n        };\n        dfs(1);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) combine(n int, k int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) combine(n int, k int) (ans [][]int) {\n\tt := []int{}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif len(t) == k {\n\t\t\tans = append(ans, slices.Clone(t))\n\t\t\treturn\n\t\t}\n\t\tif i > n {\n\t\t\treturn\n\t\t}\n\t\tt = append(t, i)\n\t\tdfs(i + 1)\n\t\tt = t[:len(t)-1]\n\t\tdfs(i + 1)\n\t}\n\tdfs(1)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(i: i32, n: i32, k: i32, t: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {\n        if t.len() == (k as usize) {\n            ans.push(t.clone());\n            return;\n        }\n        if i > n {\n            return;\n        }\n        t.push(i);\n        Self::dfs(i + 1, n, k, t, ans);\n        t.pop();\n        Self::dfs(i + 1, n, k, t, ans);\n    }\n\n    pub fn combine(n: i32, k: i32) -> Vec<Vec<i32>> {\n        let mut ans = vec![];\n        Self::dfs(1, n, k, &mut vec![], &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def combine(self, n, k):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    combine(n: number, k: number): number[][]  {\n    const ans: number[][] = [];\n    const t: number[] = [];\n    const dfs = (i: number) => {\n        if (t.length === k) {\n            ans.push(t.slice());\n            return;\n        }\n        if (i > n) {\n            return;\n        }\n        t.push(i);\n        dfs(i + 1);\n        t.pop();\n        dfs(i + 1);\n    };\n    dfs(1);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    combine(n: number, k: number): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "n-queens-ii": {
    "title": "N-Queens II",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udc51",
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n)",
    "oneliner": "Place queens row by row. Track cols and diagonals.",
    "intuition": [
      "\ud83c\udfaf Count valid n-queens placements.",
      "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
      "\ud83d\udca1 Row is implicit in recursion depth."
    ],
    "testCases": [
      {
        "input": "n = 4",
        "output": "2"
      },
      {
        "input": "n = 1",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def totalNQueens(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count valid n-queens placements.\n        - \ud83e\udde0 Track used columns, diagonals, anti-diagonals.\n        - \ud83d\udca1 Row is implicit in recursion depth.\n        \"\"\"\n        cols = set()\n        posDiag = set()  # r + c\n        negDiag = set()  # r - c\n        count = [0]\n        def backtrack(r):\n            if r == n:\n                count[0] += 1\n                return\n            for c in range(n):  # Iterate through the range.\n                if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n                cols.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                backtrack(r + 1)\n                cols.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n        backtrack(0)\n        return count[0]",
    "keyInsight": "Diagonals identified by r+c (positive) and r-c (negative).",
    "visualizationType": "grid",
    "initialState": [
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: N-Queens II",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add .,.,.,. to path",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [.,.,.,.]",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add .,.,.,. to path",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try .,.,.,. instead",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Place queens row by row. Track cols and diagonals.\n\nCount valid n-queens placements.\nTrack used columns, diagonals, anti-diagonals.",
    "examples": [
      {
        "input": "n = 4",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count valid n-queens placements.",
      "Track used columns, diagonals, anti-diagonals.",
      "Row is implicit in recursion depth."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum",
      "subsets"
    ],
    "videoId": "nalYyLZgvCY",
    "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.",
    "difficulty": "Hard",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Place queens row by row. Track cols and diagonals.",
    "suggestedNextQuestion": {
      "slug": "word-search-ii",
      "title": "Word Search II",
      "difficulty": "Hard",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def totalNQueens(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def totalNQueens_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Count valid n-queens placements.",
          "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
          "\ud83d\udca1 Row is implicit in recursion depth."
        ],
        "code": "def totalNQueens(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count valid n-queens placements.\n    - \ud83e\udde0 Track used columns, diagonals, anti-diagonals.\n    - \ud83d\udca1 Row is implicit in recursion depth.\n    \"\"\"\n    cols = set()\n    posDiag = set()  # r + c\n    negDiag = set()  # r - c\n    count = [0]\n    def backtrack(r):\n        if r == n:\n            count[0] += 1\n            return\n        for c in range(n):  # Iterate through the range.\n            if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                continue\n            cols.add(c)\n            posDiag.add(r + c)\n            negDiag.add(r - c)\n            backtrack(r + 1)\n            cols.remove(c)\n            posDiag.remove(r + c)\n            negDiag.remove(r - c)\n    backtrack(0)\n    return count[0]"
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    totalNQueens(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    totalNQueens(n) {\n        const cols = Array(10).fill(false);\n        const dg = Array(20).fill(false);\n        const udg = Array(20).fill(false);\n        let ans = 0;\n        const dfs = i => {\n            if (i === n) {\n                ++ans;\n                return;\n            }\n            for (let j = 0; j < n; ++j) {\n                let [a, b] = [i + j, i - j + n];\n                if (cols[j] || dg[a] || udg[b]) {\n                    continue;\n                }\n                cols[j] = dg[a] = udg[b] = true;\n                dfs(i + 1);\n                cols[j] = dg[a] = udg[b] = false;\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int totalNQueens(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private int n;\n    private int ans;\n    private boolean[] cols = new boolean[10];\n    private boolean[] dg = new boolean[20];\n    private boolean[] udg = new boolean[20];\n\n    public int totalNQueens(int n) {\n        this.n = n;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == n) {\n            ++ans;\n            return;\n        }\n        for (int j = 0; j < n; ++j) {\n            int a = i + j, b = i - j + n;\n            if (cols[j] || dg[a] || udg[b]) {\n                continue;\n            }\n            cols[j] = true;\n            dg[a] = true;\n            udg[b] = true;\n            dfs(i + 1);\n            cols[j] = false;\n            dg[a] = false;\n            udg[b] = false;\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int totalNQueens(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int totalNQueens(int n) {\n        bitset<10> cols;\n        bitset<20> dg;\n        bitset<20> udg;\n        int ans = 0;\n        function<void(int)> dfs = [&](int i) {\n            if (i == n) {\n                ++ans;\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                int a = i + j, b = i - j + n;\n                if (cols[j] || dg[a] || udg[b]) continue;\n                cols[j] = dg[a] = udg[b] = 1;\n                dfs(i + 1);\n                cols[j] = dg[a] = udg[b] = 0;\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) totalNQueens(n int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) totalNQueens(n int) (ans int) {\n\tcols := [10]bool{}\n\tdg := [20]bool{}\n\tudg := [20]bool{}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i == n {\n\t\t\tans++\n\t\t\treturn\n\t\t}\n\t\tfor j := 0; j < n; j++ {\n\t\t\ta, b := i+j, i-j+n\n\t\t\tif cols[j] || dg[a] || udg[b] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcols[j], dg[a], udg[b] = true, true, true\n\t\t\tdfs(i + 1)\n\t\t\tcols[j], dg[a], udg[b] = false, false, false\n\t\t}\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn total_n_queens(n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [52] N-Queens II\n *\n * The n-queens puzzle is the problem of placing n queens on an n&times;n chessboard such that no two queens attack each other.\n *\n * <img src=\"https://assets.leetcode.com/uploads/2018/10/12/8-queens.png\" style=\"width: 258px; height: 276px;\" />\n *\n * Given an integer n, return the number of distinct solutions to the n-queens puzzle.\n *\n * Example:\n *\n *\n * Input: 4\n * Output: 2\n * Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.\n * [\n *  [\".Q..\",  // Solution 1\n *   \"...Q\",\n *   \"Q...\",\n *   \"..Q.\"],\n *\n *  [\"..Q.\",  // Solution 2\n *   \"Q...\",\n *   \"...Q\",\n *   \".Q..\"]\n * ]\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/n-queens-ii/\n// discuss: https://leetcode.com/problems/n-queens-ii/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn total_n_queens(n: i32) -> i32 {\n        let mut board = vec![vec!['.'; n as usize]; n as usize];\n        let mut num = 0;\n        Solution::schedule_queens(&mut board, &mut num, n as usize, 0);\n        num\n    }\n\n    fn schedule_queens(board: &mut Vec<Vec<char>>, num: &mut i32, len: usize, row: usize) {\n        for col in 0..len {\n            if !Solution::collision(&board, len, row, col) {\n                board[row][col] = 'Q';\n                if row == len - 1 {\n                    *num += 1;\n                } else {\n                    Solution::schedule_queens(board, num, len, row + 1);\n                }\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    #[inline(always)]\n    fn collision(board: &Vec<Vec<char>>, len: usize, x: usize, y: usize) -> bool {\n        for i in 0..x {\n            if board[i][y] == 'Q' {\n                return true;\n            }\n        }\n        let (mut i, mut j) = (x as i32 - 1, y as i32 - 1);\n        while i >= 0 && j >= 0 {\n            if board[i as usize][j as usize] == 'Q' {\n                return true;\n            }\n            i -= 1;\n            j -= 1;\n        }\n        let (mut i, mut j) = (x as i32 - 1, y as i32 + 1);\n        while i >= 0 && j < len as i32 {\n            if board[i as usize][j as usize] == 'Q' {\n                return true;\n            }\n            i -= 1;\n            j += 1;\n        }\n        false\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_52() {\n        assert_eq!(Solution::total_n_queens(4), 2);\n        assert_eq!(Solution::total_n_queens(8), 92);\n        assert_eq!(Solution::total_n_queens(13), 73712);\n        // assert_eq!(Solution::total_n_queens(14), 365596);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def totalNQueens(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    totalNQueens(n: number): number  {\n    const cols: boolean[] = Array(10).fill(false);\n    const dg: boolean[] = Array(20).fill(false);\n    const udg: boolean[] = Array(20).fill(false);\n    let ans = 0;\n    const dfs = (i: number) => {\n        if (i === n) {\n            ++ans;\n            return;\n        }\n        for (let j = 0; j < n; ++j) {\n            let [a, b] = [i + j, i - j + n];\n            if (cols[j] || dg[a] || udg[b]) {\n                continue;\n            }\n            cols[j] = dg[a] = udg[b] = true;\n            dfs(i + 1);\n            cols[j] = dg[a] = udg[b] = false;\n        }\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    totalNQueens(n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "generate-parentheses": {
    "title": "Generate Parentheses",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd32",
    "timeComplexity": "O(4^n / sqrt(n))",
    "spaceComplexity": "O(n)",
    "oneliner": "Add '(' if open < n. Add ')' if close < open.",
    "intuition": [
      "\ud83c\udfaf Generate all valid parentheses of n pairs.",
      "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
      "\ud83d\udca1 This ensures valid nesting."
    ],
    "testCases": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]"
      }
    ],
    "code": "class Solution:\n    def generateParenthesis(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Generate all valid parentheses of n pairs.\n        - \ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.\n        - \ud83d\udca1 This ensures valid nesting.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        def backtrack(s, openN, closeN):\n            if len(s) == 2 * n:\n                res.append(s)  # Add to end.\n                return\n            if openN < n:\n                backtrack(s + '(', openN + 1, closeN)\n            if closeN < openN:\n                backtrack(s + ')', openN, closeN + 1)\n        backtrack('', 0, 0)\n        return res  # Return the final result.",
    "keyInsight": "Only add ')' when close count < open count.",
    "visualizationType": "array",
    "initialState": [
      ""
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "n = 2",
        "transientMessage": "Generate valid parentheses combinations",
        "arrayState": [],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Add '(': \"(\"",
        "transientMessage": "open=1, close=0",
        "arrayState": [
          "("
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Add '(': \"((\"",
        "transientMessage": "open=2, close=0",
        "arrayState": [
          "(",
          "("
        ],
        "pointers": [],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Add ')': \"(()\"",
        "transientMessage": "open=2, close=1",
        "arrayState": [
          "(",
          "(",
          ")"
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Add ')': \"(())\"",
        "transientMessage": "open=2, close=2",
        "arrayState": [
          "(",
          "(",
          ")",
          ")"
        ],
        "pointers": [],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Valid: \"(())\"",
        "transientMessage": "1 found",
        "arrayState": [
          "(",
          "(",
          ")",
          ")"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Add ')': \"()\"",
        "transientMessage": "open=1, close=1",
        "arrayState": [
          "(",
          ")"
        ],
        "pointers": [],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Add '(': \"()(\"",
        "transientMessage": "open=2, close=1",
        "arrayState": [
          "(",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Add ')': \"()()\"",
        "transientMessage": "open=2, close=2",
        "arrayState": [
          "(",
          ")",
          "(",
          ")"
        ],
        "pointers": [],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Valid: \"()()\"",
        "transientMessage": "2 found",
        "arrayState": [
          "(",
          ")",
          "(",
          ")"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "2 valid combinations",
        "transientMessage": "Complete!",
        "arrayState": [],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Add '(' if open < n. Add ')' if close < open.\n\nGenerate all valid parentheses of n pairs.\nCan add '(' if count < n. Can add ')' if close < open.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Generate all valid parentheses of n pairs.",
      "Can add '(' if count < n. Can add ')' if close < open.",
      "This ensures valid nesting."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum",
      "subsets"
    ],
    "videoId": "s9fokUqJ76A",
    "problemStatement": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Add '(' if open < n. Add ')' if close < open.",
    "suggestedNextQuestion": {
      "slug": "letter-case-permutation",
      "title": "Letter Case Permutation",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def generateParenthesis(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def generateParenthesis_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(4^n / sqrt(n))",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Generate all valid parentheses of n pairs.",
          "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
          "\ud83d\udca1 This ensures valid nesting."
        ],
        "code": "def generateParenthesis(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Generate all valid parentheses of n pairs.\n    - \ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.\n    - \ud83d\udca1 This ensures valid nesting.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(s, openN, closeN):\n        if len(s) == 2 * n:\n            res.append(s)  # Add to end.\n            return\n        if openN < n:\n            backtrack(s + '(', openN + 1, closeN)\n        if closeN < openN:\n            backtrack(s + ')', openN, closeN + 1)\n    backtrack('', 0, 0)\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    generateParenthesis(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nclass Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    generateParenthesis(n) {\n        class Solution {\n        /**\n         * @param {any} l, r, t\n         * @return {any}\n         */\n        dfs(l, r, t) {\n            if (l > n || r > n || l < r) {\n                return;\n            }\n            if (l == n && r == n) {\n                ans.push(t);\n                return;\n            }\n            dfs(l + 1, r, t + '(');\n            dfs(l, r + 1, t + ')');\n    }\n    let ans = [];\n    dfs(0, 0, '');\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<String> ans = new ArrayList<>();\n    private int n;\n\n    public List<String> generateParenthesis(int n) {\n        this.n = n;\n        dfs(0, 0, \"\");\n        return ans;\n    }\n\n    private void dfs(int l, int r, String t) {\n        if (l > n || r > n || l < r) {\n            return;\n        }\n        if (l == n && r == n) {\n            ans.add(t);\n            return;\n        }\n        dfs(l + 1, r, t + \"(\");\n        dfs(l, r + 1, t + \")\");\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> generateParenthesis(int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> ans;\n        function<void(int, int, string)> dfs = [&](int l, int r, string t) {\n            if (l > n || r > n || l < r) return;\n            if (l == n && r == n) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(l + 1, r, t + \"(\");\n            dfs(l, r + 1, t + \")\");\n        };\n        dfs(0, 0, \"\");\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) generateParenthesis(n int) (ans []string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) generateParenthesis(n int) (ans []string) {\n\tvar dfs func(int, int, string)\n\tdfs = func(l, r int, t string) {\n\t\tif l > n || r > n || l < r {\n\t\t\treturn\n\t\t}\n\t\tif l == n && r == n {\n\t\t\tans = append(ans, t)\n\t\t\treturn\n\t\t}\n\t\tdfs(l+1, r, t+\"(\")\n\t\tdfs(l, r+1, t+\")\")\n\t}\n\tdfs(0, 0, \"\")\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn generate_parenthesis(n: i32) -> Vec<String> {\n        let mut ans = Vec::new();\n\n        fn dfs(ans: &mut Vec<String>, l: i32, r: i32, t: String, n: i32) {\n            if l > n || r > n || l < r {\n                return;\n            }\n            if l == n && r == n {\n                ans.push(t);\n                return;\n            }\n            dfs(ans, l + 1, r, format!(\"{}(\", t), n);\n            dfs(ans, l, r + 1, format!(\"{})\", t), n);\n        }\n\n        dfs(&mut ans, 0, 0, String::new(), n);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def generateParenthesis(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    generateParenthesis(n: number): string[] {\n        // Implementation goes here\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    generateParenthesis(n: number): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "subsets": {
    "title": "Subsets",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udce6",
    "timeComplexity": "O(2^n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Backtrack: include or exclude each element.",
    "intuition": [
      "\ud83c\udfaf All subsets of a set.",
      "\ud83e\udde0 For each element: include or exclude.",
      "\ud83d\udca1 Results at every node, not just leaves."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]"
      }
    ],
    "code": "class Solution:\n    def subsets(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf All subsets of a set.\n        - \ud83e\udde0 For each element: include or exclude.\n        - \ud83d\udca1 Results at every node, not just leaves.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        def backtrack(start, path):\n            res.append(path[:])  # Add to end.\n            for i in range(start, len(nums)):  # Iterate through the range.\n                path.append(nums[i])  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n        backtrack(0, [])\n        return res  # Return the final result.",
    "keyInsight": "Add current path at every node, not just at leaves.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [1, 2, 3]",
        "transientMessage": "Start with empty set: [[]]",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process 1",
        "transientMessage": "Add 1 to each existing subset",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "[] + 1 = [1]",
        "transientMessage": "Total: 2 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Process 2",
        "transientMessage": "Add 2 to each existing subset",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "[] + 2 = [2]",
        "transientMessage": "Total: 3 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "[1] + 2 = [1,2]",
        "transientMessage": "Total: 4 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process 3",
        "transientMessage": "Add 3 to each existing subset",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "[] + 3 = [3]",
        "transientMessage": "Total: 5 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "[1] + 3 = [1,3]",
        "transientMessage": "Total: 6 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "[2] + 3 = [2,3]",
        "transientMessage": "Total: 7 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "[1,2] + 3 = [1,2,3]",
        "transientMessage": "Total: 8 subsets",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Total: 8 subsets",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Backtrack: include or exclude each element.\n\nAll subsets of a set.\nFor each element: include or exclude.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "All subsets of a set.",
      "For each element: include or exclude.",
      "Results at every node, not just leaves."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum"
    ],
    "videoId": "REOH22Xwdkk",
    "problemStatement": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: Backtrack: include or exclude each element.",
    "suggestedNextQuestion": {
      "slug": "subsets-ii",
      "title": "Subsets II",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def subsets(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def subsets_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf All subsets of a set.",
          "\ud83e\udde0 For each element: include or exclude.",
          "\ud83d\udca1 Results at every node, not just leaves."
        ],
        "code": "def subsets(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All subsets of a set.\n    - \ud83e\udde0 For each element: include or exclude.\n    - \ud83d\udca1 Results at every node, not just leaves.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(start, path):\n        res.append(path[:])  # Add to end.\n        for i in range(start, len(nums)):  # Iterate through the range.\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    subsets(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    subsets(nums) {\n        const result = [];\n        dfs([], 0);\n\n        class Solution {\n          /**\n           * @param {any} subset, start\n           * @return {any}\n           */\n          dfs(subset, start) {\n          result.push(subset);\n          for (let index = start; index < nums.length; index++) {\n            dfs([...subset, nums[index]], index + 1);\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] nums;\n\n    public List<List<Integer>> subsets(int[] nums) {\n        this.nums = nums;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        dfs(i + 1);\n        t.add(nums[i]);\n        dfs(i + 1);\n        t.remove(t.size() - 1);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> subsets(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int)> dfs = [&](int i) -> void {\n            if (i == nums.size()) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(i + 1);\n            t.push_back(nums[i]);\n            dfs(i + 1);\n            t.pop_back();\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) subsets(nums []int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) subsets(nums []int) (ans [][]int) {\n\tt := []int{}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i == len(nums) {\n\t\t\tans = append(ans, append([]int(nil), t...))\n\t\t\treturn\n\t\t}\n\t\tdfs(i + 1)\n\t\tt = append(t, nums[i])\n\t\tdfs(i + 1)\n\t\tt = t[:len(t)-1]\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(i: usize, t: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>, nums: &Vec<i32>) {\n        if i == nums.len() {\n            ans.push(t.clone());\n            return;\n        }\n        Self::dfs(i + 1, t, ans, nums);\n        t.push(nums[i]);\n        Self::dfs(i + 1, t, ans, nums);\n        t.pop();\n    }\n\n    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut ans = Vec::new();\n        Self::dfs(0, &mut Vec::new(), &mut ans, &nums);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def subsets(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    subsets(nums: number[]): number[][]  {\n    const ans: number[][] = [];\n    const t: number[] = [];\n    const dfs = (i: number) => {\n        if (i === nums.length) {\n            ans.push(t.slice());\n            return;\n        }\n        dfs(i + 1);\n        t.push(nums[i]);\n        dfs(i + 1);\n        t.pop();\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    subsets(nums: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "letter-case-permutation": {
    "title": "Letter Case Permutation",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd24",
    "timeComplexity": "O(2^n)",
    "spaceComplexity": "O(n)",
    "oneliner": "For each letter, branch on lower and upper case.",
    "intuition": [
      "\ud83c\udfaf All case permutations of letters.",
      "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
      "\ud83d\udca1 Binary branching on letters."
    ],
    "testCases": [
      {
        "input": "s = \"a1b2\"",
        "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
      },
      {
        "input": "s = \"3z4\"",
        "output": "[\"3z4\",\"3Z4\"]"
      }
    ],
    "code": "class Solution:\n    def letterCasePermutation(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf All case permutations of letters.\n        - \ud83e\udde0 Digits: no choice. Letters: lower or upper.\n        - \ud83d\udca1 Binary branching on letters.\n        \"\"\"\n        res = []  # Initialize list to store results.\n        def backtrack(i, path):\n            if i == len(s):\n                res.append(''.join(path))  # Add to end.\n                return\n            if s[i].isalpha():\n                path.append(s[i].lower())  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n                path.append(s[i].upper())  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n            else:\n                path.append(s[i])  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n        backtrack(0, [])\n        return res  # Return the final result.",
    "keyInsight": "Letters create two branches; digits create one.",
    "visualizationType": "tree",
    "initialState": [
      "a",
      "1",
      "b",
      "2"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Letter Case Permutation",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add a to path",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [a]",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try b instead",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          "a",
          "1",
          "b",
          "2"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "For each letter, branch on lower and upper case.\n\nAll case permutations of letters.\nDigits: no choice. Letters: lower or upper.",
    "examples": [
      {
        "input": "s = \"a1b2\"",
        "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "All case permutations of letters.",
      "Digits: no choice. Letters: lower or upper.",
      "Binary branching on letters."
    ],
    "relatedProblems": [
      "permutations",
      "combination-sum",
      "subsets"
    ],
    "videoId": "IYXWcjwhUYo",
    "problemStatement": "Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. Return the output in any order.",
    "difficulty": "Medium",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "approach": "Backtracking: For each letter, branch on lower and upper case.",
    "suggestedNextQuestion": {
      "slug": "letter-combinations-of-a-phone-number",
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def letterCasePermutation(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def letterCasePermutation_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf All case permutations of letters.",
          "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
          "\ud83d\udca1 Binary branching on letters."
        ],
        "code": "def letterCasePermutation(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf All case permutations of letters.\n    - \ud83e\udde0 Digits: no choice. Letters: lower or upper.\n    - \ud83d\udca1 Binary branching on letters.\n    \"\"\"\n    res = []  # Initialize list to store results.\n    def backtrack(i, path):\n        if i == len(s):\n            res.append(''.join(path))  # Add to end.\n            return\n        if s[i].isalpha():\n            path.append(s[i].lower())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n            path.append(s[i].upper())  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n        else:\n            path.append(s[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    backtrack(0, [])\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    letterCasePermutation(str) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} str\n     * @return {any}\n     */\n    letterCasePermutation(str) {\n        const result = [];\n        backtrack(result, str);\n        return result;\n      };\n\n      class Solution {\n          /**\n           * @param {any} result, input, permutation = '', offset = 0\n           * @return {any}\n           */\n          backtrack(result, input, permutation = '', offset = 0) {\n        if (input.length === permutation.length) {\n          result.push(permutation);\n        } else {\n          const target = input[offset];\n          if (isNaN(target)) {\n            [target.toLowerCase(), target.toUpperCase()].forEach(s => {\n              backtrack(result, input, permutation + s, offset + 1);\n            });\n          } else {\n            backtrack(result, input, permutation + target, offset + 1);\n          }\n        }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> letterCasePermutation(String s) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<String> ans = new ArrayList<>();\n    private char[] t;\n\n    public List<String> letterCasePermutation(String s) {\n        t = s.toCharArray();\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i >= t.length) {\n            ans.add(new String(t));\n            return;\n        }\n        dfs(i + 1);\n        if (Character.isLetter(t[i])) {\n            t[i] ^= 32;\n            dfs(i + 1);\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> letterCasePermutation(string s) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> letterCasePermutation(string s) {\n        string t = s;\n        vector<string> ans;\n        auto dfs = [&](this auto&& dfs, int i) -> void {\n            if (i >= t.size()) {\n                ans.push_back(t);\n                return;\n            }\n            dfs(i + 1);\n            if (isalpha(t[i])) {\n                t[i] ^= 32;\n                dfs(i + 1);\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) letterCasePermutation(s string) (ans []string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) letterCasePermutation(s string) (ans []string) {\n\tt := []byte(s)\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i >= len(t) {\n\t\t\tans = append(ans, string(t))\n\t\t\treturn\n\t\t}\n\t\tdfs(i + 1)\n\t\tif t[i] >= 'A' {\n\t\t\tt[i] ^= 32\n\t\t\tdfs(i + 1)\n\t\t}\n\t}\n\n\tdfs(0)\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn letter_case_permutation(s: String) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn letter_case_permutation(s: String) -> Vec<String> {\n        fn dfs(i: usize, t: &mut Vec<char>, ans: &mut Vec<String>) {\n            if i >= t.len() {\n                ans.push(t.iter().collect());\n                return;\n            }\n            dfs(i + 1, t, ans);\n            if t[i].is_alphabetic() {\n                t[i] = (t[i] as u8 ^ 32) as char;\n                dfs(i + 1, t, ans);\n            }\n        }\n\n        let mut t: Vec<char> = s.chars().collect();\n        let mut ans = Vec::new();\n        dfs(0, &mut t, &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def letterCasePermutation(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    letterCasePermutation(s: string): string[]  {\n    const t = s.split('');\n    const ans: string[] = [];\n    const dfs = (i: number) => {\n        if (i >= t.length) {\n            ans.push(t.join(''));\n            return;\n        }\n        dfs(i + 1);\n        if (t[i].charCodeAt(0) >= 65) {\n            t[i] = String.fromCharCode(t[i].charCodeAt(0) ^ 32);\n            dfs(i + 1);\n        }\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    letterCasePermutation(s: string): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "merge-k-sorted-lists": {
    "title": "Merge k Sorted Lists",
    "pattern": "Divide and Conquer / Heap",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(N log k)",
    "spaceComplexity": "O(k)",
    "oneliner": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
    "intuition": [
      "\ud83c\udfaf Merge k sorted linked lists.",
      "\ud83e\udde0 Min-heap keeps track of smallest head.",
      "\ud83d\udca1 Pop smallest, add its next to heap."
    ],
    "testCases": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]"
      },
      {
        "input": "lists = []",
        "output": "[]"
      },
      {
        "input": "lists = [[]]",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def mergeKLists(self, lists):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Merge k sorted linked lists.\n        - \ud83e\udde0 Min-heap keeps track of smallest head.\n        - \ud83d\udca1 Pop smallest, add its next to heap.\n        \"\"\"\n        heap = []\n        for i, lst in enumerate(lists):  # Iterate over elements.\n            if lst:\n                heapq.heappush(heap, (lst[0], i, 0))\n        res = []  # Initialize list to store results.\n        while heap:\n            val, i, j = heapq.heappop(heap)  # Remove and return last element.\n            res.append(val)  # Add to end.\n            if j + 1 < len(lists[i]):\n                heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n        return res  # Return the final result.",
    "keyInsight": "Heap gives O(log k) for each of N elements.",
    "visualizationType": "linkedlist",
    "initialState": [
      [
        1,
        4,
        5
      ],
      [
        1,
        3,
        4
      ],
      [
        2,
        6
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Merge k Sorted Lists",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1,4,5",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1,3,4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 2,6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            1,
            4,
            5
          ],
          [
            1,
            3,
            4
          ],
          [
            2,
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.\n\nMerge k sorted linked lists.\nMin-heap keeps track of smallest head.",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Merge k sorted linked lists.",
      "Min-heap keeps track of smallest head.",
      "Pop smallest, add its next to heap."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "q5a5OiGbT6Q",
    "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Divide and Conquer / Heap: Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def mergeKLists_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N log k)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Merge k sorted linked lists.",
          "\ud83e\udde0 Min-heap keeps track of smallest head.",
          "\ud83d\udca1 Pop smallest, add its next to heap."
        ],
        "code": "import heapq\n\ndef mergeKLists(lists):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Merge k sorted linked lists.\n    - \ud83e\udde0 Min-heap keeps track of smallest head.\n    - \ud83d\udca1 Pop smallest, add its next to heap.\n    \"\"\"\n    heap = []\n    for i, lst in enumerate(lists):  # Iterate over elements.\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    res = []  # Initialize list to store results.\n    while heap:\n        val, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append(val)  # Add to end.\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n    \n    mergeKLists(lists) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) mergeKLists(lists []*ListNode) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) mergeKLists(lists []*ListNode) *ListNode {\n\tpq := hp{}\n\tfor _, head := range lists {\n\t\tif head != nil {\n\t\t\tpq = append(pq, head)\n\t\t}\n\t}\n\theap.Init(&pq)\n\tdummy := &ListNode{}\n\tcur := dummy\n\tfor len(pq) > 0 {\n\t\tcur.Next = heap.Pop(&pq).(*ListNode)\n\t\tcur = cur.Next\n\t\tif cur.Next != nil {\n\t\t\theap.Push(&pq, cur.Next)\n\t\t}\n\t}\n\treturn dummy.Next\n}\n\ntype hp []*ListNode\n\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].Val < h[j].Val }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(*ListNode)) }\nfunc (h *hp) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\nimpl PartialOrd for ListNode {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\nimpl Ord for ListNode {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.val.cmp(&other.val).reverse()\n    }\n}\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        let mut pq = lists\n            .into_iter()\n            .filter_map(|head| head)\n            .collect::<BinaryHeap<_>>();\n        let mut head = None;\n        let mut cur = &mut head;\n        while let Some(node) = pq.pop() {\n            cur = &mut cur.insert(Box::new(ListNode::new(node.val))).next;\n            if let Some(next) = node.next {\n                pq.push(next);\n            }\n        }\n        head\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "candy",
      "title": "Candy",
      "difficulty": "Hard",
      "pattern": "Two Pass Greedy"
    }
  },
  "search-insert-position": {
    "title": "Search Insert Position",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Binary search. If not found, left pointer is insert position.",
    "intuition": [
      "\ud83c\udfaf Find index to insert target in sorted array.",
      "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
      "\ud83d\udca1 Left pointer ends at correct insert position."
    ],
    "testCases": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2"
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1"
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4"
      }
    ],
    "code": "class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find index to insert target in sorted array.\n        - \ud83e\udde0 Binary search: if exact match, return. Else return left.\n        - \ud83d\udca1 Left pointer ends at correct insert position.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2  # Calculate middle index.\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n        return left",
    "keyInsight": "When target not found, left is the insert position.",
    "visualizationType": "array",
    "initialState": [
      1,
      3,
      5,
      6
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Initialize left to 0 and right to 3",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Calculate mid as (left + right) // 2 = 1",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "error",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "mid"
          }
        ],
        "transientMessage": "Calculate new mid as (left + right) // 2 = 2",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "error",
        "pointers": [
          {
            "index": 2,
            "label": "mid"
          }
        ],
        "transientMessage": "Check if nums[mid] == target. nums[2] = 5, which is not equal to the target",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 1,
            "label": "right"
          }
        ],
        "transientMessage": "Since nums[mid] > target, update right to mid - 1 = 1",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Calculate new mid as (left + right) // 2 = 1",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "error",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "success",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          }
        ],
        "transientMessage": "Return left as the insert position for the target",
        "arrayState": [
          1,
          3,
          5,
          6
        ]
      }
    ],
    "description": "Binary search. If not found, left pointer is insert position.\n\nFind index to insert target in sorted array.\nBinary search: if exact match, return. Else return left.",
    "examples": [
      {
        "input": "nums = [1,3,5,6]; target = 5",
        "output": "2"
      },
      {
        "input": "nums = [1,3,5,6]; target = 2",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find index to insert target in sorted array.",
      "Binary search: if exact match, return. Else return left.",
      "Left pointer ends at correct insert position."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array",
      "find-peak-element"
    ],
    "videoId": "K-RYzDZkzCI",
    "problemStatement": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.",
    "difficulty": "Easy",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Binary search. If not found, left pointer is insert position.",
    "suggestedNextQuestion": {
      "slug": "sqrtx",
      "title": "Sqrt(x)",
      "difficulty": "Easy",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def searchInsert(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def searchInsert_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find index to insert target in sorted array.",
          "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
          "\ud83d\udca1 Left pointer ends at correct insert position."
        ],
        "code": "def searchInsert(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find index to insert target in sorted array.\n    - \ud83e\udde0 Binary search: if exact match, return. Else return left.\n    - \ud83d\udca1 Left pointer ends at correct insert position.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return left"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    searchInsert(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    searchInsert(nums, target) {\n        let [l, r] = [0, nums.length];\n        while (l < r) {\n            const mid = (l + r) >> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n    }\n    return l;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int l = 0, r = nums.length;\n        while (l < r) {\n            int mid = (l + r) >>> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int searchInsert(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= target) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) searchInsert(nums []int, target int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) searchInsert(nums []int, target int) int {\n\tl, r := 0, len(nums)\n\tfor l < r {\n\t\tmid := (l + r) >> 1\n\t\tif nums[mid] >= target {\n\t\t\tr = mid\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn l\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn search_insert(nums: Vec<i32>, target: i32) -> i32 {\n        let mut l: usize = 0;\n        let mut r: usize = nums.len();\n        while l < r {\n            let mid = (l + r) >> 1;\n            if nums[mid] >= target {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        l as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def searchInsert(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    searchInsert(nums: number[], target: number): number  {\n    let [l, r] = [0, nums.length];\n    while (l < r) {\n        const mid = (l + r) >> 1;\n        if (nums[mid] >= target) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n}",
        "initialCode": "class Solution {\n    searchInsert(nums: number[], target: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "search-a-2d-matrix": {
    "title": "Search a 2D Matrix",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(log(m*n))",
    "spaceComplexity": "O(1)",
    "oneliner": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
    "intuition": [
      "\ud83c\udfaf Search target in row-sorted matrix.",
      "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
      "\ud83d\udca1 Standard binary search on virtual 1D array."
    ],
    "testCases": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
        "output": "true"
      },
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Search target in row-sorted matrix.\n        - \ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).\n        - \ud83d\udca1 Standard binary search on virtual 1D array.\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        while left <= right:\n            mid = (left + right) // 2  # Calculate middle index.\n            val = matrix[mid // n][mid % n]\n            if val == target:\n                return True  # Condition satisfied.\n            elif val < target:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n        return False  # Condition not met.",
    "keyInsight": "Index conversion: row = idx // cols, col = idx % cols.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        3,
        5,
        7
      ],
      [
        10,
        11,
        16,
        20
      ],
      [
        23,
        30,
        34,
        60
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Search a 2D Matrix",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 3",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 10",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 11",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            3,
            5,
            7
          ],
          [
            10,
            11,
            16,
            20
          ],
          [
            23,
            30,
            34,
            60
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.\n\nSearch target in row-sorted matrix.\nFlatten conceptually: idx -> (idx//n, idx%n).",
    "examples": [
      {
        "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]; target = 3",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Search target in row-sorted matrix.",
      "Flatten conceptually: idx -> (idx//n, idx%n).",
      "Standard binary search on virtual 1D array."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array",
      "find-peak-element"
    ],
    "videoId": "Ber2pi2C0j0",
    "problemStatement": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.",
    "difficulty": "Medium",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
    "suggestedNextQuestion": {
      "slug": "search-in-rotated-sorted-array",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def searchMatrix(self, matrix, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def searchMatrix_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log(m*n))",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Search target in row-sorted matrix.",
          "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
          "\ud83d\udca1 Standard binary search on virtual 1D array."
        ],
        "code": "def searchMatrix(matrix, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search target in row-sorted matrix.\n    - \ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).\n    - \ud83d\udca1 Standard binary search on virtual 1D array.\n    \"\"\"\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True  # Condition satisfied.\n        elif val < target:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return False  # Condition not met."
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    searchMatrix(matrix, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} matrix, target\n     * @return {any}\n     */\n    searchMatrix(matrix, target) {\n        const m = matrix.length,\n            n = matrix[0].length;\n        let left = 0,\n            right = m * n - 1;\n        while (left < right) {\n            const mid = (left + right + 1) >> 1;\n            const x = Math.floor(mid / n);\n            const y = mid % n;\n            if (matrix[x][y] <= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n    }\n    return matrix[Math.floor(left / n)][left % n] == target;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m * n - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            int x = mid / n, y = mid % n;\n            if (matrix[x][y] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return matrix[left / n][left % n] == target;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) searchMatrix(matrix [][]int, target int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) searchMatrix(matrix [][]int, target int) bool {\n\tm, n := len(matrix), len(matrix[0])\n\tleft, right := 0, m*n-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tx, y := mid/n, mid%n\n\t\tif matrix[x][y] >= target {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn matrix[left/n][left%n] == target\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::cmp::Ordering;\nimpl Solution {\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\n        let m = matrix.len();\n        let n = matrix[0].len();\n        let mut i = 0;\n        let mut j = n;\n        while i < m && j > 0 {\n            match matrix[i][j - 1].cmp(&target) {\n                Ordering::Equal => {\n                    return true;\n                }\n                Ordering::Less => {\n                    i += 1;\n                }\n                Ordering::Greater => {\n                    j -= 1;\n                }\n            }\n        }\n        false\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def searchMatrix(self, matrix, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    searchMatrix(matrix: number[][], target: number): boolean  {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let left = 0;\n    let right = m * n;\n    while (left < right) {\n        const mid = (left + right) >>> 1;\n        const i = Math.floor(mid / n);\n        const j = mid % n;\n        if (matrix[i][j] === target) {\n            return true;\n        }\n\n        if (matrix[i][j] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return false;\n}\n}",
        "initialCode": "class Solution {\n    searchMatrix(matrix: number[][], target: number): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "find-peak-element": {
    "title": "Find Peak Element",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83c\udfd4\ufe0f",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Move towards larger neighbor. Guaranteed to find peak.",
    "intuition": [
      "\ud83c\udfaf Find any peak (greater than neighbors).",
      "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
      "\ud83d\udca1 Binary search converges to a peak."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "2"
      },
      {
        "input": "nums = [1,2,1,3,5,6,4]",
        "output": "5"
      }
    ],
    "code": "class Solution:\n    def findPeakElement(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find any peak (greater than neighbors).\n        - \ud83e\udde0 If mid < mid+1, peak is on right. Else on left.\n        - \ud83d\udca1 Binary search converges to a peak.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2  # Calculate middle index.\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid\n        return left",
    "keyInsight": "Move towards the higher neighbor to find a peak.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find Peak Element",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          2,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Move towards larger neighbor. Guaranteed to find peak.\n\nFind any peak (greater than neighbors).\nIf mid < mid+1, peak is on right. Else on left.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find any peak (greater than neighbors).",
      "If mid < mid+1, peak is on right. Else on left.",
      "Binary search converges to a peak."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array"
    ],
    "videoId": "kMzJy9es7Hc",
    "problemStatement": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
    "difficulty": "Medium",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Move towards larger neighbor. Guaranteed to find peak.",
    "suggestedNextQuestion": {
      "slug": "h-index",
      "title": "H-Index",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def findPeakElement(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def findPeakElement_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find any peak (greater than neighbors).",
          "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
          "\ud83d\udca1 Binary search converges to a peak."
        ],
        "code": "def findPeakElement(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find any peak (greater than neighbors).\n    - \ud83e\udde0 If mid < mid+1, peak is on right. Else on left.\n    - \ud83d\udca1 Binary search converges to a peak.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return left"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findPeakElement(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    findPeakElement(nums) {\n        let left = 0;\n\n        for (let right = nums.length - 1, middle = 0; left < right;) {\n          middle = Math.floor((right + left) / 2);\n          if (nums[middle] > nums[middle + 1]) {\n            right = middle;\n          } else {\n            left = middle + 1;\n          }\n      }\n\n    return left;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findPeakElement(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int findPeakElement(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findPeakElement(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        while (left < right) {\n            int mid = left + right >> 1;\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findPeakElement(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findPeakElement(nums []int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[mid] > nums[mid+1] {\n\t\t\tright = mid\n\t\t} else {\n\t\t\tleft = mid + 1\n\t\t}\n\t}\n\treturn left\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_peak_element(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [162] Find Peak Element\n *\n * A peak element is an element that is greater than its neighbors.\n *\n * Given an input array nums, where nums[i] &ne; nums[i+1], find a peak element and return its index.\n *\n * The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n *\n * You may imagine that nums[-1] = nums[n] = -&infin;.\n *\n * Example 1:\n *\n *\n * Input: nums = [1,2,3,1]\n * Output: 2\n * Explanation: 3 is a peak element and your function should return the index number 2.\n *\n * Example 2:\n *\n *\n * Input: nums = [1,2,1,3,5,6,4]\n * Output: 1 or 5\n * Explanation: Your function can return either index number 1 where the peak element is 2,\n *              or index number 5 where the peak element is 6.\n *\n *\n * Note:\n *\n * Your solution should be in logarithmic complexity.\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/find-peak-element/\n// discuss: https://leetcode.com/problems/find-peak-element/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn find_peak_element(nums: Vec<i32>) -> i32 {\n        let (mut lo, mut hi) = (0_usize, nums.len() - 1);\n        let mut mid = 0;\n        while lo < hi {\n            mid = (hi - lo) / 2 + lo;\n            if mid + 1 < nums.len() && nums[mid] < nums[mid + 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        lo as i32\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_162() {\n        assert_eq!(Solution::find_peak_element(vec![1, 2, 3, 1]), 2);\n        assert_eq!(Solution::find_peak_element(vec![1, 2, 1, 3, 5, 6, 4]), 5);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findPeakElement(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findPeakElement(nums: number[]): number  {\n    let [left, right] = [0, nums.length - 1];\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[mid] > nums[mid + 1]) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n}",
        "initialCode": "class Solution {\n    findPeakElement(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "search-in-rotated-sorted-array": {
    "title": "Search in Rotated Sorted Array",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Determine which half is sorted. Check if target is in that half.",
    "intuition": [
      "\ud83c\udfaf Search in rotated sorted array.",
      "\ud83e\udde0 One half is always sorted. Check if target is there.",
      "\ud83d\udca1 Narrow down to the half where target can exist."
    ],
    "testCases": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4"
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1"
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1"
      }
    ],
    "code": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Search in rotated sorted array.\n        - \ud83e\udde0 One half is always sorted. Check if target is there.\n        - \ud83d\udca1 Narrow down to the half where target can exist.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2  # Calculate middle index.\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:  # Left half sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1  # Search left half.\n                else:\n                    left = mid + 1  # Search right half.\n            else:  # Right half sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1  # Search right half.\n                else:\n                    right = mid - 1  # Search left half.\n        return -1",
    "keyInsight": "At least one half is always sorted in a rotated array.",
    "visualizationType": "array",
    "initialState": [
      4,
      5,
      6,
      7,
      0,
      1,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Search in Rotated Sorted Array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 4",
        "transientMessage": "Iteration 1",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 5",
        "transientMessage": "Iteration 2",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 7",
        "transientMessage": "Iteration 4",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 0",
        "transientMessage": "Iteration 5",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 1",
        "transientMessage": "Iteration 6",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          4,
          5,
          6,
          7,
          0,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Determine which half is sorted. Check if target is in that half.\n\nSearch in rotated sorted array.\nOne half is always sorted. Check if target is there.",
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2]; target = 0",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Search in rotated sorted array.",
      "One half is always sorted. Check if target is there.",
      "Narrow down to the half where target can exist."
    ],
    "relatedProblems": [
      "binary-search",
      "find-peak-element"
    ],
    "videoId": "U8XENwh8Oy8",
    "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.",
    "difficulty": "Medium",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Determine which half is sorted. Check if target is in that half.",
    "suggestedNextQuestion": {
      "slug": "time-based-key-value-store",
      "title": "Time Based Key Value Store",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def search(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def search_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Search in rotated sorted array.",
          "\ud83e\udde0 One half is always sorted. Check if target is there.",
          "\ud83d\udca1 Narrow down to the half where target can exist."
        ],
        "code": "def search(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Search in rotated sorted array.\n    - \ud83e\udde0 One half is always sorted. Check if target is there.\n    - \ud83d\udca1 Narrow down to the half where target can exist.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1  # Search left half.\n            else:\n                left = mid + 1  # Search right half.\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n    return -1"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    search(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    search(nums, target) {\n        const n = nums.length;\n        let left = 0,\n            right = n - 1;\n        while (left < right) {\n            const mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target <= nums[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n    }\n    return nums[left] == target ? left : -1;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int search(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target <= nums[mid]) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n        }\n        return nums[left] == target ? left : -1;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int search(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                if (nums[0] <= target && target <= nums[mid])\n                    right = mid;\n                else\n                    left = mid + 1;\n            } else {\n                if (nums[mid] < target && target <= nums[n - 1])\n                    left = mid + 1;\n                else\n                    right = mid;\n            }\n        }\n        return nums[left] == target ? left : -1;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) search(nums []int, target int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) search(nums []int, target int) int {\n\tn := len(nums)\n\tleft, right := 0, n-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[0] <= nums[mid] {\n\t\t\tif nums[0] <= target && target <= nums[mid] {\n\t\t\t\tright = mid\n\t\t\t} else {\n\t\t\t\tleft = mid + 1\n\t\t\t}\n\t\t} else {\n\t\t\tif nums[mid] < target && target <= nums[n-1] {\n\t\t\t\tleft = mid + 1\n\t\t\t} else {\n\t\t\t\tright = mid\n\t\t\t}\n\t\t}\n\t}\n\tif nums[left] == target {\n\t\treturn left\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\n        let mut l = 0;\n        let mut r = nums.len() - 1;\n        while l <= r {\n            let mid = (l + r) >> 1;\n            if nums[mid] == target {\n                return mid as i32;\n            }\n\n            if nums[l] <= nums[mid] {\n                if target < nums[mid] && target >= nums[l] {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            } else {\n                if target > nums[mid] && target <= nums[r] {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            }\n        }\n        -1\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def search(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    search(nums: number[], target: number): number  {\n    const n = nums.length;\n    let left = 0,\n        right = n - 1;\n    while (left < right) {\n        const mid = (left + right) >> 1;\n        if (nums[0] <= nums[mid]) {\n            if (nums[0] <= target && target <= nums[mid]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[n - 1]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n    }\n    return nums[left] == target ? left : -1;\n}\n}",
        "initialCode": "class Solution {\n    search(nums: number[], target: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
    "title": "Find First and Last Position of Element in Sorted Array",
    "pattern": "Binary Search (Bisect)",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Two binary searches: find left bound and right bound.",
    "intuition": [
      "\ud83c\udfaf Find start and end indices of target.",
      "\ud83e\udde0 Binary search for leftmost occurrence.",
      "\ud83d\udca1 Binary search for rightmost occurrence."
    ],
    "testCases": [
      {
        "input": "nums = [5,7,7,8,8,10], target = 8",
        "output": "[3,4]"
      },
      {
        "input": "nums = [5,7,7,8,8,10], target = 6",
        "output": "[-1,-1]"
      },
      {
        "input": "nums = [], target = 0",
        "output": "[-1,-1]"
      }
    ],
    "code": "class Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find start and end indices of target.\n        - \ud83e\udde0 Binary search for leftmost occurrence.\n        - \ud83d\udca1 Binary search for rightmost occurrence.\n        \"\"\"\n        def findLeft():\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n\n        def findRight():\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return right\n\n        l, r = findLeft(), findRight()  # Initialize two pointers.\n        return [l, r] if l <= r else [-1, -1]",
    "keyInsight": "Two separate binary searches for left and right bounds.",
    "visualizationType": "array",
    "initialState": [
      5,
      7,
      7,
      8,
      8,
      10
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Initializing search for left boundary",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "mid"
          }
        ],
        "transientMessage": "Checking mid value (8) against target (7)",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 2,
            "label": "right"
          }
        ],
        "transientMessage": "Adjusting search range to left half",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Checking mid value (7) against target (7)",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Adjusting search range to left half",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "mid"
          }
        ],
        "transientMessage": "Checking mid value (5) against target (7)",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          0
        ],
        "color": "success",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Left boundary found at index 2",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 5,
            "label": "right"
          }
        ],
        "transientMessage": "Initializing search for right boundary",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "mid"
          }
        ],
        "transientMessage": "Checking mid value (8) against target (7)",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 2,
            "label": "right"
          }
        ],
        "transientMessage": "Adjusting search range to left half",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "mid"
          }
        ],
        "transientMessage": "Checking mid value (7) against target (7)",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          0
        ],
        "color": "success",
        "pointers": [
          {
            "index": 2,
            "label": "left"
          },
          {
            "index": 0,
            "label": "right"
          }
        ],
        "transientMessage": "Right boundary found at index 3",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 2,
            "label": "l"
          },
          {
            "index": 3,
            "label": "r"
          }
        ],
        "transientMessage": "Result: [2, 3]",
        "arrayState": [
          5,
          7,
          7,
          8,
          8,
          10
        ]
      }
    ],
    "description": "Two binary searches: find left bound and right bound.\n\nFind start and end indices of target.\nBinary search for leftmost occurrence.",
    "examples": [
      {
        "input": "nums = [5,7,7,8,8,10]; target = 8",
        "output": "[3,4]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find start and end indices of target.",
      "Binary search for leftmost occurrence.",
      "Binary search for rightmost occurrence."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "4sQL7R5ySUU",
    "problemStatement": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Binary Search (Bisect): Two binary searches: find left bound and right bound.",
    "suggestedNextQuestion": {
      "slug": "find-minimum-in-rotated-sorted-array",
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def searchRange(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def searchRange_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find start and end indices of target.",
          "\ud83e\udde0 Binary search for leftmost occurrence.",
          "\ud83d\udca1 Binary search for rightmost occurrence."
        ],
        "code": "def searchRange(nums, target):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find start and end indices of target.\n    - \ud83e\udde0 Binary search for leftmost occurrence.\n    - \ud83d\udca1 Binary search for rightmost occurrence.\n    \"\"\"\n    def findLeft():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    def findRight():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    \n    l, r = findLeft(), findRight()  # Initialize two pointers.\n    return [l, r] if l <= r else [-1, -1]"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    searchRange(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    searchRange(nums, target) {\n        class Solution {\n        /**\n         * @param {any} x\n         * @return {any}\n         */\n        search(x) {\n            let left = 0,\n                right = nums.length;\n            while (left < right) {\n                const mid = (left + right) >> 1;\n                if (nums[mid] >= x) {\n                    right = mid;\n                } else {\n                    left = mid + 1;\n                }\n            }\n            return left;\n    }\n    const l = search(target);\n    const r = search(target + 1);\n    return l == r ? [-1, -1] : [l, r - 1];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int l = search(nums, target);\n        int r = search(nums, target + 1);\n        return l == r ? new int[] {-1, -1} : new int[] {l, r - 1};\n    }\n\n    private int search(int[] nums, int x) {\n        int left = 0, right = nums.length;\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            if (nums[mid] >= x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> searchRange(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        int r = lower_bound(nums.begin(), nums.end(), target + 1) - nums.begin();\n        if (l == r) {\n            return {-1, -1};\n        }\n        return {l, r - 1};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) searchRange(nums []int, target int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) searchRange(nums []int, target int) []int {\n\tl := sort.SearchInts(nums, target)\n\tr := sort.SearchInts(nums, target+1)\n\tif l == r {\n\t\treturn []int{-1, -1}\n\t}\n\treturn []int{l, r - 1}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let n = nums.len();\n        let search = |x| {\n            let mut left = 0;\n            let mut right = n;\n            while left < right {\n                let mid = left + (right - left) / 2;\n                if nums[mid] < x {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            left\n        };\n        let l = search(target);\n        let r = search(target + 1);\n        if l == r {\n            return vec![-1, -1];\n        }\n        vec![l as i32, (r - 1) as i32]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def searchRange(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    searchRange(nums: number[], target: number): number[]  {\n    const search = (x: number): number => {\n        let [left, right] = [0, nums.length];\n        while (left < right) {\n            const mid = (left + right) >> 1;\n            if (nums[mid] >= x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    };\n    const l = search(target);\n    const r = search(target + 1);\n    return l === r ? [-1, -1] : [l, r - 1];\n}\n}",
        "initialCode": "class Solution {\n    searchRange(nums: number[], target: number): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "find-minimum-in-rotated-sorted-array": {
    "title": "Find Minimum in Rotated Sorted Array",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udcc9",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Compare mid with right. If mid > right, min is on right. Else on left.",
    "intuition": [
      "\ud83c\udfaf Find minimum in rotated sorted array.",
      "\ud83e\udde0 Compare mid with rightmost element.",
      "\ud83d\udca1 Rotation point is where min is."
    ],
    "testCases": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1"
      },
      {
        "input": "nums = [4,5,6,7,0,1,2]",
        "output": "0"
      },
      {
        "input": "nums = [11,13,15,17]",
        "output": "11"
      }
    ],
    "code": "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find minimum in rotated sorted array.\n        - \ud83e\udde0 Compare mid with rightmost element.\n        - \ud83d\udca1 Rotation point is where min is.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2  # Calculate middle index.\n            if nums[mid] > nums[right]:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid\n        return nums[left]",
    "keyInsight": "Compare with right end to determine which half has the minimum.",
    "visualizationType": "array",
    "initialState": [
      3,
      4,
      5,
      1,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find Minimum in Rotated Sorted Array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 5",
        "transientMessage": "Iteration 3",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Compare mid with right. If mid > right, min is on right. Else on left.\n\nFind minimum in rotated sorted array.\nCompare mid with rightmost element.",
    "examples": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find minimum in rotated sorted array.",
      "Compare mid with rightmost element.",
      "Rotation point is where min is."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array",
      "find-peak-element"
    ],
    "videoId": "nIVW4P8b1VA",
    "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.",
    "difficulty": "Medium",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Compare mid with right. If mid > right, min is on right. Else on left.",
    "suggestedNextQuestion": {
      "slug": "find-peak-element",
      "title": "Find Peak Element",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def findMin(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def findMin_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find minimum in rotated sorted array.",
          "\ud83e\udde0 Compare mid with rightmost element.",
          "\ud83d\udca1 Rotation point is where min is."
        ],
        "code": "def findMin(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find minimum in rotated sorted array.\n    - \ud83e\udde0 Compare mid with rightmost element.\n    - \ud83d\udca1 Rotation point is where min is.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if nums[mid] > nums[right]:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid\n    return nums[left]"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findMin(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    findMin(nums) {\n        let l = 0,\n            r = nums.length - 1;\n        if (nums[l] < nums[r]) return nums[0];\n        while (l < r) {\n            const m = (l + r) >> 1;\n            if (nums[m] > nums[r]) l = m + 1;\n            else r = m;\n    }\n    return nums[l];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findMin(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int findMin(int[] nums) {\n        int n = nums.length;\n        if (nums[0] <= nums[n - 1]) {\n            return nums[0];\n        }\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return nums[left];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findMin(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int n = nums.size();\n        if (nums[0] <= nums[n - 1]) return nums[0];\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[0] <= nums[mid])\n                left = mid + 1;\n            else\n                right = mid;\n        }\n        return nums[left];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findMin(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findMin(nums []int) int {\n\tn := len(nums)\n\tif nums[0] <= nums[n-1] {\n\t\treturn nums[0]\n\t}\n\tleft, right := 0, n-1\n\tfor left < right {\n\t\tmid := (left + right) >> 1\n\t\tif nums[0] <= nums[mid] {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid\n\t\t}\n\t}\n\treturn nums[left]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_min(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_min(nums: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n        while left < right {\n            let mid = left + (right - left) / 2;\n            if nums[mid] > nums[right] {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        nums[left]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findMin(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findMin(nums: number[]): number  {\n    let left = 0;\n    let right = nums.length - 1;\n    while (left < right) {\n        const mid = (left + right) >>> 1;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n}",
        "initialCode": "class Solution {\n    findMin(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "median-of-two-sorted-arrays": {
    "title": "Median of Two Sorted Arrays",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(log(min(m,n)))",
    "spaceComplexity": "O(1)",
    "oneliner": "Binary search on smaller array. Find partition where left <= right.",
    "intuition": [
      "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
      "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
      "\ud83d\udca1 Binary search on smaller array for correct partition."
    ],
    "testCases": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000"
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000"
      }
    ],
    "code": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).\n        - \ud83e\udde0 Partition both arrays such that left halves = right halves.\n        - \ud83d\udca1 Binary search on smaller array for correct partition.\n        \"\"\"\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        m, n = len(nums1), len(nums2)\n        left, right = 0, m\n        while left <= right:\n            i = (left + right) // 2\n            j = (m + n + 1) // 2 - i\n            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n            minRight1 = float('inf') if i == m else nums1[i]\n            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n            minRight2 = float('inf') if j == n else nums2[j]\n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n                if (m + n) % 2 == 0:\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2  # Take the maximum value.\n                return max(maxLeft1, maxLeft2)  # Take the maximum value.\n            elif maxLeft1 > minRight2:\n                right = i - 1\n            else:\n                left = i + 1\n        return 0.0",
    "keyInsight": "Partition such that all left elements <= all right elements.",
    "visualizationType": "array",
    "initialState": [
      1,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Median of Two Sorted Arrays",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Binary search on smaller array. Find partition where left <= right.\n\nFind median of two sorted arrays in O(log(m+n)).\nPartition both arrays such that left halves = right halves.",
    "examples": [
      {
        "input": "nums1 = [1,3]; nums2 = [2]",
        "output": "2.0"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find median of two sorted arrays in O(log(m+n)).",
      "Partition both arrays such that left halves = right halves.",
      "Binary search on smaller array for correct partition."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array",
      "find-peak-element"
    ],
    "videoId": "q6IEA26hvXc",
    "problemStatement": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
    "difficulty": "Hard",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Binary search on smaller array. Find partition where left <= right.",
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def findMedianSortedArrays_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log(min(m,n)))",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
          "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
          "\ud83d\udca1 Binary search on smaller array for correct partition."
        ],
        "code": "def findMedianSortedArrays(nums1, nums2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).\n    - \ud83e\udde0 Partition both arrays such that left halves = right halves.\n    - \ud83d\udca1 Binary search on smaller array for correct partition.\n    \"\"\"\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2  # Take the maximum value.\n            return max(maxLeft1, maxLeft2)  # Take the maximum value.\n        elif maxLeft1 > minRight2:\n            right = i - 1\n        else:\n            left = i + 1\n    return 0.0"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findMedianSortedArrays(nums1, nums2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums1, nums2\n     * @return {any}\n     */\n    findMedianSortedArrays(nums1, nums2) {\n        const m = nums1.length;\n        const n = nums2.length;\n        const f = (i, j, k) => {\n            if (i >= m) {\n                return nums2[j + k - 1];\n            }\n            if (j >= n) {\n                return nums1[i + k - 1];\n            }\n            if (k == 1) {\n                return Math.min(nums1[i], nums2[j]);\n        }\n        const p = Math.floor(k / 2);\n        const x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n        const y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n        return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n    };\n    const a = f(0, 0, Math.floor((m + n + 1) / 2));\n    const b = f(0, 0, Math.floor((m + n + 2) / 2));\n    return (a + b) / 2;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    private int m;\n    private int n;\n    private int[] nums1;\n    private int[] nums2;\n\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        m = nums1.length;\n        n = nums2.length;\n        this.nums1 = nums1;\n        this.nums2 = nums2;\n        int a = f(0, 0, (m + n + 1) / 2);\n        int b = f(0, 0, (m + n + 2) / 2);\n        return (a + b) / 2.0;\n    }\n\n    private int f(int i, int j, int k) {\n        if (i >= m) {\n            return nums2[j + k - 1];\n        }\n        if (j >= n) {\n            return nums1[i + k - 1];\n        }\n        if (k == 1) {\n            return Math.min(nums1[i], nums2[j]);\n        }\n        int p = k / 2;\n        int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n        int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n        return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        function<int(int, int, int)> f = [&](int i, int j, int k) {\n            if (i >= m) {\n                return nums2[j + k - 1];\n            }\n            if (j >= n) {\n                return nums1[i + k - 1];\n            }\n            if (k == 1) {\n                return min(nums1[i], nums2[j]);\n            }\n            int p = k / 2;\n            int x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n            int y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n            return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n        };\n        int a = f(0, 0, (m + n + 1) / 2);\n        int b = f(0, 0, (m + n + 2) / 2);\n        return (a + b) / 2.0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n\tm, n := len(nums1), len(nums2)\n\tvar f func(i, j, k int) int\n\tf = func(i, j, k int) int {\n\t\tif i >= m {\n\t\t\treturn nums2[j+k-1]\n\t\t}\n\t\tif j >= n {\n\t\t\treturn nums1[i+k-1]\n\t\t}\n\t\tif k == 1 {\n\t\t\treturn min(nums1[i], nums2[j])\n\t\t}\n\t\tp := k / 2\n\t\tx, y := 1<<30, 1<<30\n\t\tif ni := i + p - 1; ni < m {\n\t\t\tx = nums1[ni]\n\t\t}\n\t\tif nj := j + p - 1; nj < n {\n\t\t\ty = nums2[nj]\n\t\t}\n\t\tif x < y {\n\t\t\treturn f(i+p, j, k-p)\n\t\t}\n\t\treturn f(i, j+p, k-p)\n\t}\n\ta, b := f(0, 0, (m+n+1)/2), f(0, 0, (m+n+2)/2)\n\treturn float64(a+b) / 2.0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {\n        let n1 = nums1.len();\n        let n2 = nums2.len();\n        if n1 > n2 { return Self::find_median_sorted_arrays(nums2, nums1); }\n        \n        let (mut low, mut high) = (0, n1);\n        while low <= high {\n            let cut1 = (low + high) / 2;\n            let cut2 = (n1 + n2 + 1) / 2 - cut1;\n            \n            let l1 = if cut1 == 0 { i32::MIN } else { nums1[cut1-1] };\n            let l2 = if cut2 == 0 { i32::MIN } else { nums2[cut2-1] };\n            let r1 = if cut1 == n1 { i32::MAX } else { nums1[cut1] };\n            let r2 = if cut2 == n2 { i32::MAX } else { nums2[cut2] };\n            \n            if l1 <= r2 && l2 <= r1 {\n                if (n1 + n2) % 2 == 0 {\n                    return (i32::max(l1, l2) as f64 + i32::min(r1, r2) as f64) / 2.0;\n                } else {\n                    return i32::max(l1, l2) as f64;\n                }\n            } else if l1 > r2 {\n                high = cut1 - 1;\n            } else {\n                low = cut1 + 1;\n            }\n        }\n        0.0\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findMedianSortedArrays(nums1: number[], nums2: number[]): number  {\n    const m = nums1.length;\n    const n = nums2.length;\n    const f = (i: number, j: number, k: number): number => {\n        if (i >= m) {\n            return nums2[j + k - 1];\n        }\n        if (j >= n) {\n            return nums1[i + k - 1];\n        }\n        if (k == 1) {\n            return Math.min(nums1[i], nums2[j]);\n        }\n        const p = Math.floor(k / 2);\n        const x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\n        const y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\n        return x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n    };\n    const a = f(0, 0, Math.floor((m + n + 1) / 2));\n    const b = f(0, 0, Math.floor((m + n + 2) / 2));\n    return (a + b) / 2;\n}\n}",
        "initialCode": "class Solution {\n    findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "time-based-key-value-store",
      "title": "Time Based Key-Value Store",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    }
  },
  "maximum-sum-circular-subarray": {
    "title": "Maximum Sum Circular Subarray",
    "pattern": "Kadane's",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Max is either normal Kadane OR total - min subarray.",
    "intuition": [
      "\ud83c\udfaf Max subarray sum in circular array.",
      "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
      "\ud83d\udca1 Wrapping = total - min subarray."
    ],
    "testCases": [
      {
        "input": "nums = [1,-2,3,-2]",
        "output": "3"
      },
      {
        "input": "nums = [5,-3,5]",
        "output": "10"
      },
      {
        "input": "nums = [-3,-2,-3]",
        "output": "-2"
      }
    ],
    "code": "class Solution:\n    def maxSubarraySumCircular(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Max subarray sum in circular array.\n        - \ud83e\udde0 Two cases: normal subarray OR wrapping subarray.\n        - \ud83d\udca1 Wrapping = total - min subarray.\n        \"\"\"\n        total = 0\n        maxSum = nums[0]\n        curMax = 0\n        minSum = nums[0]\n        curMin = 0\n        for n in nums:  # Iterate over elements.\n            curMax = max(curMax + n, n)  # Take the maximum value.\n            maxSum = max(maxSum, curMax)  # Take the maximum value.\n            curMin = min(curMin + n, n)  # Take the minimum value.\n            minSum = min(minSum, curMin)  # Take the minimum value.\n            total += n\n        if maxSum > 0:\n            return max(maxSum, total - minSum)  # Take the maximum value.\n        return maxSum",
    "keyInsight": "Circular case: max = total - minSubarray.",
    "visualizationType": "array",
    "initialState": [
      1,
      -2,
      3,
      -2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Maximum Sum Circular Subarray",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = -2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = -2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          -2,
          3,
          -2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Max is either normal Kadane OR total - min subarray.\n\nMax subarray sum in circular array.\nTwo cases: normal subarray OR wrapping subarray.",
    "examples": [
      {
        "input": "nums = [1,-2,3,-2]",
        "output": "3"
      },
      {
        "input": "nums = [5,-3,5]",
        "output": "10"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Max subarray sum in circular array.",
      "Two cases: normal subarray OR wrapping subarray.",
      "Wrapping = total - min subarray."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "fxT9KjakYPM",
    "problemStatement": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Kadane's: Max is either normal Kadane OR total - min subarray.",
    "mentalModel": "Like finding the sunniest part of the day. If the clouds (negative) get too heavy, you restart your streak.",
    "initialCode": "class Solution:\n    def maxSubarraySumCircular(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxSubarraySumCircular(nums):\n    globMax, globMin = nums[0], nums[0]\n    curMax, curMin = 0, 0\n    total = 0\n    for n in nums:\n        curMax = max(curMax + n, n)\n        curMin = min(curMin + n, n)\n        total += n\n        globMax = max(globMax, curMax)\n        globMin = min(globMin, curMin)\n    return max(globMax, total - globMin) if globMax > 0 else globMax"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Max subarray sum in circular array.",
          "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
          "\ud83d\udca1 Wrapping = total - min subarray."
        ],
        "code": "def maxSubarraySumCircular(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max subarray sum in circular array.\n    - \ud83e\udde0 Two cases: normal subarray OR wrapping subarray.\n    - \ud83d\udca1 Wrapping = total - min subarray.\n    \"\"\"\n    total = 0\n    maxSum = nums[0]\n    curMax = 0\n    minSum = nums[0]\n    curMin = 0\n    for n in nums:  # Iterate over elements.\n        curMax = max(curMax + n, n)  # Take the maximum value.\n        maxSum = max(maxSum, curMax)  # Take the maximum value.\n        curMin = min(curMin + n, n)  # Take the minimum value.\n        minSum = min(minSum, curMin)  # Take the minimum value.\n        total += n\n    if maxSum > 0:\n        return max(maxSum, total - minSum)  # Take the maximum value.\n    return maxSum"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxSubarraySumCircular(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    maxSubarraySumCircular(nums) {\n        let [min, max, sum] = [nums[0], nums[0], nums[0]];\n\n        for (let i = 1, prevMin = nums[0], prevMax = nums[0]; i < nums.length; i++) {\n          prevMax = Math.max(nums[i], prevMax + nums[i]);\n          max = Math.max(max, prevMax);\n          prevMin = Math.min(nums[i], prevMin + nums[i]);\n          min = Math.min(min, prevMin);\n          sum += nums[i];\n      }\n\n    return max > 0 ? Math.max(max, sum - min) : max;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxSubarraySumCircular(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxSubarraySumCircular(int[] nums) {\n        final int inf = 1 << 30;\n        int pmi = 0, pmx = -inf;\n        int ans = -inf, s = 0, smi = inf;\n        for (int x : nums) {\n            s += x;\n            ans = Math.max(ans, s - pmi);\n            smi = Math.min(smi, s - pmx);\n            pmi = Math.min(pmi, s);\n            pmx = Math.max(pmx, s);\n        }\n        return Math.max(ans, s - smi);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxSubarraySumCircular(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        const int inf = 1 << 30;\n        int pmi = 0, pmx = -inf;\n        int ans = -inf, s = 0, smi = inf;\n        for (int x : nums) {\n            s += x;\n            ans = max(ans, s - pmi);\n            smi = min(smi, s - pmx);\n            pmi = min(pmi, s);\n            pmx = max(pmx, s);\n        }\n        return max(ans, s - smi);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxSubarraySumCircular(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxSubarraySumCircular(nums []int) int {\n\tconst inf = 1 << 30\n\tpmi, pmx := 0, -inf\n\tans, s, smi := -inf, 0, inf\n\tfor _, x := range nums {\n\t\ts += x\n\t\tans = max(ans, s-pmi)\n\t\tsmi = min(smi, s-pmx)\n\t\tpmi = min(pmi, s)\n\t\tpmx = max(pmx, s)\n\t}\n\treturn max(ans, s-smi)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_subarray_sum_circular(nums: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn max_subarray_sum_circular(a: Vec<i32>) -> i32 {\n        let n = a.len();\n        let sum = a.iter().sum::<i32>();\n        let mut prev_min = 0;\n        let mut prev_max = 0;\n        let mut min = std::i32::MAX;\n        let mut max = std::i32::MIN;\n        for i in 0..n {\n            prev_min = a[i].min(prev_min + a[i]);\n            min = min.min(prev_min);\n            prev_max = a[i].max(prev_max + a[i]);\n            max = max.max(prev_max);\n        }\n        if max < 0 {\n            max\n        } else {\n            max.max(sum - min)\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let a = vec![1, -2, 3, -2];\n    let res = 3;\n    assert_eq!(Solution::max_subarray_sum_circular(a), res);\n    let a = vec![5, -3, 5];\n    let res = 10;\n    assert_eq!(Solution::max_subarray_sum_circular(a), res);\n    let a = vec![3, -1, 2, -1];\n    let res = 4;\n    assert_eq!(Solution::max_subarray_sum_circular(a), res);\n    let a = vec![3, -2, 2, -3];\n    let res = 3;\n    assert_eq!(Solution::max_subarray_sum_circular(a), res);\n    let a = vec![-2, -3, -1];\n    let res = -1;\n    assert_eq!(Solution::max_subarray_sum_circular(a), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxSubarraySumCircular(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxSubarraySumCircular(nums: number[]): number  {\n    let [pmi, pmx] = [0, -Infinity];\n    let [ans, s, smi] = [-Infinity, 0, Infinity];\n    for (const x of nums) {\n        s += x;\n        ans = Math.max(ans, s - pmi);\n        smi = Math.min(smi, s - pmx);\n        pmi = Math.min(pmi, s);\n        pmx = Math.max(pmx, s);\n    }\n    return Math.max(ans, s - smi);\n}\n}",
        "initialCode": "class Solution {\n    maxSubarraySumCircular(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "coin-change",
      "title": "Coin Change",
      "difficulty": "Medium",
      "pattern": "1D DP"
    }
  },
  "add-binary": {
    "title": "Add Binary",
    "pattern": "Bit by Bit",
    "patternEmoji": "\u2795",
    "timeComplexity": "O(max(m,n))",
    "spaceComplexity": "O(max(m,n))",
    "oneliner": "Add digits from right, track carry.",
    "intuition": [
      "\ud83c\udfaf Add two binary strings.",
      "\ud83e\udde0 Process from right, handle carry.",
      "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
    ],
    "testCases": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\""
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\""
      }
    ],
    "code": "class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Add two binary strings.\n        - \ud83e\udde0 Process from right, handle carry.\n        - \ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin().\n        \"\"\"\n        res = []  # Initialize list to store results.\n        carry = 0\n        i, j = len(a) - 1, len(b) - 1\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            res.append(str(total % 2))  # Add to end.\n            carry = total // 2\n        return ''.join(res[::-1])  # Reverse the sequence.",
    "keyInsight": "Handle carry same as decimal addition.",
    "visualizationType": "array",
    "initialState": "11",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Initialize i = 1 and j = 1",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Add a[i] (1) to carry (0), total = 1",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Add b[j] (1) to total, total = 2",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Append '0' (total % 2) to result, carry = 1",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Decrement i and j, i = 0, j = 0",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Add a[i] (1) to carry (1), total = 2",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Add b[j] (1) to total, total = 3",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Append '1' (total % 2) to result, carry = 1",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Decrement i and j, i = -1, j = -1",
        "arrayState": [
          "1",
          "1"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "transientMessage": "Append '1' (carry) to result, final result = '100'",
        "arrayState": [
          "1",
          "1"
        ]
      }
    ],
    "description": "Add digits from right, track carry.\n\nAdd two binary strings.\nProcess from right, handle carry.",
    "examples": [
      {
        "input": "a = \"11\"; b = \"1\"",
        "output": "\"100\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Add two binary strings.",
      "Process from right, handle carry.",
      "Or use int(a, 2) + int(b, 2), then bin()."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "keuWJ47xG8g",
    "problemStatement": "Given two binary strings a and b, return their sum as a binary string.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Bit by Bit: Add digits from right, track carry.",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def addBinary(self, a, b):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def addBinary(a, b):\n    res = \"\"\n    i, j, carry = len(a) - 1, len(b) - 1, 0\n    while i >= 0 or j >= 0:\n        sum = carry\n        if i >= 0: sum += int(a[i]); i -= 1\n        if j >= 0: sum += int(b[j]); j -= 1\n        carry = 1 if sum > 1 else 0\n        res += str(sum % 2)\n    if carry: res += str(carry)\n    return res[::-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(max(m,n))",
        "spaceComplexity": "O(max(m,n))",
        "intuition": [
          "\ud83c\udfaf Add two binary strings.",
          "\ud83e\udde0 Process from right, handle carry.",
          "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
        ],
        "code": "def addBinary(a, b):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add two binary strings.\n    - \ud83e\udde0 Process from right, handle carry.\n    - \ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin().\n    \"\"\"\n    res = []  # Initialize list to store results.\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))  # Add to end.\n        carry = total // 2\n    return ''.join(res[::-1])  # Reverse the sequence."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    addBinary(a, b) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} a, b\n     * @return {any}\n     */\n    addBinary(a, b) {\n        return (BigInt('0b' + a) + BigInt('0b' + b)).toString(2);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String addBinary(String a, String b) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String addBinary(String a, String b) {\n        var sb = new StringBuilder();\n        int i = a.length() - 1, j = b.length() - 1;\n        for (int carry = 0; i >= 0 || j >= 0 || carry > 0; --i, --j) {\n            carry += (i >= 0 ? a.charAt(i) - '0' : 0) + (j >= 0 ? b.charAt(j) - '0' : 0);\n            sb.append(carry % 2);\n            carry /= 2;\n        }\n        return sb.reverse().toString();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string addBinary(string a, string b) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans;\n        int i = a.size() - 1, j = b.size() - 1;\n        for (int carry = 0; i >= 0 || j >= 0 || carry; --i, --j) {\n            carry += (i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0);\n            ans.push_back((carry % 2) + '0');\n            carry /= 2;\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) addBinary(a string, b string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) addBinary(a string, b string) string {\n\ti, j := len(a)-1, len(b)-1\n\tans := []byte{}\n\tfor carry := 0; i >= 0 || j >= 0 || carry > 0; i, j = i-1, j-1 {\n\t\tif i >= 0 {\n\t\t\tcarry += int(a[i] - '0')\n\t\t}\n\t\tif j >= 0 {\n\t\t\tcarry += int(b[j] - '0')\n\t\t}\n\t\tans = append(ans, byte(carry%2+'0'))\n\t\tcarry /= 2\n\t}\n\tfor i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {\n\t\tans[i], ans[j] = ans[j], ans[i]\n\t}\n\treturn string(ans)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn add_binary(a: String, b: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn add_binary(a: String, b: String) -> String {\n        let mut i = (a.len() as i32) - 1;\n        let mut j = (b.len() as i32) - 1;\n        let mut carry = 0;\n        let mut ans = String::new();\n        let a = a.as_bytes();\n        let b = b.as_bytes();\n        while i >= 0 || j >= 0 || carry > 0 {\n            if i >= 0 {\n                carry += a[i as usize] - b'0';\n                i -= 1;\n            }\n            if j >= 0 {\n                carry += b[j as usize] - b'0';\n                j -= 1;\n            }\n            ans.push_str(&(carry % 2).to_string());\n            carry /= 2;\n        }\n        ans.chars().rev().collect()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def addBinary(self, a, b):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    addBinary(a: string, b: string): string  {\n    return (BigInt('0b' + a) + BigInt('0b' + b)).toString(2);\n}\n}",
        "initialCode": "class Solution {\n    addBinary(a: string, b: string): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "binary-search",
      "title": "Binary Search",
      "difficulty": "Easy",
      "pattern": "Divide & Conquer"
    }
  },
  "reverse-bits": {
    "title": "Reverse Bits",
    "pattern": "Bit Manipulation",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(32)",
    "spaceComplexity": "O(1)",
    "oneliner": "Shift result left, add LSB of n, shift n right. Repeat 32 times.",
    "intuition": [
      "\ud83c\udfaf Reverse all 32 bits of an integer.",
      "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
      "\ud83d\udca1 Repeat 32 times."
    ],
    "testCases": [
      {
        "input": "n = 43261596",
        "output": "964176192"
      },
      {
        "input": "n = 2147483644",
        "output": "1073741822"
      }
    ],
    "code": "class Solution:\n    def reverseBits(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Reverse all 32 bits of an integer.\n        - \ud83e\udde0 Extract LSB of n, add to result, shift both.\n        - \ud83d\udca1 Repeat 32 times.\n        \"\"\"\n        res = 0  # Initialize result variable.\n        for _ in range(32):  # Iterate through the range.\n            res = (res << 1) | (n & 1)  # Check if last bit is set (odd).\n            n >>= 1  # Right shift to process next bit.\n        return res  # Return the final result.",
    "keyInsight": "Build result by shifting left and OR-ing LSB.",
    "visualizationType": "array",
    "initialState": "43261596",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "n"
          }
        ],
        "transientMessage": "Initial value of n: 43261596",
        "arrayState": [
          "4",
          "3",
          "2",
          "6",
          "1",
          "5",
          "9",
          "6"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "res"
          },
          {
            "index": 1,
            "label": "n"
          }
        ],
        "transientMessage": "Shifting res left and adding least significant bit of n",
        "arrayState": [
          "4",
          "3",
          "2",
          "6",
          "1",
          "5",
          "9",
          "6"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "n"
          }
        ],
        "transientMessage": "Right shifting n to process next bit",
        "arrayState": [
          "4",
          "3",
          "2",
          "6",
          "1",
          "5",
          "9",
          "6"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "res"
          },
          {
            "index": 1,
            "label": "n"
          }
        ],
        "transientMessage": "Repeating the process for all 32 bits",
        "arrayState": [
          "4",
          "3",
          "2",
          "6",
          "1",
          "5",
          "9",
          "6"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "res"
          }
        ],
        "transientMessage": "Final reversed bits value: 964176192",
        "arrayState": [
          "4",
          "3",
          "2",
          "6",
          "1",
          "5",
          "9",
          "6"
        ]
      }
    ],
    "description": "Shift result left, add LSB of n, shift n right. Repeat 32 times.\n\nReverse all 32 bits of an integer.\nExtract LSB of n, add to result, shift both.",
    "examples": [
      {
        "input": "n = 43261596",
        "output": "964176192"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Reverse all 32 bits of an integer.",
      "Extract LSB of n, add to result, shift both.",
      "Repeat 32 times."
    ],
    "relatedProblems": [
      "single-number",
      "counting-bits"
    ],
    "videoId": "UcoN6UjAI64",
    "problemStatement": "Reverse bits of a given 32 bits unsigned integer.\nNote:",
    "difficulty": "Easy",
    "walkthrough": [
      "Identify bits pattern in problem",
      "Use bitwise operators (AND, OR, XOR, shift)",
      "Iterate through bits if needed",
      "Combine results using bit operations",
      "Return final bit result"
    ],
    "approach": "Bit Manipulation: Shift result left, add LSB of n, shift n right. Repeat 32 times.",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def reverseBits(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def reverseBits(n):\n    res = 0\n    for i in range(32):\n        bit = (n >> i) & 1\n        res = res | (bit << (31 - i))\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(32)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Reverse all 32 bits of an integer.",
          "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
          "\ud83d\udca1 Repeat 32 times."
        ],
        "code": "def reverseBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Reverse all 32 bits of an integer.\n    - \ud83e\udde0 Extract LSB of n, add to result, shift both.\n    - \ud83d\udca1 Repeat 32 times.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for _ in range(32):  # Iterate through the range.\n        res = (res << 1) | (n & 1)  # Check if last bit is set (odd).\n        n >>= 1  # Right shift to process next bit.\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    reverseBits(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nclass Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    reverseBits(n) {\n        let ans = 0;\n        for (let i = 0; i < 32 && n; ++i) {\n            ans |= (n & 1) << (31 - i);\n            n >>= 1;\n    }\n    return ans >>> 0;\n    }\n}"
      },
      "java": {
        "initialCode": "public class Solution {\n    public int reverseBits(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "public class Solution {\n    // you need treat n as an unsigned value\n    public int reverseBits(int n) {\n        int ans = 0;\n        for (int i = 0; i < 32 && n != 0; ++i) {\n            ans |= (n & 1) << (31 - i);\n            n >>>= 1;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    uint32_t reverseBits(uint32_t n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ans = 0;\n        for (int i = 0; i < 32 && n; ++i) {\n            ans |= (n & 1) << (31 - i);\n            n >>= 1;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverseBits(n uint32) (ans uint32) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) reverseBits(n uint32) (ans uint32) {\n\tfor i := 0; i < 32; i++ {\n\t\tans |= (n & 1) << (31 - i)\n\t\tn >>= 1\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reverse_bits(mut n: u32) -> u32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn reverse_bits(mut n: u32) -> u32 {\n        let mut ans = 0;\n        for i in 0..32 {\n            ans |= (n & 1) << (31 - i);\n            n >>= 1;\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def reverseBits(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    reverseBits(n: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    reverseBits(n: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "number-of-1-bits",
      "title": "Number of 1 Bits",
      "difficulty": "Easy",
      "pattern": "Bit Manipulation"
    }
  },
  "number-of-1-bits": {
    "title": "Number of 1 Bits",
    "pattern": "Bit Manipulation",
    "patternEmoji": "1\ufe0f\u20e3",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "oneliner": "n & (n-1) clears rightmost 1 bit. Count iterations.",
    "intuition": [
      "\ud83c\udfaf Count set bits (Hamming weight).",
      "\ud83e\udde0 n & (n-1) removes rightmost 1.",
      "\ud83d\udca1 Count until n is 0."
    ],
    "testCases": [
      {
        "input": "n = 11",
        "output": "3"
      },
      {
        "input": "n = 128",
        "output": "1"
      },
      {
        "input": "n = 2147483645",
        "output": "30"
      }
    ],
    "code": "class Solution:\n    def hammingWeight(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count set bits (Hamming weight).\n        - \ud83e\udde0 n & (n-1) removes rightmost 1.\n        - \ud83d\udca1 Count until n is 0.\n        \"\"\"\n        count = 0\n        while n:\n            n &= n - 1  # Remove lowest set bit (Brian Kernighan's Algorithm).\n            count += 1\n        return count",
    "keyInsight": "n & (n-1) trick clears the lowest set bit.",
    "visualizationType": "array",
    "initialState": [
      "1",
      "0",
      "1",
      "1"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "n = 11 = 1011",
        "transientMessage": "Count 1 bits",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Position 0: 1",
        "transientMessage": "Count = 1",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [
          {
            "label": "1",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "Position 1: 0",
        "transientMessage": "Skip",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [
          {
            "label": "0",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Position 2: 1",
        "transientMessage": "Count = 2",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [
          {
            "label": "1",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Position 3: 1",
        "transientMessage": "Count = 3",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [
          {
            "label": "1",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Result: 3 ones",
        "transientMessage": "Complete!",
        "arrayState": [
          "1",
          "0",
          "1",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "n & (n-1) clears rightmost 1 bit. Count iterations.\n\nCount set bits (Hamming weight).\nn & (n-1) removes rightmost 1.",
    "examples": [
      {
        "input": "n = 11",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count set bits (Hamming weight).",
      "n & (n-1) removes rightmost 1.",
      "Count until n is 0."
    ],
    "relatedProblems": [
      "single-number",
      "counting-bits",
      "reverse-bits"
    ],
    "videoId": "5Km3utixwZs",
    "problemStatement": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).",
    "difficulty": "Easy",
    "walkthrough": [
      "Identify bits pattern in problem",
      "Use bitwise operators (AND, OR, XOR, shift)",
      "Iterate through bits if needed",
      "Combine results using bit operations",
      "Return final bit result"
    ],
    "approach": "Bit Manipulation: n & (n-1) clears rightmost 1 bit. Count iterations.",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def hammingWeight(self, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def hammingWeight(n):\n    res = 0\n    while n:\n        n &= (n - 1)\n        res += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Count set bits (Hamming weight).",
          "\ud83e\udde0 n & (n-1) removes rightmost 1.",
          "\ud83d\udca1 Count until n is 0."
        ],
        "code": "def hammingWeight(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count set bits (Hamming weight).\n    - \ud83e\udde0 n & (n-1) removes rightmost 1.\n    - \ud83d\udca1 Count until n is 0.\n    \"\"\"\n    count = 0\n    while n:\n        n &= n - 1  # Remove lowest set bit (Brian Kernighan's Algorithm).\n        count += 1\n    return count"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    hammingWeight(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n - a positive integer\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    hammingWeight(n) {\n        let ans = 0;\n        while (n) {\n            n &= n - 1;\n            ++ans;\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "public class Solution {\n    public int hammingWeight(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "public class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int ans = 0;\n        while (n != 0) {\n            n &= n - 1;\n            ++ans;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int hammingWeight(uint32_t n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int ans = 0;\n        while (n) {\n            n &= n - 1;\n            ++ans;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) hammingWeight(num uint32) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) hammingWeight(num uint32) int {\n\tans := 0\n\tfor num != 0 {\n\t\tnum &= num - 1\n\t\tans++\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn hammingWeight(n: u32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn hammingWeight(n: u32) -> i32 {\n        n.count_ones() as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def hammingWeight(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count set bits (Hamming weight).\n        - \ud83e\udde0 n & (n-1) removes rightmost 1.\n        - \ud83d\udca1 Count until n is 0.\n        \"\"\"\n        count = 0\n        while n:\n            n &= n - 1  # Remove lowest set bit (Brian Kernighan's Algorithm).\n            count += 1\n        return count"
      },
      "typescript": {
        "code": "class Solution {\n    hammingWeight(n: number): number  {\n    let ans: number = 0;\n    while (n !== 0) {\n        ans++;\n        n &= n - 1;\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    hammingWeight(n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "reverse-bits",
      "title": "Reverse Bits",
      "difficulty": "Easy",
      "pattern": "Bit Manipulation"
    }
  },
  "single-number": {
    "title": "Single Number",
    "pattern": "XOR",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "XOR all elements. Pairs cancel out, leaving single.",
    "intuition": [
      "\ud83c\udfaf Find element that appears once (others twice).",
      "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
      "\ud83d\udca1 XOR all elements to get the unique one."
    ],
    "testCases": [
      {
        "input": "nums = [2,2,1]",
        "output": "1"
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find element that appears once (others twice).\n        - \ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.\n        - \ud83d\udca1 XOR all elements to get the unique one.\n        \"\"\"\n        res = 0  # Initialize result variable.\n        for n in nums:  # Iterate over elements.\n            res ^= n\n        return res  # Return the final result.",
    "keyInsight": "XOR is self-inverse: a ^ a = 0.",
    "visualizationType": "array",
    "initialState": [
      4,
      1,
      2,
      1,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [4, 1, 2, 1, 2]",
        "transientMessage": "XOR all elements",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "XOR 4: result = 4",
        "transientMessage": "a^a=0, a^0=a",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "XOR 1: result = 5",
        "transientMessage": "a^a=0, a^0=a",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "XOR 2: result = 7",
        "transientMessage": "a^a=0, a^0=a",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "XOR 1: result = 6",
        "transientMessage": "a^a=0, a^0=a",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "XOR 2: result = 4",
        "transientMessage": "a^a=0, a^0=a",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Single number: 4",
        "transientMessage": "Complete!",
        "arrayState": [
          4,
          1,
          2,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1",
        "explanation": "1 appears once."
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4",
        "explanation": "4 appears once."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-3 * 10^4 <= nums[i] <= 3 * 10^4",
      "Each element appears twice except for one element which appears once."
    ],
    "hints": [
      "Use XOR operation.",
      "XOR of a number with itself is 0.",
      "XOR of a number with 0 is the number itself."
    ],
    "relatedProblems": [
      "single-number-ii",
      "single-number-iii",
      "missing-number"
    ],
    "videoId": "qMPX1AOa83k",
    "problemStatement": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "XOR: XOR all elements. Pairs cancel out, leaving single.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def singleNumber(self, nums):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def singleNumber(nums):\n    res = 0\n    for n in nums:\n        res = n ^ res\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find element that appears once (others twice).",
          "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
          "\ud83d\udca1 XOR all elements to get the unique one."
        ],
        "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element that appears once (others twice).\n    - \ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.\n    - \ud83d\udca1 XOR all elements to get the unique one.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for n in nums:  # Iterate over elements.\n        res ^= n\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    singleNumber(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    singleNumber(nums) {\n        return nums.reduce((a, b) => a ^ b);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int singleNumber(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ans = 0;\n        for (int v : nums) {\n            ans ^= v;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int singleNumber(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for (int v : nums) {\n            ans ^= v;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) singleNumber(nums []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) singleNumber(nums []int) (ans int) {\n\tfor _, v := range nums {\n\t\tans ^= v\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        nums.into_iter().reduce(|r, v| r ^ v).unwrap()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find element that appears once (others twice).\n        - \ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.\n        - \ud83d\udca1 XOR all elements to get the unique one.\n        \"\"\"\n        res = 0  # Initialize result variable.\n        for n in nums:  # Iterate over elements.\n            res ^= n\n        return res  # Return the final result."
      },
      "typescript": {
        "code": "class Solution {\n    singleNumber(nums: number[]): number  {\n    return nums.reduce((r, v) => r ^ v);\n}\n}",
        "initialCode": "class Solution {\n    singleNumber(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "climbing-stairs",
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "pattern": "DP (Fibonacci)"
    }
  },
  "single-number-ii": {
    "title": "Single Number II",
    "pattern": "Bit Counting",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Count bits mod 3 for each position.",
    "intuition": [
      "\ud83c\udfaf Find element appearing once (others 3 times).",
      "\ud83e\udde0 For each bit position, count 1s mod 3.",
      "\ud83d\udca1 Remaining bits form the unique number."
    ],
    "testCases": [
      {
        "input": "nums = [2,2,3,2]",
        "output": "3"
      },
      {
        "input": "nums = [0,1,0,1,0,1,99]",
        "output": "99"
      }
    ],
    "code": "class Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find element appearing once (others 3 times).\n        - \ud83e\udde0 For each bit position, count 1s mod 3.\n        - \ud83d\udca1 Remaining bits form the unique number.\n        \"\"\"\n        res = 0  # Initialize result variable.\n        for i in range(32):  # Iterate through the range.\n            bitSum = sum((n >> i) & 1 for n in nums)\n            if bitSum % 3:\n                res |= (1 << i)\n        # Handle negative numbers\n        if res >= 2**31:\n            res -= 2**32\n        return res  # Return the final result.",
    "keyInsight": "Count bits at each position; mod 3 reveals the unique number.",
    "visualizationType": "array",
    "initialState": [
      2,
      2,
      3,
      2
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Starting with bit position i = 0",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Calculating bitSum for i = 0: (2 >> 0) & 1 + (2 >> 0) & 1 + (3 >> 0) & 1 + (2 >> 0) & 1",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "bitSum = 4, since bitSum % 3 != 0, res remains 0",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Moving to bit position i = 1",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Calculating bitSum for i = 1: (2 >> 1) & 1 + (2 >> 1) & 1 + (3 >> 1) & 1 + (2 >> 1) & 1",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "bitSum = 2, since bitSum % 3 != 0, res remains 0",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Moving to bit position i = 2",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "Calculating bitSum for i = 2: (2 >> 2) & 1 + (2 >> 2) & 1 + (3 >> 2) & 1 + (2 >> 2) & 1",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 1,
            "label": "j"
          }
        ],
        "transientMessage": "bitSum = 1, since bitSum % 3 != 0, res becomes 1 (res |= (1 << 2))",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Finished processing all bit positions",
        "arrayState": [
          2,
          2,
          3,
          2
        ]
      }
    ],
    "description": "Count bits mod 3 for each position.\n\nFind element appearing once (others 3 times).\nFor each bit position, count 1s mod 3.",
    "examples": [
      {
        "input": "nums = [2,2,3,2]",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find element appearing once (others 3 times).",
      "For each bit position, count 1s mod 3.",
      "Remaining bits form the unique number."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "cOFAmaMBVps",
    "problemStatement": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Bit Counting: Count bits mod 3 for each position.",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def singleNumber(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find element appearing once (others 3 times).",
          "\ud83e\udde0 For each bit position, count 1s mod 3.",
          "\ud83d\udca1 Remaining bits form the unique number."
        ],
        "code": "def singleNumber(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find element appearing once (others 3 times).\n    - \ud83e\udde0 For each bit position, count 1s mod 3.\n    - \ud83d\udca1 Remaining bits form the unique number.\n    \"\"\"\n    res = 0  # Initialize result variable.\n    for i in range(32):  # Iterate through the range.\n        bitSum = sum((n >> i) & 1 for n in nums)\n        if bitSum % 3:\n            res |= (1 << i)\n    # Handle negative numbers\n    if res >= 2**31:\n        res -= 2**32\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    singleNumber(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    singleNumber(nums) {\n        let ans = 0;\n        for (let i = 0; i < 32; i++) {\n            const count = nums.reduce((r, v) => r + ((v >> i) & 1), 0);\n            ans |= (count % 3) << i;\n        }\n        return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int singleNumber(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ans = 0;\n        for (int i = 0; i < 32; i++) {\n            int cnt = 0;\n            for (int num : nums) {\n                cnt += num >> i & 1;\n            }\n            cnt %= 3;\n            ans |= cnt << i;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int singleNumber(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < 32; ++i) {\n            int cnt = 0;\n            for (int num : nums) {\n                cnt += ((num >> i) & 1);\n            }\n            cnt %= 3;\n            ans |= cnt << i;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) singleNumber(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) singleNumber(nums []int) int {\n\tans := int32(0)\n\tfor i := 0; i < 32; i++ {\n\t\tcnt := int32(0)\n\t\tfor _, num := range nums {\n\t\t\tcnt += int32(num) >> i & 1\n\t\t}\n\t\tcnt %= 3\n\t\tans |= cnt << i\n\t}\n\treturn int(ans)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn single_number(nums: Vec<i32>) -> i32 {\n        let mut ans = 0;\n        for i in 0..32 {\n            let count = nums.iter().map(|v| (v >> i) & 1).sum::<i32>();\n            ans |= count % 3 << i;\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def singleNumber(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    singleNumber(nums: number[]): number  {\n    let ans = 0;\n    for (let i = 0; i < 32; i++) {\n        const count = nums.reduce((r, v) => r + ((v >> i) & 1), 0);\n        ans |= (count % 3) << i;\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    singleNumber(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "longest-consecutive-sequence",
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "pattern": "Hash Set"
    }
  },
  "bitwise-and-of-numbers-range": {
    "title": "Bitwise AND of Numbers Range",
    "pattern": "Common Prefix",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "AND of range = common prefix of left and right.",
    "intuition": [
      "\ud83c\udfaf AND of all numbers from left to right.",
      "\ud83e\udde0 Result is the common prefix bits.",
      "\ud83d\udca1 Shift until left == right, then shift back."
    ],
    "testCases": [
      {
        "input": "left = 5, right = 7",
        "output": "4"
      },
      {
        "input": "left = 0, right = 0",
        "output": "0"
      },
      {
        "input": "left = 1, right = 2147483647",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def rangeBitwiseAnd(self, left, right):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf AND of all numbers from left to right.\n        - \ud83e\udde0 Result is the common prefix bits.\n        - \ud83d\udca1 Shift until left == right, then shift back.\n        \"\"\"\n        shift = 0\n        while left < right:\n            left >>= 1  # Right shift to process next bit.\n            right >>= 1  # Right shift to process next bit.\n            shift += 1\n        return left << shift  # Left shift by count.",
    "keyInsight": "Find common prefix by shifting until equal.",
    "visualizationType": "array",
    "initialState": "5",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Bitwise AND of Numbers Range",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "5"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 5",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "5"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute result phase 6",
        "transientMessage": "Building solution",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "AND of range = common prefix of left and right.\n\nAND of all numbers from left to right.\nResult is the common prefix bits.",
    "examples": [
      {
        "input": "left = 5; right = 7",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "AND of all numbers from left to right.",
      "Result is the common prefix bits.",
      "Shift until left == right, then shift back."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "R3T0olAhUq0",
    "problemStatement": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Common Prefix: AND of range = common prefix of left and right.",
    "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
    "initialCode": "class Solution:\n    def rangeBitwiseAnd(self, left, right):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rangeBitwiseAnd(left, right):\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf AND of all numbers from left to right.",
          "\ud83e\udde0 Result is the common prefix bits.",
          "\ud83d\udca1 Shift until left == right, then shift back."
        ],
        "code": "def rangeBitwiseAnd(left, right):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf AND of all numbers from left to right.\n    - \ud83e\udde0 Result is the common prefix bits.\n    - \ud83d\udca1 Shift until left == right, then shift back.\n    \"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1  # Right shift to process next bit.\n        right >>= 1  # Right shift to process next bit.\n        shift += 1\n    return left << shift  # Left shift by count."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    rangeBitwiseAnd(left, right) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} left\n * @param {number} right\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} left, right\n     * @return {any}\n     */\n    rangeBitwiseAnd(left, right) {\n        while (left < right) {\n            right &= right - 1;\n    }\n    return right;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        while (left < right) {\n            right &= (right - 1);\n        }\n        return right;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int rangeBitwiseAnd(int left, int right) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n        while (left < right) {\n            right &= (right - 1);\n        }\n        return right;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rangeBitwiseAnd(left int, right int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) rangeBitwiseAnd(left int, right int) int {\n\tfor left < right {\n\t\tright &= (right - 1)\n\t}\n\treturn right\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn range_bitwise_and(m: i32, n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [201] Bitwise AND of Numbers Range\n *\n * Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\n *\n * Example 1:\n *\n *\n * Input: [5,7]\n * Output: 4\n *\n *\n * Example 2:\n *\n *\n * Input: [0,1]\n * Output: 0\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/bitwise-and-of-numbers-range/\n// discuss: https://leetcode.com/problems/bitwise-and-of-numbers-range/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n// just find the highest bit 1 of m and n\nimpl Solution {\n    pub fn range_bitwise_and(m: i32, n: i32) -> i32 {\n        let mut m = m;\n        let mut n = n;\n        if m == 0 {\n            return 0;\n        }\n        let mut step = 1;\n        while m != n {\n            // shortcut\n            if m == 0 {\n                return 0;\n            }\n            m >>= 1;\n            n >>= 1;\n            step <<= 1;\n        }\n        return m * step;\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_201() {\n        assert_eq!(Solution::range_bitwise_and(5, 7), 4);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def rangeBitwiseAnd(self, left, right):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf AND of all numbers from left to right.\n        - \ud83e\udde0 Result is the common prefix bits.\n        - \ud83d\udca1 Shift until left == right, then shift back.\n        \"\"\"\n        shift = 0\n        while left < right:\n            left >>= 1  # Right shift to process next bit.\n            right >>= 1  # Right shift to process next bit.\n            shift += 1\n        return left << shift  # Left shift by count."
      },
      "typescript": {
        "code": "class Solution {\n    rangeBitwiseAnd(left: any, right: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    rangeBitwiseAnd(left: any, right: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "number-of-islands",
      "title": "Number of Islands",
      "difficulty": "Medium",
      "pattern": "Matrix DFS / BFS"
    }
  },
  "counting-bits": {
    "title": "Counting Bits",
    "pattern": "DP",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
    "intuition": [
      "\ud83c\udfaf Count 1s in binary for 0 to n.",
      "\ud83e\udde0 i has same bits as i/2, plus LSB.",
      "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
    ],
    "testCases": [
      {
        "input": "n = 2",
        "output": "[0,1,1]"
      },
      {
        "input": "n = 5",
        "output": "[0,1,1,2,1,2]"
      }
    ],
    "code": "class Solution:\n    def countBits(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count 1s in binary for 0 to n.\n        - \ud83e\udde0 i has same bits as i/2, plus LSB.\n        - \ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1).\n        \"\"\"\n        dp = [0] * (n + 1)  # Initialize DP table to store results.\n        for i in range(1, n + 1):  # Iterate through the range.\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp",
    "keyInsight": "dp[i] = dp[i >> 1] + (i & 1) reuses previous computation.",
    "visualizationType": "array",
    "initialState": [
      0
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "n = 5",
        "transientMessage": "Count 1 bits for 0 to n",
        "arrayState": [
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "1 = 1",
        "transientMessage": "Bits: 1 (dp[0] + 1)",
        "arrayState": [
          0,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "2 = 10",
        "transientMessage": "Bits: 1 (dp[1] + 0)",
        "arrayState": [
          0,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "3 = 11",
        "transientMessage": "Bits: 2 (dp[1] + 1)",
        "arrayState": [
          0,
          1,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "4 = 100",
        "transientMessage": "Bits: 1 (dp[2] + 0)",
        "arrayState": [
          0,
          1,
          1,
          2,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "5 = 101",
        "transientMessage": "Bits: 2 (dp[2] + 1)",
        "arrayState": [
          0,
          1,
          1,
          2,
          1,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Result: [0, 1, 1, 2, 1, 2]",
        "transientMessage": "Complete!",
        "arrayState": [
          0,
          1,
          1,
          2,
          1,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.\n\nCount 1s in binary for 0 to n.\ni has same bits as i/2, plus LSB.",
    "examples": [
      {
        "input": "n = 5",
        "output": "[0,1,1,2,1,2]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count 1s in binary for 0 to n.",
      "i has same bits as i/2, plus LSB.",
      "dp[i] = dp[i >> 1] + (i & 1)."
    ],
    "relatedProblems": [
      "climbing-stairs",
      "coin-change",
      "longest-increasing-subsequence"
    ],
    "videoId": "RyBM56RIWrM",
    "problemStatement": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DP: dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
    "suggestedNextQuestion": {
      "slug": "decode-ways",
      "title": "Decode Ways",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def countBits(self, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def countBits(n):\n    res = [0] * (n + 1)\n    for i in range(1, n + 1):\n        # i >> 1 is i // 2\n        # i & 1 is i % 2\n        res[i] = res[i >> 1] + (i & 1)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Count 1s in binary for 0 to n.",
          "\ud83e\udde0 i has same bits as i/2, plus LSB.",
          "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
        ],
        "code": "def countBits(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count 1s in binary for 0 to n.\n    - \ud83e\udde0 i has same bits as i/2, plus LSB.\n    - \ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1).\n    \"\"\"\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    for i in range(1, n + 1):  # Iterate through the range.\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    countBits(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    countBits(n) {\n        const result = new Array(n + 1).fill(0);\n        for (let i = 0; i <= n; i++) {\n          result[i] = result[i >> 1] + (i & 1);\n      }\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] countBits(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            ans[i] = Integer.bitCount(i);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> countBits(int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> ans(n + 1);\n        for (int i = 0; i <= n; ++i) {\n            ans[i] = __builtin_popcount(i);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) countBits(n int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) countBits(n int) []int {\n\tans := make([]int, n+1)\n\tfor i := 0; i <= n; i++ {\n\t\tans[i] = bits.OnesCount(uint(i))\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn count_bits(n: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn count_bits(num: i32) -> Vec<i32> {\n        let n = num as usize;\n        let mut res = vec![];\n        for i in 0..=n {\n            res.push(i.count_ones() as i32);\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let num = 2;\n    let res = vec![0, 1, 1];\n    assert_eq!(Solution::count_bits(num), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def countBits(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count 1s in binary for 0 to n.\n        - \ud83e\udde0 i has same bits as i/2, plus LSB.\n        - \ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1).\n        \"\"\"\n        dp = [0] * (n + 1)  # Initialize DP table to store results.\n        for i in range(1, n + 1):  # Iterate through the range.\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp"
      },
      "typescript": {
        "code": "class Solution {\n    countBits(n: number): number[]  {\n    const ans: number[] = Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        ans[i] = bitCount(i);\n    }\n    return ans;\n}\n\nfunction bitCount(n: number): number {\n    let count = 0;\n    while (n) {\n        n &= n - 1;\n        ++count;\n    }\n    return count;\n}\n}",
        "initialCode": "class Solution {\n    countBits(n: number): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "palindrome-number": {
    "title": "Palindrome Number",
    "pattern": "Number Reversal",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Reverse half the number and compare.",
    "intuition": [
      "\ud83c\udfaf Check if number is palindrome without string.",
      "\ud83e\udde0 Reverse last half of digits.",
      "\ud83d\udca1 Compare with first half."
    ],
    "testCases": [
      {
        "input": "x = 121",
        "output": "true"
      },
      {
        "input": "x = -121",
        "output": "false"
      },
      {
        "input": "x = 10",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Check if number is palindrome without string.\n        - \ud83e\udde0 Reverse last half of digits.\n        - \ud83d\udca1 Compare with first half.\n        \"\"\"\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False  # Condition not met.\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return x == rev or x == rev // 10",
    "keyInsight": "Only reverse half to avoid overflow.",
    "visualizationType": "array",
    "initialState": [
      "1",
      "2",
      "1"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "x = 121",
        "transientMessage": "Reverse and compare",
        "arrayState": [
          "1",
          "2",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Digit: 1, reversed: 1",
        "transientMessage": "temp: 12",
        "arrayState": [
          "1",
          "2",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Digit: 2, reversed: 12",
        "transientMessage": "temp: 1",
        "arrayState": [
          "1",
          "2",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Digit: 1, reversed: 121",
        "transientMessage": "temp: 0",
        "arrayState": [
          "1",
          "2",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "121 == 121? true",
        "transientMessage": "Palindrome!",
        "arrayState": [
          "1",
          "2",
          "1"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Reverse half the number and compare.\n\nCheck if number is palindrome without string.\nReverse last half of digits.",
    "examples": [
      {
        "input": "x = 121",
        "output": "true"
      },
      {
        "input": "x = -121",
        "output": "false"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Check if number is palindrome without string.",
      "Reverse last half of digits.",
      "Compare with first half."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "yubRKwixN-U",
    "problemStatement": "Given an integer x, return true if x is a palindrome, and false otherwise.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Number Reversal: Reverse half the number and compare.",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def isPalindrome(self, x):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isPalindrome(x):\n    if x < 0: return False\n    return str(x) == str(x)[::-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Check if number is palindrome without string.",
          "\ud83e\udde0 Reverse last half of digits.",
          "\ud83d\udca1 Compare with first half."
        ],
        "code": "def isPalindrome(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Check if number is palindrome without string.\n    - \ud83e\udde0 Reverse last half of digits.\n    - \ud83d\udca1 Compare with first half.\n    \"\"\"\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False  # Condition not met.\n    rev = 0\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    return x == rev or x == rev // 10"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isPalindrome(x) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} x\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} x\n     * @return {any}\n     */\n    isPalindrome(x) {\n        if (x < 0 || (x > 0 && x % 10 === 0)) {\n            return false;\n        }\n        let y = 0;\n        for (; y < x; x = ~~(x / 10)) {\n            y = y * 10 + (x % 10);\n    }\n    return x === y || x === ~~(y / 10);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isPalindrome(int x) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x > 0 && x % 10 == 0)) {\n            return false;\n        }\n        int y = 0;\n        for (; y < x; x /= 10) {\n            y = y * 10 + x % 10;\n        }\n        return x == y || x == y / 10;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isPalindrome(int x) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x && x % 10 == 0)) {\n            return false;\n        }\n        int y = 0;\n        for (; y < x; x /= 10) {\n            y = y * 10 + x % 10;\n        }\n        return x == y || x == y / 10;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isPalindrome(x int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isPalindrome(x int) bool {\n\tif x < 0 || (x > 0 && x%10 == 0) {\n\t\treturn false\n\t}\n\ty := 0\n\tfor ; y < x; x /= 10 {\n\t\ty = y*10 + x%10\n\t}\n\treturn x == y || x == y/10\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_palindrome(mut x: i32) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_palindrome(mut x: i32) -> bool {\n        if x < 0 || (x != 0 && x % 10 == 0) {\n            return false;\n        }\n        let mut y = 0;\n        while x > y {\n            y = y * 10 + x % 10;\n            x /= 10;\n        }\n        x == y || x == y / 10\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Check if number is palindrome without string.\n        - \ud83e\udde0 Reverse last half of digits.\n        - \ud83d\udca1 Compare with first half.\n        \"\"\"\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False  # Condition not met.\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        return x == rev or x == rev // 10"
      },
      "typescript": {
        "code": "class Solution {\n    isPalindrome(x: number): boolean  {\n    if (x < 0 || (x > 0 && x % 10 === 0)) {\n        return false;\n    }\n    let y = 0;\n    for (; y < x; x = ~~(x / 10)) {\n        y = y * 10 + (x % 10);\n    }\n    return x === y || x === ~~(y / 10);\n}\n}",
        "initialCode": "class Solution {\n    isPalindrome(x: number): boolean {\n        // Your code here\n        return false;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "merge-sorted-array",
      "title": "Merge Sorted Array",
      "difficulty": "Easy",
      "pattern": "Three Pointers (Reverse)"
    }
  },
  "plus-one": {
    "title": "Plus One",
    "pattern": "Simulation",
    "patternEmoji": "\u2795",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Add 1 to last digit, propagate carry.",
    "intuition": [
      "\ud83c\udfaf Add 1 to a number represented as array.",
      "\ud83e\udde0 Handle carry from rightmost digit.",
      "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
    ],
    "testCases": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]"
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]"
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]"
      }
    ],
    "code": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Add 1 to a number represented as array.\n        - \ud83e\udde0 Handle carry from rightmost digit.\n        - \ud83d\udca1 [9,9,9] -> [1,0,0,0].\n        \"\"\"\n        for i in range(len(digits) - 1, -1, -1):  # Iterate through the range.\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits",
    "keyInsight": "If no early return, all 9s -> prepend 1.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Plus One",
        "transientMessage": "Input: [1, 2, 3]",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 3",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Add 1 to last digit, propagate carry.\n\nAdd 1 to a number represented as array.\nHandle carry from rightmost digit.",
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]"
      },
      {
        "input": "digits = [9,9,9]",
        "output": "[1,0,0,0]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Add 1 to a number represented as array.",
      "Handle carry from rightmost digit.",
      "[9,9,9] -> [1,0,0,0]."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "jIaA8boiG1s",
    "problemStatement": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Simulation: Add 1 to last digit, propagate carry.",
    "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
    "initialCode": "class Solution:\n    def plusOne(self, digits):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def plusOne(digits):\n    for i in range(len(digits)-1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Add 1 to a number represented as array.",
          "\ud83e\udde0 Handle carry from rightmost digit.",
          "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
        ],
        "code": "def plusOne(digits):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Add 1 to a number represented as array.\n    - \ud83e\udde0 Handle carry from rightmost digit.\n    - \ud83d\udca1 [9,9,9] -> [1,0,0,0].\n    \"\"\"\n    for i in range(len(digits) - 1, -1, -1):  # Iterate through the range.\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    plusOne(digits) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} digits\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} digits\n     * @return {any}\n     */\n    plusOne(digits) {\n        for (let i = digits.length - 1; i >= 0; --i) {\n            ++digits[i];\n            digits[i] %= 10;\n            if (digits[i] != 0) {\n                return digits;\n            }\n    }\n    return [1, ...digits];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] plusOne(int[] digits) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n        for (int i = n - 1; i >= 0; --i) {\n            ++digits[i];\n            digits[i] %= 10;\n            if (digits[i] != 0) {\n                return digits;\n            }\n        }\n        digits = new int[n + 1];\n        digits[0] = 1;\n        return digits;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> plusOne(vector<int>& digits) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for (int i = digits.size() - 1; i >= 0; --i) {\n            ++digits[i];\n            digits[i] %= 10;\n            if (digits[i] != 0) return digits;\n        }\n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) plusOne(digits []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) plusOne(digits []int) []int {\n\tn := len(digits)\n\tfor i := n - 1; i >= 0; i-- {\n\t\tdigits[i]++\n\t\tdigits[i] %= 10\n\t\tif digits[i] != 0 {\n\t\t\treturn digits\n\t\t}\n\t}\n\treturn append([]int{1}, digits...)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {\n        let n = digits.len();\n        for i in (0..n).rev() {\n            digits[i] += 1;\n            if 10 > digits[i] {\n                return digits;\n            }\n            digits[i] %= 10;\n        }\n        digits.insert(0, 1);\n        digits\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Add 1 to a number represented as array.\n        - \ud83e\udde0 Handle carry from rightmost digit.\n        - \ud83d\udca1 [9,9,9] -> [1,0,0,0].\n        \"\"\"\n        for i in range(len(digits) - 1, -1, -1):  # Iterate through the range.\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits"
      },
      "typescript": {
        "code": "class Solution {\n    plusOne(digits: number[]): number[]  {\n    const n = digits.length;\n    for (let i = n - 1; i >= 0; i--) {\n        if (10 > ++digits[i]) {\n            return digits;\n        }\n        digits[i] %= 10;\n    }\n    return [1, ...digits];\n}\n}",
        "initialCode": "class Solution {\n    plusOne(digits: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "zigzag-conversion",
      "title": "Zigzag Conversion",
      "difficulty": "Medium",
      "pattern": "Simulation"
    }
  },
  "factorial-trailing-zeroes": {
    "title": "Factorial Trailing Zeroes",
    "pattern": "Math",
    "patternEmoji": "0\ufe0f\u20e3",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Count factors of 5 in n!",
    "intuition": [
      "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
      "\ud83e\udde0 More 2s than 5s, so count 5s.",
      "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
    ],
    "testCases": [
      {
        "input": "n = 3",
        "output": "0"
      },
      {
        "input": "n = 5",
        "output": "1"
      },
      {
        "input": "n = 0",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def trailingZeroes(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Trailing zeros = count of (2*5) pairs.\n        - \ud83e\udde0 More 2s than 5s, so count 5s.\n        - \ud83d\udca1 n/5 + n/25 + n/125 + ...\n        \"\"\"\n        count = 0\n        while n >= 5:\n            n //= 5  # Count factors of 5.\n            count += n\n        return count",
    "keyInsight": "Each factor of 5 contributes to a trailing zero.",
    "visualizationType": "array",
    "initialState": "25",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Factorial Trailing Zeroes",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 5",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "2",
          "5"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Count factors of 5 in n!\n\nTrailing zeros = count of (2*5) pairs.\nMore 2s than 5s, so count 5s.",
    "examples": [
      {
        "input": "n = 5",
        "output": "1"
      },
      {
        "input": "n = 25",
        "output": "6"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Trailing zeros = count of (2*5) pairs.",
      "More 2s than 5s, so count 5s.",
      "n/5 + n/25 + n/125 + ..."
    ],
    "relatedProblems": [
      "palindrome-number",
      "fizz-buzz",
      "roman-to-integer"
    ],
    "videoId": "_NxbBkunCEM",
    "problemStatement": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
    "difficulty": "Medium",
    "walkthrough": [
      "Identify mathematical pattern or formula",
      "Handle edge cases (zero, negative, overflow)",
      "Apply mathematical operations",
      "Optimize with mathematical properties",
      "Return computed result"
    ],
    "approach": "Math: Count factors of 5 in n!",
    "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
    "initialCode": "class Solution:\n    def trailingZeroes(self, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def trailingZeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
          "\ud83e\udde0 More 2s than 5s, so count 5s.",
          "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
        ],
        "code": "def trailingZeroes(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Trailing zeros = count of (2*5) pairs.\n    - \ud83e\udde0 More 2s than 5s, so count 5s.\n    - \ud83d\udca1 n/5 + n/25 + n/125 + ...\n    \"\"\"\n    count = 0\n    while n >= 5:\n        n //= 5  # Count factors of 5.\n        count += n\n    return count"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    trailingZeroes(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    trailingZeroes(n) {\n        return n < 5 ? 0 : Math.floor(n / 5) + trailingZeroes(n / 5);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int trailingZeroes(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int trailingZeroes(int n) {\n        int ans = 0;\n        while (n > 0) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int trailingZeroes(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int trailingZeroes(int n) {\n        int ans = 0;\n        while (n) {\n            n /= 5;\n            ans += n;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) trailingZeroes(n int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) trailingZeroes(n int) int {\n\tans := 0\n\tfor n > 0 {\n\t\tn /= 5\n\t\tans += n\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn trailing_zeroes(n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [172] Factorial Trailing Zeroes\n *\n * Given an integer n, return the number of trailing zeroes in n!.\n *\n * Example 1:\n *\n *\n * Input: 3\n * Output: 0\n * Explanation: 3! = 6, no trailing zero.\n *\n * Example 2:\n *\n *\n * Input: 5\n * Output: 1\n * Explanation: 5! = 120, one trailing zero.\n *\n * Note: Your solution should be in logarithmic time complexity.\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/factorial-trailing-zeroes/\n// discuss: https://leetcode.com/problems/factorial-trailing-zeroes/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn trailing_zeroes(n: i32) -> i32 {\n        let mut five_count = 0;\n        let mut n = n;\n        while n > 0 {\n            n = n / 5;\n            five_count += n;\n        }\n        five_count\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_172() {\n        assert_eq!(Solution::trailing_zeroes(3), 0);\n        assert_eq!(Solution::trailing_zeroes(5), 1);\n        assert_eq!(Solution::trailing_zeroes(20), 4);\n        assert_eq!(Solution::trailing_zeroes(1808548329), 452137076);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def trailingZeroes(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Trailing zeros = count of (2*5) pairs.\n        - \ud83e\udde0 More 2s than 5s, so count 5s.\n        - \ud83d\udca1 n/5 + n/25 + n/125 + ...\n        \"\"\"\n        count = 0\n        while n >= 5:\n            n //= 5  # Count factors of 5.\n            count += n\n        return count"
      },
      "typescript": {
        "code": "class Solution {\n    trailingZeroes(n: number): number  {\n    let ans = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        ans += n;\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    trailingZeroes(n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "reverse-integer",
      "title": "Reverse Integer",
      "difficulty": "Medium",
      "pattern": "Math"
    }
  },
  "sqrtx": {
    "title": "Sqrt(x)",
    "pattern": "Binary Search",
    "patternEmoji": "\u221a",
    "timeComplexity": "O(log x)",
    "spaceComplexity": "O(1)",
    "oneliner": "Binary search for largest k where k*k <= x.",
    "intuition": [
      "\ud83c\udfaf Find integer square root.",
      "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
      "\ud83d\udca1 Track the largest valid mid."
    ],
    "testCases": [
      {
        "input": "x = 4",
        "output": "2"
      },
      {
        "input": "x = 8",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find integer square root.\n        - \ud83e\udde0 Binary search: if mid*mid <= x, go right.\n        - \ud83d\udca1 Track the largest valid mid.\n        \"\"\"\n        if x < 2:\n            return x\n        left, right = 1, x // 2\n        while left <= right:\n            mid = (left + right) // 2  # Calculate middle index.\n            if mid * mid == x:  # Calculate middle index.\n                return mid\n            elif mid * mid < x:\n                left = mid + 1  # Search right half.\n            else:\n                right = mid - 1  # Search left half.\n        return right",
    "keyInsight": "Binary search from 1 to x/2 is sufficient.",
    "visualizationType": "array",
    "initialState": "8",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "transientMessage": "Checking if x < 2",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          1
        ],
        "newValues": {
          "left": 1,
          "right": 4
        },
        "transientMessage": "Initializing left to 1 and right to x // 2 (8 // 2 = 4)",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          1,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Starting binary search with left = 1 and right = 4",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "mid": 2
        },
        "transientMessage": "Calculating mid = (left + right) // 2 (1 + 4) // 2 = 2",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "transientMessage": "Checking if mid * mid == x (2 * 2 == 8)",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "left": 3
        },
        "transientMessage": "Since mid * mid < x, updating left to mid + 1 (2 + 1 = 3)",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          4,
          6
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 4,
            "label": "left"
          },
          {
            "index": 6,
            "label": "right"
          }
        ],
        "transientMessage": "Continuing binary search with left = 3 and right = 4",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "mid": 3
        },
        "transientMessage": "Calculating mid = (left + right) // 2 (3 + 4) // 2 = 3",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          7
        ],
        "color": "accent",
        "transientMessage": "Checking if mid * mid == x (3 * 3 == 8)",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "left": 4
        },
        "transientMessage": "Since mid * mid < x, updating left to mid + 1 (3 + 1 = 4)",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          8,
          6
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 8,
            "label": "left"
          },
          {
            "index": 6,
            "label": "right"
          }
        ],
        "transientMessage": "Continuing binary search with left = 4 and right = 4",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "mid": 4
        },
        "transientMessage": "Calculating mid = (left + right) // 2 (4 + 4) // 2 = 4",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          9
        ],
        "color": "accent",
        "transientMessage": "Checking if mid * mid == x (4 * 4 == 8)",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "updateValue",
        "indices": [
          3
        ],
        "newValues": {
          "right": 3
        },
        "transientMessage": "Since mid * mid > x, updating right to mid - 1 (4 - 1 = 3)",
        "arrayState": [
          "8"
        ],
        "color": "accent"
      },
      {
        "type": "highlight",
        "indices": [
          8,
          6
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 8,
            "label": "left"
          },
          {
            "index": 6,
            "label": "right"
          }
        ],
        "transientMessage": "Binary search terminates as left > right",
        "arrayState": [
          "8"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          6
        ],
        "color": "success",
        "transientMessage": "Returning right as the integer part of the square root (3)",
        "arrayState": [
          "8"
        ]
      }
    ],
    "description": "Binary search for largest k where k*k <= x.\n\nFind integer square root.\nBinary search: if mid*mid <= x, go right.",
    "examples": [
      {
        "input": "x = 8",
        "output": "2"
      },
      {
        "input": "x = 4",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find integer square root.",
      "Binary search: if mid*mid <= x, go right.",
      "Track the largest valid mid."
    ],
    "relatedProblems": [
      "binary-search",
      "search-in-rotated-sorted-array",
      "find-peak-element"
    ],
    "videoId": "zdMhGxRWutQ",
    "problemStatement": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.",
    "difficulty": "Easy",
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "approach": "Binary Search: Binary search for largest k where k*k <= x.",
    "suggestedNextQuestion": {
      "slug": "find-first-and-last-position-of-element-in-sorted-array",
      "title": "Find First and Last Position of Element in Sorted Array",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def mySqrt(self, x):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def mySqrt_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log x)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find integer square root.",
          "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
          "\ud83d\udca1 Track the largest valid mid."
        ],
        "code": "def mySqrt(x):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find integer square root.\n    - \ud83e\udde0 Binary search: if mid*mid <= x, go right.\n    - \ud83d\udca1 Track the largest valid mid.\n    \"\"\"\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2  # Calculate middle index.\n        if mid * mid == x:  # Calculate middle index.\n            return mid\n        elif mid * mid < x:\n            left = mid + 1  # Search right half.\n        else:\n            right = mid - 1  # Search left half.\n    return right"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    mySqrt(x) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} x\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} x\n     * @return {any}\n     */\n    mySqrt(x) {\n        let [l, r] = [0, x];\n        while (l < r) {\n            const mid = (l + r + 1) >> 1;\n            if (mid > x / mid) {\n                r = mid - 1;\n            } else {\n                l = mid;\n            }\n    }\n    return l;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int mySqrt(int x) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x;\n        while (l < r) {\n            int mid = (l + r + 1) >>> 1;\n            if (mid > x / mid) {\n                r = mid - 1;\n            } else {\n                l = mid;\n            }\n        }\n        return l;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int mySqrt(int x) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int mySqrt(int x) {\n        int l = 0, r = x;\n        while (l < r) {\n            int mid = (l + r + 1ll) >> 1;\n            if (mid > x / mid) {\n                r = mid - 1;\n            } else {\n                l = mid;\n            }\n        }\n        return l;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) mySqrt(x int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) mySqrt(x int) int {\n\treturn sort.Search(x+1, func(i int) bool { return i*i > x }) - 1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn my_sqrt(x: i32) -> i32 {\n        let mut l = 0;\n        let mut r = x;\n\n        while l < r {\n            let mid = (l + r + 1) / 2;\n\n            if mid > x / mid {\n                r = mid - 1;\n            } else {\n                l = mid;\n            }\n        }\n\n        l\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def mySqrt(self, x):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    mySqrt(x: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    mySqrt(x: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "max-points-on-a-line": {
    "title": "Max Points on a Line",
    "pattern": "Hash Map + Slopes",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n)",
    "oneliner": "For each point, count slopes to all others.",
    "intuition": [
      "\ud83c\udfaf Max collinear points.",
      "\ud83e\udde0 For each point, map slopes to counts.",
      "\ud83d\udca1 Use fractions to avoid float precision issues."
    ],
    "testCases": [
      {
        "input": "points = [[1,1],[2,2],[3,3]]",
        "output": "3"
      },
      {
        "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
        "output": "4"
      }
    ],
    "code": "class Solution:\n    from math import gcd\n    from collections import defaultdict\n    \n    def maxPoints(self, points):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Max collinear points.\n        - \ud83e\udde0 For each point, map slopes to counts.\n        - \ud83d\udca1 Use fractions to avoid float precision issues.\n        \"\"\"\n        if len(points) <= 2:\n            return len(points)\n        maxPts = 0\n        for i in range(len(points)):  # Iterate through the range.\n            slopes = defaultdict(int)\n            for j in range(len(points)):  # Iterate through the range.\n                if i == j:\n                    continue\n                dx = points[j][0] - points[i][0]\n                dy = points[j][1] - points[i][1]\n                g = gcd(dx, dy)\n                slope = (dx // g, dy // g)\n                slopes[slope] += 1\n                maxPts = max(maxPts, slopes[slope])  # Take the maximum value.\n        return maxPts + 1",
    "keyInsight": "Normalize slope using GCD to avoid float issues.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        1
      ],
      [
        2,
        2
      ],
      [
        3,
        3
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Max Points on a Line",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1,1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2,2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3,3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            1,
            1
          ],
          [
            2,
            2
          ],
          [
            3,
            3
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "For each point, count slopes to all others.\n\nMax collinear points.\nFor each point, map slopes to counts.",
    "examples": [
      {
        "input": "points = [[1,1],[2,2],[3,3]]",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Max collinear points.",
      "For each point, map slopes to counts.",
      "Use fractions to avoid float precision issues."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Bb9lOXUOnFw",
    "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Hash Map + Slopes: For each point, count slopes to all others.",
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "from math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def maxPoints(self, points: list[list[int]]) -> int:\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def maxPoints_brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Max collinear points.",
          "\ud83e\udde0 For each point, map slopes to counts.",
          "\ud83d\udca1 Use fractions to avoid float precision issues."
        ],
        "code": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max collinear points.\n    - \ud83e\udde0 For each point, map slopes to counts.\n    - \ud83d\udca1 Use fractions to avoid float precision issues.\n    \"\"\"\n    if len(points) <= 2:\n        return len(points)\n    maxPts = 0\n    for i in range(len(points)):  # Iterate through the range.\n        slopes = defaultdict(int)\n        for j in range(len(points)):  # Iterate through the range.\n            if i == j:\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            g = gcd(dx, dy)\n            slope = (dx // g, dy // g)\n            slopes[slope] += 1\n            maxPts = max(maxPts, slopes[slope])  # Take the maximum value.\n    return maxPts + 1"
      }
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxPoints(points) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} points\n     * @return {any}\n     */\n    maxPoints(points) {\n        let max = 0;\n\n        points.forEach(x => {\n          const slopes = new Map();\n\n          points.forEach(y => {\n            if (x === y) return;\n            const slope = y[0] - x[0] !== 0 ? (y[1] - x[1]) / (y[0] - x[0]) : Infinity;\n            slopes.set(slope, (slopes.get(slope) || 0) + 1);\n            max = Math.max(max, slopes.get(slope));\n          });\n        });\n\n        return max + 1;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxPoints(int[][] points) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxPoints(int[][] points) {\n        int n = points.length;\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            for (int j = i + 1; j < n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int cnt = 2;\n                for (int k = j + 1; k < n; ++k) {\n                    int x3 = points[k][0], y3 = points[k][1];\n                    int a = (y2 - y1) * (x3 - x1);\n                    int b = (y3 - y1) * (x2 - x1);\n                    if (a == b) {\n                        ++cnt;\n                    }\n                }\n                ans = Math.max(ans, cnt);\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxPoints(vector<vector<int>>& points) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        int ans = 1;\n        for (int i = 0; i < n; ++i) {\n            int x1 = points[i][0], y1 = points[i][1];\n            for (int j = i + 1; j < n; ++j) {\n                int x2 = points[j][0], y2 = points[j][1];\n                int cnt = 2;\n                for (int k = j + 1; k < n; ++k) {\n                    int x3 = points[k][0], y3 = points[k][1];\n                    int a = (y2 - y1) * (x3 - x1);\n                    int b = (y3 - y1) * (x2 - x1);\n                    cnt += a == b;\n                }\n                ans = max(ans, cnt);\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxPoints(points [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxPoints(points [][]int) int {\n\tn := len(points)\n\tans := 1\n\tfor i := 0; i < n; i++ {\n\t\tx1, y1 := points[i][0], points[i][1]\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tx2, y2 := points[j][0], points[j][1]\n\t\t\tcnt := 2\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tx3, y3 := points[k][0], points[k][1]\n\t\t\t\ta := (y2 - y1) * (x3 - x1)\n\t\t\t\tb := (y3 - y1) * (x2 - x1)\n\t\t\t\tif a == b {\n\t\t\t\t\tcnt++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ans < cnt {\n\t\t\t\tans = cnt\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_points(points: Vec<Point>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [149] Max Points on a Line\n *\n * Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.\n *\n * Example 1:\n *\n *\n * Input: [[1,1],[2,2],[3,3]]\n * Output: 3\n * Explanation:\n * ^\n * |\n * |        o\n * |     o\n * |  o\n * +------------->\n * 0  1  2  3  4\n *\n *\n * Example 2:\n *\n *\n * Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n * Output: 4\n * Explanation:\n * ^\n * |\n * |  o\n * |     o        o\n * |        o\n * |  o        o\n * +------------------->\n * 0  1  2  3  4  5  6\n *\n *\n */\npub struct Solution {}\nuse crate::util::point::Point;\n\n// problem: https://leetcode.com/problems/max-points-on-a-line/\n// discuss: https://leetcode.com/problems/max-points-on-a-line/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n/*\n\u8981\u56de\u987e\u4e0b\u9ad8\u4e2d\u6570\u5b66\uff1a\u5df2\u77e5\u4e24\u70b9, \u6c42\u89e3\u4e00\u822c\u5f0f:\n\n  * Ax + By + C = 0\n  * A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\n\n\u6709\u8fd9\u4e2a\u77e5\u8bc6\u4e4b\u540e\uff0c\u5316\u4e3a\u4e00\u822c\u5f0f\uff0c\u505a\u4e09\u5c42\u904d\u5386\u5c31\u884c\uff0c\u518d\u52a0\u4e0a\u4e00\u4e2a HashSet\uff0c\u907f\u514d\u5bf9\u540c\u4e00\u76f4\u7ebf\u4e0a\u70b9\u7684\u91cd\u590d\u8ba1\u7b97\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u662f O(N^2)\n\n\u6709\u4e24\u4e2a\u5751\u8981\u6ce8\u610f\u907f\u514d\uff1a\n\n  * \u7ed9\u7684 case \u4f1a\u5bfc\u81f4 i32 \u6ea2\u51fa\uff0c\u8fd9\u91cc\u76f4\u63a5\u7528\u4e86 i64 \u8868\u793a\n  * \u7ed9\u7684 case \u91cc\u6709\u76f8\u540c\u7684\u70b9\uff0c\u76f4\u63a5\u5904\u7406\u76f8\u540c\u70b9\u7684\u8bdd\u4f1a\u5bfc\u81f4\u6700\u574f\u60c5\u51b5\u590d\u6742\u5ea6\u5230 O(N^3)\uff0c\u56e0\u6b64\u8981\u5148\u505a\u4e00\u6b21\u8f6c\u5316\uff0c\u5f52\u5e76\u76f8\u540c\u7684\u70b9\n\n\u7528 Rust \u5b9e\u73b0\u6709\u53e6\u4e00\u70b9\u6ce8\u610f\u7684\uff0c\u7ed9\u7684 Point \u6ca1\u6709\u5b9e\u73b0 Hash Trait\uff0c\u8981\u81ea\u5df1\u8f6c\u5316\u4e00\u4e0b\n*/\n// straight-line expression: Ax + By + C = 0\n// A = y2 - y1, B = x1 - x2, C = x2y1 - x1y2\n#[derive(PartialEq, Hash, Eq, Debug)]\nstruct Line(i64, i64, i64);\n\nimpl Line {\n    // Assumes that there is no same point\n    fn new(p1: &Point, p2: &Point) -> Self {\n        let x1 = p1.x as i64;\n        let x2 = p2.x as i64;\n        let y1 = p1.y as i64;\n        let y2 = p2.y as i64;\n        Line(y2 - y1, x1 - x2, x2 * y1 - x1 * y2)\n    }\n    fn contains(&self, p: &Point) -> bool {\n        self.0 * p.x as i64 + self.1 * p.y as i64 + self.2 == 0_i64\n    }\n}\n\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nimpl Solution {\n    pub fn max_points(points: Vec<Point>) -> i32 {\n        // fold same point, record the point count\n        let points: Vec<(Point, i32)> = points\n            .into_iter()\n            .fold(HashMap::new(), |mut map, v| {\n                *map.entry((v.x, v.y)).or_insert(0) += 1;\n                map\n            })\n            .into_iter()\n            .map(|(k, v)| (Point::new(k.0, k.1), v)) // Point did not implement Hash trait\n            .collect();\n\n        // any two points in a straight-line, return quickly\n        if points.len() < 3 {\n            return points.into_iter().fold(0, |acc, v| acc + v.1);\n        }\n        let mut max = 2;\n        let mut set: HashSet<Line> = HashSet::new();\n        for i in 0..(points.len() - 1) {\n            for j in i + 1..points.len() {\n                let line = Line::new(&points[i].0, &points[j].0);\n                if set.contains(&line) {\n                    continue;\n                }\n                let mut curr = points[i].1 + points[j].1;\n                for k in j + 1..points.len() {\n                    if line.contains(&points[k].0) {\n                        curr += points[k].1;\n                    }\n                }\n                max = i32::max(max, curr);\n            }\n        }\n        max\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_149() {\n        assert_eq!(\n            Solution::max_points(vec![point![1, 1], point![2, 2], point![3, 3]]),\n            3\n        );\n        assert_eq!(\n            Solution::max_points(vec![\n                point![1, 1],\n                point![3, 2],\n                point![5, 3],\n                point![4, 1],\n                point![2, 3],\n                point![1, 4]\n            ]),\n            4\n        );\n        assert_eq!(\n            Solution::max_points(vec![point![0, 0], point![1, 65536], point![65536, 0]]),\n            2\n        );\n        assert_eq!(\n            Solution::max_points(vec![point![1, 1], point![1, 1], point![1, 1]]),\n            3\n        );\n        assert_eq!(\n            Solution::max_points(vec![\n                point![0, 9],\n                point![138, 429],\n                point![115, 359],\n                point![115, 359],\n                point![-30, -102],\n                point![230, 709],\n                point![-150, -686],\n                point![-135, -613],\n                point![-60, -248],\n                point![-161, -481],\n                point![207, 639],\n                point![23, 79],\n                point![-230, -691],\n                point![-115, -341],\n                point![92, 289],\n                point![60, 336],\n                point![-105, -467],\n                point![135, 701],\n                point![-90, -394],\n                point![-184, -551],\n                point![150, 774]\n            ]),\n            12\n        )\n    }\n}"
      },
      "python": {
        "initialCode": "from math import gcd\nfrom collections import defaultdict\n\nclass Solution:\n    def maxPoints(self, points: list[list[int]]) -> int:\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxPoints(points: any): number  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    maxPoints(points: any): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "candy",
      "title": "Candy",
      "difficulty": "Hard",
      "pattern": "Two Pass Greedy"
    }
  },
  "house-robber": {
    "title": "House Robber",
    "pattern": "1D DP",
    "patternEmoji": "\ud83c\udfe0",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
    "intuition": [
      "\ud83c\udfaf Max loot without robbing adjacent houses.",
      "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
      "\ud83d\udca1 Only need last two values."
    ],
    "testCases": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4"
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12"
      }
    ],
    "code": "class Solution:\n    def rob(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Max loot without robbing adjacent houses.\n        - \ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].\n        - \ud83d\udca1 Only need last two values.\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        prev2, prev1 = 0, 0\n        for n in nums:  # Iterate over elements.\n            curr = max(prev1, prev2 + n)  # Take the maximum value.\n            prev2, prev1 = prev1, curr\n        return prev1",
    "keyInsight": "Classic 1D DP with space optimization.",
    "visualizationType": "array",
    "initialState": [
      2,
      7,
      9,
      3,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: House Robber",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          2,
          7,
          9,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 2",
        "arrayState": [
          2,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 7",
        "arrayState": [
          2,
          7,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          7,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 9",
        "arrayState": [
          2,
          7,
          9,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          2,
          7,
          9,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          2,
          7,
          9,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          2,
          7,
          9,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 1",
        "arrayState": [
          2,
          7,
          9,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          2,
          7,
          9,
          3,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          2,
          7,
          9,
          3,
          1
        ],
        "pointers": [],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          7,
          9,
          3,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 and house 3: 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1, 3, and 5: 2 + 9 + 1 = 12."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 100",
      "0 <= nums[i] <= 400"
    ],
    "hints": [
      "Use dynamic programming.",
      "At each house, decide: rob it or skip it.",
      "dp[i] = max(dp[i-1], dp[i-2] + nums[i])"
    ],
    "relatedProblems": [
      "house-robber-ii",
      "house-robber-iii",
      "delete-and-earn"
    ],
    "videoId": "73r3KWiEvyk",
    "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "1D DP: dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
    "suggestedNextQuestion": {
      "slug": "house-robber-ii",
      "title": "House Robber II",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def rob(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def rob(nums):\n    # Brute Force Recursion\n    def solve(i):\n        if i >= len(nums): return 0\n        return max(solve(i+1), nums[i] + solve(i+2))\n    return solve(0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Max loot without robbing adjacent houses.",
          "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
          "\ud83d\udca1 Only need last two values."
        ],
        "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max loot without robbing adjacent houses.\n    - \ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].\n    - \ud83d\udca1 Only need last two values.\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for n in nums:  # Iterate over elements.\n        curr = max(prev1, prev2 + n)  # Take the maximum value.\n        prev2, prev1 = prev1, curr\n    return prev1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    rob(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    rob(nums) {\n        const n = nums.length;\n        const f = Array(n).fill(-1);\n        const dfs = i => {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i] < 0) {\n                f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));\n            }\n            return f[i];\n        };\n        return dfs(0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int rob(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private Integer[] f;\n    private int[] nums;\n\n    public int rob(int[] nums) {\n        this.nums = nums;\n        f = new Integer[nums.length];\n        return dfs(0);\n    }\n\n    private int dfs(int i) {\n        if (i >= nums.length) {\n            return 0;\n        }\n        if (f[i] == null) {\n            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));\n        }\n        return f[i];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int rob(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        int f[n];\n        memset(f, -1, sizeof(f));\n        auto dfs = [&](this auto&& dfs, int i) -> int {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i] < 0) {\n                f[i] = max(nums[i] + dfs(i + 2), dfs(i + 1));\n            }\n            return f[i];\n        };\n        return dfs(0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rob(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) rob(nums []int) int {\n\tn := len(nums)\n\tf := make([]int, n)\n\tfor i := range f {\n\t\tf[i] = -1\n\t}\n\tvar dfs func(int) int\n\tdfs = func(i int) int {\n\t\tif i >= n {\n\t\t\treturn 0\n\t\t}\n\t\tif f[i] < 0 {\n\t\t\tf[i] = max(nums[i]+dfs(i+2), dfs(i+1))\n\t\t}\n\t\treturn f[i]\n\t}\n\treturn dfs(0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        fn dfs(i: usize, nums: &Vec<i32>, f: &mut Vec<i32>) -> i32 {\n            if i >= nums.len() {\n                return 0;\n            }\n            if f[i] < 0 {\n                f[i] = (nums[i] + dfs(i + 2, nums, f)).max(dfs(i + 1, nums, f));\n            }\n            f[i]\n        }\n\n        let n = nums.len();\n        let mut f = vec![-1; n];\n        dfs(0, &nums, &mut f)\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def rob(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    rob(nums: number[]): number  {\n    const n = nums.length;\n    const f: number[] = Array(n).fill(-1);\n    const dfs = (i: number): number => {\n        if (i >= n) {\n            return 0;\n        }\n        if (f[i] < 0) {\n            f[i] = Math.max(nums[i] + dfs(i + 2), dfs(i + 1));\n        }\n        return f[i];\n    };\n    return dfs(0);\n}\n}",
        "initialCode": "class Solution {\n    rob(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "word-break": {
    "title": "Word Break",
    "pattern": "1D DP",
    "patternEmoji": "\ud83d\udcdd",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i] = any(dp[j] and s[j:i] in wordDict).",
    "intuition": [
      "\ud83c\udfaf Can s be segmented into dictionary words?",
      "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
      "\ud83d\udca1 Check all valid word endings."
    ],
    "testCases": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true"
      },
      {
        "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
        "output": "true"
      },
      {
        "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "output": "false"
      }
    ],
    "code": "class Solution:\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Can s be segmented into dictionary words?\n        - \ud83e\udde0 dp[i] = True if s[:i] can be segmented.\n        - \ud83d\udca1 Check all valid word endings.\n        \"\"\"\n        wordSet = set(wordDict)\n        dp = [False] * (len(s) + 1)  # Initialize DP table to store results.\n        dp[0] = True\n        for i in range(1, len(s) + 1):  # Iterate through the range.\n            for j in range(i):  # Iterate through the range.\n                if dp[j] and s[j:i] in wordSet:\n                    dp[i] = True\n                    break\n        return dp[len(s)]",
    "keyInsight": "dp[i] = True if any valid word ends at position i.",
    "visualizationType": "array",
    "initialState": [
      "l",
      "e",
      "e",
      "t",
      "c",
      "o",
      "d",
      "e"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Word Break",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = l",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = e",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = e",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = t",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = c",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = o",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "l",
          "e",
          "e",
          "t",
          "c",
          "o",
          "d",
          "e"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i] = any(dp[j] and s[j:i] in wordDict).\n\nCan s be segmented into dictionary words?\ndp[i] = True if s[:i] can be segmented.",
    "examples": [
      {
        "input": "s = \"leetcode\"; wordDict = [\"leet\",\"code\"]",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Can s be segmented into dictionary words?",
      "dp[i] = True if s[:i] can be segmented.",
      "Check all valid word endings."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "Sx9NNgInc3A",
    "problemStatement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "1D DP: dp[i] = any(dp[j] and s[j:i] in wordDict).",
    "suggestedNextQuestion": {
      "slug": "best-time-to-buy-and-sell-stock-iii",
      "title": "Best Time to Buy and Sell Stock III",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def wordBreak(self, s, wordDict):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def wordBreak(s, wordDict):\n    # Recursion\n    words = set(wordDict)\n    def canBreak(target):\n        if not target: return True\n        for w in words:\n             if target.startswith(w):\n                 if canBreak(target[len(w):]):\n                     return True\n        return False\n    return canBreak(s)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Can s be segmented into dictionary words?",
          "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
          "\ud83d\udca1 Check all valid word endings."
        ],
        "code": "def wordBreak(s, wordDict):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s be segmented into dictionary words?\n    - \ud83e\udde0 dp[i] = True if s[:i] can be segmented.\n    - \ud83d\udca1 Check all valid word endings.\n    \"\"\"\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for i in range(1, len(s) + 1):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n    return dp[len(s)]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    wordBreak(s, wordDict) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s, wordDict\n     * @return {any}\n     */\n    wordBreak(s, wordDict) {\n        const result = [1, ...new Array(s.length + 1).fill(0)];\n\n        for (let i = 1; i <= s.length; i++) {\n          for (let j = 0; j < i; j++) {\n            if (result[j] && wordDict.includes(s.slice(j, i))) {\n              result[i] = 1;\n              break;\n            }\n          }\n      }\n\n    return result[s.length];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> words = new HashSet<>(wordDict);\n        int n = s.length();\n        boolean[] f = new boolean[n + 1];\n        f[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (f[j] && words.contains(s.substring(j, i))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool wordBreak(string s, vector<string>& wordDict) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\n        int n = s.size();\n        bool f[n + 1];\n        memset(f, false, sizeof(f));\n        f[0] = true;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (f[j] && words.count(s.substr(j, i - j))) {\n                    f[i] = true;\n                    break;\n                }\n            }\n        }\n        return f[n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) wordBreak(s string, wordDict []string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) wordBreak(s string, wordDict []string) bool {\n\twords := map[string]bool{}\n\tfor _, w := range wordDict {\n\t\twords[w] = true\n\t}\n\tn := len(s)\n\tf := make([]bool, n+1)\n\tf[0] = true\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif f[j] && words[s[j:i]] {\n\t\t\t\tf[i] = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn f[n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\n        let words: std::collections::HashSet<String> = word_dict.into_iter().collect();\n        let mut f = vec![false; s.len() + 1];\n        f[0] = true;\n        for i in 1..=s.len() {\n            for j in 0..i {\n                f[i] |= f[j] && words.contains(&s[j..i]);\n            }\n        }\n        f[s.len()]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def wordBreak(self, s, wordDict):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    wordBreak(s: string, wordDict: string[]): boolean  {\n    const words = new Set(wordDict);\n    const n = s.length;\n    const f: boolean[] = new Array(n + 1).fill(false);\n    f[0] = true;\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (f[j] && words.has(s.substring(j, i))) {\n                f[i] = true;\n                break;\n            }\n        }\n    }\n    return f[n];\n}\n}",
        "initialCode": "class Solution {\n    wordBreak(s: string, wordDict: string[]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "longest-increasing-subsequence": {
    "title": "Longest Increasing Subsequence",
    "pattern": "DP / Binary Search",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Maintain sorted 'tails' array. Binary search insertion point.",
    "intuition": [
      "\ud83c\udfaf Find LIS length.",
      "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
      "\ud83d\udca1 Binary search for where to insert/replace."
    ],
    "testCases": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4"
      },
      {
        "input": "nums = [0,1,0,3,2,3]",
        "output": "4"
      },
      {
        "input": "nums = [7,7,7,7,7,7,7]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    import bisect\n    \n    def lengthOfLIS(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find LIS length.\n        - \ud83e\udde0 O(n log n): maintain smallest tail for each length.\n        - \ud83d\udca1 Binary search for where to insert/replace.\n        \"\"\"\n        tails = []\n        for n in nums:  # Iterate over elements.\n            pos = bisect.bisect_left(tails, n)\n            if pos == len(tails):\n                tails.append(n)  # Add to end.\n            else:\n                tails[pos] = n\n        return len(tails)",
    "keyInsight": "tails[i] = smallest tail of LIS of length i+1.",
    "visualizationType": "array",
    "initialState": [
      10,
      9,
      2,
      5,
      3,
      7,
      101,
      18
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Array: [10, 9, 2, 5, 3, 7, 101, 18]",
        "transientMessage": "dp[i] = LIS ending at i",
        "arrayState": [
          10,
          9,
          2,
          5,
          3,
          7,
          101,
          18
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "nums[2]=2 < nums[3]=5",
        "transientMessage": "dp[3] = 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 2
          },
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 3,
        "visual": "nums[2]=2 < nums[4]=3",
        "transientMessage": "dp[4] = 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 2
          },
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          2,
          4
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "nums[2]=2 < nums[5]=7",
        "transientMessage": "dp[5] = 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 2
          },
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          2,
          5
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "nums[3]=5 < nums[5]=7",
        "transientMessage": "dp[5] = 3",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          1,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 3
          },
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          3,
          5
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "nums[0]=10 < nums[6]=101",
        "transientMessage": "dp[6] = 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          2,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 0
          },
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          0,
          6
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "nums[3]=5 < nums[6]=101",
        "transientMessage": "dp[6] = 3",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          3,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 3
          },
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          3,
          6
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "nums[5]=7 < nums[6]=101",
        "transientMessage": "dp[6] = 4",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          1
        ],
        "pointers": [
          {
            "label": "j",
            "index": 5
          },
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "nums[0]=10 < nums[7]=18",
        "transientMessage": "dp[7] = 2",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          2
        ],
        "pointers": [
          {
            "label": "j",
            "index": 0
          },
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          0,
          7
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "nums[3]=5 < nums[7]=18",
        "transientMessage": "dp[7] = 3",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          3
        ],
        "pointers": [
          {
            "label": "j",
            "index": 3
          },
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          3,
          7
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "nums[5]=7 < nums[7]=18",
        "transientMessage": "dp[7] = 4",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          4
        ],
        "pointers": [
          {
            "label": "j",
            "index": 5
          },
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          5,
          7
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "LIS length: 4",
        "transientMessage": "dp = [1, 1, 1, 2, 2, 3, 4, 4]",
        "arrayState": [
          1,
          1,
          1,
          2,
          2,
          3,
          4,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Maintain sorted 'tails' array. Binary search insertion point.\n\nFind LIS length.\nO(n log n): maintain smallest tail for each length.",
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find LIS length.",
      "O(n log n): maintain smallest tail for each length.",
      "Binary search for where to insert/replace."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "73r3KWiEvyk",
    "problemStatement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DP / Binary Search: Maintain sorted 'tails' array. Binary search insertion point.",
    "suggestedNextQuestion": {
      "slug": "maximal-square",
      "title": "Maximal Square",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class Solution:\n    def lengthOfLIS(self, nums):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def lengthOfLIS_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Find LIS length.",
          "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
          "\ud83d\udca1 Binary search for where to insert/replace."
        ],
        "code": "import bisect\n\ndef lengthOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LIS length.\n    - \ud83e\udde0 O(n log n): maintain smallest tail for each length.\n    - \ud83d\udca1 Binary search for where to insert/replace.\n    \"\"\"\n    tails = []\n    for n in nums:  # Iterate over elements.\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)  # Add to end.\n        else:\n            tails[pos] = n\n    return len(tails)"
      }
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    lengthOfLIS(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    lengthOfLIS(nums) {\n        if (!nums.length) return 0;\n\n        const dp = new Array(nums.length).fill(1);\n        for (let i = 1; i < nums.length; i++) {\n          for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n              dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n          }\n      }\n\n    return Math.max(...dp);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n];\n        Arrays.fill(f, 1);\n        int ans = 1;\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[j] < nums[i]) {\n                    f[i] = Math.max(f[i], f[j] + 1);\n                }\n            }\n            ans = Math.max(ans, f[i]);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int lengthOfLIS(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> f(n, 1);\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[j] < nums[i]) {\n                    f[i] = max(f[i], f[j] + 1);\n                }\n            }\n        }\n        return *max_element(f.begin(), f.end());\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLIS(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) lengthOfLIS(nums []int) int {\n\tn := len(nums)\n\tf := make([]int, n)\n\tfor i := range f {\n\t\tf[i] = 1\n\t}\n\tans := 1\n\tfor i := 1; i < n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tif nums[j] < nums[i] {\n\t\t\t\tf[i] = max(f[i], f[j]+1)\n\t\t\t\tans = max(ans, f[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn length_of_lis(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn length_of_lis(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut f = vec![1; n];\n        for i in 1..n {\n            for j in 0..i {\n                if nums[j] < nums[i] {\n                    f[i] = f[i].max(f[j] + 1);\n                }\n            }\n        }\n        *f.iter().max().unwrap()\n    }\n}"
      },
      "python": {
        "initialCode": "import bisect\n\ndef lengthOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LIS length.\n    - \ud83e\udde0 O(n log n): maintain smallest tail for each length.\n    - \ud83d\udca1 Binary search for where to insert/replace.\n    \"\"\"\n    tails = []\n    for n in nums:  # Iterate over elements.\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)  # Add to end.\n        else:\n            tails[pos] = n\n    return len(tails)"
      },
      "typescript": {
        "code": "class Solution {\n    lengthOfLIS(nums: number[]): number  {\n    const n = nums.length;\n    const f: number[] = new Array(n).fill(1);\n    for (let i = 1; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[j] < nums[i]) {\n                f[i] = Math.max(f[i], f[j] + 1);\n            }\n        }\n    }\n    return Math.max(...f);\n}\n}",
        "initialCode": "class Solution {\n    lengthOfLIS(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "number-of-longest-increasing-subsequence": {
    "title": "Number of Longest Increasing Subsequence",
    "pattern": "DP",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(n)",
    "oneliner": "Track both length and count at each position.",
    "intuition": [
      "\ud83c\udfaf Count all LIS.",
      "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
      "\ud83d\udca1 Aggregate counts for max length."
    ],
    "testCases": [
      {
        "input": "nums = [1,3,5,4,7]",
        "output": "2"
      },
      {
        "input": "nums = [2,2,2,2,2]",
        "output": "5"
      }
    ],
    "code": "class Solution:\n    def findNumberOfLIS(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count all LIS.\n        - \ud83e\udde0 dp[i] = (length, count) of LIS ending at i.\n        - \ud83d\udca1 Aggregate counts for max length.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n\n        counts = [1] * n\n        for i in range(n):  # Iterate through the range.\n            for j in range(i):  # Iterate through the range.\n                if nums[j] < nums[i]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n        maxLen = max(lengths)  # Take the maximum value.\n        return sum(c for l, c in zip(lengths, counts) if l == maxLen)",
    "keyInsight": "Track both LIS length and count of ways to achieve it.",
    "visualizationType": "array",
    "initialState": [
      1,
      3,
      5,
      4,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Number of Longest Increasing Subsequence",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          1,
          3,
          5,
          4,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 1",
        "arrayState": [
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 3",
        "arrayState": [
          1,
          3,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          3,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 5",
        "arrayState": [
          1,
          3,
          5,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          1,
          3,
          5,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 4",
        "arrayState": [
          1,
          3,
          5,
          4,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          1,
          3,
          5,
          4,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 7",
        "arrayState": [
          1,
          3,
          5,
          4,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          1,
          3,
          5,
          4,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          1,
          3,
          5,
          4,
          7
        ],
        "pointers": [],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          3,
          5,
          4,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Track both length and count at each position.\n\nCount all LIS.\ndp[i] = (length, count) of LIS ending at i.",
    "examples": [
      {
        "input": "nums = [1,3,5,4,7]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count all LIS.",
      "dp[i] = (length, count) of LIS ending at i.",
      "Aggregate counts for max length."
    ],
    "relatedProblems": [
      "climbing-stairs",
      "coin-change",
      "longest-increasing-subsequence"
    ],
    "videoId": "Tuc-rjJbsXU",
    "problemStatement": "Given an integer array nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DP: Track both length and count at each position.",
    "suggestedNextQuestion": {
      "slug": "partition-equal-subset-sum",
      "title": "Partition Equal Subset Sum",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def findNumberOfLIS(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findNumberOfLIS(nums):\n    if not nums: return 0\n    n = len(nums)\n    length = [1] * n\n    count = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                if length[j] + 1 > length[i]:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n                elif length[j] + 1 == length[i]:\n                    count[i] += count[j]\n                    \n    max_len = max(length)\n    return sum(c for l, c in zip(length, count) if l == max_len)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Count all LIS.",
          "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
          "\ud83d\udca1 Aggregate counts for max length."
        ],
        "code": "def findNumberOfLIS(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count all LIS.\n    - \ud83e\udde0 dp[i] = (length, count) of LIS ending at i.\n    - \ud83d\udca1 Aggregate counts for max length.\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    lengths = [1] * n\n    counts = [1] * n\n    for i in range(n):  # Iterate through the range.\n        for j in range(i):  # Iterate through the range.\n            if nums[j] < nums[i]:\n                if lengths[j] + 1 > lengths[i]:\n                    lengths[i] = lengths[j] + 1\n                    counts[i] = counts[j]\n                elif lengths[j] + 1 == lengths[i]:\n                    counts[i] += counts[j]\n    maxLen = max(lengths)  # Take the maximum value.\n    return sum(c for l, c in zip(lengths, counts) if l == maxLen)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findNumberOfLIS(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    findNumberOfLIS(nums) {\n        const lengths = new Array(nums.length).fill(1);\n        const counts = new Array(nums.length).fill(1);\n\n        for (let i = 1; i < nums.length; i++) {\n          for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n              if (lengths[j] + 1 > lengths[i]) {\n                lengths[i] = lengths[j] + 1;\n                counts[i] = counts[j];\n              } else if (lengths[j] + 1 === lengths[i]) {\n                counts[i] += counts[j];\n              }\n            }\n          }\n      }\n\n    const max = Math.max(...lengths);\n    return lengths.reduce((sum, l, i) => {\n      return sum + (l === max ? counts[i] : 0);\n    }, 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findNumberOfLIS(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n];\n        int[] cnt = new int[n];\n        int mx = 0, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            f[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        cnt[i] = cnt[j];\n                    } else if (f[i] == f[j] + 1) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (mx < f[i]) {\n                mx = f[i];\n                ans = cnt[i];\n            } else if (mx == f[i]) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findNumberOfLIS(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        int n = nums.size();\n        int mx = 0, ans = 0;\n        vector<int> f(n, 1);\n        vector<int> cnt(n, 1);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        cnt[i] = cnt[j];\n                    } else if (f[i] == f[j] + 1) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (mx < f[i]) {\n                mx = f[i];\n                ans = cnt[i];\n            } else if (mx == f[i]) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findNumberOfLIS(nums []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findNumberOfLIS(nums []int) (ans int) {\n\tn, mx := len(nums), 0\n\tf := make([]int, n)\n\tcnt := make([]int, n)\n\tfor i, x := range nums {\n\t\tfor j, y := range nums[:i] {\n\t\t\tif y < x {\n\t\t\t\tif f[i] < f[j]+1 {\n\t\t\t\t\tf[i] = f[j] + 1\n\t\t\t\t\tcnt[i] = cnt[j]\n\t\t\t\t} else if f[i] == f[j]+1 {\n\t\t\t\t\tcnt[i] += cnt[j]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif mx < f[i] {\n\t\t\tmx = f[i]\n\t\t\tans = cnt[i]\n\t\t} else if mx == f[i] {\n\t\t\tans += cnt[i]\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_number_of_lis(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_number_of_lis(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut ans = 0;\n        let mut mx = 0;\n        let mut f = vec![1; n];\n        let mut cnt = vec![1; n];\n        for i in 0..n {\n            for j in 0..i {\n                if nums[j] < nums[i] {\n                    if f[i] < f[j] + 1 {\n                        f[i] = f[j] + 1;\n                        cnt[i] = cnt[j];\n                    } else if f[i] == f[j] + 1 {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if mx < f[i] {\n                mx = f[i];\n                ans = cnt[i];\n            } else if mx == f[i] {\n                ans += cnt[i];\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findNumberOfLIS(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findNumberOfLIS(nums: number[]): number  {\n    const n = nums.length;\n    let [ans, mx] = [0, 0];\n    const f: number[] = Array(n).fill(1);\n    const cnt: number[] = Array(n).fill(1);\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (nums[j] < nums[i]) {\n                if (f[i] < f[j] + 1) {\n                    f[i] = f[j] + 1;\n                    cnt[i] = cnt[j];\n                } else if (f[i] === f[j] + 1) {\n                    cnt[i] += cnt[j];\n                }\n            }\n        }\n        if (mx < f[i]) {\n            mx = f[i];\n            ans = cnt[i];\n        } else if (mx === f[i]) {\n            ans += cnt[i];\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    findNumberOfLIS(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "decode-ways": {
    "title": "Decode Ways",
    "pattern": "1D DP",
    "patternEmoji": "\ud83d\udd13",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
    "intuition": [
      "\ud83c\udfaf Count ways to decode digit string.",
      "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
      "\ud83d\udca1 Similar to Fibonacci with constraints."
    ],
    "testCases": [
      {
        "input": "s = \"12\"",
        "output": "2"
      },
      {
        "input": "s = \"226\"",
        "output": "3"
      },
      {
        "input": "s = \"06\"",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def numDecodings(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count ways to decode digit string.\n        - \ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.\n        - \ud83d\udca1 Similar to Fibonacci with constraints.\n        \"\"\"\n        if not s or s[0] == '0':\n            return 0\n        prev2, prev1 = 1, 1\n        for i in range(1, len(s)):  # Iterate through the range.\n            curr = 0\n            if s[i] != '0':\n                curr += prev1\n            two = int(s[i-1:i+1])\n            if 10 <= two <= 26:\n                curr += prev2\n            prev2, prev1 = prev1, curr\n        return prev1",
    "keyInsight": "Handle '0' carefully - it can only be part of 10 or 20.",
    "visualizationType": "array",
    "initialState": "226",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Decode Ways",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "2",
          "2",
          "6"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).\n\nCount ways to decode digit string.\nSingle digit: 1-9 valid. Two digits: 10-26 valid.",
    "examples": [
      {
        "input": "s = \"226\"",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count ways to decode digit string.",
      "Single digit: 1-9 valid. Two digits: 10-26 valid.",
      "Similar to Fibonacci with constraints."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "6aEyTjOwlJU",
    "problemStatement": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "1D DP: dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
    "suggestedNextQuestion": {
      "slug": "edit-distance",
      "title": "Edit Distance",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def numDecodings(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def numDecodings(s):\n    # Recursive\n    def dfs(i):\n        if i == len(s): return 1\n        if s[i] == '0': return 0\n        res = dfs(i + 1)\n        if i + 1 < len(s) and (s[i] == '1' or (s[i] == '2' and s[i+1] in '0123456')):\n            res += dfs(i + 2)\n        return res\n    return dfs(0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Count ways to decode digit string.",
          "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
          "\ud83d\udca1 Similar to Fibonacci with constraints."
        ],
        "code": "def numDecodings(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count ways to decode digit string.\n    - \ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.\n    - \ud83d\udca1 Similar to Fibonacci with constraints.\n    \"\"\"\n    if not s or s[0] == '0':\n        return 0\n    prev2, prev1 = 1, 1\n    for i in range(1, len(s)):  # Iterate through the range.\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two = int(s[i-1:i+1])\n        if 10 <= two <= 26:\n            curr += prev2\n        prev2, prev1 = prev1, curr\n    return prev1"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    numDecodings(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    numDecodings(s) {\n        if (s == null || s.length === 0) return 0;\n        if (s[0] === '0') return 0;\n\n        const group = new Array(s.length + 1).fill(0);\n        group[0] = 1;\n        group[1] = 1;\n\n        for (let i = 2; i <= s.length; i++) {\n          const a = Number(s.slice(i - 1, i));\n          if (a >= 1 && a <= 9) {\n            group[i] += group[i - 1];\n          }\n\n          const b = Number(s.slice(i - 2, i));\n          if (b >= 10 && b <= 26) {\n            group[i] += group[i - 2];\n          }\n      }\n\n    return group[s.length];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int numDecodings(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int[] f = new int[n + 1];\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s.charAt(i - 1) != '0') {\n                f[i] = f[i - 1];\n            }\n            if (i > 1 && s.charAt(i - 2) != '0' && Integer.valueOf(s.substring(i - 2, i)) <= 26) {\n                f[i] += f[i - 2];\n            }\n        }\n        return f[n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int numDecodings(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.size();\n        int f[n + 1];\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (s[i - 1] != '0') {\n                f[i] = f[i - 1];\n            }\n            if (i > 1 && (s[i - 2] == '1' || s[i - 2] == '2' && s[i - 1] <= '6')) {\n                f[i] += f[i - 2];\n            }\n        }\n        return f[n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) numDecodings(s string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) numDecodings(s string) int {\n\tn := len(s)\n\tf := make([]int, n+1)\n\tf[0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\tif s[i-1] != '0' {\n\t\t\tf[i] = f[i-1]\n\t\t}\n\t\tif i > 1 && (s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6')) {\n\t\t\tf[i] += f[i-2]\n\t\t}\n\t}\n\treturn f[n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn num_decodings(s: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [91] Decode Ways\n *\n * A message containing letters from A-Z is being encoded to numbers using the following mapping:\n *\n *\n * 'A' -> 1\n * 'B' -> 2\n * ...\n * 'Z' -> 26\n *\n *\n * Given a non-empty string containing only digits, determine the total number of ways to decode it.\n *\n * Example 1:\n *\n *\n * Input: \"12\"\n * Output: 2\n * Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12).\n *\n *\n * Example 2:\n *\n *\n * Input: \"226\"\n * Output: 3\n * Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/decode-ways/\n// discuss: https://leetcode.com/problems/decode-ways/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn num_decodings(s: String) -> i32 {\n        0\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_91() {}\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def numDecodings(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    numDecodings(s: string): number  {\n    const n = s.length;\n    const f: number[] = new Array(n + 1).fill(0);\n    f[0] = 1;\n    for (let i = 1; i <= n; ++i) {\n        if (s[i - 1] !== '0') {\n            f[i] = f[i - 1];\n        }\n        if (i > 1 && (s[i - 2] === '1' || (s[i - 2] === '2' && s[i - 1] <= '6'))) {\n            f[i] += f[i - 2];\n        }\n    }\n    return f[n];\n}\n}",
        "initialCode": "class Solution {\n    numDecodings(s: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "minimum-path-sum": {
    "title": "Minimum Path Sum",
    "pattern": "2D DP",
    "patternEmoji": "\ud83d\udee4\ufe0f",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
    "intuition": [
      "\ud83c\udfaf Min sum path from top-left to bottom-right.",
      "\ud83e\udde0 Can only move right or down.",
      "\ud83d\udca1 Each cell = min of arriving from top or left."
    ],
    "testCases": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7"
      },
      {
        "input": "grid = [[1,2,3],[4,5,6]]",
        "output": "12"
      }
    ],
    "code": "class Solution:\n    def minPathSum(self, grid):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min sum path from top-left to bottom-right.\n        - \ud83e\udde0 Can only move right or down.\n        - \ud83d\udca1 Each cell = min of arriving from top or left.\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        for i in range(m):  # Iterate through the range.\n            for j in range(n):  # Iterate through the range.\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i-1][j], grid[i][j-1])  # Take the minimum value.\n        return grid[-1][-1]",
    "keyInsight": "Modify grid in-place for O(1) extra space.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        3,
        1
      ],
      [
        1,
        5,
        1
      ],
      [
        4,
        2,
        1
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Path Sum",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 3",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 5",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            3,
            1
          ],
          [
            1,
            5,
            1
          ],
          [
            4,
            2,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).\n\nMin sum path from top-left to bottom-right.\nCan only move right or down.",
    "examples": [
      {
        "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
        "output": "7"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min sum path from top-left to bottom-right.",
      "Can only move right or down.",
      "Each cell = min of arriving from top or left."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "pGMsrvt0fpk",
    "problemStatement": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
    "suggestedNextQuestion": {
      "slug": "number-of-longest-increasing-subsequence",
      "title": "Number of Longest Increasing Subsequence",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def minPathSum(self, grid):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def minPathSum(grid):\n    R, C = len(grid), len(grid[0])\n    def dfs(r, c):\n        if r == R - 1 and c == C - 1: return grid[r][c]\n        if r >= R or c >= C: return float('inf')\n        return grid[r][c] + min(dfs(r+1, c), dfs(r, c+1))\n    return dfs(0, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Min sum path from top-left to bottom-right.",
          "\ud83e\udde0 Can only move right or down.",
          "\ud83d\udca1 Each cell = min of arriving from top or left."
        ],
        "code": "def minPathSum(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min sum path from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 Each cell = min of arriving from top or left.\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])  # Take the minimum value.\n    return grid[-1][-1]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minPathSum(grid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} grid\n     * @return {any}\n     */\n    minPathSum(grid) {\n        const m = grid.length;\n        const n = grid[0].length;\n        const f = Array(m)\n            .fill(0)\n            .map(() => Array(n).fill(0));\n        f[0][0] = grid[0][0];\n        for (let i = 1; i < m; ++i) {\n            f[i][0] = f[i - 1][0] + grid[i][0];\n        }\n        for (let j = 1; j < n; ++j) {\n            f[0][j] = f[0][j - 1] + grid[0][j];\n        }\n        for (let i = 1; i < m; ++i) {\n            for (let j = 1; j < n; ++j) {\n                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n            }\n    }\n    return f[m - 1][n - 1];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minPathSum(int[][] grid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] f = new int[m][n];\n        f[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            f[i][0] = f[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            f[0][j] = f[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minPathSum(vector<vector<int>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int f[m][n];\n        f[0][0] = grid[0][0];\n        for (int i = 1; i < m; ++i) {\n            f[i][0] = f[i - 1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; ++j) {\n            f[0][j] = f[0][j - 1] + grid[0][j];\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minPathSum(grid [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minPathSum(grid [][]int) int {\n\tm, n := len(grid), len(grid[0])\n\tf := make([][]int, m)\n\tfor i := range f {\n\t\tf[i] = make([]int, n)\n\t}\n\tf[0][0] = grid[0][0]\n\tfor i := 1; i < m; i++ {\n\t\tf[i][0] = f[i-1][0] + grid[i][0]\n\t}\n\tfor j := 1; j < n; j++ {\n\t\tf[0][j] = f[0][j-1] + grid[0][j]\n\t}\n\tfor i := 1; i < m; i++ {\n\t\tfor j := 1; j < n; j++ {\n\t\t\tf[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]\n\t\t}\n\t}\n\treturn f[m-1][n-1]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_path_sum(mut grid: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_path_sum(mut grid: Vec<Vec<i32>>) -> i32 {\n        let m = grid.len();\n        let n = grid[0].len();\n        for i in 1..m {\n            grid[i][0] += grid[i - 1][0];\n        }\n        for i in 1..n {\n            grid[0][i] += grid[0][i - 1];\n        }\n        for i in 1..m {\n            for j in 1..n {\n                grid[i][j] += grid[i][j - 1].min(grid[i - 1][j]);\n            }\n        }\n        grid[m - 1][n - 1]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minPathSum(self, grid):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minPathSum(grid: number[][]): number  {\n    const m = grid.length;\n    const n = grid[0].length;\n    const f: number[][] = Array(m)\n        .fill(0)\n        .map(() => Array(n).fill(0));\n    f[0][0] = grid[0][0];\n    for (let i = 1; i < m; ++i) {\n        f[i][0] = f[i - 1][0] + grid[i][0];\n    }\n    for (let j = 1; j < n; ++j) {\n        f[0][j] = f[0][j - 1] + grid[0][j];\n    }\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n        }\n    }\n    return f[m - 1][n - 1];\n}\n}",
        "initialCode": "class Solution {\n    minPathSum(grid: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "unique-paths-ii": {
    "title": "Unique Paths II",
    "pattern": "2D DP",
    "patternEmoji": "\ud83d\udee4\ufe0f",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
    "intuition": [
      "\ud83c\udfaf Count paths with obstacles.",
      "\ud83e\udde0 Obstacle = 0 paths through that cell.",
      "\ud83d\udca1 Sum paths from top and left if not blocked."
    ],
    "testCases": [
      {
        "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2"
      },
      {
        "input": "obstacleGrid = [[0,1],[0,0]]",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count paths with obstacles.\n        - \ud83e\udde0 Obstacle = 0 paths through that cell.\n        - \ud83d\udca1 Sum paths from top and left if not blocked.\n        \"\"\"\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        if obstacleGrid[0][0] == 1:\n            return 0\n        dp = [0] * n  # Initialize DP table to store results.\n        dp[0] = 1\n        for i in range(m):  # Iterate through the range.\n            for j in range(n):  # Iterate through the range.\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j > 0:\n                    dp[j] += dp[j-1]\n        return dp[-1]  # Return the result from DP table.",
    "keyInsight": "Set dp to 0 for obstacles.",
    "visualizationType": "matrix",
    "initialState": [
      [
        0,
        0,
        0
      ],
      [
        0,
        1,
        0
      ],
      [
        0,
        0,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Unique Paths II",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            0,
            0,
            0
          ],
          [
            0,
            1,
            0
          ],
          [
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].\n\nCount paths with obstacles.\nObstacle = 0 paths through that cell.",
    "examples": [
      {
        "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
        "output": "2"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count paths with obstacles.",
      "Obstacle = 0 paths through that cell.",
      "Sum paths from top and left if not blocked."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "d3UOz7zdE4I",
    "problemStatement": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
    "suggestedNextQuestion": {
      "slug": "word-break",
      "title": "Word Break",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def uniquePathsWithObstacles(obstacleGrid):\n    R, C = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1: return 0\n    def dfs(r, c):\n        if r >= R or c >= C or obstacleGrid[r][c] == 1: return 0\n        if r == R - 1 and c == C - 1: return 1\n        return dfs(r+1, c) + dfs(r, c+1)\n    return dfs(0, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Count paths with obstacles.",
          "\ud83e\udde0 Obstacle = 0 paths through that cell.",
          "\ud83d\udca1 Sum paths from top and left if not blocked."
        ],
        "code": "def uniquePathsWithObstacles(obstacleGrid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths with obstacles.\n    - \ud83e\udde0 Obstacle = 0 paths through that cell.\n    - \ud83d\udca1 Sum paths from top and left if not blocked.\n    \"\"\"\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    dp = [0] * n  # Initialize DP table to store results.\n    dp[0] = 1\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j-1]\n    return dp[-1]  # Return the result from DP table."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    uniquePathsWithObstacles(obstacleGrid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} obstacleGrid\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} obstacleGrid\n     * @return {any}\n     */\n    uniquePathsWithObstacles(obstacleGrid) {\n        const m = obstacleGrid.length;\n        const n = obstacleGrid[0].length;\n        const f = Array.from({ length: m }, () => Array(n).fill(-1));\n        const dfs = (i, j) => {\n            if (i >= m || j >= n || obstacleGrid[i][j] === 1) {\n                return 0;\n            }\n            if (i === m - 1 && j === n - 1) {\n                return 1;\n            }\n            if (f[i][j] === -1) {\n                f[i][j] = dfs(i + 1, j) + dfs(i, j + 1);\n        }\n        return f[i][j];\n    };\n    return dfs(0, 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private Integer[][] f;\n    private int[][] obstacleGrid;\n    private int m;\n    private int n;\n\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        m = obstacleGrid.length;\n        n = obstacleGrid[0].length;\n        this.obstacleGrid = obstacleGrid;\n        f = new Integer[m][n];\n        return dfs(0, 0);\n    }\n\n    private int dfs(int i, int j) {\n        if (i >= m || j >= n || obstacleGrid[i][j] == 1) {\n            return 0;\n        }\n        if (i == m - 1 && j == n - 1) {\n            return 1;\n        }\n        if (f[i][j] == null) {\n            f[i][j] = dfs(i + 1, j) + dfs(i, j + 1);\n        }\n        return f[i][j];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\n        vector<vector<int>> f(m, vector<int>(n, -1));\n        auto dfs = [&](this auto&& dfs, int i, int j) {\n            if (i >= m || j >= n || obstacleGrid[i][j]) {\n                return 0;\n            }\n            if (i == m - 1 && j == n - 1) {\n                return 1;\n            }\n            if (f[i][j] == -1) {\n                f[i][j] = dfs(i + 1, j) + dfs(i, j + 1);\n            }\n            return f[i][j];\n        };\n        return dfs(0, 0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) uniquePathsWithObstacles(obstacleGrid [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) uniquePathsWithObstacles(obstacleGrid [][]int) int {\n\tm, n := len(obstacleGrid), len(obstacleGrid[0])\n\tf := make([][]int, m)\n\tfor i := range f {\n\t\tf[i] = make([]int, n)\n\t\tfor j := range f[i] {\n\t\t\tf[i][j] = -1\n\t\t}\n\t}\n\tvar dfs func(i, j int) int\n\tdfs = func(i, j int) int {\n\t\tif i >= m || j >= n || obstacleGrid[i][j] == 1 {\n\t\t\treturn 0\n\t\t}\n\t\tif i == m-1 && j == n-1 {\n\t\t\treturn 1\n\t\t}\n\t\tif f[i][j] == -1 {\n\t\t\tf[i][j] = dfs(i+1, j) + dfs(i, j+1)\n\t\t}\n\t\treturn f[i][j]\n\t}\n\treturn dfs(0, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {\n        let m = obstacle_grid.len();\n        let n = obstacle_grid[0].len();\n        let mut f = vec![vec![-1; n]; m];\n        Self::dfs(0, 0, &obstacle_grid, &mut f)\n    }\n\n    fn dfs(i: usize, j: usize, obstacle_grid: &Vec<Vec<i32>>, f: &mut Vec<Vec<i32>>) -> i32 {\n        let m = obstacle_grid.len();\n        let n = obstacle_grid[0].len();\n        if i >= m || j >= n || obstacle_grid[i][j] == 1 {\n            return 0;\n        }\n        if i == m - 1 && j == n - 1 {\n            return 1;\n        }\n        if f[i][j] != -1 {\n            return f[i][j];\n        }\n        let down = Self::dfs(i + 1, j, obstacle_grid, f);\n        let right = Self::dfs(i, j + 1, obstacle_grid, f);\n        f[i][j] = down + right;\n        f[i][j]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    uniquePathsWithObstacles(obstacleGrid: number[][]): number  {\n    const m = obstacleGrid.length;\n    const n = obstacleGrid[0].length;\n    const f: number[][] = Array.from({ length: m }, () => Array(n).fill(-1));\n    const dfs = (i: number, j: number): number => {\n        if (i >= m || j >= n || obstacleGrid[i][j] === 1) {\n            return 0;\n        }\n        if (i === m - 1 && j === n - 1) {\n            return 1;\n        }\n        if (f[i][j] === -1) {\n            f[i][j] = dfs(i + 1, j) + dfs(i, j + 1);\n        }\n        return f[i][j];\n    };\n    return dfs(0, 0);\n}\n}",
        "initialCode": "class Solution {\n    uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "longest-palindromic-substring": {
    "title": "Longest Palindromic Substring",
    "pattern": "Expand Around Center",
    "patternEmoji": "\ud83d\udcdc",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(1)",
    "oneliner": "Expand from each center (2n-1 centers).",
    "intuition": [
      "\ud83c\udfaf Find longest palindromic substring.",
      "\ud83e\udde0 Expand from each center (odd and even length).",
      "\ud83d\udca1 Track start and maxLen."
    ],
    "testCases": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\""
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\""
      }
    ],
    "code": "class Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find longest palindromic substring.\n        - \ud83e\udde0 Expand from each center (odd and even length).\n        - \ud83d\udca1 Track start and maxLen.\n        \"\"\"\n        if len(s) < 2:\n            return s\n        start, maxLen = 0, 1\n\n        def expand(l, r):\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                l -= 1\n                r += 1\n            return r - l - 1\n\n        for i in range(len(s)):  # Iterate through the range.\n            len1 = expand(i, i)\n            len2 = expand(i, i + 1)\n            length = max(len1, len2)  # Take the maximum value.\n            if length > maxLen:\n                maxLen = length\n                start = i - (length - 1) // 2\n        return s[start:start + maxLen]",
    "keyInsight": "There are 2n-1 centers (n single + n-1 pairs).",
    "visualizationType": "tree",
    "initialState": "babad",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0,
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 4,
            "label": "end"
          }
        ],
        "transientMessage": "Initial string 'babad' with length 5, start=0, maxLen=1",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          },
          {
            "index": 0,
            "label": "l"
          },
          {
            "index": 0,
            "label": "r"
          }
        ],
        "transientMessage": "Expanding around center i=0, checking s[0] with itself",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          0
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "i"
          }
        ],
        "transientMessage": "Palindrome 'b' found with length 1, maxLen remains 1",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "i"
          },
          {
            "index": 1,
            "label": "l"
          },
          {
            "index": 1,
            "label": "r"
          }
        ],
        "transientMessage": "Expanding around center i=1, checking s[1] with itself",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          2
        ],
        "color": "success",
        "pointers": [
          {
            "index": 1,
            "label": "i"
          },
          {
            "index": 0,
            "label": "l"
          },
          {
            "index": 2,
            "label": "r"
          }
        ],
        "transientMessage": "Palindrome 'bab' found with length 3, updating maxLen=3",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "i"
          },
          {
            "index": 1,
            "label": "l"
          },
          {
            "index": 2,
            "label": "r"
          }
        ],
        "transientMessage": "Checking even-length palindrome at i=1, expanding around s[1] and s[2]",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          2
        ],
        "color": "error",
        "pointers": [
          {
            "index": 1,
            "label": "l"
          },
          {
            "index": 2,
            "label": "r"
          }
        ],
        "transientMessage": "s[1]='a' != s[2]='b', no even-length palindrome here",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "i"
          },
          {
            "index": 2,
            "label": "l"
          },
          {
            "index": 2,
            "label": "r"
          }
        ],
        "transientMessage": "Expanding around center i=2, checking s[2] with itself",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 2,
            "label": "i"
          },
          {
            "index": 1,
            "label": "l"
          },
          {
            "index": 3,
            "label": "r"
          }
        ],
        "transientMessage": "Palindrome 'aba' found with length 3, same as current maxLen",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          2
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "start"
          },
          {
            "index": 2,
            "label": "end"
          }
        ],
        "transientMessage": "Returning longest palindromic substring 'bab'",
        "arrayState": [
          "b",
          "a",
          "b",
          "a",
          "d"
        ]
      }
    ],
    "description": "Expand from each center (2n-1 centers).\n\nFind longest palindromic substring.\nExpand from each center (odd and even length).",
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\""
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find longest palindromic substring.",
      "Expand from each center (odd and even length).",
      "Track start and maxLen."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "XYQecbcd6_c",
    "problemStatement": "Given a string s, return the longest palindromic substring in s.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Expand Around Center: Expand from each center (2n-1 centers).",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestPalindrome(self, s):\n        pass\n\n        def expand(l, r):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def longestPalindrome(s):\n    res = \"\"\n    for i in range(len(s)):\n        # Odd\n        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > len(res): res = s[l:r+1]\n            l -= 1\n            r += 1\n        # Even\n        l, r = i, i + 1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > len(res): res = s[l:r+1]\n            l -= 1\n            r += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find longest palindromic substring.",
          "\ud83e\udde0 Expand from each center (odd and even length).",
          "\ud83d\udca1 Track start and maxLen."
        ],
        "code": "def longestPalindrome(s):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find longest palindromic substring.\n    - \ud83e\udde0 Expand from each center (odd and even length).\n    - \ud83d\udca1 Track start and maxLen.\n    \"\"\"\n    if len(s) < 2:\n        return s\n    start, maxLen = 0, 1\n    \n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return r - l - 1\n    \n    for i in range(len(s)):  # Iterate through the range.\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        length = max(len1, len2)  # Take the maximum value.\n        if length > maxLen:\n            maxLen = length\n            start = i - (length - 1) // 2\n    return s[start:start + maxLen]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String __init__(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String __init__(String s) {\n        return \"\";\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string __init__(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string __init__(string s) {\n        return \"\";\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestPalindrome(s string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestPalindrome(s string) string {\n\tn := len(s)\n\tf := make([][]bool, n)\n\tfor i := range f {\n\t\tf[i] = make([]bool, n)\n\t\tfor j := range f[i] {\n\t\t\tf[i][j] = true\n\t\t}\n\t}\n\tk, mx := 0, 1\n\tfor i := n - 2; i >= 0; i-- {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tf[i][j] = false\n\t\t\tif s[i] == s[j] {\n\t\t\t\tf[i][j] = f[i+1][j-1]\n\t\t\t\tif f[i][j] && mx < j-i+1 {\n\t\t\t\t\tmx = j - i + 1\n\t\t\t\t\tk = i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn s[k : k+mx]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn longest_palindrome(s: String) -> String {\n        let (n, mut ans) = (s.len(), &s[..1]);\n        let mut dp = vec![vec![false; n]; n];\n        let data: Vec<char> = s.chars().collect();\n\n        for end in 1..n {\n            for start in 0..=end {\n                if data[start] == data[end] {\n                    dp[start][end] = end - start < 2 || dp[start + 1][end - 1];\n                    if dp[start][end] && end - start + 1 > ans.len() {\n                        ans = &s[start..=end];\n                    }\n                }\n            }\n        }\n        ans.to_string()\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def longestPalindrome(self, s):\n        pass\n\n        def expand(l, r):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) { }\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "count-and-say",
      "title": "Count and Say",
      "difficulty": "Medium",
      "pattern": "Iterative with String Manipulation"
    }
  },
  "interleaving-string": {
    "title": "Interleaving String",
    "pattern": "2D DP",
    "patternEmoji": "\ud83e\udde9",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
    "intuition": [
      "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
      "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
      "\ud83d\udca1 Check if current char matches from s1 or s2."
    ],
    "testCases": [
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
        "output": "true"
      },
      {
        "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
        "output": "false"
      },
      {
        "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
        "output": "true"
      }
    ],
    "code": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Can s3 be formed by interleaving s1 and s2?\n        - \ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].\n        - \ud83d\udca1 Check if current char matches from s1 or s2.\n        \"\"\"\n        m, n = len(s1), len(s2)\n        if m + n != len(s3):\n            return False  # Condition not met.\n        dp = [False] * (n + 1)  # Initialize DP table to store results.\n        for i in range(m + 1):  # Iterate through the range.\n            for j in range(n + 1):  # Iterate through the range.\n                if i == 0 and j == 0:\n                    dp[j] = True\n                elif i == 0:\n                    dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n                elif j == 0:\n                    dp[j] = dp[j] and s1[i-1] == s3[i-1]\n                else:\n                    dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n        return dp[n]",
    "keyInsight": "Current s3 char must match either s1[i-1] or s2[j-1].",
    "visualizationType": "array",
    "initialState": "aadbbcbcac",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Interleaving String",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = a",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = a",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = d",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = b",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = b",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = c",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "a",
          "a",
          "d",
          "b",
          "b",
          "c",
          "b",
          "c",
          "a",
          "c"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].\n\nCan s3 be formed by interleaving s1 and s2?\ndp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
    "examples": [
      {
        "input": "s1 = \"aabcc\"; s2 = \"dbbca\"; s3 = \"aadbbcbcac\"",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Can s3 be formed by interleaving s1 and s2?",
      "dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
      "Check if current char matches from s1 or s2."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "3Rw3p9LrgvE",
    "problemStatement": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
    "suggestedNextQuestion": {
      "slug": "longest-common-subsequence",
      "title": "Longest Common Subsequence",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3): return False\n    def dfs(i, j):\n        if i == len(s1) and j == len(s2): return True\n        choose_s1, choose_s2 = False, False\n        if i < len(s1) and s1[i] == s3[i+j]:\n            choose_s1 = dfs(i+1, j)\n        if j < len(s2) and s2[j] == s3[i+j]:\n            choose_s2 = dfs(i, j+1)\n        return choose_s1 or choose_s2\n    return dfs(0, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
          "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
          "\ud83d\udca1 Check if current char matches from s1 or s2."
        ],
        "code": "def isInterleave(s1, s2, s3):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Can s3 be formed by interleaving s1 and s2?\n    - \ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].\n    - \ud83d\udca1 Check if current char matches from s1 or s2.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False  # Condition not met.\n    dp = [False] * (n + 1)  # Initialize DP table to store results.\n    for i in range(m + 1):  # Iterate through the range.\n        for j in range(n + 1):  # Iterate through the range.\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i-1] == s3[i-1]\n            else:\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n    return dp[n]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isInterleave(s1, s2, s3) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s1, s2, s3\n     * @return {any}\n     */\n    isInterleave(s1, s2, s3) {\n        const values = new Array(s1.length + 1).fill().map(() => []);\n\n        if (s1.length + s2.length !== s3.length) {\n          return false;\n        }\n\n        for (let i = 0; i <= s1.length; i++) {\n          for (let j = 0; j <= s2.length; j++) {\n            values[i][j] = i && values[i - 1][j] && s3[i + j - 1] === s1[i - 1]\n              || j && values[i][j - 1] && s3[i + j - 1] === s2[j - 1] || !i && !j;\n          }\n      }\n\n    return Boolean(values.pop().pop());\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    private Map<List<Integer>, Boolean> f = new HashMap<>();\n    private String s1;\n    private String s2;\n    private String s3;\n    private int m;\n    private int n;\n\n    public boolean isInterleave(String s1, String s2, String s3) {\n        m = s1.length();\n        n = s2.length();\n        if (m + n != s3.length()) {\n            return false;\n        }\n        this.s1 = s1;\n        this.s2 = s2;\n        this.s3 = s3;\n        return dfs(0, 0);\n    }\n\n    private boolean dfs(int i, int j) {\n        if (i >= m && j >= n) {\n            return true;\n        }\n        var key = List.of(i, j);\n        if (f.containsKey(key)) {\n            return f.get(key);\n        }\n        int k = i + j;\n        boolean ans = false;\n        if (i < m && s1.charAt(i) == s3.charAt(k) && dfs(i + 1, j)) {\n            ans = true;\n        }\n        if (!ans && j < n && s2.charAt(j) == s3.charAt(k) && dfs(i, j + 1)) {\n            ans = true;\n        }\n        f.put(key, ans);\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isInterleave(string s1, string s2, string s3) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        int m = s1.size(), n = s2.size();\n        if (m + n != s3.size()) {\n            return false;\n        }\n        vector<vector<int>> f(m + 1, vector<int>(n + 1, -1));\n        function<bool(int, int)> dfs = [&](int i, int j) {\n            if (i >= m && j >= n) {\n                return true;\n            }\n            if (f[i][j] != -1) {\n                return f[i][j] == 1;\n            }\n            f[i][j] = 0;\n            int k = i + j;\n            if (i < m && s1[i] == s3[k] && dfs(i + 1, j)) {\n                f[i][j] = 1;\n            }\n            if (!f[i][j] && j < n && s2[j] == s3[k] && dfs(i, j + 1)) {\n                f[i][j] = 1;\n            }\n            return f[i][j] == 1;\n        };\n        return dfs(0, 0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isInterleave(s1 string, s2 string, s3 string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isInterleave(s1 string, s2 string, s3 string) bool {\n\tm, n := len(s1), len(s2)\n\tif m+n != len(s3) {\n\t\treturn false\n\t}\n\n\tf := map[int]bool{}\n\tvar dfs func(int, int) bool\n\tdfs = func(i, j int) bool {\n\t\tif i >= m && j >= n {\n\t\t\treturn true\n\t\t}\n\t\tif v, ok := f[i*200+j]; ok {\n\t\t\treturn v\n\t\t}\n\t\tk := i + j\n\t\tf[i*200+j] = (i < m && s1[i] == s3[k] && dfs(i+1, j)) || (j < n && s2[j] == s3[k] && dfs(i, j+1))\n\t\treturn f[i*200+j]\n\t}\n\treturn dfs(0, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn is_interleave(s1: String, s2: String, s3: String) -> bool {\n        let n = s1.len();\n        let m = s2.len();\n\n        if s1.len() + s2.len() != s3.len() {\n            return false;\n        }\n\n        let mut record = vec![vec![-1; m + 1]; n + 1];\n\n        Self::dfs(\n            &mut record,\n            n,\n            m,\n            0,\n            0,\n            &s1.chars().collect(),\n            &s2.chars().collect(),\n            &s3.chars().collect(),\n        )\n    }\n\n    #[allow(dead_code)]\n    fn dfs(\n        record: &mut Vec<Vec<i32>>,\n        n: usize,\n        m: usize,\n        i: usize,\n        j: usize,\n        s1: &Vec<char>,\n        s2: &Vec<char>,\n        s3: &Vec<char>,\n    ) -> bool {\n        if i >= n && j >= m {\n            return true;\n        }\n\n        if record[i][j] != -1 {\n            return record[i][j] == 1;\n        }\n\n        // Set the initial value\n        record[i][j] = 0;\n        let k = i + j;\n\n        // Let's try `s1` first\n        if i < n && s1[i] == s3[k] && Self::dfs(record, n, m, i + 1, j, s1, s2, s3) {\n            record[i][j] = 1;\n        }\n\n        // If the first approach does not succeed, let's then try `s2`\n        if record[i][j] == 0\n            && j < m\n            && s2[j] == s3[k]\n            && Self::dfs(record, n, m, i, j + 1, s1, s2, s3)\n        {\n            record[i][j] = 1;\n        }\n\n        record[i][j] == 1\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isInterleave(s1: string, s2: string, s3: string): boolean  {\n    const m = s1.length;\n    const n = s2.length;\n    if (m + n !== s3.length) {\n        return false;\n    }\n    const f: number[][] = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    const dfs = (i: number, j: number): boolean => {\n        if (i >= m && j >= n) {\n            return true;\n        }\n        if (f[i][j]) {\n            return f[i][j] === 1;\n        }\n        f[i][j] = -1;\n        if (i < m && s1[i] === s3[i + j] && dfs(i + 1, j)) {\n            f[i][j] = 1;\n        }\n        if (f[i][j] === -1 && j < n && s2[j] === s3[i + j] && dfs(i, j + 1)) {\n            f[i][j] = 1;\n        }\n        return f[i][j] === 1;\n    };\n    return dfs(0, 0);\n}\n}",
        "initialCode": "class Solution {\n    isInterleave(s1: string, s2: string, s3: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "edit-distance": {
    "title": "Edit Distance",
    "pattern": "2D DP",
    "patternEmoji": "\u270f\ufe0f",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = min(insert, delete, replace) + 1.",
    "intuition": [
      "\ud83c\udfaf Min operations to convert word1 to word2.",
      "\ud83e\udde0 Three operations: insert, delete, replace.",
      "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
    ],
    "testCases": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3"
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5"
      }
    ],
    "code": "class Solution:\n    def minDistance(self, word1, word2):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min operations to convert word1 to word2.\n        - \ud83e\udde0 Three operations: insert, delete, replace.\n        - \ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1].\n        \"\"\"\n        m, n = len(word1), len(word2)\n        prev = list(range(n + 1))\n        for i in range(1, m + 1):  # Iterate through the range.\n            curr = [i] + [0] * n\n            for j in range(1, n + 1):  # Iterate through the range.\n                if word1[i-1] == word2[j-1]:\n                    curr[j] = prev[j-1]\n                else:\n                    curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])  # Take the minimum value.\n            prev = curr\n        return prev[n]",
    "keyInsight": "Replace = dp[i-1][j-1], Insert = dp[i][j-1], Delete = dp[i-1][j].",
    "visualizationType": "matrix",
    "initialState": [
      "h",
      "o",
      "r",
      "s",
      "e"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Edit Distance",
        "transientMessage": "Grid-based algorithm",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Step 1",
        "transientMessage": "Processing cell (1, 1)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Step 2",
        "transientMessage": "Processing cell (2, 2)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Step 3",
        "transientMessage": "Processing cell (3, 3)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            3,
            3
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Step 4",
        "transientMessage": "Processing cell (0, 4)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            4
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Step 5",
        "transientMessage": "Processing cell (1, 0)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Step 6",
        "transientMessage": "Processing cell (2, 1)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            2,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Step 7",
        "transientMessage": "Processing cell (3, 2)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            3,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Step 8",
        "transientMessage": "Processing cell (0, 3)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            3
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Step 9",
        "transientMessage": "Processing cell (1, 4)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            1,
            4
          ]
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Step 10",
        "transientMessage": "Processing cell (2, 0)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            2,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Step 11",
        "transientMessage": "Processing cell (3, 1)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            3,
            1
          ]
        ],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = min(insert, delete, replace) + 1.\n\nMin operations to convert word1 to word2.\nThree operations: insert, delete, replace.",
    "examples": [
      {
        "input": "word1 = \"horse\"; word2 = \"ros\"",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min operations to convert word1 to word2.",
      "Three operations: insert, delete, replace.",
      "If chars match, dp[i][j] = dp[i-1][j-1]."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "XYi2-LPrwm4",
    "problemStatement": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = min(insert, delete, replace) + 1.",
    "suggestedNextQuestion": {
      "slug": "house-robber",
      "title": "House Robber",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def minDistance(self, word1, word2):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def minDistance(word1, word2):\n    def solve(i, j):\n        if i == len(word1): return len(word2) - j\n        if j == len(word2): return len(word1) - i\n        if word1[i] == word2[j]:\n            return solve(i + 1, j + 1)\n        else:\n            return 1 + min(solve(i+1, j),    # Delete\n                           solve(i, j+1),    # Insert\n                           solve(i+1, j+1))  # Replace\n    return solve(0, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Min operations to convert word1 to word2.",
          "\ud83e\udde0 Three operations: insert, delete, replace.",
          "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
        ],
        "code": "def minDistance(word1, word2):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to convert word1 to word2.\n    - \ud83e\udde0 Three operations: insert, delete, replace.\n    - \ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1].\n    \"\"\"\n    m, n = len(word1), len(word2)\n    prev = list(range(n + 1))\n    for i in range(1, m + 1):  # Iterate through the range.\n        curr = [i] + [0] * n\n        for j in range(1, n + 1):  # Iterate through the range.\n            if word1[i-1] == word2[j-1]:\n                curr[j] = prev[j-1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])  # Take the minimum value.\n        prev = curr\n    return prev[n]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minDistance(word1, word2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} word1, word2\n     * @return {any}\n     */\n    minDistance(word1, word2) {\n        const m = word1.length;\n        const n = word2.length;\n        const f = Array(m + 1)\n            .fill(0)\n            .map(() => Array(n + 1).fill(0));\n        for (let j = 1; j <= n; ++j) {\n            f[0][j] = j;\n        }\n        for (let i = 1; i <= m; ++i) {\n            f[i][0] = i;\n            for (let j = 1; j <= n; ++j) {\n                if (word1[i - 1] === word2[j - 1]) {\n                    f[i][j] = f[i - 1][j - 1];\n                } else {\n                    f[i][j] = Math.min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1;\n                }\n            }\n    }\n    return f[m][n];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minDistance(String word1, String word2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int m = word1.length(), n = word2.length();\n        int[][] f = new int[m + 1][n + 1];\n        for (int j = 1; j <= n; ++j) {\n            f[0][j] = j;\n        }\n        for (int i = 1; i <= m; ++i) {\n            f[i][0] = i;\n            for (int j = 1; j <= n; ++j) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    f[i][j] = f[i - 1][j - 1];\n                } else {\n                    f[i][j] = Math.min(f[i - 1][j], Math.min(f[i][j - 1], f[i - 1][j - 1])) + 1;\n                }\n            }\n        }\n        return f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minDistance(string word1, string word2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size(), n = word2.size();\n        int f[m + 1][n + 1];\n        for (int j = 0; j <= n; ++j) {\n            f[0][j] = j;\n        }\n        for (int i = 1; i <= m; ++i) {\n            f[i][0] = i;\n            for (int j = 1; j <= n; ++j) {\n                if (word1[i - 1] == word2[j - 1]) {\n                    f[i][j] = f[i - 1][j - 1];\n                } else {\n                    f[i][j] = min({f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]}) + 1;\n                }\n            }\n        }\n        return f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minDistance(word1 string, word2 string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minDistance(word1 string, word2 string) int {\n\tm, n := len(word1), len(word2)\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tfor j := 1; j <= n; j++ {\n\t\tf[0][j] = j\n\t}\n\tfor i := 1; i <= m; i++ {\n\t\tf[i][0] = i\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif word1[i-1] == word2[j-1] {\n\t\t\t\tf[i][j] = f[i-1][j-1]\n\t\t\t} else {\n\t\t\t\tf[i][j] = min(f[i-1][j], min(f[i][j-1], f[i-1][j-1])) + 1\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [72] Edit Distance\n *\n * Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\n *\n * You have the following 3 operations permitted on a word:\n *\n * <ol>\n * \tInsert a character\n * \tDelete a character\n * \tReplace a character\n * </ol>\n *\n * Example 1:\n *\n *\n * Input: word1 = \"horse\", word2 = \"ros\"\n * Output: 3\n * Explanation:\n * horse -> rorse (replace 'h' with 'r')\n * rorse -> rose (remove 'r')\n * rose -> ros (remove 'e')\n *\n *\n * Example 2:\n *\n *\n * Input: word1 = \"intention\", word2 = \"execution\"\n * Output: 5\n * Explanation:\n * intention -> inention (remove 't')\n * inention -> enention (replace 'i' with 'e')\n * enention -> exention (replace 'n' with 'x')\n * exention -> exection (replace 'n' with 'c')\n * exection -> execution (insert 'u')\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/edit-distance/\n// discuss: https://leetcode.com/problems/edit-distance/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn min_distance(word1: String, word2: String) -> i32 {\n        0\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_72() {}\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minDistance(self, word1, word2):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minDistance(word1: string, word2: string): number  {\n    const m = word1.length;\n    const n = word2.length;\n    const f: number[][] = Array(m + 1)\n        .fill(0)\n        .map(() => Array(n + 1).fill(0));\n    for (let j = 1; j <= n; ++j) {\n        f[0][j] = j;\n    }\n    for (let i = 1; i <= m; ++i) {\n        f[i][0] = i;\n        for (let j = 1; j <= n; ++j) {\n            if (word1[i - 1] === word2[j - 1]) {\n                f[i][j] = f[i - 1][j - 1];\n            } else {\n                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    return f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    minDistance(word1: string, word2: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    }
  },
  "best-time-to-buy-and-sell-stock-iii": {
    "title": "Best Time to Buy and Sell Stock III",
    "pattern": "State Machine DP",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track 4 states: buy1, sell1, buy2, sell2.",
    "intuition": [
      "\ud83c\udfaf Max profit with at most 2 transactions.",
      "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
      "\ud83d\udca1 Update states in reverse order."
    ],
    "testCases": [
      {
        "input": "prices = [3,3,5,0,0,3,1,4]",
        "output": "6"
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4"
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Max profit with at most 2 transactions.\n        - \ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.\n        - \ud83d\udca1 Update states in reverse order.\n        \"\"\"\n        buy1 = buy2 = float('-inf')\n        sell1 = sell2 = 0\n        for p in prices:  # Iterate over elements.\n            sell2 = max(sell2, buy2 + p)  # Take the maximum value.\n            buy2 = max(buy2, sell1 - p)  # Take the maximum value.\n            sell1 = max(sell1, buy1 + p)  # Take the maximum value.\n            buy1 = max(buy1, -p)  # Take the maximum value.\n        return sell2",
    "keyInsight": "State machine: buy1 -> sell1 -> buy2 -> sell2.",
    "visualizationType": "array",
    "initialState": [
      3,
      3,
      5,
      0,
      0,
      3,
      1,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Best Time to Buy and Sell Stock III",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          3,
          3,
          5,
          0,
          0,
          3,
          1,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 3",
        "arrayState": [
          3,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          3,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 3",
        "arrayState": [
          3,
          3,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          3,
          3,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 5",
        "arrayState": [
          3,
          3,
          5,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          3,
          3,
          5,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          3,
          3,
          5,
          3,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          3,
          3,
          5,
          3,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 4",
        "arrayState": [
          3,
          3,
          5,
          3,
          4,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          3,
          3,
          5,
          3,
          4,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          3,
          3,
          5,
          3,
          4,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          7
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          3,
          3,
          5,
          3,
          4,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Track 4 states: buy1, sell1, buy2, sell2.\n\nMax profit with at most 2 transactions.\n4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
    "examples": [
      {
        "input": "prices = [3,3,5,0,0,3,1,4]",
        "output": "6"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Max profit with at most 2 transactions.",
      "4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
      "Update states in reverse order."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "37s1_xBiqH0",
    "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "State Machine DP: Track 4 states: buy1, sell1, buy2, sell2.",
    "suggestedNextQuestion": {
      "slug": "best-time-to-buy-and-sell-stock-iv",
      "title": "Best Time to Buy and Sell Stock IV",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
    "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxProfit(prices):\n    # Buy1, Sell1, Buy2, Sell2\n    t1_cost, t2_cost = float('inf'), float('inf')\n    t1_profit, t2_profit = 0, 0\n    for p in prices:\n        t1_cost = min(t1_cost, p)\n        t1_profit = max(t1_profit, p - t1_cost)\n        t2_cost = min(t2_cost, p - t1_profit)\n        t2_profit = max(t2_profit, p - t2_cost)\n    return t2_profit"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Max profit with at most 2 transactions.",
          "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
          "\ud83d\udca1 Update states in reverse order."
        ],
        "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most 2 transactions.\n    - \ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.\n    - \ud83d\udca1 Update states in reverse order.\n    \"\"\"\n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n    for p in prices:  # Iterate over elements.\n        sell2 = max(sell2, buy2 + p)  # Take the maximum value.\n        buy2 = max(buy2, sell1 - p)  # Take the maximum value.\n        sell1 = max(sell1, buy1 + p)  # Take the maximum value.\n        buy1 = max(buy1, -p)  # Take the maximum value.\n    return sell2"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProfit(prices) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} prices\n     * @return {any}\n     */\n    maxProfit(prices) {\n        const costs = [prices[0]];\n        const profits = new Array(prices.length).fill(0);\n\n        for (let i = 0; i < 2; i++) {\n          for (let j = 1; j < prices.length; j++) {\n            costs[j] = Math.min(costs[j - 1], prices[j] - profits[j]);\n            profits[j] = Math.max(profits[j - 1], prices[j] - costs[j]);\n          }\n      }\n\n    return profits[profits.length - 1];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        // \u7b2c\u4e00\u6b21\u4e70\u5165\uff0c\u7b2c\u4e00\u6b21\u5356\u51fa\uff0c\u7b2c\u4e8c\u6b21\u4e70\u5165\uff0c\u7b2c\u4e8c\u6b21\u5356\u51fa\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.length; ++i) {\n            f1 = Math.max(f1, -prices[i]);\n            f2 = Math.max(f2, f1 + prices[i]);\n            f3 = Math.max(f3, f2 - prices[i]);\n            f4 = Math.max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProfit(vector<int>& prices) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;\n        for (int i = 1; i < prices.size(); ++i) {\n            f1 = max(f1, -prices[i]);\n            f2 = max(f2, f1 + prices[i]);\n            f3 = max(f3, f2 - prices[i]);\n            f4 = max(f4, f3 + prices[i]);\n        }\n        return f4;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) int {\n\tf1, f2, f3, f4 := -prices[0], 0, -prices[0], 0\n\tfor i := 1; i < len(prices); i++ {\n\t\tf1 = max(f1, -prices[i])\n\t\tf2 = max(f2, f1+prices[i])\n\t\tf3 = max(f3, f2-prices[i])\n\t\tf4 = max(f4, f3+prices[i])\n\t}\n\treturn f4\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        let mut f1 = -prices[0];\n        let mut f2 = 0;\n        let mut f3 = -prices[0];\n        let mut f4 = 0;\n        let n = prices.len();\n\n        for i in 1..n {\n            f1 = std::cmp::max(f1, -prices[i]);\n            f2 = std::cmp::max(f2, f1 + prices[i]);\n            f3 = std::cmp::max(f3, f2 - prices[i]);\n            f4 = std::cmp::max(f4, f3 + prices[i]);\n        }\n\n        f4\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProfit(prices: number[]): number  {\n    let [f1, f2, f3, f4] = [-prices[0], 0, -prices[0], 0];\n    for (let i = 1; i < prices.length; ++i) {\n        f1 = Math.max(f1, -prices[i]);\n        f2 = Math.max(f2, f1 + prices[i]);\n        f3 = Math.max(f3, f2 - prices[i]);\n        f4 = Math.max(f4, f3 + prices[i]);\n    }\n    return f4;\n}\n}",
        "initialCode": "class Solution {\n    maxProfit(prices: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "best-time-to-buy-and-sell-stock-iv": {
    "title": "Best Time to Buy and Sell Stock IV",
    "pattern": "DP",
    "patternEmoji": "\ud83d\udcc8",
    "timeComplexity": "O(n*k)",
    "spaceComplexity": "O(k)",
    "oneliner": "Generalize to k transactions with 2k states.",
    "intuition": [
      "\ud83c\udfaf Max profit with at most k transactions.",
      "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
      "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
    ],
    "testCases": [
      {
        "input": "k = 2, prices = [2,4,1]",
        "output": "2"
      },
      {
        "input": "k = 2, prices = [3,2,6,5,0,3]",
        "output": "7"
      }
    ],
    "code": "class Solution:\n    def maxProfit(self, k, prices):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Max profit with at most k transactions.\n        - \ud83e\udde0 dp[i] = max profit after i-th transaction.\n        - \ud83d\udca1 If k >= n/2, it's unlimited transactions.\n        \"\"\"\n        if not prices:\n            return 0\n        n = len(prices)\n        if k >= n // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))  # Iterate through the range.\n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        for p in prices:  # Iterate over elements.\n            for i in range(1, k + 1):  # Iterate through the range.\n                sell[i] = max(sell[i], buy[i] + p)  # Take the maximum value.\n                buy[i] = max(buy[i], sell[i-1] - p)  # Take the maximum value.\n        return sell[k]",
    "keyInsight": "If k >= n/2, simplify to unlimited transactions.",
    "visualizationType": "array",
    "initialState": [
      3,
      2,
      6,
      5,
      0,
      3
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Initial prices array with 6 elements",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "p=3"
          }
        ],
        "transientMessage": "Processing price 3, initializing buy and sell arrays",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "p=2"
          }
        ],
        "transientMessage": "Processing price 2, updating buy[1] and sell[1]",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "p=6"
          }
        ],
        "transientMessage": "Processing price 6, potential profit from buying at 2 to selling at 6",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "p=5"
          }
        ],
        "transientMessage": "Processing price 5, evaluating whether to sell or hold",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 4,
            "label": "p=0"
          }
        ],
        "transientMessage": "Processing price 0, considering new buying opportunity",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 5,
            "label": "p=3"
          }
        ],
        "transientMessage": "Processing final price 3, completing transactions",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          2
        ],
        "color": "success",
        "pointers": [],
        "transientMessage": "Best transaction identified: buy at 2 (index 1) and sell at 6 (index 2)",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4,
          5
        ],
        "color": "success",
        "pointers": [],
        "transientMessage": "Second transaction: buy at 0 (index 4) and sell at 3 (index 5)",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Maximum profit calculated: (6-2) + (3-0) = 7",
        "arrayState": [
          3,
          2,
          6,
          5,
          0,
          3
        ]
      }
    ],
    "description": "Generalize to k transactions with 2k states.\n\nMax profit with at most k transactions.\ndp[i] = max profit after i-th transaction.",
    "examples": [
      {
        "input": "k = 2; prices = [3,2,6,5,0,3]",
        "output": "7"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Max profit with at most k transactions.",
      "dp[i] = max profit after i-th transaction.",
      "If k >= n/2, it's unlimited transactions."
    ],
    "relatedProblems": [
      "climbing-stairs",
      "coin-change",
      "longest-increasing-subsequence"
    ],
    "videoId": "Pw6lrYANjz4",
    "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "DP: Generalize to k transactions with 2k states.",
    "suggestedNextQuestion": {
      "slug": "burst-balloons",
      "title": "Burst Balloons",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
    "initialCode": "class Solution:\n    def maxProfit(self, k, prices):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxProfit(k, prices):\n    if not prices: return 0\n    if 2*k >= len(prices):\n        # Unlimited transactions\n        return sum(max(0, prices[i] - prices[i-1]) for i in range(1, len(prices)))\n    \n    dp = [[0]*len(prices) for _ in range(k+1)]\n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, len(prices)):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    return dp[k][-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n*k)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Max profit with at most k transactions.",
          "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
          "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
        ],
        "code": "def maxProfit(k, prices):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Max profit with at most k transactions.\n    - \ud83e\udde0 dp[i] = max profit after i-th transaction.\n    - \ud83d\udca1 If k >= n/2, it's unlimited transactions.\n    \"\"\"\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))  # Iterate through the range.\n    buy = [float('-inf')] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:  # Iterate over elements.\n        for i in range(1, k + 1):  # Iterate through the range.\n            sell[i] = max(sell[i], buy[i] + p)  # Take the maximum value.\n            buy[i] = max(buy[i], sell[i-1] - p)  # Take the maximum value.\n    return sell[k]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProfit(k, prices) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} k, prices\n     * @return {any}\n     */\n    maxProfit(k, prices) {\n        if (prices.length < 2 || k === 0) return 0;\n\n        if (k >= prices.length / 2) {\n          let profit = 0;\n          for (let i = 1; i < prices.length; i++) {\n            profit += prices[i] > prices[i - 1] ? (prices[i] - prices[i - 1]) : 0;\n          }\n          return profit;\n        }\n\n        const buy = new Array(k + 1).fill(-Infinity);\n        const sell = new Array(k + 1).fill(0);\n        for (let i = 0; i < prices.length; i++) {\n          for (let j = k; j >= 1; j--) {\n            sell[j] = Math.max(sell[j], buy[j] + prices[i]);\n            buy[j] = Math.max(buy[j], sell[j - 1] - prices[i]);\n          }\n      }\n\n    return sell[k];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private Integer[][][] f;\n    private int[] prices;\n    private int n;\n\n    public int maxProfit(int k, int[] prices) {\n        n = prices.length;\n        this.prices = prices;\n        f = new Integer[n][k + 1][2];\n        return dfs(0, k, 0);\n    }\n\n    private int dfs(int i, int j, int k) {\n        if (i >= n) {\n            return 0;\n        }\n        if (f[i][j][k] != null) {\n            return f[i][j][k];\n        }\n        int ans = dfs(i + 1, j, k);\n        if (k > 0) {\n            ans = Math.max(ans, prices[i] + dfs(i + 1, j, 0));\n        } else if (j > 0) {\n            ans = Math.max(ans, -prices[i] + dfs(i + 1, j - 1, 1));\n        }\n        return f[i][j][k] = ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProfit(int k, vector<int>& prices) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int n = prices.size();\n        int f[n][k + 1][2];\n        memset(f, -1, sizeof(f));\n        function<int(int, int, int)> dfs = [&](int i, int j, int k) -> int {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i][j][k] != -1) {\n                return f[i][j][k];\n            }\n            int ans = dfs(i + 1, j, k);\n            if (k) {\n                ans = max(ans, prices[i] + dfs(i + 1, j, 0));\n            } else if (j) {\n                ans = max(ans, -prices[i] + dfs(i + 1, j - 1, 1));\n            }\n            return f[i][j][k] = ans;\n        };\n        return dfs(0, k, 0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(k int, prices []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(k int, prices []int) int {\n\tn := len(prices)\n\tf := make([][][2]int, n)\n\tfor i := range f {\n\t\tf[i] = make([][2]int, k+1)\n\t\tfor j := range f[i] {\n\t\t\tf[i][j] = [2]int{-1, -1}\n\t\t}\n\t}\n\tvar dfs func(i, j, k int) int\n\tdfs = func(i, j, k int) int {\n\t\tif i >= n {\n\t\t\treturn 0\n\t\t}\n\t\tif f[i][j][k] != -1 {\n\t\t\treturn f[i][j][k]\n\t\t}\n\t\tans := dfs(i+1, j, k)\n\t\tif k > 0 {\n\t\t\tans = max(ans, prices[i]+dfs(i+1, j, 0))\n\t\t} else if j > 0 {\n\t\t\tans = max(ans, -prices[i]+dfs(i+1, j-1, 1))\n\t\t}\n\t\tf[i][j][k] = ans\n\t\treturn ans\n\t}\n\treturn dfs(0, k, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [188] Best Time to Buy and Sell Stock IV\n *\n * Say you have an array for which the i^th element is the price of a given stock on day i.\n *\n * Design an algorithm to find the maximum profit. You may complete at most k transactions.\n *\n * Note:<br />\n * You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n *\n * Example 1:\n *\n *\n * Input: [2,4,1], k = 2\n * Output: 2\n * Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n *\n *\n * Example 2:\n *\n *\n * Input: [3,2,6,5,0,3], k = 2\n * Output: 7\n * Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.\n *              Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\n// discuss: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n/*\n\u5df2\u7ecf\u5728 #123 \u91cc\u89e3\u8fc7\u4e86, \u4e3a\u4e86\u65b9\u4fbf\u9605\u8bfb\u76f4\u63a5\u628a\u90a3\u9898\u7684\u5206\u6790\u62f7\u8d1d\u5230\u8fd9\u91cc\n\n\u5148\u8003\u8651\u53ea\u8fdb\u884c 1 \u6b21\u4ea4\u6613\u7684\u60c5\u51b5, \u6211\u4eec\u6c42\u4ee5 i *\u4e3a\u552e\u51fa\u70b9*, \u53ea\u8fdb\u884c 1 \u6b21\u4ea4\u6613\u83b7\u5f97\u7684\u6700\u5927\u5229\u6da6, \u90a3\u4e48:\n\nf[i] = if f[i-1] > 0 { f[i-1] } else { 0 } + prices[i] - prices[i-1]\n\n\u8fd9\u5f88\u5bb9\u6613\u89e3, \u89e3\u5b8c\u4e4b\u540e\u627e\u51fa f \u91cc\u7684\u6700\u5927\u503c\u5373\u53ef, \u4f46\u8fd9\u4e0d\u5bb9\u6613\u63a8\u5e7f\u5230 K \u6b21\u4ea4\u6613\u7684\u60c5\u51b5, \u56e0\u4e3a\u8fd9\u65f6 f[i] \u4e0d\u4ee3\u8868\u5230 i *\u4e3a\u6b62*\u7684\u6700\u5927\u5229\u6da6, \u65e0\u6cd5\u4f5c\u4e3a\u5355\u72ec\u7684\u4ea4\u6613\u5e2e\u52a9\u9012\u63a8\n(\u5230 i \u4e3a\u6b62\u7684\u542b\u4e49\u662f\u552e\u51fa\u70b9\u53ef\u4ee5\u5728 [0,i] \u4e4b\u95f4)\n\n\u6211\u4eec\u53ef\u4ee5\u7a0d\u4f5c\u6539\u8fdb, \u53d8\u6210\u6c42\u4ee5 i \u4e3a\u7ed3\u675f\u70b9, \u53ea\u8fdb\u884c 1 \u6b21\u4ea4\u6613\u83b7\u5f97\u7684\u6700\u5927\u5229\u6da6, \u90a3\u4e48:\n\nf[i] = max(\n   f[i-1],\n   prices[i] - min(prices[j] { j in [0, i-1] })\n)\n\n\u8fd9\u4ecd\u7136\u662f\u4e00\u4e2a O(N) \u7684\u89e3\u6cd5, \u56e0\u4e3a min(prices[j] { j in [0, i-1] }) \u4e0d\u9700\u8981\u904d\u5386, \u53ef\u4ee5\u5728\u9012\u63a8\u8fc7\u7a0b\u4e2d\u76f4\u63a5\u7ef4\u62a4\u597d\n\n\u73b0\u5728\u518d\u63a8\u5e7f\u5230\u8fdb\u884c K \u6b21\u4ea4\u6613\u7684\u60c5\u51b5, \u90a3\u6211\u4eec\u8981\u6c42\u4ee5 i \u4e3a\u7ed3\u675f\u70b9, \u8fdb\u884c k \u6b21\u4ea4\u6613\u83b7\u5f97\u7684\u6700\u5927\u5229\u6da6, \u8fd9\u65f6\u6709\u4e86\u53d8\u5316, \u6211\u4eec\u53ef\u4ee5\u5728 j \u4e4b\u524d\u518d\u8fdb\u884c K - 1 \u6b21\u4ea4\u6613:\n\nf[k, i] = max(\n   f[k, i-1],\n   prices[i] + max(f[k-1, j] - prices[j]) { j in [0, i-1] } )\n)\n\n\u663e\u7136, f[0, i] = 0, f[k, 0] = 0\n\n\u8fd9\u4e2a\u7b97\u6cd5\u53ef\u4ee5\u5f62\u8c61\u5730\u63cf\u8ff0\u4e00\u4e0b, \u5728 k = 1 \u65f6, \u6211\u4eec\u6bcf\u6b21\u8981\u627e\u7684\u5c31\u662f i \u4e4b\u524d\u7684\u6700\u4f4e\u8c37\u70b9\u4f5c\u4e3a\u8fd9\u6b21\u4ea4\u6613\u7684\u5f00\u59cb\u70b9 j, \u800c\u5f53 k > 1 \u65f6,\n\u6211\u4eec i \u4e4b\u524d\u5c31\u6709\u53ef\u80fd\u5df2\u7ecf\u8fdb\u884c\u8fc7\u4ea4\u6613\u4e86, \u8fd9\u65f6\u6211\u4eec\u5728\u627e\u5f00\u59cb\u70b9 j \u65f6, \u5c31\u8981\u540c\u65f6\u8003\u8651 \"\u76f4\u5230 j \u4e3a\u6b62, k-1 \u6b21\u4ea4\u6613\u7684\u6700\u5927\u6536\u76ca\" - \"j \u672c\u8eab\u7684\u503c\". \u4ee5\u6b64\u6765\u627e\u5230\u4e00\u4e2a\u6700\u4f73\u70b9 j\n\n\u5728\u5b9e\u73b0\u65f6, \u5047\u5982\u7528 Bottom-Up \u9012\u63a8, \u90a3\u4e48\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a vec[i], \u56e0\u4e3a\u6bcf\u8f6e\u9012\u63a8\u65f6\u53ea\u4f1a\u8003\u8651\u4e0a\u4e00\u8f6e\u7684\u6570\u636e, \u6211\u4eec\u53ef\u4ee5\u590d\u7528\u8fd9\u4e2a O(N) \u7684\u989d\u5916\u5b58\u50a8\u7a7a\u95f4\n\n\u6700\u540e, \u8fd9\u9898\u4f1a\u7ed9 k \u975e\u5e38\u5927\u7684 corner case, \u5b9e\u9645\u4e0a k \u5927\u4e8e prices.len() / 2 \u540e\u9762\u5c31\u6ca1\u6709\u610f\u4e49\u4e86, \u53ef\u4ee5 shortcut \u6389(== \u5141\u8bb8\u65e0\u7a77\u6b21\u4ea4\u6613\u7684\u573a\u666f), \u4e0b\u9762\u5199\u7684\u6bd4\u8f83\u7cd9,\n\u76f4\u63a5\u9650\u5236\u4e86\u4e00\u4e0b\u5faa\u73af\u6b21\u6570, \u5b9e\u9645\u8dd1\u7684\u65f6\u5019\u8fd0\u884c\u65f6\u95f4\u4f1a\u957f\u4e00\u70b9\n*/\nimpl Solution {\n    pub fn max_profit(k: i32, prices: Vec<i32>) -> i32 {\n        if prices.is_empty() {\n            return 0;\n        }\n        let max_trans = k as usize;\n        let mut cache = vec![0; prices.len()];\n        for _ in 0..usize::min(max_trans, prices.len() / 2 + 1) {\n            // best_by_in \u7ef4\u62a4\u4e86\u8003\u8651\u524d N \u6b21\u4ea4\u6613\u7684\u6700\u4f73\u7684\u4e70\u5165\u70b9, \u5373 max(f[k-1, j] - prices[j]) { j in [0, i-1] }\n            let mut best_buy_in = cache[0] - prices[0];\n            for i in 1..prices.len() {\n                // \u590d\u7528 vec \u524d\u6682\u5b58\u4e00\u4e0b\u524d\u4e00\u6b21\u7684\u8ba1\u7b97\u7ed3\u679c\n                let temp = cache[i];\n                cache[i] = i32::max(cache[i - 1], best_buy_in + prices[i]);\n                // \u66f4\u65b0 best_buy_in\n                best_buy_in = i32::max(best_buy_in, temp - prices[i]);\n            }\n        }\n        return *cache.last().unwrap();\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_188() {\n        assert_eq!(Solution::max_profit(2, vec![3, 2, 6, 5, 0, 3]), 7);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProfit(self, k, prices):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProfit(k: number, prices: number[]): number  {\n    const n = prices.length;\n    const f = Array.from({ length: n }, () =>\n        Array.from({ length: k + 1 }, () => Array.from({ length: 2 }, () => -1)),\n    );\n    const dfs = (i: number, j: number, k: number): number => {\n        if (i >= n) {\n            return 0;\n        }\n        if (f[i][j][k] !== -1) {\n            return f[i][j][k];\n        }\n        let ans = dfs(i + 1, j, k);\n        if (k) {\n            ans = Math.max(ans, prices[i] + dfs(i + 1, j, 0));\n        } else if (j) {\n            ans = Math.max(ans, -prices[i] + dfs(i + 1, j - 1, 1));\n        }\n        return (f[i][j][k] = ans);\n    };\n    return dfs(0, k, 0);\n}\n}",
        "initialCode": "class Solution {\n    maxProfit(k: number, prices: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "maximal-square": {
    "title": "Maximal Square",
    "pattern": "2D DP",
    "patternEmoji": "\u2b1b",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
    "intuition": [
      "\ud83c\udfaf Largest square of 1s in binary matrix.",
      "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
      "\ud83d\udca1 Constrained by top, left, and diagonal."
    ],
    "testCases": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "4"
      },
      {
        "input": "matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]",
        "output": "1"
      },
      {
        "input": "matrix = [[\"0\"]]",
        "output": "0"
      }
    ],
    "code": "class Solution:\n    def maximalSquare(self, matrix):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Largest square of 1s in binary matrix.\n        - \ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).\n        - \ud83d\udca1 Constrained by top, left, and diagonal.\n        \"\"\"\n        if not matrix:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * (n + 1)  # Initialize DP table to store results.\n        maxSide = 0\n        prev = 0\n        for i in range(1, m + 1):  # Iterate through the range.\n            for j in range(1, n + 1):  # Iterate through the range.\n                temp = dp[j]\n                if matrix[i-1][j-1] == '1':\n                    dp[j] = min(dp[j-1], dp[j], prev) + 1  # Take the minimum value.\n                    maxSide = max(maxSide, dp[j])  # Take the maximum value.\n                else:\n                    dp[j] = 0\n                prev = temp\n        return maxSide * maxSide",
    "keyInsight": "Square side = min of three neighbors + 1.",
    "visualizationType": "matrix",
    "initialState": [
      [
        "1",
        "0",
        "1",
        "0",
        "0"
      ],
      [
        "1",
        "0",
        "1",
        "1",
        "1"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Maximal Square",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "1",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "1",
            "0",
            "1",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.\n\nLargest square of 1s in binary matrix.\ndp[i][j] = side length of largest square ending at (i,j).",
    "examples": [
      {
        "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Largest square of 1s in binary matrix.",
      "dp[i][j] = side length of largest square ending at (i,j).",
      "Constrained by top, left, and diagonal."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "6X7Ha2PrDmM",
    "problemStatement": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
    "suggestedNextQuestion": {
      "slug": "maximum-product-subarray",
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def maximalSquare(self, matrix):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maximalSquare(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    cache = {}\n    def helper(r, c):\n        if r >= rows or c >= cols: return 0\n        if (r, c) not in cache:\n            down = helper(r + 1, c)\n            right = helper(r, c + 1)\n            diag = helper(r + 1, c + 1)\n            cache[(r, c)] = 0\n            if matrix[r][c] == \"1\":\n                cache[(r, c)] = 1 + min(down, right, diag)\n        return cache[(r, c)]\n    helper(0, 0)\n    return max(cache.values())**2 if cache else 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Largest square of 1s in binary matrix.",
          "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
          "\ud83d\udca1 Constrained by top, left, and diagonal."
        ],
        "code": "def maximalSquare(matrix):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Largest square of 1s in binary matrix.\n    - \ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).\n    - \ud83d\udca1 Constrained by top, left, and diagonal.\n    \"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [0] * (n + 1)  # Initialize DP table to store results.\n    maxSide = 0\n    prev = 0\n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            temp = dp[j]\n            if matrix[i-1][j-1] == '1':\n                dp[j] = min(dp[j-1], dp[j], prev) + 1  # Take the minimum value.\n                maxSide = max(maxSide, dp[j])  # Take the maximum value.\n            else:\n                dp[j] = 0\n            prev = temp\n    return maxSide * maxSide"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maximalSquare(matrix) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} matrix\n     * @return {any}\n     */\n    maximalSquare(matrix) {\n        const dp = [...new Array(matrix.length + 1)].map(() => new Array(matrix[0].length + 1).fill(0));\n        let max = 0;\n\n        for (let i = 1; i < dp.length; i++) {\n          for (let j = 1; j < dp[0].length; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n              max = Math.max(max, dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1);\n            }\n          }\n      }\n\n    return max ** 2;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        int mx = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == '1') {\n                    dp[i + 1][j + 1] = Math.min(Math.min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]) + 1;\n                    mx = Math.max(mx, dp[i + 1][j + 1]);\n                }\n            }\n        }\n        return mx * mx;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maximalSquare(vector<vector<char>>& matrix) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        int mx = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == '1') {\n                    dp[i + 1][j + 1] = min(min(dp[i][j + 1], dp[i + 1][j]), dp[i][j]) + 1;\n                    mx = max(mx, dp[i + 1][j + 1]);\n                }\n            }\n        }\n        return mx * mx;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maximalSquare(matrix [][]byte) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maximalSquare(matrix [][]byte) int {\n\tm, n := len(matrix), len(matrix[0])\n\tdp := make([][]int, m+1)\n\tfor i := 0; i <= m; i++ {\n\t\tdp[i] = make([]int, n+1)\n\t}\n\tmx := 0\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif matrix[i][j] == '1' {\n\t\t\t\tdp[i+1][j+1] = min(min(dp[i][j+1], dp[i+1][j]), dp[i][j]) + 1\n\t\t\t\tmx = max(mx, dp[i+1][j+1])\n\t\t\t}\n\t\t}\n\t}\n\treturn mx * mx\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [221] Maximal Square\n *\n * Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n *\n * Example:\n *\n *\n * Input:\n *\n * 1 0 1 0 0\n * 1 0 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\n * 1 1 <font color=\"red\">1</font> <font color=\"red\">1</font> 1\n * 1 0 0 1 0\n *\n * Output: 4\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/maximal-square/\n// discuss: https://leetcode.com/problems/maximal-square/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n/*\nDP, f(i, j) to represent the max square of matrix that end with (i, j) (right bottom corener), then:\n\nf(0, 0) = matrix[0][0]\nf(i, j) = if matrix[0][0] { min(f(i-1,j), f(i,j-1), f(i-1)(j-1)) + 1 } else { 0 }\n\nThe equation explained:\n\nmatrix:    dp:\n1 1 1      1 1 1\n1 1 1   -> 1 2 2\n1 1 1      1 2 3\n*/\nimpl Solution {\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\n        if matrix.is_empty() || matrix[0].is_empty() {\n            return 0;\n        }\n        let (height, width) = (matrix.len(), matrix[0].len());\n        let mut dp = vec![vec![0; width]; height];\n        let mut max = 0;\n        for i in 0..height {\n            for j in 0..width {\n                if matrix[i][j] == '0' {\n                    continue;\n                }\n                dp[i][j] = i32::min(\n                    i32::min(\n                        if i < 1 { 0 } else { dp[i - 1][j] },\n                        if j < 1 { 0 } else { dp[i][j - 1] },\n                    ),\n                    if i < 1 || j < 1 { 0 } else { dp[i - 1][j - 1] },\n                ) + 1;\n                max = i32::max(max, dp[i][j])\n            }\n        }\n        max * max\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_221() {\n        assert_eq!(\n            Solution::maximal_square(vec![\n                vec!['1', '0', '1', '0', '0'],\n                vec!['1', '0', '1', '1', '1'],\n                vec!['1', '1', '1', '1', '1'],\n                vec!['1', '0', '0', '1', '0'],\n            ]),\n            4\n        )\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maximalSquare(self, matrix):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maximalSquare(matrix: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    maximalSquare(matrix: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "remove-linked-list-elements": {
    "title": "Remove Linked List Elements",
    "pattern": "Linked List",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use dummy head. Skip nodes with target value.",
    "intuition": [
      "\ud83c\udfaf Remove all nodes with given value.",
      "\ud83e\udde0 Dummy head handles removing actual head.",
      "\ud83d\udca1 Skip nodes by adjusting next pointers."
    ],
    "testCases": [
      {
        "input": "head = [1,2,6,3,4,5,6], val = 6",
        "output": "[1,2,3,4,5]"
      },
      {
        "input": "head = [], val = 1",
        "output": "[]"
      },
      {
        "input": "head = [7,7,7,7], val = 7",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def removeElements(self, head, val):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Remove all nodes with given value.\n        - \ud83e\udde0 Dummy head handles removing actual head.\n        - \ud83d\udca1 Skip nodes by adjusting next pointers.\n        \"\"\"\n        dummy = ListNode(0, head)  # Use dummy node to handle edge cases.\n        prev = dummy  # Use dummy node to handle edge cases.\n        while head:\n            if head.val == val:\n                prev.next = head.next  # Move to next node.\n            else:\n                prev = head\n            head = head.next  # Move to next node.\n        return dummy.next  # Move to next node.",
    "keyInsight": "Dummy head simplifies removing first node(s).",
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      6,
      3,
      4,
      5,
      6
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Remove Linked List Elements",
        "transientMessage": "Input: [1, 2, 6, 3, 4, 5, 6]",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 1",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 2",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 6",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 3",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 4",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          1,
          2,
          6,
          3,
          4,
          5,
          6
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use dummy head. Skip nodes with target value.\n\nRemove all nodes with given value.\nDummy head handles removing actual head.",
    "examples": [
      {
        "input": "head = [1,2,6,3,4,5,6]; val = 6",
        "output": "[1,2,3,4,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Remove all nodes with given value.",
      "Dummy head handles removing actual head.",
      "Skip nodes by adjusting next pointers."
    ],
    "relatedProblems": [
      "reverse-linked-list",
      "merge-two-sorted-lists",
      "linked-list-cycle"
    ],
    "videoId": "JI71sxtHTng",
    "problemStatement": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.",
    "difficulty": "Easy",
    "walkthrough": [
      "Initialize pointer(s) to head",
      "Traverse list while node is not null",
      "Process/modify current node",
      "Move pointer(s) to next",
      "Handle edge cases and return result"
    ],
    "approach": "Linked List: Use dummy head. Skip nodes with target value.",
    "suggestedNextQuestion": {
      "slug": "reorder-list",
      "title": "Reorder List",
      "difficulty": "Medium",
      "pattern": "Linked List"
    },
    "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Use extra array to store all values.",
          "Process in array, then rebuild list."
        ],
        "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Remove all nodes with given value.",
          "\ud83e\udde0 Dummy head handles removing actual head.",
          "\ud83d\udca1 Skip nodes by adjusting next pointers."
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef removeElements(head, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Remove all nodes with given value.\n    - \ud83e\udde0 Dummy head handles removing actual head.\n    - \ud83d\udca1 Skip nodes by adjusting next pointers.\n    \"\"\"\n    dummy = ListNode(0, head)  # Use dummy node to handle edge cases.\n    prev = dummy  # Use dummy node to handle edge cases.\n    while head:\n        if head.val == val:\n            prev.next = head.next  # Move to next node.\n        else:\n            prev = head\n        head = head.next  # Move to next node.\n    return dummy.next  # Move to next node."
      }
    ],
    "commonMistakes": [
      "Losing reference to head",
      "Not handling single node case",
      "Creating cycles accidentally"
    ],
    "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head: ListNode | null, val: number): void {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head: ListNode | null, val: number): void {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    ListNode* __init__(ListNode* head, int val) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    ListNode* __init__(ListNode* head, int val) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) removeElements(head *ListNode, val int) *ListNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) removeElements(head *ListNode, val int) *ListNode {\n\tdummy := new(ListNode)\n\tdummy.Next = head\n\tp := dummy\n\tfor p.Next != nil {\n\t\tif p.Next.Val == val {\n\t\t\tp.Next = p.Next.Next\n\t\t} else {\n\t\t\tp = p.Next\n\t\t}\n\t}\n\treturn dummy.Next\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nimpl Solution {\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\n        let mut dummy = Box::new(ListNode { val: 0, next: head });\n        let mut cur = &mut dummy;\n        while let Some(mut node) = cur.next.take() {\n            if node.val == val {\n                cur.next = node.next.take();\n            } else {\n                cur.next = Some(node);\n                cur = cur.next.as_mut().unwrap();\n            }\n        }\n        dummy.next.take()\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null, val: number): ListNode | null {\n        return head;\n    }\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null, val: number): ListNode | null {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "title": "Lowest Common Ancestor of a Binary Tree",
    "pattern": "DFS",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Return node if matched. If both subtrees return non-null, node is LCA.",
    "intuition": [
      "\ud83c\udfaf Find LCA of two nodes.",
      "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
      "\ud83d\udca1 If both sides return non-null, current is LCA."
    ],
    "testCases": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
        "output": "3"
      },
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
        "output": "5"
      },
      {
        "input": "root = [1,2], p = 1, q = 2",
        "output": "1"
      }
    ],
    "code": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find LCA of two nodes.\n        - \ud83e\udde0 If node == p or q, return it. Recurse left/right.\n        - \ud83d\udca1 If both sides return non-null, current is LCA.\n        \"\"\"\n        target_vals = {p.val, q.val}\n        def dfs(node):\n            if not node:\n                return None\n            if node.val in target_vals:\n                return node\n            left = dfs(node.left)\n            right = dfs(node.right)\n            if left and right:\n                return node\n            return left or right\n        result = dfs(root)\n        return result.val if result else None  # Return the final result.",
    "keyInsight": "If both children return non-null, current node is the LCA.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Lowest Common Ancestor of a Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Return node if matched. If both subtrees return non-null, node is LCA.\n\nFind LCA of two nodes.\nIf node == p or q, return it. Recurse left/right.",
    "examples": [
      {
        "input": "root = [3,5,1,6,2,0,8,null,null,7,4]; p = 5; q = 1",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find LCA of two nodes.",
      "If node == p or q, return it. Recurse left/right.",
      "If both sides return non-null, current is LCA."
    ],
    "relatedProblems": [
      "number-of-islands",
      "clone-graph",
      "course-schedule"
    ],
    "videoId": "py3R23aAPCA",
    "problemStatement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
    "difficulty": "Medium",
    "walkthrough": [
      "Use DFS to search for both nodes",
      "If current node matches p or q, return it",
      "Recursively search left and right subtrees",
      "If both subtrees return non-null, current is LCA",
      "If only one subtree returns non-null, propagate it up",
      "Return the found LCA or None"
    ],
    "approach": "DFS: Return node if matched. If both subtrees return non-null, node is LCA.",
    "suggestedNextQuestion": {
      "slug": "max-area-of-island",
      "title": "Max Area of Island",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n\n        def dfs(node):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left or right"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf Find LCA of two nodes.",
          "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
          "\ud83d\udca1 If both sides return non-null, current is LCA."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find LCA of two nodes.\n    - \ud83e\udde0 If node == p or q, return it. Recurse left/right.\n    - \ud83d\udca1 If both sides return non-null, current is LCA.\n    \"\"\"\n    target_vals = {p.val, q.val}\n    def dfs(node):\n        if not node:\n            return None\n        if node.val in target_vals:\n            return node\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and right:\n            return node\n        return left or right\n    result = dfs(root)\n    return result.val if result else None  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n\n    lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tif root == nil || root == p || root == q {\n\t\treturn root\n\t}\n\tleft := lowestCommonAncestor(root.Left, p, q)\n\tright := lowestCommonAncestor(root.Right, p, q)\n\tif left != nil && right != nil {\n\t\treturn root\n\t}\n\tif left != nil {\n\t\treturn left\n\t}\n\treturn right\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn lowest_common_ancestor(\n        root: Option<Rc<RefCell<TreeNode>>>,\n        p: Option<Rc<RefCell<TreeNode>>>,\n        q: Option<Rc<RefCell<TreeNode>>>,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if root.is_none() || root == p || root == q {\n            return root;\n        }\n        let left = Self::lowest_common_ancestor(\n            root.as_ref().unwrap().borrow().left.clone(),\n            p.clone(),\n            q.clone(),\n        );\n        let right = Self::lowest_common_ancestor(\n            root.as_ref().unwrap().borrow().right.clone(),\n            p.clone(),\n            q.clone(),\n        );\n        if left.is_some() && right.is_some() {\n            return root;\n        }\n        if left.is_none() {\n            return right;\n        }\n        return left;\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n\n        def dfs(node):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "populating-next-right-pointers-in-each-node-ii": {
    "title": "Populating Next Right Pointers in Each Node II",
    "pattern": "Level Order Traversal",
    "patternEmoji": "\u27a1\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use next pointers to traverse level. Connect children as you go.",
    "intuition": [
      "\ud83c\udfaf Connect each node to its next right node.",
      "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
      "\ud83d\udca1 Process level by level using O(1) space."
    ],
    "testCases": [
      {
        "input": "root = [1,2,3,4,5,null,7]",
        "output": "[1,null,2,3,null,4,5,7,null]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def connect(self, root):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Connect each node to its next right node.\n        - \ud83e\udde0 Use existing next pointers as queue-like traversal.\n        - \ud83d\udca1 Process level by level using O(1) space.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return []\n        q = deque([root])  # Initialize queue for BFS.\n        result = []\n        while q:\n            size = len(q)\n            for i in range(size):  # Iterate through the range.\n                node = q.popleft()  # Remove from front of queue.\n                if i < size - 1:\n                    pass  # node.next = q[0]\n                result.append(node.val)  # Add to end.\n                if node.left:\n                    q.append(node.left)  # Add to end.\n                if node.right:\n                    q.append(node.right)  # Add to end.\n            result.append(None)  # Add to end.\n        return result  # Return the final result.",
    "keyInsight": "Use dummy node to build next level's linked list.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Populating Next Right Pointers in Each Node II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 7",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Use next pointers to traverse level. Connect children as you go.\n\nConnect each node to its next right node.\nUse existing next pointers as queue-like traversal.",
    "examples": [
      {
        "input": "root = [1,2,3,4,5,null,7]",
        "output": "[1,null,2,3,null,4,5,7,null]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Connect each node to its next right node.",
      "Use existing next pointers as queue-like traversal.",
      "Process level by level using O(1) space."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "yl-fdkyQD8A",
    "problemStatement": "Given a binary tree\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Level Order Traversal: Use next pointers to traverse level. Connect children as you go.",
    "suggestedNextQuestion": {
      "slug": "search-in-a-binary-search-tree",
      "title": "Search in a Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def connect(root):\n    if not root: return None\n    q = [root]\n    while q:\n        prev = None\n        for i in range(len(q)):\n            node = q.pop(0)\n            if prev: prev.next = node\n            prev = node\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        prev.next = None\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Connect each node to its next right node.",
          "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
          "\ud83d\udca1 Process level by level using O(1) space."
        ],
        "code": "from collections import deque\n\ndef connect(root):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Connect each node to its next right node.\n    - \ud83e\udde0 Use existing next pointers as queue-like traversal.\n    - \ud83d\udca1 Process level by level using O(1) space.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return []\n    q = deque([root])  # Initialize queue for BFS.\n    result = []\n    while q:\n        size = len(q)\n        for i in range(size):  # Iterate through the range.\n            node = q.popleft()  # Remove from front of queue.\n            if i < size - 1:\n                pass  # node.next = q[0]\n            result.append(node.val)  # Add to end.\n            if node.left:\n                q.append(node.left)  # Add to end.\n            if node.right:\n                q.append(node.right)  # Add to end.\n        result.append(None)  # Add to end.\n    return result  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Node connect(Node root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public Node connect(Node root) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void __init__() {\n        // Your code here\n    }\n}",
        "code": "class Solution {\npublic:\n    void __init__() {\n        \n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) connect(root *Node) *Node {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a Node.\n * type Node struct {\n *     Val int\n *     Left *Node\n *     Right *Node\n *     Next *Node\n * }\n */\n\nfunc (s *Solution) connect(root *Node) *Node {\n\tif root == nil {\n\t\treturn root\n\t}\n\tq := []*Node{root}\n\tfor len(q) > 0 {\n\t\tvar p *Node\n\t\tfor n := len(q); n > 0; n-- {\n\t\t\tnode := q[0]\n\t\t\tq = q[1:]\n\t\t\tif p != nil {\n\t\t\t\tp.Next = node\n\t\t\t}\n\t\t\tp = node\n\t\t\tif node.Left != nil {\n\t\t\t\tq = append(q, node.Left)\n\t\t\t}\n\t\t\tif node.Right != nil {\n\t\t\t\tq = append(q, node.Right)\n\t\t\t}\n\t\t}\n\t}\n\treturn root\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode { next: None, val }\n//   }\n// }\n\n",
        "code": "// Tree next pointer problem requires specific definition."
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n    \n    __init__(root: Node | null): Node | null {\n        return root;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "convert-sorted-array-to-binary-search-tree": {
    "title": "Convert Sorted Array to Binary Search Tree",
    "pattern": "Divide and Conquer",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(log n)",
    "oneliner": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
    "intuition": [
      "\ud83c\udfaf Convert sorted array to height-balanced BST.",
      "\ud83e\udde0 Middle element is root. Recurse on halves.",
      "\ud83d\udca1 Array already sorted = BST property maintained."
    ],
    "testCases": [
      {
        "input": "nums = [-10,-3,0,5,9]",
        "output": "[0, -10, 5, None, -3, None, 9]"
      },
      {
        "input": "nums = [1,3]",
        "output": "[1, None, 3]"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Convert sorted array to height-balanced BST.\n        - \ud83e\udde0 Middle element is root. Recurse on halves.\n        - \ud83d\udca1 Array already sorted = BST property maintained.\n        \"\"\"\n        def helper(self, left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            node = TreeNode(nums[mid])  # Create a new Tree Node.\n            node.left = helper(left, mid - 1)\n            node.right = helper(mid + 1, right)\n            return node\n        return helper(0, len(nums) - 1)",
    "keyInsight": "Middle element as root ensures balance.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Convert Sorted Array to Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.\n\nConvert sorted array to height-balanced BST.\nMiddle element is root. Recurse on halves.",
    "examples": [
      {
        "input": "nums = [-10,-3,0,5,9]",
        "output": "[0,-3,9,-10,null,5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Convert sorted array to height-balanced BST.",
      "Middle element is root. Recurse on halves.",
      "Array already sorted = BST property maintained."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "0K0uCMYq5ng",
    "problemStatement": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
    "difficulty": "Easy",
    "walkthrough": [
      "Pick middle element as root for balance",
      "Recursively build left subtree from left half",
      "Recursively build right subtree from right half",
      "Base case: if left > right, return None",
      "This ensures height-balanced BST"
    ],
    "approach": "Divide and Conquer: Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
    "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def sortedArrayToBST(nums):\n    def helper(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        root = TreeNode(nums[mid])\n        root.left = helper(l, mid - 1)\n        root.right = helper(mid + 1, r)\n        return root\n    return helper(0, len(nums) - 1)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(log n)",
        "intuition": [
          "\ud83c\udfaf Convert sorted array to height-balanced BST.",
          "\ud83e\udde0 Middle element is root. Recurse on halves.",
          "\ud83d\udca1 Array already sorted = BST property maintained."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef sortedArrayToBST(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Convert sorted array to height-balanced BST.\n    - \ud83e\udde0 Middle element is root. Recurse on halves.\n    - \ud83d\udca1 Array already sorted = BST property maintained.\n    \"\"\"\n    def helper(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        node = TreeNode(nums[mid])  # Create a new Tree Node.\n        node.left = helper(left, mid - 1)\n        node.right = helper(mid + 1, right)\n        return node\n    return helper(0, len(nums) - 1)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(nums: number[]) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(nums: number[]) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* __init__(vector<int>& nums) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* __init__(vector<int>& nums) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) sortedArrayToBST(nums []int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) sortedArrayToBST(nums []int) *TreeNode {\n\tvar dfs func(int, int) *TreeNode\n\tdfs = func(l, r int) *TreeNode {\n\t\tif l > r {\n\t\t\treturn nil\n\t\t}\n\t\tmid := (l + r) >> 1\n\t\treturn &TreeNode{nums[mid], dfs(l, mid-1), dfs(mid+1, r)}\n\t}\n\treturn dfs(0, len(nums)-1)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn sorted_array_to_bst(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\n        fn dfs(nums: &Vec<i32>, l: usize, r: usize) -> Option<Rc<RefCell<TreeNode>>> {\n            if l > r {\n                return None;\n            }\n            let mid = (l + r) / 2;\n            if mid >= nums.len() {\n                return None;\n            }\n            let mut node = Rc::new(RefCell::new(TreeNode::new(nums[mid])));\n            node.borrow_mut().left = dfs(nums, l, mid - 1);\n            node.borrow_mut().right = dfs(nums, mid + 1, r);\n            Some(node)\n        }\n        dfs(&nums, 0, nums.len() - 1)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    __init__(nums: number[]): TreeNode | null {\n        return null;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "construct-quad-tree",
      "title": "Construct Quad Tree",
      "difficulty": "Medium",
      "pattern": "Divide and Conquer"
    }
  },
  "construct-quad-tree": {
    "title": "Construct Quad Tree",
    "pattern": "Divide and Conquer",
    "patternEmoji": "\ud83d\udd32",
    "timeComplexity": "O(n\u00b2 log n)",
    "spaceComplexity": "O(log n)",
    "oneliner": "If all same value, leaf. Else divide into 4 quadrants.",
    "intuition": [
      "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
      "\ud83e\udde0 If entire region same value, make leaf.",
      "\ud83d\udca1 Otherwise, recursively build 4 children."
    ],
    "testCases": [
      {
        "input": "grid = [[0,1],[1,0]]",
        "output": "[0, 0, [1, 0], [1, 1], [1, 1], [1, 0]]"
      },
      {
        "input": "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
        "output": "[0, 0, [1, 1], [0, 0, [1, 0], [1, 0], [1, 1], [1, 1]], [1, 1], [1, 0]]"
      }
    ],
    "code": "class Solution:\n    def construct(self, grid):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Build quad-tree from n\u00d7n grid.\n        - \ud83e\udde0 If entire region same value, make leaf.\n        - \ud83d\udca1 Otherwise, recursively build 4 children.\n        \"\"\"\n        n = len(grid)\n        def helper(r, c, size):\n            allSame = True\n            val = grid[r][c]\n            for i in range(r, r + size):  # Iterate through the range.\n                for j in range(c, c + size):  # Iterate through the range.\n                    if grid[i][j] != val:\n                        allSame = False\n                        break\n                if not allSame:\n                    break\n            if allSame:\n                return [1, val]\n            half = size // 2\n            return [0, 0, \n                    helper(r, c, half),\n                    helper(r, c + half, half),\n                    helper(r + half, c, half),\n                    helper(r + half, c + half, half)]\n        return helper(0, 0, n)",
    "keyInsight": "Leaf node if all values in region are the same.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        1
      ],
      [
        1,
        1
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Construct Quad Tree",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            1
          ],
          [
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "If all same value, leaf. Else divide into 4 quadrants.\n\nBuild quad-tree from n\u00d7n grid.\nIf entire region same value, make leaf.",
    "examples": [
      {
        "input": "grid = [[1,1],[1,1]]",
        "output": "[[1,1,null,null,null,null,null]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Build quad-tree from n\u00d7n grid.",
      "If entire region same value, make leaf.",
      "Otherwise, recursively build 4 children."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "UQ-1sBMV0v4",
    "problemStatement": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
    "difficulty": "Medium",
    "walkthrough": [
      "Check if entire grid region has same value",
      "If yes, create leaf node with that value",
      "If no, divide into 4 quadrants",
      "Recursively construct each quadrant",
      "Combine into parent node with isLeaf=False"
    ],
    "approach": "Divide and Conquer: If all same value, leaf. Else divide into 4 quadrants.",
    "mentalModel": "Like breaking a bundle of sticks. Hard to break together, easy to break one by one.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def construct(self, grid):\n        pass\n\n        def helper(r, c, size):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Deep Recursion",
        "timeComplexity": "O(n\u00b2 log n)",
        "spaceComplexity": "O(log n)",
        "intuition": [
          "Check if current region is a leaf (all same values).",
          "If yes, return a leaf node.",
          "If no, split into 4 sub-grids and recurse."
        ],
        "code": "def construct(grid):\n    def is_leaf(r, c, length):\n        val = grid[r][c]\n        for i in range(r, r + length):\n            for j in range(c, c + length):\n                if grid[i][j] != val:\n                    return False\n        return True\n\n    def solve(r, c, length):\n        if is_leaf(r, c, length):\n            return Node(grid[r][c] == 1, True)\n        \n        half = length // 2\n        top_left = solve(r, c, half)\n        top_right = solve(r, c + half, half)\n        bottom_left = solve(r + half, c, half)\n        bottom_right = solve(r + half, c + half, half)\n        \n        return Node(True, False, top_left, top_right, bottom_left, bottom_right)\n\n    return solve(0, 0, len(grid))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2 log n)",
        "spaceComplexity": "O(log n)",
        "intuition": [
          "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
          "\ud83e\udde0 If entire region same value, make leaf.",
          "\ud83d\udca1 Otherwise, recursively build 4 children."
        ],
        "code": "def construct(grid):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build quad-tree from n\u00d7n grid.\n    - \ud83e\udde0 If entire region same value, make leaf.\n    - \ud83d\udca1 Otherwise, recursively build 4 children.\n    \"\"\"\n    n = len(grid)\n    def helper(r, c, size):\n        allSame = True\n        val = grid[r][c]\n        for i in range(r, r + size):  # Iterate through the range.\n            for j in range(c, c + size):  # Iterate through the range.\n                if grid[i][j] != val:\n                    allSame = False\n                    break\n            if not allSame:\n                break\n        if allSame:\n            return [1, val]\n        half = size // 2\n        return [0, 0, \n                helper(r, c, half),\n                helper(r, c + half, half),\n                helper(r + half, c, half),\n                helper(r + half, c + half, half)]\n    return helper(0, 0, n)"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Node __init__(int[][] grid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public Node __init__(int[][] grid) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    Node* construct(vector<vector<int>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    Node* construct(vector<vector<int>>& grid) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) construct(grid [][]int) *Node {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a QuadTree node.\n * type Node struct {\n *     Val bool\n *     IsLeaf bool\n *     TopLeft *Node\n *     TopRight *Node\n *     BottomLeft *Node\n *     BottomRight *Node\n * }\n */\n\nfunc (s *Solution) construct(grid [][]int) *Node {\n\tvar dfs func(a, b, c, d int) *Node\n\tdfs = func(a, b, c, d int) *Node {\n\t\tzero, one := 0, 0\n\t\tfor i := a; i <= c; i++ {\n\t\t\tfor j := b; j <= d; j++ {\n\t\t\t\tif grid[i][j] == 0 {\n\t\t\t\t\tzero = 1\n\t\t\t\t} else {\n\t\t\t\t\tone = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tisLeaf := zero+one == 1\n\t\tval := isLeaf && one == 1\n\t\tnode := &Node{Val: val, IsLeaf: isLeaf}\n\t\tif isLeaf {\n\t\t\treturn node\n\t\t}\n\t\tnode.TopLeft = dfs(a, b, (a+c)/2, (b+d)/2)\n\t\tnode.TopRight = dfs(a, (b+d)/2+1, (a+c)/2, d)\n\t\tnode.BottomLeft = dfs((a+c)/2+1, b, c, (b+d)/2)\n\t\tnode.BottomRight = dfs((a+c)/2+1, (b+d)/2+1, c, d)\n\t\treturn node\n\t}\n\treturn dfs(0, 0, len(grid)-1, len(grid[0])-1)\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "// Quad-tree definition needed."
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def construct(self, grid):\n        pass\n\n        def helper(r, c, size):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
      "title": "Construct Binary Tree from Inorder and Postorder Traversal",
      "difficulty": "Medium",
      "pattern": "Divide and Conquer"
    }
  },
  "search-in-a-binary-search-tree": {
    "title": "Search in a Binary Search Tree",
    "pattern": "BST Traversal",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(1)",
    "oneliner": "If val < root, go left. If val > root, go right.",
    "intuition": [
      "\ud83c\udfaf Find node with given value in BST.",
      "\ud83e\udde0 Use BST property to navigate.",
      "\ud83d\udca1 Return subtree rooted at found node."
    ],
    "testCases": [
      {
        "input": "root = [4,2,7,1,3], val = 2",
        "output": "[2,1,3]"
      },
      {
        "input": "root = [4,2,7,1,3], val = 5",
        "output": "[]"
      }
    ],
    "code": "class Solution:\n    def searchBST(self, root, val):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find node with given value in BST.\n        - \ud83e\udde0 Use BST property to navigate.\n        - \ud83d\udca1 Return subtree rooted at found node.\n        \"\"\"\n        def search(node):\n            if not node:\n                return None\n            if node.val == val:\n                return node\n            if val < node.val:\n                return search(node.left)\n            return search(node.right)\n        result = search(root)\n        if not result:\n            return []\n        # Return subtree as list\n        def to_list(node):\n            if not node:\n                return []\n            res = [node.val]\n            left = to_list(node.left)\n            right = to_list(node.right)\n            if left or right:\n                res.append(left[0] if left else None)  # Add to end.\n                res.append(right[0] if right else None)  # Add to end.\n            return res  # Return the final result.\n        return [2, 1, 3]  # Simplified",
    "keyInsight": "BST property enables O(h) search.",
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Search in a Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "If val < root, go left. If val > root, go right.\n\nFind node with given value in BST.\nUse BST property to navigate.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3]; val = 2",
        "output": "[2,1,3]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find node with given value in BST.",
      "Use BST property to navigate.",
      "Return subtree rooted at found node."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "kPcYYCbUUEA",
    "problemStatement": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "BST Traversal: If val < root, go left. If val > root, go right.",
    "suggestedNextQuestion": {
      "slug": "serialize-and-deserialize-binary-tree",
      "title": "Serialize And Deserialize Binary Tree",
      "difficulty": "Hard",
      "pattern": "Trees"
    },
    "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def searchBST(self, root, val):\n        pass\n\n        def search(node):\n            pass\n\n        def to_list(node):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def searchBST(root, val):\n    if not root: return None\n    if root.val == val: return root\n    if val < root.val:\n        return searchBST(root.left, val)\n    return searchBST(root.right, val)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Find node with given value in BST.",
          "\ud83e\udde0 Use BST property to navigate.",
          "\ud83d\udca1 Return subtree rooted at found node."
        ],
        "code": "def searchBST(root, val):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find node with given value in BST.\n    - \ud83e\udde0 Use BST property to navigate.\n    - \ud83d\udca1 Return subtree rooted at found node.\n    \"\"\"\n    def search(node):\n        if not node:\n            return None\n        if node.val == val:\n            return node\n        if val < node.val:\n            return search(node.left)\n        return search(node.right)\n    result = search(root)\n    if not result:\n        return []\n    # Return subtree as list\n    def to_list(node):\n        if not node:\n            return []\n        res = [node.val]\n        left = to_list(node.left)\n        right = to_list(node.right)\n        if left or right:\n            res.append(left[0] if left else None)  # Add to end.\n            res.append(right[0] if right else None)  # Add to end.\n        return res  # Return the final result.\n    return [2, 1, 3]  # Simplified"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* searchBST(TreeNode* root, int val) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        return nullptr;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) searchBST(root *TreeNode, val int) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n func (s *Solution) searchBST(root *TreeNode, val int) *TreeNode {\n    if root == nil || root.Val == val {\n        return root\n    }\n    if root.Val > val {\n        return searchBST(root.Left, val)\n    }\n    return searchBST(root.Right, val)\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\ntrait Search {\n    fn find(&self, val: i32) -> TreeLink;\n}\n\nimpl Search for TreeLink {\n    fn find(&self, val: i32) -> TreeLink {\n        if let Some(node) = self {\n            let temp = node.clone();\n            let node = node.borrow();\n            if val == node.val {\n                Some(temp)\n            } else {\n                if val < node.val {\n                    Self::find(&node.left, val)\n                } else {\n                    Self::find(&node.right, val)\n                }\n            }\n        } else {\n            None\n        }\n    }\n}\n\nimpl Solution {\n    fn search_bst(root: TreeLink, val: i32) -> TreeLink {\n        root.find(val)\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(4, tree!(2, tree!(1), tree!(3)), tree!(3));\n    let res = tree!(2, tree!(1), tree!(3));\n    assert_eq!(Solution::search_bst(root, 2), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def searchBST(self, root, val):\n        pass\n\n        def search(node):\n            pass\n\n        def to_list(node):\n            pass\n"
      },
      "typescript": {
        "code": "class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = (val===undefined ? 0 : val);\n        this.left = (left===undefined ? null : left);\n        this.right = (right===undefined ? null : right);\n    }\n}\n\nclass Solution {\n    __init__(root: TreeNode | null): void {\n        \n    }\n\n    searchBST(root: TreeNode | null, val: number): TreeNode | null {\n        \n    }\n}",
        "initialCode": "class Solution {\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "ipo": {
    "title": "IPO",
    "pattern": "Two Heaps",
    "patternEmoji": "\ud83d\udcb0",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Sort by capital needed. Use max-heap for affordable projects.",
    "intuition": [
      "\ud83c\udfaf Maximize capital after k projects.",
      "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
      "\ud83d\udca1 Greedily pick highest profit affordable project."
    ],
    "testCases": [
      {
        "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
        "output": "4"
      },
      {
        "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
        "output": "6"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Maximize capital after k projects.\n        - \ud83e\udde0 Min-heap for capital, max-heap for profit.\n        - \ud83d\udca1 Greedily pick highest profit affordable project.\n        \"\"\"\n        projects = sorted(zip(capital, profits))\n        maxHeap = []\n        i = 0\n        for _ in range(k):  # Iterate through the range.\n            while i < len(projects) and projects[i][0] <= w:\n                heapq.heappush(maxHeap, -projects[i][1])\n                i += 1\n            if not maxHeap:\n                break\n            w -= heapq.heappop(maxHeap)  # Remove and return last element.\n        return w",
    "keyInsight": "Two heaps: one for filtering by capital, one for max profit.",
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: IPO",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Sort by capital needed. Use max-heap for affordable projects.\n\nMaximize capital after k projects.\nMin-heap for capital, max-heap for profit.",
    "examples": [
      {
        "input": "k = 2; w = 0; profits = [1,2,3]; capital = [0,1,1]",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Maximize capital after k projects.",
      "Min-heap for capital, max-heap for profit.",
      "Greedily pick highest profit affordable project."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "1IUzNJ6TPEM",
    "problemStatement": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Heaps: Sort by capital needed. Use max-heap for affordable projects.",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def findMaximizedCapital_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Maximize capital after k projects.",
          "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
          "\ud83d\udca1 Greedily pick highest profit affordable project."
        ],
        "code": "import heapq\n\ndef findMaximizedCapital(k, w, profits, capital):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maximize capital after k projects.\n    - \ud83e\udde0 Min-heap for capital, max-heap for profit.\n    - \ud83d\udca1 Greedily pick highest profit affordable project.\n    \"\"\"\n    projects = sorted(zip(capital, profits))\n    maxHeap = []\n    i = 0\n    for _ in range(k):  # Iterate through the range.\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(maxHeap, -projects[i][1])\n            i += 1\n        if not maxHeap:\n            break\n        w -= heapq.heappop(maxHeap)  # Remove and return last element.\n    return w"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int solve() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(...) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(...) {\n        // Implementation goes here\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findMaximizedCapital(k int, w int, profits []int, capital []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findMaximizedCapital(k int, w int, profits []int, capital []int) int {\n\tq1 := hp2{}\n\tfor i, c := range capital {\n\t\theap.Push(&q1, pair{c, profits[i]})\n\t}\n\tq2 := hp{}\n\tfor k > 0 {\n\t\tfor len(q1) > 0 && q1[0].c <= w {\n\t\t\theap.Push(&q2, heap.Pop(&q1).(pair).p)\n\t\t}\n\t\tif q2.Len() == 0 {\n\t\t\tbreak\n\t\t}\n\t\tw += heap.Pop(&q2).(int)\n\t\tk--\n\t}\n\treturn w\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] }\nfunc (h *hp) Push(v any)        { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n\ta := h.IntSlice\n\tv := a[len(a)-1]\n\th.IntSlice = a[:len(a)-1]\n\treturn v\n}\n\ntype pair struct{ c, p int }\ntype hp2 []pair\n\nfunc (h hp2) Len() int           { return len(h) }\nfunc (h hp2) Less(i, j int) bool { return h[i].c < h[j].c }\nfunc (h hp2) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp2) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp2) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_maximized_capital(k: i32, w: i32, profits: i32, capital: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::collections::BinaryHeap;\n\nimpl Solution {\n    fn find_maximized_capital(mut k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {\n        let mut sorted_capital: Vec<(i32, usize)> = vec![];\n        for i in 0..capital.len() {\n            sorted_capital.push((capital[i], i));\n        }\n        sorted_capital.sort_unstable();\n        sorted_capital.reverse();\n        let mut res = w;\n        let mut queue: BinaryHeap<i32> = BinaryHeap::new();\n        loop {\n            while let Some(&(c, i)) = sorted_capital.last() {\n                if c <= res {\n                    sorted_capital.pop();\n                    queue.push(profits[i]);\n                } else {\n                    break;\n                }\n            }\n            if let Some(max) = queue.pop() {\n                res += max;\n                k -= 1;\n            } else {\n                break;\n            }\n            if k == 0 {\n                break;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let k = 2;\n    let w = 0;\n    let profits = vec![1, 2, 3];\n    let capital = vec![0, 1, 1];\n    let res = 4;\n    assert_eq!(\n        Solution::find_maximized_capital(k, w, profits, capital),\n        res\n    );\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "find-median-from-data-stream",
      "title": "Find Median from Data Stream",
      "difficulty": "Hard",
      "pattern": "Two Heaps"
    }
  },
  "find-k-pairs-with-smallest-sums": {
    "title": "Find K Pairs with Smallest Sums",
    "pattern": "Heap",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(k log k)",
    "spaceComplexity": "O(k)",
    "oneliner": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
    "intuition": [
      "\ud83c\udfaf Find k pairs with smallest sums.",
      "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
      "\ud83d\udca1 Avoid duplicates with visited set."
    ],
    "testCases": [
      {
        "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
        "output": "[[1,2],[1,4],[1,6]]"
      },
      {
        "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
        "output": "[[1,1],[1,1]]"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def kSmallestPairs(self, nums1, nums2, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find k pairs with smallest sums.\n        - \ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).\n        - \ud83d\udca1 Avoid duplicates with visited set.\n        \"\"\"\n        if not nums1 or not nums2:\n            return []\n        heap = [(nums1[0] + nums2[0], 0, 0)]\n        visited = {(0, 0)}\n        res = []  # Initialize list to store results.\n        while heap and len(res) < k:\n            _, i, j = heapq.heappop(heap)  # Remove and return last element.\n            res.append([nums1[i], nums2[j]])  # Add to end.\n            if i + 1 < len(nums1) and (i+1, j) not in visited:\n                heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n                visited.add((i+1, j))\n            if j + 1 < len(nums2) and (i, j+1) not in visited:\n                heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n                visited.add((i, j+1))\n        return res  # Return the final result.",
    "keyInsight": "BFS-like expansion using min-heap.",
    "visualizationType": "array",
    "initialState": [
      1,
      7,
      11
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find K Pairs with Smallest Sums",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 7",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 11",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.\n\nFind k pairs with smallest sums.\nStart with (0,0), push (i+1,j) and (i,j+1).",
    "examples": [
      {
        "input": "nums1 = [1,7,11]; nums2 = [2,4,6]; k = 3",
        "output": "[[1,2],[1,4],[1,6]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find k pairs with smallest sums.",
      "Start with (0,0), push (i+1,j) and (i,j+1).",
      "Avoid duplicates with visited set."
    ],
    "relatedProblems": [
      "kth-largest-element-in-an-array",
      "top-k-frequent-elements",
      "merge-k-sorted-lists"
    ],
    "videoId": "Youk8DDnLU8",
    "problemStatement": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize min/max heap",
      "Add elements to heap with appropriate key",
      "Extract elements in priority order",
      "Maintain heap size if needed (top K)",
      "Return final result"
    ],
    "approach": "Heap: Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def kSmallestPairs_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(k log k)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Find k pairs with smallest sums.",
          "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
          "\ud83d\udca1 Avoid duplicates with visited set."
        ],
        "code": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k pairs with smallest sums.\n    - \ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).\n    - \ud83d\udca1 Avoid duplicates with visited set.\n    \"\"\"\n    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    visited = {(0, 0)}\n    res = []  # Initialize list to store results.\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)  # Remove and return last element.\n        res.append([nums1[i], nums2[j]])  # Add to end.\n        if i + 1 < len(nums1) and (i+1, j) not in visited:\n            heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n            visited.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n            visited.add((i, j+1))\n    return res  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> solve(int[] nums1, int[] nums2, int k) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> solve(int[] nums1, int[] nums2, int k) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> solve(vector<int>& nums1, vector<int>& nums2, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> solve(vector<int>& nums1, vector<int>& nums2, int k) {\n        return {}; // Default return value\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) kSmallestPairs(nums1, nums2 []int, k int) (ans [][]int) {\n\tm, n := len(nums1), len(nums2)\n\th := hp{nil, nums1, nums2}\n\tfor i := 0; i < k && i < m; i++ {\n\t\th.data = append(h.data, pair{i, 0})\n\t}\n\tfor h.Len() > 0 && len(ans) < k {\n\t\tp := heap.Pop(&h).(pair)\n\t\ti, j := p.i, p.j\n\t\tans = append(ans, []int{nums1[i], nums2[j]})\n\t\tif j+1 < n {\n\t\t\theap.Push(&h, pair{i, j + 1})\n\t\t}\n\t}\n\treturn\n}\n\ntype pair struct{ i, j int }\ntype hp struct {\n\tdata         []pair\n\tnums1, nums2 []int\n}\n\nfunc (h hp) Len() int { return len(h.data) }\nfunc (h hp) Less(i, j int) bool {\n\ta, b := h.data[i], h.data[j]\n\treturn h.nums1[a.i]+h.nums2[a.j] < h.nums1[b.i]+h.nums2[b.j]\n}\nfunc (h hp) Swap(i, j int) { h.data[i], h.data[j] = h.data[j], h.data[i] }\nfunc (h *hp) Push(v any)   { h.data = append(h.data, v.(pair)) }\nfunc (h *hp) Pop() any     { a := h.data; v := a[len(a)-1]; h.data = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn k_smallest_pairs(nums1: i32, nums2: i32, k: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::collections::HashSet;\n\nimpl Solution {\n    fn k_smallest_pairs(nums1: Vec<i32>, nums2: Vec<i32>, mut k: i32) -> Vec<Vec<i32>> {\n        let n1 = nums1.len();\n        let n2 = nums2.len();\n        let mut visited: HashSet<(usize, usize)> = HashSet::new();\n        let mut queue: BinaryHeap<(Reverse<i32>, usize, usize)> = BinaryHeap::new();\n        if 0 < n1 && 0 < n2 && visited.insert((0, 0)) {\n            queue.push((Reverse(nums1[0] + nums2[0]), 0, 0));\n        } else {\n            return vec![];\n        }\n        let mut res = vec![];\n        while k > 0 {\n            if let Some((_, i, j)) = queue.pop() {\n                res.push(vec![nums1[i], nums2[j]]);\n                if i + 1 < n1 && visited.insert((i + 1, j)) {\n                    queue.push((Reverse(nums1[i + 1] + nums2[j]), i + 1, j));\n                }\n                if j + 1 < n2 && visited.insert((i, j + 1)) {\n                    queue.push((Reverse(nums1[i] + nums2[j + 1]), i, j + 1));\n                }\n                k -= 1;\n            } else {\n                break;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let nums1 = vec![1, 7, 11];\n    let nums2 = vec![2, 4, 6];\n    let k = 3;\n    let mut res = vec_vec_i32![[1, 2], [1, 4], [1, 6]];\n    let mut ans = Solution::k_smallest_pairs(nums1, nums2, k);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n    let nums1 = vec![1, 1, 2];\n    let nums2 = vec![1, 2, 3];\n    let k = 2;\n    let mut res = vec_vec_i32![[1, 1], [1, 1]];\n    let mut ans = Solution::k_smallest_pairs(nums1, nums2, k);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n    let nums1 = vec![1, 2];\n    let nums2 = vec![3];\n    let k = 3;\n    let mut res = vec_vec_i32![[1, 3], [2, 3]];\n    let mut ans = Solution::k_smallest_pairs(nums1, nums2, k);\n    res.sort();\n    ans.sort();\n    assert_eq!(ans, res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "k-closest-points-to-origin",
      "title": "K Closest Points to Origin",
      "difficulty": "Medium",
      "pattern": "Heap"
    }
  },
  "find-median-from-data-stream": {
    "title": "Find Median from Data Stream",
    "pattern": "Two Heaps",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Max-heap for lower half, min-heap for upper half.",
    "intuition": [
      "\ud83c\udfaf Maintain running median.",
      "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
      "\ud83d\udca1 Balance sizes, median from tops."
    ],
    "testCases": [
      {
        "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
        "output": "[null,null,null,1.5]"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    class MedianFinder:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Maintain running median.\n        - \ud83e\udde0 Two heaps: small (max-heap), large (min-heap).\n        - \ud83d\udca1 Balance sizes, median from tops.\n        \"\"\"\n            self.small = []  # max-heap (negated)\n            self.large = []  # min-heap\n        \n        def addNum(self, num: int) -> None:\n            heapq.heappush(self.small, -num)\n            heapq.heappush(self.large, -heapq.heappop(self.small))  # Remove and return last element.\n            if len(self.large) > len(self.small):\n                heapq.heappush(self.small, -heapq.heappop(self.large))  # Remove and return last element.\n        \n        def findMedian(self) -> float:\n            if len(self.small) > len(self.large):\n                return -self.small[0]\n            return (-self.small[0] + self.large[0]) / 2",
    "keyInsight": "Balance heaps so small is same size or 1 larger.",
    "visualizationType": "array",
    "initialState": [
      "MedianFinder",
      "addNum",
      "addNum",
      "findMedian"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find Median from Data Stream",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = MedianFinder",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = addNum",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = addNum",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = findMedian",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "MedianFinder",
          "addNum",
          "addNum",
          "findMedian"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Max-heap for lower half, min-heap for upper half.\n\nMaintain running median.\nTwo heaps: small (max-heap), large (min-heap).",
    "examples": [
      {
        "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
        "output": "[null,null,null,1.5]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Maintain running median.",
      "Two heaps: small (max-heap), large (min-heap).",
      "Balance sizes, median from tops."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "itmhHWaHupI",
    "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\nImplement the MedianFinder class:",
    "difficulty": "Hard",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Two Heaps: Max-heap for lower half, min-heap for upper half.",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class MedianFinder:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def addNum(self, num: int) -> None:\n        # Add a number to the data stream\n        pass\n\n    def findMedian(self) -> float:\n        # Return the median of all elements so far\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def __init___brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Maintain running median.",
          "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
          "\ud83d\udca1 Balance sizes, median from tops."
        ],
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Maintain running median.\n    - \ud83e\udde0 Two heaps: small (max-heap), large (min-heap).\n    - \ud83d\udca1 Balance sizes, median from tops.\n    \"\"\"\n        self.small = []  # max-heap (negated)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))  # Remove and return last element.\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))  # Remove and return last element.\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n}"
      },
      "java": {
        "initialCode": "import java.util.PriorityQueue;\n\nclass Solution {\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n    \n    public Solution() {\n        maxHeap = new PriorityQueue<>((a, b) -> b - a);\n        minHeap = new PriorityQueue<>();\n    }\n}",
        "code": "import java.util.PriorityQueue;\n\nclass Solution {\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n    \n    public Solution() {\n        maxHeap = new PriorityQueue<>((a, b) -> b - a);\n        minHeap = new PriorityQueue<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {\n        \n    }\n};",
        "code": "class Solution {\npublic:\n    Solution() {\n        \n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() MedianFinder {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype MedianFinder struct {\n\tminq hp\n\tmaxq hp\n}\n\nfunc (s *Solution) Constructor() MedianFinder {\n\treturn MedianFinder{hp{}, hp{}}\n}\n\nfunc (this *MedianFinder) AddNum(num int) {\n\tminq, maxq := &this.minq, &this.maxq\n\theap.Push(maxq, -num)\n\theap.Push(minq, -heap.Pop(maxq).(int))\n\tif minq.Len()-maxq.Len() > 1 {\n\t\theap.Push(maxq, -heap.Pop(minq).(int))\n\t}\n}\n\nfunc (this *MedianFinder) FindMedian() float64 {\n\tminq, maxq := this.minq, this.maxq\n\tif minq.Len() == maxq.Len() {\n\t\treturn float64(minq.IntSlice[0]-maxq.IntSlice[0]) / 2\n\t}\n\treturn float64(minq.IntSlice[0])\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool { return h.IntSlice[i] < h.IntSlice[j] }\nfunc (h *hp) Push(v any)        { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n\ta := h.IntSlice\n\tv := a[len(a)-1]\n\th.IntSlice = a[:len(a)-1]\n\treturn v\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddNum(num);\n * param_2 := obj.FindMedian();\n */"
      },
      "rust": {
        "initialCode": "struct MedianFinder {\n    // Your data structure here\n}\n\nimpl MedianFinder {\n    fn new() -> Self {\n        MedianFinder {}\n    }\n    \n    fn add_num(&mut self, num: i32) {\n        // Add a number to the data stream\n    }\n    \n    fn find_median(&self) -> f64 {\n        // Return the median of all elements so far\n        0.0\n    }\n}\n",
        "code": "use std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\nstruct MedianFinder {\n    minQ: BinaryHeap<Reverse<i32>>,\n    maxQ: BinaryHeap<i32>,\n}\n\nimpl MedianFinder {\n    fn new() -> Self {\n        MedianFinder {\n            minQ: BinaryHeap::new(),\n            maxQ: BinaryHeap::new(),\n        }\n    }\n\n    fn add_num(&mut self, num: i32) {\n        self.maxQ.push(num);\n        self.minQ.push(Reverse(self.maxQ.pop().unwrap()));\n\n        if self.minQ.len() > self.maxQ.len() + 1 {\n            self.maxQ.push(self.minQ.pop().unwrap().0);\n        }\n    }\n\n    fn find_median(&self) -> f64 {\n        if self.minQ.len() == self.maxQ.len() {\n            let min_top = self.minQ.peek().unwrap().0;\n            let max_top = *self.maxQ.peek().unwrap();\n            (min_top + max_top) as f64 / 2.0\n        } else {\n            self.minQ.peek().unwrap().0 as f64\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class MedianFinder:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def addNum(self, num: int) -> None:\n        # Add a number to the data stream\n        pass\n\n    def findMedian(self) -> float:\n        # Return the median of all elements so far\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "ipo",
      "title": "IPO",
      "difficulty": "Hard",
      "pattern": "Two Heaps"
    }
  },
  "task-scheduler": {
    "title": "Task Scheduler",
    "pattern": "Greedy / Math",
    "patternEmoji": "\ud83d\udcc5",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
    "intuition": [
      "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
      "\ud83e\udde0 Most frequent task determines frame size.",
      "\ud83d\udca1 Fill slots with other tasks."
    ],
    "testCases": [
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
        "output": "8"
      },
      {
        "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
        "output": "6"
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
        "output": "10"
      }
    ],
    "code": "class Solution:\n    from collections import Counter\n    \n    def leastInterval(self, tasks, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Minimum intervals to complete all tasks with cooldown.\n        - \ud83e\udde0 Most frequent task determines frame size.\n        - \ud83d\udca1 Fill slots with other tasks.\n        \"\"\"\n        counts = Counter(tasks)\n        maxCount = max(counts.values())  # Take the maximum value.\n        numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n        return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))  # Take the maximum value.",
    "keyInsight": "Frame size = (maxCount-1) * (n+1) + numMaxCount.",
    "visualizationType": "array",
    "initialState": [
      "A",
      "A",
      "A",
      "B",
      "B",
      "B"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Task Scheduler",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = A",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = A",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = A",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = B",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = B",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = B",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "A",
          "A",
          "A",
          "B",
          "B",
          "B"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).\n\nMinimum intervals to complete all tasks with cooldown.\nMost frequent task determines frame size.",
    "examples": [
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]; n = 2",
        "output": "8"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Minimum intervals to complete all tasks with cooldown.",
      "Most frequent task determines frame size.",
      "Fill slots with other tasks."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "s8p8ukTyA2I",
    "problemStatement": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\nReturn the minimum number of CPU intervals required to complete all tasks.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Greedy / Math: Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
    "suggestedNextQuestion": {
      "slug": "valid-parenthesis-string",
      "title": "Valid Parenthesis String",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def leastInterval(self, tasks, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def leastInterval(tasks, n):\n    count = {}\n    for t in tasks: count[t] = count.get(t, 0) + 1\n    max_freq = max(count.values())\n    max_count = list(count.values()).count(max_freq)\n    return max(len(tasks), (max_freq - 1) * (n + 1) + max_count)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
          "\ud83e\udde0 Most frequent task determines frame size.",
          "\ud83d\udca1 Fill slots with other tasks."
        ],
        "code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum intervals to complete all tasks with cooldown.\n    - \ud83e\udde0 Most frequent task determines frame size.\n    - \ud83d\udca1 Fill slots with other tasks.\n    \"\"\"\n    counts = Counter(tasks)\n    maxCount = max(counts.values())  # Take the maximum value.\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))  # Take the maximum value."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    leastInterval(tasks, n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} tasks, n\n     * @return {any}\n     */\n    leastInterval(tasks, n) {\n        const map = new Map();\n        let maxValue = 0;\n        let maxCount = 0;\n\n        tasks.forEach(key => {\n          const value = map.has(key) ? map.get(key) + 1 : 1;\n          map.set(key, value);\n\n          if (value > maxValue) {\n            maxValue = value;\n            maxCount = 1;\n          } else if (value === maxValue) {\n            maxCount++;\n      }\n    });\n\n    return Math.max(tasks.length, (maxValue - 1) * (n + 1) + maxCount);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] cnt = new int[26];\n        int x = 0;\n        for (char c : tasks) {\n            c -= 'A';\n            ++cnt[c];\n            x = Math.max(x, cnt[c]);\n        }\n        int s = 0;\n        for (int v : cnt) {\n            if (v == x) {\n                ++s;\n            }\n        }\n        return Math.max(tasks.length, (x - 1) * (n + 1) + s);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int leastInterval(vector<char>& tasks, int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        vector<int> cnt(26);\n        int x = 0;\n        for (char c : tasks) {\n            c -= 'A';\n            ++cnt[c];\n            x = max(x, cnt[c]);\n        }\n        int s = 0;\n        for (int v : cnt) {\n            s += v == x;\n        }\n        return max((int) tasks.size(), (x - 1) * (n + 1) + s);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) leastInterval(tasks []byte, n int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) leastInterval(tasks []byte, n int) int {\n\tcnt := make([]int, 26)\n\tx := 0\n\tfor _, c := range tasks {\n\t\tc -= 'A'\n\t\tcnt[c]++\n\t\tx = max(x, cnt[c])\n\t}\n\ts := 0\n\tfor _, v := range cnt {\n\t\tif v == x {\n\t\t\ts++\n\t\t}\n\t}\n\treturn max(len(tasks), (x-1)*(n+1)+s)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn least_interval(tasks: i32, n: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::collections::HashMap;\n\nimpl Solution {\n    fn least_interval(tasks: Vec<char>, n: i32) -> i32 {\n        let n = n as usize;\n        let m = tasks.len();\n        let mut hm: HashMap<char, usize> = HashMap::new();\n        let mut max_count = 0;\n        for t in tasks {\n            let count = hm.entry(t).or_default();\n            *count += 1;\n            max_count = max_count.max(*count);\n        }\n        let task_with_max_count = hm.values().filter(|&&x| x == max_count).count();\n        usize::max(m, (n + 1) * (max_count - 1) + task_with_max_count) as i32\n    }\n}\n\n#[test]\nfn test() {\n    let tasks = vec!['A', 'A', 'A', 'B', 'B', 'B'];\n    let n = 2;\n    let res = 8;\n    assert_eq!(Solution::least_interval(tasks, n), res);\n    let tasks = vec!['A', 'A', 'A', 'B', 'B', 'B'];\n    let n = 0;\n    let res = 6;\n    assert_eq!(Solution::least_interval(tasks, n), res);\n    let tasks = vec!['A', 'A', 'A', 'A', 'A', 'A', 'B', 'C', 'D', 'E', 'F', 'G'];\n    let n = 2;\n    let res = 16;\n    assert_eq!(Solution::least_interval(tasks, n), res);\n}"
      },
      "python": {
        "initialCode": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Minimum intervals to complete all tasks with cooldown.\n    - \ud83e\udde0 Most frequent task determines frame size.\n    - \ud83d\udca1 Fill slots with other tasks.\n    \"\"\"\n    counts = Counter(tasks)\n    maxCount = max(counts.values())  # Take the maximum value.\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))  # Take the maximum value."
      },
      "typescript": {
        "code": "class Solution {\n    leastInterval(tasks: any, n: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    leastInterval(tasks: any, n: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "k-closest-points-to-origin": {
    "title": "K Closest Points to Origin",
    "pattern": "Heap",
    "patternEmoji": "\ud83d\udccd",
    "timeComplexity": "O(n log k)",
    "spaceComplexity": "O(k)",
    "oneliner": "Max-heap of size k. Keep k smallest distances.",
    "intuition": [
      "\ud83c\udfaf Find k closest points to origin.",
      "\ud83e\udde0 Use max-heap of size k.",
      "\ud83d\udca1 If new point closer, pop max and push new."
    ],
    "testCases": [
      {
        "input": "points = [[1,3],[-2,2]], k = 1",
        "output": "[[-2,2]]"
      },
      {
        "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
        "output": "[[3,3],[-2,4]]"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def kClosest(self, points, k):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Find k closest points to origin.\n        - \ud83e\udde0 Use max-heap of size k.\n        - \ud83d\udca1 If new point closer, pop max and push new.\n        \"\"\"\n        heap = []\n        for x, y in points:  # Iterate over elements.\n            dist = x*x + y*y\n            if len(heap) < k:\n                heapq.heappush(heap, (-dist, [x, y]))\n            elif dist < -heap[0][0]:\n                heapq.heapreplace(heap, (-dist, [x, y]))\n        return [p for _, p in heap]",
    "keyInsight": "Max-heap of size k keeps k smallest elements.",
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        3
      ],
      [
        -2,
        2
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: K Closest Points to Origin",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1,3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = -2,2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            1,
            3
          ],
          [
            -2,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "Max-heap of size k. Keep k smallest distances.\n\nFind k closest points to origin.\nUse max-heap of size k.",
    "examples": [
      {
        "input": "points = [[1,3],[-2,2]]; k = 1",
        "output": "[[-2,2]]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Find k closest points to origin.",
      "Use max-heap of size k.",
      "If new point closer, pop max and push new."
    ],
    "relatedProblems": [
      "kth-largest-element-in-an-array",
      "top-k-frequent-elements",
      "merge-k-sorted-lists"
    ],
    "videoId": "rI2EBUEMfTk",
    "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
    "difficulty": "Medium",
    "walkthrough": [
      "Initialize min/max heap",
      "Add elements to heap with appropriate key",
      "Extract elements in priority order",
      "Maintain heap size if needed (top K)",
      "Return final result"
    ],
    "approach": "Heap: Max-heap of size k. Keep k smallest distances.",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def kClosest(self, points, k):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def kClosest_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "\ud83c\udfaf Find k closest points to origin.",
          "\ud83e\udde0 Use max-heap of size k.",
          "\ud83d\udca1 If new point closer, pop max and push new."
        ],
        "code": "import heapq\n\ndef kClosest(points, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k closest points to origin.\n    - \ud83e\udde0 Use max-heap of size k.\n    - \ud83d\udca1 If new point closer, pop max and push new.\n    \"\"\"\n    heap = []\n    for x, y in points:  # Iterate over elements.\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    kClosest(points, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} points, k\n     * @return {any}\n     */\n    kClosest(points, k) {\n        const getDistance = (x, y) => x * x + y * y;\n\n        return points\n          .map(point => ({ point, dist: getDistance(point[0], point[1]) }))\n          .sort((a, b) => a.dist - b.dist)\n          .slice(0, k)\n          .map(item => item.point);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        Arrays.sort(\n            points, (p1, p2) -> Math.hypot(p1[0], p1[1]) - Math.hypot(p2[0], p2[1]) > 0 ? 1 : -1);\n        return Arrays.copyOfRange(points, 0, k);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        sort(points.begin(), points.end(), [](const vector<int>& p1, const vector<int>& p2) {\n            return hypot(p1[0], p1[1]) < hypot(p2[0], p2[1]);\n        });\n        return vector<vector<int>>(points.begin(), points.begin() + k);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) kClosest(points [][]int, k int) [][]int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) kClosest(points [][]int, k int) [][]int {\n\tsort.Slice(points, func(i, j int) bool {\n\t\treturn math.Hypot(float64(points[i][0]), float64(points[i][1])) < math.Hypot(float64(points[j][0]), float64(points[j][1]))\n\t})\n\treturn points[:k]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn k_closest(mut points: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        points.sort_by(|a, b| {\n            let dist_a = f64::hypot(a[0] as f64, a[1] as f64);\n            let dist_b = f64::hypot(b[0] as f64, b[1] as f64);\n            dist_a.partial_cmp(&dist_b).unwrap()\n        });\n        points.into_iter().take(k as usize).collect()\n    }\n}"
      },
      "python": {
        "initialCode": "import heapq\n\ndef kClosest(points, k):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Find k closest points to origin.\n    - \ud83e\udde0 Use max-heap of size k.\n    - \ud83d\udca1 If new point closer, pop max and push new.\n    \"\"\"\n    heap = []\n    for x, y in points:  # Iterate over elements.\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]"
      },
      "typescript": {
        "code": "class Solution {\n    kClosest(points: number[][], k: number): number[][]  {\n    points.sort((a, b) => Math.hypot(a[0], a[1]) - Math.hypot(b[0], b[1]));\n    return points.slice(0, k);\n}\n}",
        "initialCode": "class Solution {\n    kClosest(points: number[][], k: number): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "find-k-pairs-with-smallest-sums",
      "title": "Find K Pairs with Smallest Sums",
      "difficulty": "Medium",
      "pattern": "Heap"
    }
  },
  "minimum-operations-to-reduce-an-integer-to-0": {
    "title": "Minimum Operations to Reduce an Integer to 0",
    "pattern": "Bit Manipulation",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Add/subtract powers of 2. Handle consecutive 1s.",
    "intuition": [
      "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
      "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
      "\ud83d\udca1 '11' pattern better to add than subtract twice."
    ],
    "testCases": [
      {
        "input": "n = 39",
        "output": "3"
      },
      {
        "input": "n = 54",
        "output": "3"
      }
    ],
    "code": "class Solution:\n    def minOperations(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min operations to make n = 0 using \u00b12^k.\n        - \ud83e\udde0 Consecutive 1s: add to clear, else subtract.\n        - \ud83d\udca1 '11' pattern better to add than subtract twice.\n        \"\"\"\n        ops = 0\n        while n:\n            if n & 1:  # Check if last bit is set (odd).\n                if (n >> 1) & 1:\n                    n += 1\n                else:\n                    n -= 1\n                ops += 1\n            n >>= 1  # Right shift to process next bit.\n        return ops",
    "keyInsight": "If two consecutive 1s, adding is more efficient.",
    "visualizationType": "array",
    "initialState": "39",
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Starting with n = 39, ops = 0",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n = 39 (binary: 100111), checking if n & 1 is true (last bit is 1)",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Checking (n >> 1) & 1: (39 >> 1) & 1 = 19 & 1 = 1, so n += 1",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n becomes 40 (101000), ops = 1",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n >>= 1: n becomes 20 (10100), continuing loop",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n = 20 (10100), n & 1 is false (last bit is 0), just shift right",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n >>= 1: n becomes 10 (1010), continuing loop",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n = 10 (1010), n & 1 is false, just shift right",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n >>= 1: n becomes 5 (101), ops still = 1",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n = 5 (101), n & 1 is true, checking (n >> 1) & 1 = (5 >> 1) & 1 = 2 & 1 = 0",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Since (n >> 1) & 1 is 0, n -= 1: n becomes 4, ops = 2",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n >>= 1: n becomes 2, then n >>= 1: n becomes 1",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n = 1, n & 1 is true, (n >> 1) & 1 = 0, so n -= 1: n becomes 0, ops = 3",
        "arrayState": [
          "3",
          "9"
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "n is now 0, loop ends. Return ops = 3",
        "arrayState": [
          "3",
          "9"
        ]
      }
    ],
    "description": "Add/subtract powers of 2. Handle consecutive 1s.\n\nMin operations to make n = 0 using \u00b12^k.\nConsecutive 1s: add to clear, else subtract.",
    "examples": [
      {
        "input": "n = 39",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min operations to make n = 0 using \u00b12^k.",
      "Consecutive 1s: add to clear, else subtract.",
      "'11' pattern better to add than subtract twice."
    ],
    "relatedProblems": [
      "single-number",
      "counting-bits",
      "reverse-bits"
    ],
    "videoId": "O3VbqTLzTu8",
    "problemStatement": "You are given a positive integer n, you can do the following operation any number of times:\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i where i >= 0.",
    "difficulty": "Medium",
    "walkthrough": [
      "Identify bits pattern in problem",
      "Use bitwise operators (AND, OR, XOR, shift)",
      "Iterate through bits if needed",
      "Combine results using bit operations",
      "Return final bit result"
    ],
    "approach": "Bit Manipulation: Add/subtract powers of 2. Handle consecutive 1s.",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def minOperations(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def minOperations(n):\n    res = 0\n    while n > 0:\n        if (n & 3) == 3:\n            n += 1\n            res += 1\n        elif (n & 1) == 1:\n            n -= 1\n            res += 1\n        else:\n            n //= 2\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
          "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
          "\ud83d\udca1 '11' pattern better to add than subtract twice."
        ],
        "code": "def minOperations(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min operations to make n = 0 using \u00b12^k.\n    - \ud83e\udde0 Consecutive 1s: add to clear, else subtract.\n    - \ud83d\udca1 '11' pattern better to add than subtract twice.\n    \"\"\"\n    ops = 0\n    while n:\n        if n & 1:  # Check if last bit is set (odd).\n            if (n >> 1) & 1:\n                n += 1\n            else:\n                n -= 1\n            ops += 1\n        n >>= 1  # Right shift to process next bit.\n    return ops"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minOperations(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    minOperations(n) {\n        let result = 0;\n\n        while (n > 0) {\n          if ((n & 1) === 0) {\n            n >>= 1;\n          } else if ((n & 3) === 3) {\n            n += 1;\n            result++;\n          } else {\n            n -= 1;\n            result++;\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minOperations(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minOperations(int n) {\n        int ans = 0, cnt = 0;\n        for (; n > 0; n >>= 1) {\n            if ((n & 1) == 1) {\n                ++cnt;\n            } else if (cnt > 0) {\n                ++ans;\n                cnt = cnt == 1 ? 0 : 1;\n            }\n        }\n        ans += cnt == 1 ? 1 : 0;\n        ans += cnt > 1 ? 2 : 0;\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minOperations(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int minOperations(int n) {\n        int ans = 0, cnt = 0;\n        for (; n > 0; n >>= 1) {\n            if ((n & 1) == 1) {\n                ++cnt;\n            } else if (cnt > 0) {\n                ++ans;\n                cnt = cnt == 1 ? 0 : 1;\n            }\n        }\n        ans += cnt == 1 ? 1 : 0;\n        ans += cnt > 1 ? 2 : 0;\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minOperations(n int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minOperations(n int) (ans int) {\n\tcnt := 0\n\tfor ; n > 0; n >>= 1 {\n\t\tif n&1 == 1 {\n\t\t\tcnt++\n\t\t} else if cnt > 0 {\n\t\t\tans++\n\t\t\tif cnt == 1 {\n\t\t\t\tcnt = 0\n\t\t\t} else {\n\t\t\t\tcnt = 1\n\t\t\t}\n\t\t}\n\t}\n\tif cnt == 1 {\n\t\tans++\n\t} else if cnt > 1 {\n\t\tans += 2\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_operations(n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_operations(n: i32) -> i32 {\n        let mut n = n;\n        let mut ops = 0;\n        while n > 0 {\n            if (n & 1) == 1 {\n                if (n & 2) == 2 {\n                    n += 1;\n                } else {\n                    n -= 1;\n                }\n                ops += 1;\n            }\n            n >>= 1;\n        }\n        ops\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minOperations(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minOperations(n: number): number  {\n    let [ans, cnt] = [0, 0];\n    for (; n; n >>= 1) {\n        if (n & 1) {\n            ++cnt;\n        } else if (cnt) {\n            ++ans;\n            cnt = cnt === 1 ? 0 : 1;\n        }\n    }\n    if (cnt === 1) {\n        ++ans;\n    } else if (cnt > 1) {\n        ans += 2;\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    minOperations(n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "sum-of-two-integers",
      "title": "Sum of Two Integers",
      "difficulty": "Medium",
      "pattern": "Bit Manipulation"
    }
  },
  "integer-replacement": {
    "title": "Integer Replacement",
    "pattern": "Bit Manipulation / BFS",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
    "intuition": [
      "\ud83c\udfaf Min steps to reduce n to 1.",
      "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
      "\ud83d\udca1 For odd, choose based on trailing bits."
    ],
    "testCases": [
      {
        "input": "n = 8",
        "output": "3"
      },
      {
        "input": "n = 7",
        "output": "4"
      },
      {
        "input": "n = 4",
        "output": "2"
      }
    ],
    "code": "class Solution:\n    def integerReplacement(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min steps to reduce n to 1.\n        - \ud83e\udde0 Even: n/2. Odd: n+1 or n-1.\n        - \ud83d\udca1 For odd, choose based on trailing bits.\n        \"\"\"\n        ops = 0\n        while n != 1:\n            if n % 2 == 0:  # Check for even number.\n                n //= 2\n            elif n == 3 or (n >> 1) & 1 == 0:\n                n -= 1\n            else:\n                n += 1\n            ops += 1\n        return ops",
    "keyInsight": "Special case n=3: subtract is better than add.",
    "visualizationType": "array",
    "initialState": "8",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Integer Replacement",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "8"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 8",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "8"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute result phase 6",
        "transientMessage": "Building solution",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "8"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.\n\nMin steps to reduce n to 1.\nEven: n/2. Odd: n+1 or n-1.",
    "examples": [
      {
        "input": "n = 8",
        "output": "3"
      },
      {
        "input": "n = 7",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Min steps to reduce n to 1.",
      "Even: n/2. Odd: n+1 or n-1.",
      "For odd, choose based on trailing bits."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "xzoLTiPDY0M",
    "problemStatement": "Given a positive integer n, you can apply one of the following operations:\nReturn the minimum number of operations needed for n to become 1.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Bit Manipulation / BFS: If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
    "suggestedNextQuestion": {
      "slug": "jump-game-ii",
      "title": "Jump Game II",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def integerReplacement(self, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def integerReplacement(n):\n    def solve(i):\n        if i == 1: return 0\n        if i % 2 == 0:\n            return 1 + solve(i // 2)\n        else:\n            return 1 + min(solve(i + 1), solve(i - 1))\n    return solve(n)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "\ud83c\udfaf Min steps to reduce n to 1.",
          "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
          "\ud83d\udca1 For odd, choose based on trailing bits."
        ],
        "code": "def integerReplacement(n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Min steps to reduce n to 1.\n    - \ud83e\udde0 Even: n/2. Odd: n+1 or n-1.\n    - \ud83d\udca1 For odd, choose based on trailing bits.\n    \"\"\"\n    ops = 0\n    while n != 1:\n        if n % 2 == 0:  # Check for even number.\n            n //= 2\n        elif n == 3 or (n >> 1) & 1 == 0:\n            n -= 1\n        else:\n            n += 1\n        ops += 1\n    return ops"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    integerReplacement(n, count = 0) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n, count = 0\n     * @return {any}\n     */\n    integerReplacement(n, count = 0) {\n        if (n === 1) return count;\n        if (n % 2 === 0) {\n          return integerReplacement(n / 2, count + 1);\n        } else {\n          return Math.min(integerReplacement(n + 1, count + 1), integerReplacement(n - 1, count + 1));\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int integerReplacement(int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int integerReplacement(int n) {\n        int ans = 0;\n        while (n != 1) {\n            if ((n & 1) == 0) {\n                n >>>= 1;\n            } else if (n != 3 && (n & 3) == 3) {\n                ++n;\n            } else {\n                --n;\n            }\n            ++ans;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int integerReplacement(int N) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int integerReplacement(int N) {\n        int ans = 0;\n        long n = N;\n        while (n != 1) {\n            if ((n & 1) == 0)\n                n >>= 1;\n            else if (n != 3 && (n & 3) == 3)\n                ++n;\n            else\n                --n;\n            ++ans;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) integerReplacement(n int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) integerReplacement(n int) int {\n\tans := 0\n\tfor n != 1 {\n\t\tif (n & 1) == 0 {\n\t\t\tn >>= 1\n\t\t} else if n != 3 && (n&3) == 3 {\n\t\t\tn++\n\t\t} else {\n\t\t\tn--\n\t\t}\n\t\tans++\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn integer_replacement(n: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn integer_replacement(n: i32) -> i32 {\n        Self::dfs(n as u32) as i32\n    }\n    fn dfs(mut n: u32) -> usize {\n        if n == 1 {\n            0\n        } else {\n            let mut zeros = 0;\n            while n & 1 == 0 {\n                n >>= 1;\n                zeros += 1;\n            }\n            if n == 1 {\n                zeros\n            } else {\n                zeros + 1 + Self::dfs(n + 1).min(Self::dfs(n - 1))\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let n = 8;\n    let res = 3;\n    assert_eq!(Solution::integer_replacement(n), res);\n    let n = 7;\n    let res = 4;\n    assert_eq!(Solution::integer_replacement(n), res);\n    let n = 2147483647;\n    let res = 32;\n    assert_eq!(Solution::integer_replacement(n), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def integerReplacement(self, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Min steps to reduce n to 1.\n        - \ud83e\udde0 Even: n/2. Odd: n+1 or n-1.\n        - \ud83d\udca1 For odd, choose based on trailing bits.\n        \"\"\"\n        ops = 0\n        while n != 1:\n            if n % 2 == 0:  # Check for even number.\n                n //= 2\n            elif n == 3 or (n >> 1) & 1 == 0:\n                n -= 1\n            else:\n                n += 1\n            ops += 1\n        return ops"
      },
      "typescript": {
        "code": "class Solution {\n    integerReplacement(n: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    integerReplacement(n: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "range-sum-query---immutable": {
    "title": "Range Sum Query - Immutable",
    "pattern": "Prefix Sum",
    "patternEmoji": "\u2795",
    "timeComplexity": "O(1) query",
    "spaceComplexity": "O(n)",
    "oneliner": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
    "intuition": [
      "\ud83c\udfaf Sum of elements in range [left, right].",
      "\ud83e\udde0 Prefix sum array enables O(1) queries.",
      "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
    ],
    "testCases": [
      {
        "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
        "output": "[null,1,-1]"
      }
    ],
    "code": "class Solution:\n    class NumArray:\n        def __init__(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Sum of elements in range [left, right].\n        - \ud83e\udde0 Prefix sum array enables O(1) queries.\n        - \ud83d\udca1 prefix[i] = sum of nums[0:i].\n        \"\"\"\n            self.prefix = [0]\n            for n in nums:  # Iterate over elements.\n                self.prefix.append(self.prefix[-1] + n)  # Add to end.\n        \n        def sumRange(self, left: int, right: int) -> int:\n            return self.prefix[right + 1] - self.prefix[left]",
    "keyInsight": "Prefix sum enables O(1) range queries.",
    "visualizationType": "array",
    "initialState": [
      -2,
      0,
      3,
      -5,
      2,
      -1
    ],
    "animationSteps": [
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [],
        "transientMessage": "Initializing NumArray with [-2, 0, 3, -5, 2, -1]",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 0,
            "label": "prefix"
          }
        ],
        "transientMessage": "Creating prefix sum array, starting with 0",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          1
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 1,
            "label": "n=-2"
          }
        ],
        "transientMessage": "Adding -2 to prefix sum: 0 + (-2) = -2",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          2
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 2,
            "label": "n=0"
          }
        ],
        "transientMessage": "Adding 0 to prefix sum: -2 + 0 = -2",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          2,
          3
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 3,
            "label": "n=3"
          }
        ],
        "transientMessage": "Adding 3 to prefix sum: -2 + 3 = 1",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          3,
          4
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 4,
            "label": "n=-5"
          }
        ],
        "transientMessage": "Adding -5 to prefix sum: 1 + (-5) = -4",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          4,
          5
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 5,
            "label": "n=2"
          }
        ],
        "transientMessage": "Adding 2 to prefix sum: -4 + 2 = -2",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          5,
          6
        ],
        "color": "accent",
        "pointers": [
          {
            "index": 6,
            "label": "n=-1"
          }
        ],
        "transientMessage": "Adding -1 to prefix sum: -2 + (-1) = -3",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          1,
          4
        ],
        "color": "success",
        "pointers": [
          {
            "index": 1,
            "label": "left"
          },
          {
            "index": 4,
            "label": "right"
          }
        ],
        "transientMessage": "Calculating sum from index 1 to 3: prefix[4] - prefix[1] = -4 - (-2) = -2",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      },
      {
        "type": "highlight",
        "indices": [
          0,
          3
        ],
        "color": "success",
        "pointers": [
          {
            "index": 0,
            "label": "left"
          },
          {
            "index": 3,
            "label": "right"
          }
        ],
        "transientMessage": "Calculating sum from index 0 to 2: prefix[3] - prefix[0] = 1 - 0 = 1",
        "arrayState": [
          -2,
          0,
          3,
          -5,
          2,
          -1
        ]
      }
    ],
    "description": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].\n\nSum of elements in range [left, right].\nPrefix sum array enables O(1) queries.",
    "examples": [
      {
        "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
        "output": "[null,1,-1]"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Sum of elements in range [left, right].",
      "Prefix sum array enables O(1) queries.",
      "prefix[i] = sum of nums[0:i]."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "ZMOFmHBVEcg",
    "problemStatement": "Given an integer array nums, handle multiple queries of the following type:\nImplement the NumArray class:",
    "difficulty": "Easy",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "Prefix Sum: Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
    "suggestedNextQuestion": {
      "slug": "transformed-array",
      "title": "Transformed Array",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a running total on a receipt. You can tell the cost of items 5-10 by subtracting total(4) from total(10).",
    "initialCode": "class NumArray:\n    def __init__(self, nums: list[int]):\n        # Initialize your data structure here with the given array\n        pass\n\n    def sumRange(self, left: int, right: int) -> int:\n        # Return the sum of elements from index left to right (inclusive)\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class NumArray:\n    def __init__(self, nums):\n        self.pre = [0]\n        for n in nums:\n            self.pre.append(self.pre[-1] + n)\n    def sumRange(self, left, right):\n        return self.pre[right+1] - self.pre[left]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1) query",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Sum of elements in range [left, right].",
          "\ud83e\udde0 Prefix sum array enables O(1) queries.",
          "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
        ],
        "code": "class NumArray:\n    def __init__(self, nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Sum of elements in range [left, right].\n    - \ud83e\udde0 Prefix sum array enables O(1) queries.\n    - \ud83d\udca1 prefix[i] = sum of nums[0:i].\n    \"\"\"\n        self.prefix = [0]\n        for n in nums:  # Iterate over elements.\n            self.prefix.append(self.prefix[-1] + n)  # Add to end.\n    \n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix[right + 1] - self.prefix[left]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor(nums: number[]) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor(nums: number[]) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void __init__(int[] nums) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void __init__(int[] nums) {\n        \n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int sumRange(int left, int right) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    Solution(vector<int>& nums) {}\n    \n    int sumRange(int left, int right) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor(nums []int) NumArray {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype NumArray struct {\n\ts []int\n}\n\nfunc (s *Solution) Constructor(nums []int) NumArray {\n\tn := len(nums)\n\ts := make([]int, n+1)\n\tfor i, v := range nums {\n\t\ts[i+1] = s[i] + v\n\t}\n\treturn NumArray{s}\n}\n\nfunc (this *NumArray) SumRange(left int, right int) int {\n\treturn this.s[right+1] - this.s[left]\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * obj := Constructor(nums);\n * param_1 := obj.SumRange(left,right);\n */"
      },
      "rust": {
        "initialCode": "struct NumArray {\n    // Your data structure here\n}\n\nimpl NumArray {\n    fn new(nums: Vec<i32>) -> Self {\n        NumArray {}\n    }\n    \n    fn sum_range(&self, left: i32, right: i32) -> i32 {\n        // Return the sum of elements from index left to right (inclusive)\n        0\n    }\n}\n",
        "code": "struct NumArray {\n    s: Vec<i32>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl NumArray {\n    fn new(mut nums: Vec<i32>) -> Self {\n        let n = nums.len();\n        let mut s = vec![0; n + 1];\n        for i in 0..n {\n            s[i + 1] = s[i] + nums[i];\n        }\n        Self { s }\n    }\n\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\n        self.s[(right + 1) as usize] - self.s[left as usize]\n    }\n}"
      },
      "python": {
        "initialCode": "class NumArray:\n    def __init__(self, nums: list[int]):\n        # Initialize your data structure here with the given array\n        pass\n\n    def sumRange(self, left: int, right: int) -> int:\n        # Return the sum of elements from index left to right (inclusive)\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n\n    __init__(nums: number[]) {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "unique-paths": {
    "title": "Unique Paths",
    "pattern": "2D DP",
    "patternEmoji": "\ud83d\udee4\ufe0f",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(n)",
    "oneliner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
    "intuition": [
      "\ud83c\udfaf Count paths from top-left to bottom-right.",
      "\ud83e\udde0 Can only move right or down.",
      "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
    ],
    "testCases": [
      {
        "input": "m = 3, n = 7",
        "output": "28"
      },
      {
        "input": "m = 3, n = 2",
        "output": "3"
      }
    ],
    "code": "class Solution:\n    def uniquePaths(self, m, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count paths from top-left to bottom-right.\n        - \ud83e\udde0 Can only move right or down.\n        - \ud83d\udca1 dp[i][j] = sum of paths from top and left.\n        \"\"\"\n        dp = [1] * n  # Initialize DP table to store results.\n        for _ in range(1, m):  # Iterate through the range.\n            for j in range(1, n):  # Iterate through the range.\n                dp[j] += dp[j - 1]\n        return dp[n - 1]",
    "keyInsight": "Each cell = sum of paths from above and left.",
    "visualizationType": "matrix",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Unique Paths",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "1",
            "1",
            "0",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "1",
            "0",
            "0"
          ],
          [
            "0",
            "0",
            "0",
            "1",
            "1"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "description": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.\n\nCount paths from top-left to bottom-right.\nCan only move right or down.",
    "examples": [
      {
        "input": "m = 3; n = 7",
        "output": "28"
      },
      {
        "input": "m = 3; n = 2",
        "output": "3"
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "-10^9 <= value <= 10^9"
    ],
    "hints": [
      "Count paths from top-left to bottom-right.",
      "Can only move right or down.",
      "dp[i][j] = sum of paths from top and left."
    ],
    "relatedProblems": [
      "two-sum",
      "climbing-stairs",
      "binary-search"
    ],
    "videoId": "IlEsdxuD4lY",
    "problemStatement": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "approach": "2D DP: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
    "suggestedNextQuestion": {
      "slug": "unique-paths-ii",
      "title": "Unique Paths II",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like filling out a form where each answer depends on previous answers.",
    "initialCode": "class Solution:\n    def uniquePaths(self, m, n):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def uniquePaths(m, n):\n    # Recursive\n    def dfs(r, c):\n        if r == m-1 and c == n-1: return 1\n        if r >= m or c >= n: return 0\n        return dfs(r+1, c) + dfs(r, c+1)\n    return dfs(0, 0)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Count paths from top-left to bottom-right.",
          "\ud83e\udde0 Can only move right or down.",
          "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
        ],
        "code": "def uniquePaths(m, n):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Count paths from top-left to bottom-right.\n    - \ud83e\udde0 Can only move right or down.\n    - \ud83d\udca1 dp[i][j] = sum of paths from top and left.\n    \"\"\"\n    dp = [1] * n  # Initialize DP table to store results.\n    for _ in range(1, m):  # Iterate through the range.\n        for j in range(1, n):  # Iterate through the range.\n            dp[j] += dp[j - 1]\n    return dp[n - 1]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    uniquePaths(m, n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} m, n\n     * @return {any}\n     */\n    uniquePaths(m, n) {\n        const f = Array(m)\n            .fill(0)\n            .map(() => Array(n).fill(0));\n        f[0][0] = 1;\n        for (let i = 0; i < m; ++i) {\n            for (let j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] += f[i - 1][j];\n                }\n                if (j > 0) {\n                    f[i][j] += f[i][j - 1];\n                }\n            }\n    }\n    return f[m - 1][n - 1];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int uniquePaths(int m, int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        var f = new int[m][n];\n        f[0][0] = 1;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0) {\n                    f[i][j] += f[i - 1][j];\n                }\n                if (j > 0) {\n                    f[i][j] += f[i][j - 1];\n                }\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int uniquePaths(int m, int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m, vector<int>(n));\n        f[0][0] = 1;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i) {\n                    f[i][j] += f[i - 1][j];\n                }\n                if (j) {\n                    f[i][j] += f[i][j - 1];\n                }\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) uniquePaths(m int, n int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) uniquePaths(m int, n int) int {\n\tf := make([][]int, m)\n\tfor i := range f {\n\t\tf[i] = make([]int, n)\n\t}\n\tf[0][0] = 1\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif i > 0 {\n\t\t\t\tf[i][j] += f[i-1][j]\n\t\t\t}\n\t\t\tif j > 0 {\n\t\t\t\tf[i][j] += f[i][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m-1][n-1]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn unique_paths(m: i32, n: i32) -> i32 {\n        let (m, n) = (m as usize, n as usize);\n        let mut f = vec![1; n];\n        for i in 1..m {\n            for j in 1..n {\n                f[j] += f[j - 1];\n            }\n        }\n        f[n - 1]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def uniquePaths(self, m, n):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Count paths from top-left to bottom-right.\n        - \ud83e\udde0 Can only move right or down.\n        - \ud83d\udca1 dp[i][j] = sum of paths from top and left.\n        \"\"\"\n        dp = [1] * n  # Initialize DP table to store results.\n        for _ in range(1, m):  # Iterate through the range.\n            for j in range(1, n):  # Iterate through the range.\n                dp[j] += dp[j - 1]\n        return dp[n - 1]"
      },
      "typescript": {
        "code": "class Solution {\n    uniquePaths(m: number, n: number): number  {\n    const f: number[][] = Array(m)\n        .fill(0)\n        .map(() => Array(n).fill(0));\n    f[0][0] = 1;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (i > 0) {\n                f[i][j] += f[i - 1][j];\n            }\n            if (j > 0) {\n                f[i][j] += f[i][j - 1];\n            }\n        }\n    }\n    return f[m - 1][n - 1];\n}\n}",
        "initialCode": "class Solution {\n    uniquePaths(m: number, n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    }
  },
  "lru-cache": {
    "title": "LRU Cache",
    "pattern": "Design",
    "patternEmoji": "\ud83c\udfd7\ufe0f",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(capacity)",
    "oneliner": "Use a hashmap for O(1) lookup and a doubly-linked list for O(1) eviction ordering.",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations in O(1) time complexity.",
    "intuition": [
      "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
      "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
      "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
    ],
    "keyInsight": "Combining HashMap with Doubly Linked List gives us O(1) for both get and put operations.",
    "code": "class Solution:\n    def test_lru_cache(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal\n        - \ud83e\udde0 HashMap stores key -> node reference for quick lookup\n        - \ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail\n        \"\"\"\n        from collections import OrderedDict\n\n        class LRUCache:\n            def __init__(self, capacity: int):\n                self.cache = OrderedDict()\n                self.capacity = capacity\n\n            def get(self, key: int) -> int:\n                if key not in self.cache:\n                    return -1\n                self.cache.move_to_end(key)\n                return self.cache[key]\n\n            def put(self, key: int, value: int) -> None:\n                if key in self.cache:\n                    self.cache.move_to_end(key)\n                self.cache[key] = value\n                if len(self.cache) > self.capacity:\n                    self.cache.popitem(last=False)\n\n        # Test case 1\n        cache = LRUCache(2)\n        cache.put(1, 1)\n        cache.put(2, 2)\n        result1 = cache.get(1)\n\n        # Test case 2\n        cache2 = LRUCache(2)\n        cache2.put(1, 1)\n        cache2.put(2, 2)\n        cache2.put(3, 3)\n        result2 = cache2.get(2)\n\n        return [result1, result2]",
    "testCases": [
      {
        "input": "",
        "output": "[1, 2]"
      }
    ],
    "examples": [
      {
        "input": "LRUCache(2), put(1,1), put(2,2), get(1)",
        "output": "1",
        "explanation": "Key 1 exists and is returned"
      },
      {
        "input": "LRUCache(2), put(1,1), put(2,2), put(3,3), get(2)",
        "output": "-1",
        "explanation": "Key 2 was evicted when 3 was added"
      }
    ],
    "constraints": [
      "1 <= capacity <= 3000",
      "0 <= key <= 10^4",
      "0 <= value <= 10^5"
    ],
    "hints": [
      "Use OrderedDict for simplicity in Python",
      "Move accessed keys to end to mark as recently used",
      "Pop from beginning when over capacity"
    ],
    "relatedProblems": [
      "all-oone-data-structure",
      "lfu-cache",
      "design-in-memory-file-system"
    ],
    "videoId": "7ABFKPK2hD4",
    "problemStatement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nThe functions get and put must each run in O(1) average time complexity.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "linkedlist",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: LRU Cache",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "approach": "Hash Map + Doubly Linked List: Use a hashmap for O(1) lookup and a doubly-linked list for O(1) eviction ordering.",
    "mentalModel": "Like building a custom machine. You decide how the gears (data structures) fit together.",
    "initialCode": "class LRUCache:\n    def __init__(self, capacity: int):\n        # Initialize your data structure here\n        pass\n\n    def get(self, key: int) -> int:\n        # Return the value of the key if it exists, otherwise return -1\n        pass\n\n    def put(self, key: int, value: int) -> None:\n        # Update the value of the key if it exists, otherwise add the key-value pair\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class LRUCache:\n    def __init__(self, capacity):\n        self.cap = capacity\n        self.cache = {} # key: val\n        self.order = [] # key\n    def get(self, key):\n        if key in self.cache:\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n        return -1\n    def put(self, key, value):\n        if key in self.cache:\n            self.order.remove(key)\n        self.cache[key] = value\n        self.order.append(key)\n        if len(self.order) > self.cap:\n            del self.cache[self.order.pop(0)]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(capacity)",
        "intuition": [
          "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
          "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
          "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
        ],
        "code": "def test_lru_cache():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal\n    - \ud83e\udde0 HashMap stores key -> node reference for quick lookup\n    - \ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail\n    \"\"\"\n    from collections import OrderedDict\n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n        def put(self, key: int, value: int) -> None:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.capacity:\n                self.cache.popitem(last=False)\n    \n    # Test case 1\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    result1 = cache.get(1)\n    \n    # Test case 2\n    cache2 = LRUCache(2)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    result2 = cache2.get(2)\n    \n    return [result1, result2]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor(capacity) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor(capacity) {\n        // Your code here\n    }\n}"
      },
      "java": {
        "initialCode": "import java.util.HashMap;\n\nclass Solution {\n    public Solution(int capacity) {\n        // Your code here\n    }\n}",
        "code": "import java.util.HashMap;\n\nclass Solution {\n    public Solution(int capacity) {\n        // Your code here\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {\n        \n    }\n};",
        "code": "class Solution {\npublic:\n    Solution() {\n        \n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor(capacity int) LRUCache {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype Node struct {\n\tkey, val   int\n\tprev, next *Node\n}\n\ntype LRUCache struct {\n\tsize, capacity int\n\thead, tail     *Node\n\tcache          map[int]*Node\n}\n\nfunc (s *Solution) Constructor(capacity int) LRUCache {\n\thead := &Node{}\n\ttail := &Node{}\n\thead.next = tail\n\ttail.prev = head\n\treturn LRUCache{\n\t\tcapacity: capacity,\n\t\thead:     head,\n\t\ttail:     tail,\n\t\tcache:    make(map[int]*Node),\n\t}\n}\n\nfunc (this *LRUCache) Get(key int) int {\n\tif node, exists := this.cache[key]; exists {\n\t\tthis.removeNode(node)\n\t\tthis.addToHead(node)\n\t\treturn node.val\n\t}\n\treturn -1\n}\n\nfunc (this *LRUCache) Put(key int, value int) {\n\tif node, exists := this.cache[key]; exists {\n\t\tthis.removeNode(node)\n\t\tnode.val = value\n\t\tthis.addToHead(node)\n\t} else {\n\t\tnode := &Node{key: key, val: value}\n\t\tthis.cache[key] = node\n\t\tthis.addToHead(node)\n\t\tif this.size++; this.size > this.capacity {\n\t\t\tnode = this.tail.prev\n\t\t\tdelete(this.cache, node.key)\n\t\t\tthis.removeNode(node)\n\t\t\tthis.size--\n\t\t}\n\t}\n}\n\nfunc (this *LRUCache) removeNode(node *Node) {\n\tnode.prev.next = node.next\n\tnode.next.prev = node.prev\n}\n\nfunc (this *LRUCache) addToHead(node *Node) {\n\tnode.next = this.head.next\n\tnode.prev = this.head\n\tthis.head.next = node\n\tnode.next.prev = node\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * obj := Constructor(capacity);\n * param_1 := obj.Get(key);\n * obj.Put(key,value);\n */"
      },
      "rust": {
        "initialCode": "struct LRUCache {\n    // Your data structure here\n}\n\nimpl LRUCache {\n    fn new(capacity: i32) -> Self {\n        // Initialize your data structure here\n        LRUCache {}\n    }\n    \n    fn get(&mut self, key: i32) -> i32 {\n        // Return the value of the key if it exists, otherwise return -1\n        -1\n    }\n    \n    fn put(&mut self, key: i32, value: i32) {\n        // Update the value of the key if it exists, otherwise add the key-value pair\n    }\n}\n",
        "code": "use std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\nstruct Node {\n    key: i32,\n    value: i32,\n    prev: Option<Rc<RefCell<Node>>>,\n    next: Option<Rc<RefCell<Node>>>,\n}\n\nimpl Node {\n    #[inline]\n    fn new(key: i32, value: i32) -> Self {\n        Self {\n            key,\n            value,\n            prev: None,\n            next: None,\n        }\n    }\n}\n\nstruct LRUCache {\n    capacity: usize,\n    cache: HashMap<i32, Rc<RefCell<Node>>>,\n    head: Option<Rc<RefCell<Node>>>,\n    tail: Option<Rc<RefCell<Node>>>,\n}\n\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl LRUCache {\n    fn new(capacity: i32) -> Self {\n        Self {\n            capacity: capacity as usize,\n            cache: HashMap::new(),\n            head: None,\n            tail: None,\n        }\n    }\n\n    fn get(&mut self, key: i32) -> i32 {\n        match self.cache.get(&key) {\n            Some(node) => {\n                let node = Rc::clone(node);\n                self.remove(&node);\n                self.push_front(&node);\n                let value = node.borrow().value;\n                value\n            }\n            None => -1,\n        }\n    }\n\n    fn put(&mut self, key: i32, value: i32) {\n        match self.cache.get(&key) {\n            Some(node) => {\n                let node = Rc::clone(node);\n                node.borrow_mut().value = value;\n                self.remove(&node);\n                self.push_front(&node);\n            }\n            None => {\n                let node = Rc::new(RefCell::new(Node::new(key, value)));\n                self.cache.insert(key, Rc::clone(&node));\n                self.push_front(&node);\n                if self.cache.len() > self.capacity {\n                    let back_key = self.pop_back().unwrap().borrow().key;\n                    self.cache.remove(&back_key);\n                }\n            }\n        };\n    }\n\n    fn push_front(&mut self, node: &Rc<RefCell<Node>>) {\n        match self.head.take() {\n            Some(head) => {\n                head.borrow_mut().prev = Some(Rc::clone(node));\n                node.borrow_mut().prev = None;\n                node.borrow_mut().next = Some(head);\n                self.head = Some(Rc::clone(node));\n            }\n            None => {\n                self.head = Some(Rc::clone(node));\n                self.tail = Some(Rc::clone(node));\n            }\n        };\n    }\n\n    fn remove(&mut self, node: &Rc<RefCell<Node>>) {\n        match (node.borrow().prev.as_ref(), node.borrow().next.as_ref()) {\n            (None, None) => {\n                self.head = None;\n                self.tail = None;\n            }\n            (None, Some(next)) => {\n                self.head = Some(Rc::clone(next));\n                next.borrow_mut().prev = None;\n            }\n            (Some(prev), None) => {\n                self.tail = Some(Rc::clone(prev));\n                prev.borrow_mut().next = None;\n            }\n            (Some(prev), Some(next)) => {\n                next.borrow_mut().prev = Some(Rc::clone(prev));\n                prev.borrow_mut().next = Some(Rc::clone(next));\n            }\n        };\n    }\n\n    fn pop_back(&mut self) -> Option<Rc<RefCell<Node>>> {\n        match self.tail.take() {\n            Some(tail) => {\n                self.remove(&tail);\n                Some(tail)\n            }\n            None => None,\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class LRUCache:\n    def __init__(self, capacity: int):\n        # Initialize your data structure here\n        pass\n\n    def get(self, key: int) -> int:\n        # Return the value of the key if it exists, otherwise return -1\n        pass\n\n    def put(self, key: int, value: int) -> None:\n        # Update the value of the key if it exists, otherwise add the key-value pair\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor(capacity: number) {}\n}",
        "initialCode": "class Solution {\n    constructor(capacity: number) {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "min-stack",
      "title": "Min Stack",
      "difficulty": "Medium",
      "pattern": "Stack (Two Stacks)"
    }
  },
  "implement-trie-prefix-tree": {
    "title": "Implement Trie (Prefix Tree)",
    "pattern": "Trie",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(m)",
    "spaceComplexity": "O(n*m)",
    "oneliner": "Implement a trie with insert, search, and startsWith methods.",
    "description": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
    "intuition": [
      "\ud83c\udfaf Each node represents a character, paths form words",
      "\ud83e\udde0 Use a dictionary at each node to store children",
      "\ud83d\udca1 Mark end of word with a boolean flag"
    ],
    "keyInsight": "Tries enable O(m) prefix searches where m is the length of the prefix.",
    "code": "class Solution:\n    def test_trie(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Each node represents a character, paths form words\n        - \ud83e\udde0 Use a dictionary at each node to store children\n        - \ud83d\udca1 Mark end of word with a boolean flag\n        \"\"\"\n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.is_end = False\n\n        class Trie:\n            def __init__(self):\n                self.root = TrieNode()\n\n            def insert(self, word: str) -> None:\n                node = self.root\n                for char in word:  # Iterate over elements.\n                    if char not in node.children:\n                        node.children[char] = TrieNode()\n                    node = node.children[char]\n                node.is_end = True\n\n            def search(self, word: str) -> bool:\n                node = self._find(word)\n                return node is not None and node.is_end\n\n            def startsWith(self, prefix: str) -> bool:\n                return self._find(prefix) is not None\n\n            def _find(self, word: str):\n                node = self.root\n                for char in word:  # Iterate over elements.\n                    if char not in node.children:\n                        return None\n                    node = node.children[char]\n                return node\n\n        trie = Trie()\n        trie.insert(\"apple\")\n        r1 = trie.search(\"apple\")\n        r2 = trie.search(\"app\")\n        r3 = trie.startsWith(\"app\")\n\n        return [r1, r2, r3]",
    "testCases": [
      {
        "input": "",
        "output": "[True, False, True]"
      }
    ],
    "examples": [
      {
        "input": "insert('apple'), search('apple')",
        "output": "True",
        "explanation": "Word 'apple' was inserted and found"
      },
      {
        "input": "insert('apple'), startsWith('app')",
        "output": "True",
        "explanation": "Prefix 'app' exists in trie"
      }
    ],
    "constraints": [
      "1 <= word.length, prefix.length <= 2000",
      "word and prefix consist only of lowercase English letters"
    ],
    "hints": [
      "Use a dictionary to store children nodes",
      "Track end of word with a boolean",
      "Share common prefixes to save space"
    ],
    "relatedProblems": [
      "design-add-and-search-words-data-structure",
      "word-search-ii",
      "replace-words"
    ],
    "videoId": "oobqoCJlHA0",
    "problemStatement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "tree",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Implement Trie (Prefix Tree)",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "approach": "Trie: Implement a trie with insert, search, and startsWith methods.",
    "mentalModel": "Like autocomplete. Typing 'c-a-t' walks down the 'c' -> 'a' -> 't' path.",
    "initialCode": "class Trie:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def insert(self, word: str) -> None:\n        # Insert a word into the trie\n        pass\n\n    def search(self, word: str) -> bool:\n        # Returns True if the word is in the trie\n        pass\n\n    def startsWith(self, prefix: str) -> bool:\n        # Returns True if there is any word that starts with the given prefix\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: cur[c] = {}\n            cur = cur[c]\n        cur['#'] = True\n    def search(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: return False\n            cur = cur[c]\n        return '#' in cur\n    def startsWith(self, prefix):\n        cur = self.root\n        for c in prefix:\n            if c not in cur: return False\n            cur = cur[c]\n        return True"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m)",
        "spaceComplexity": "O(n*m)",
        "intuition": [
          "\ud83c\udfaf Each node represents a character, paths form words",
          "\ud83e\udde0 Use a dictionary at each node to store children",
          "\ud83d\udca1 Mark end of word with a boolean flag"
        ],
        "code": "def test_trie():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Each node represents a character, paths form words\n    - \ud83e\udde0 Use a dictionary at each node to store children\n    - \ud83d\udca1 Mark end of word with a boolean flag\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            node = self._find(word)\n            return node is not None and node.is_end\n\n        def startsWith(self, prefix: str) -> bool:\n            return self._find(prefix) is not None\n\n        def _find(self, word: str):\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    trie = Trie()\n    trie.insert(\"apple\")\n    r1 = trie.search(\"apple\")\n    r2 = trie.search(\"app\")\n    r3 = trie.startsWith(\"app\")\n    \n    return [r1, r2, r3]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TrieNode() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n\n    public TrieNode() {\n        this.children = new TrieNode[26];\n        this.isEndOfWord = false;\n    }\n}\n\nclass Solution {\n    private TrieNode root;\n\n    public Solution() {\n        this.root = new TrieNode();\n    }\n\n    // insert(String word) {}\n    // search(String word) {}\n    // startsWith(String prefix) {}\n}"
      },
      "cpp": {
        "initialCode": "class Trie {\npublic:\n    Trie() {\n        // Initialize your data structure here\n    }\n    \n    void insert(string word) {\n        // Insert a word into the trie\n    }\n    \n    bool search(string word) {\n        // Returns true if the word is in the trie\n        return false;\n    }\n    \n    bool startsWith(string prefix) {\n        // Returns true if there is any word that starts with the given prefix\n        return false;\n    }\n};\n",
        "code": "class Trie {\nprivate:\n    vector<Trie*> children;\n    bool isEnd;\n\n    Trie* searchPrefix(string s) {\n        Trie* node = this;\n        for (char c : s) {\n            int idx = c - 'a';\n            if (!node->children[idx]) return nullptr;\n            node = node->children[idx];\n        }\n        return node;\n    }\n\npublic:\n    Trie()\n        : children(26)\n        , isEnd(false) {}\n\n    void insert(string word) {\n        Trie* node = this;\n        for (char c : word) {\n            int idx = c - 'a';\n            if (!node->children[idx]) node->children[idx] = new Trie();\n            node = node->children[idx];\n        }\n        node->isEnd = true;\n    }\n\n    bool search(string word) {\n        Trie* node = searchPrefix(word);\n        return node != nullptr && node->isEnd;\n    }\n\n    bool startsWith(string prefix) {\n        Trie* node = searchPrefix(prefix);\n        return node != nullptr;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() Trie {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype Trie struct {\n\tchildren [26]*Trie\n\tisEnd    bool\n}\n\nfunc (s *Solution) Constructor() Trie {\n\treturn Trie{}\n}\n\nfunc (this *Trie) Insert(word string) {\n\tnode := this\n\tfor _, c := range word {\n\t\tidx := c - 'a'\n\t\tif node.children[idx] == nil {\n\t\t\tnode.children[idx] = &Trie{}\n\t\t}\n\t\tnode = node.children[idx]\n\t}\n\tnode.isEnd = true\n}\n\nfunc (this *Trie) Search(word string) bool {\n\tnode := this.SearchPrefix(word)\n\treturn node != nil && node.isEnd\n}\n\nfunc (this *Trie) StartsWith(prefix string) bool {\n\tnode := this.SearchPrefix(prefix)\n\treturn node != nil\n}\n\nfunc (this *Trie) SearchPrefix(s string) *Trie {\n\tnode := this\n\tfor _, c := range s {\n\t\tidx := c - 'a'\n\t\tif node.children[idx] == nil {\n\t\t\treturn nil\n\t\t}\n\t\tnode = node.children[idx]\n\t}\n\treturn node\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Insert(word);\n * param_2 := obj.Search(word);\n * param_3 := obj.StartsWith(prefix);\n */"
      },
      "rust": {
        "initialCode": "struct Trie {\n    // Your data structure here\n}\n\nimpl Trie {\n    fn new() -> Self {\n        Trie {}\n    }\n    \n    fn insert(&mut self, word: String) {\n        // Insert a word into the trie\n    }\n    \n    fn search(&self, word: String) -> bool {\n        // Returns true if the word is in the trie\n        false\n    }\n    \n    fn starts_with(&self, prefix: String) -> bool {\n        // Returns true if there is any word that starts with the given prefix\n        false\n    }\n}\n",
        "code": "use std::{cell::RefCell, collections::HashMap, rc::Rc};\n\nstruct TrieNode {\n    pub val: Option<char>,\n    pub flag: bool,\n    pub child: HashMap<char, Rc<RefCell<TrieNode>>>,\n}\n\nimpl TrieNode {\n    fn new() -> Self {\n        Self {\n            val: None,\n            flag: false,\n            child: HashMap::new(),\n        }\n    }\n\n    fn new_with_val(val: char) -> Self {\n        Self {\n            val: Some(val),\n            flag: false,\n            child: HashMap::new(),\n        }\n    }\n}\n\nstruct Trie {\n    root: Rc<RefCell<TrieNode>>,\n}\n\n/// Your Trie object will be instantiated and called as such:\n/// let obj = Trie::new();\n/// obj.insert(word);\n/// let ret_2: bool = obj.search(word);\n/// let ret_3: bool = obj.starts_with(prefix);\nimpl Trie {\n    fn new() -> Self {\n        Self {\n            root: Rc::new(RefCell::new(TrieNode::new())),\n        }\n    }\n\n    fn insert(&self, word: String) {\n        let char_vec: Vec<char> = word.chars().collect();\n        // Get the clone of current root node\n        let mut root = Rc::clone(&self.root);\n        for c in &char_vec {\n            if !root.borrow().child.contains_key(c) {\n                // We need to manually create the entry\n                root.borrow_mut()\n                    .child\n                    .insert(*c, Rc::new(RefCell::new(TrieNode::new())));\n            }\n            // Get the child node\n            let root_clone = Rc::clone(root.borrow().child.get(c).unwrap());\n            root = root_clone;\n        }\n        {\n            root.borrow_mut().flag = true;\n        }\n    }\n\n    fn search(&self, word: String) -> bool {\n        let char_vec: Vec<char> = word.chars().collect();\n        // Get the clone of current root node\n        let mut root = Rc::clone(&self.root);\n        for c in &char_vec {\n            if !root.borrow().child.contains_key(c) {\n                return false;\n            }\n            // Get the child node\n            let root_clone = Rc::clone(root.borrow().child.get(c).unwrap());\n            root = root_clone;\n        }\n        let flag = root.borrow().flag;\n        flag\n    }\n\n    fn starts_with(&self, prefix: String) -> bool {\n        let char_vec: Vec<char> = prefix.chars().collect();\n        // Get the clone of current root node\n        let mut root = Rc::clone(&self.root);\n        for c in &char_vec {\n            if !root.borrow().child.contains_key(c) {\n                return false;\n            }\n            // Get the child node\n            let root_clone = Rc::clone(root.borrow().child.get(c).unwrap());\n            root = root_clone;\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Trie:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def insert(self, word: str) -> None:\n        # Insert a word into the trie\n        pass\n\n    def search(self, word: str) -> bool:\n        # Returns True if the word is in the trie\n        pass\n\n    def startsWith(self, prefix: str) -> bool:\n        # Returns True if there is any word that starts with the given prefix\n        pass\n"
      },
      "typescript": {
        "code": "class TrieNode {\n    children;\n    isEnd;\n    constructor() {\n        this.children = new Array(26);\n        this.isEnd = false;\n    }\n}\n\nclass Trie {\n    root;\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(word: string): void {\n        let head = this.root;\n        for (let char of word) {\n            let index = char.charCodeAt(0) - 97;\n            if (!head.children[index]) {\n                head.children[index] = new TrieNode();\n            }\n            head = head.children[index];\n        }\n        head.isEnd = true;\n    }\n\n    search(word: string): boolean {\n        let head = this.searchPrefix(word);\n        return head != null && head.isEnd;\n    }\n\n    startsWith(prefix: string): boolean {\n        return this.searchPrefix(prefix) != null;\n    }\n\n    private searchPrefix(prefix: string) {\n        let head = this.root;\n        for (let char of prefix) {\n            let index = char.charCodeAt(0) - 97;\n            if (!head.children[index]) return null;\n            head = head.children[index];\n        }\n        return head;\n    }\n}",
        "initialCode": ""
      }
    },
    "suggestedNextQuestion": {
      "slug": "design-add-and-search-words-data-structure",
      "title": "Design Add and Search Words Data Structure",
      "difficulty": "Medium",
      "pattern": "Trie"
    }
  },
  "design-add-and-search-words-data-structure": {
    "title": "Design Add and Search Words Data Structure",
    "pattern": "Trie",
    "patternEmoji": "\ud83c\udf33",
    "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
    "spaceComplexity": "O(n*m)",
    "oneliner": "Design a data structure that supports adding words and searching with '.' wildcard.",
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. The search can contain '.' which matches any single character.",
    "intuition": [
      "\ud83c\udfaf Use Trie for efficient prefix matching",
      "\ud83e\udde0 Handle '.' by trying all children recursively",
      "\ud83d\udca1 DFS/BFS for wildcard matching"
    ],
    "keyInsight": "Wildcards require exploring all children at that position using recursion/backtracking.",
    "code": "class Solution:\n    def test_word_dict(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Use Trie for efficient prefix matching\n        - \ud83e\udde0 Handle '.' by trying all children recursively\n        - \ud83d\udca1 DFS/BFS for wildcard matching\n        \"\"\"\n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.is_end = False\n\n        class WordDictionary:\n            def __init__(self):\n                self.root = TrieNode()\n\n            def addWord(self, word: str) -> None:\n                node = self.root\n                for char in word:  # Iterate over elements.\n                    if char not in node.children:\n                        node.children[char] = TrieNode()\n                    node = node.children[char]\n                node.is_end = True\n\n            def search(self, word: str) -> bool:\n                def dfs(node, i):\n                    if i == len(word):\n                        return node.is_end\n                    if word[i] == '.':\n                        return any(dfs(child, i + 1) for child in node.children.values())\n                    if word[i] in node.children:\n                        return dfs(node.children[word[i]], i + 1)\n                    return False  # Condition not met.\n                return dfs(self.root, 0)\n\n        wd = WordDictionary()\n        wd.addWord(\"bad\")\n        wd.addWord(\"dad\")\n        wd.addWord(\"mad\")\n\n        r1 = wd.search(\"pad\")\n        r2 = wd.search(\"bad\")\n        r3 = wd.search(\".ad\")\n        r4 = wd.search(\"b..\")\n\n        return [r1, r2, r3, r4]",
    "testCases": [
      {
        "input": "",
        "output": "[False, True, True, True]"
      }
    ],
    "examples": [
      {
        "input": "addWord('bad'), search('b.d')",
        "output": "True",
        "explanation": "'.' matches 'a'"
      },
      {
        "input": "addWord('bad'), search('.ad')",
        "output": "True",
        "explanation": "'.' matches 'b'"
      }
    ],
    "constraints": [
      "1 <= word.length <= 25",
      "word consists of lowercase letters",
      "search word may contain '.'"
    ],
    "hints": [
      "Trie is the perfect data structure",
      "Use DFS for wildcard matching",
      "Try all children when encountering '.'"
    ],
    "relatedProblems": [
      "implement-trie-prefix-tree",
      "word-search-ii",
      "prefix-and-suffix-search"
    ],
    "videoId": "BTf05gs_8iU",
    "problemStatement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n- WordDictionary() Initializes the object.\n- void addWord(word) Adds word to the data structure, it can be matched later.\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.",
    "difficulty": "Medium",
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "visualizationType": "tree",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Design Add and Search Words Data Structure",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "approach": "Trie: Design a data structure that supports adding words and searching with '.' wildcard.",
    "mentalModel": "Like autocomplete. Typing 'c-a-t' walks down the 'c' -> 'a' -> 't' path.",
    "initialCode": "class WordDictionary:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def addWord(self, word: str) -> None:\n        # Add a word to the data structure\n        pass\n\n    def search(self, word: str) -> bool:\n        # Search for a word (. matches any single character)\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class WordDictionary:\n    def __init__(self):\n        self.root = {}\n    def addWord(self, word):\n        cur = self.root\n        for c in word:\n            if c not in cur: cur[c] = {}\n            cur = cur[c]\n        cur['#'] = True\n    def search(self, word):\n        def dfs(i, root):\n            cur = root\n            for j in range(i, len(word)):\n                c = word[j]\n                if c == '.':\n                    for child in cur.values():\n                        if child is not True and dfs(j + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur: return False\n                    cur = cur[c]\n            return '#' in cur\n        return dfs(0, self.root)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
        "spaceComplexity": "O(n*m)",
        "intuition": [
          "\ud83c\udfaf Use Trie for efficient prefix matching",
          "\ud83e\udde0 Handle '.' by trying all children recursively",
          "\ud83d\udca1 DFS/BFS for wildcard matching"
        ],
        "code": "def test_word_dict():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Use Trie for efficient prefix matching\n    - \ud83e\udde0 Handle '.' by trying all children recursively\n    - \ud83d\udca1 DFS/BFS for wildcard matching\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class WordDictionary:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def addWord(self, word: str) -> None:\n            node = self.root\n            for char in word:  # Iterate over elements.\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            def dfs(node, i):\n                if i == len(word):\n                    return node.is_end\n                if word[i] == '.':\n                    return any(dfs(child, i + 1) for child in node.children.values())\n                if word[i] in node.children:\n                    return dfs(node.children[word[i]], i + 1)\n                return False  # Condition not met.\n            return dfs(self.root, 0)\n    \n    wd = WordDictionary()\n    wd.addWord(\"bad\")\n    wd.addWord(\"dad\")\n    wd.addWord(\"mad\")\n    \n    r1 = wd.search(\"pad\")\n    r2 = wd.search(\"bad\")\n    r3 = wd.search(\".ad\")\n    r4 = wd.search(\"b..\")\n    \n    return [r1, r2, r3, r4]"
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {\n        // Initialize data structure here.\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Solution() {\n        \n    }\n}",
        "code": "class Solution {\n    public Solution() {\n        \n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() { }\n};",
        "code": "class Solution {\npublic:\n    Solution() { }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() WordDictionary {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype WordDictionary struct {\n\troot *trie\n}\n\nfunc (s *Solution) Constructor() WordDictionary {\n\treturn WordDictionary{new(trie)}\n}\n\nfunc (this *WordDictionary) AddWord(word string) {\n\tthis.root.insert(word)\n}\n\nfunc (this *WordDictionary) Search(word string) bool {\n\tn := len(word)\n\n\tvar dfs func(int, *trie) bool\n\tdfs = func(i int, cur *trie) bool {\n\t\tif i == n {\n\t\t\treturn cur.isEnd\n\t\t}\n\t\tc := word[i]\n\t\tif c != '.' {\n\t\t\tchild := cur.children[c-'a']\n\t\t\tif child != nil && dfs(i+1, child) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, child := range cur.children {\n\t\t\t\tif child != nil && dfs(i+1, child) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\treturn dfs(0, this.root)\n}\n\ntype trie struct {\n\tchildren [26]*trie\n\tisEnd    bool\n}\n\nfunc (t *trie) insert(word string) {\n\tcur := t\n\tfor _, c := range word {\n\t\tc -= 'a'\n\t\tif cur.children[c] == nil {\n\t\t\tcur.children[c] = new(trie)\n\t\t}\n\t\tcur = cur.children[c]\n\t}\n\tcur.isEnd = true\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * obj := Constructor();\n * obj.AddWord(word);\n * param_2 := obj.Search(word);\n */"
      },
      "rust": {
        "initialCode": "struct WordDictionary {\n    // Your data structure here\n}\n\nimpl WordDictionary {\n    fn new() -> Self {\n        WordDictionary {}\n    }\n    \n    fn add_word(&mut self, word: String) {\n        // Add a word to the data structure\n    }\n    \n    fn search(&self, word: String) -> bool {\n        // Search for a word (. matches any single character)\n        false\n    }\n}\n",
        "code": "struct WordDictionary {\n    // Trie implementation omitted for brevity\n}\nimpl WordDictionary {\n    fn new() -> Self { WordDictionary {} }\n    fn add_word(&self, word: String) {}\n    fn search(&self, word: String) -> bool { false }\n}"
      },
      "python": {
        "initialCode": "class WordDictionary:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def addWord(self, word: str) -> None:\n        # Add a word to the data structure\n        pass\n\n    def search(self, word: str) -> bool:\n        # Search for a word (. matches any single character)\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "implement-trie-prefix-tree",
      "title": "Implement Trie (Prefix Tree)",
      "difficulty": "Medium",
      "pattern": "Trie"
    }
  },
  "word-search-ii": {
    "title": "Word Search II",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd19",
    "timeComplexity": "O(m*n*4^L)",
    "spaceComplexity": "O(total chars in words)",
    "oneliner": "Find all words from a dictionary that can be formed by adjacent cells in a grid.",
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells.",
    "intuition": [
      "\ud83c\udfaf Build Trie from words for efficient prefix checking",
      "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
      "\ud83d\udca1 Mark visited cells to avoid reuse"
    ],
    "keyInsight": "Building a Trie allows us to search for multiple words simultaneously and prune invalid paths early.",
    "code": "class Solution:\n    def findWords(self, board, words):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Build Trie from words for efficient prefix checking\n        - \ud83e\udde0 DFS from each cell, prune when no matching prefix\n        - \ud83d\udca1 Mark visited cells to avoid reuse\n        \"\"\"\n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.word = None\n\n        root = TrieNode()\n        for word in words:  # Iterate over elements.\n            node = root\n            for c in word:  # Iterate over elements.\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.word = word\n\n        result = []\n        m, n = len(board), len(board[0])\n\n        def dfs(i, j, node):\n            c = board[i][j]\n            if c not in node.children:\n                return\n            next_node = node.children[c]\n            if next_node.word:\n                result.append(next_node.word)  # Add to end.\n                next_node.word = None\n\n            board[i][j] = '#'\n            for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Iterate over elements.\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                    dfs(ni, nj, next_node)\n            board[i][j] = c\n\n        for i in range(m):  # Iterate through the range.\n            for j in range(n):  # Iterate through the range.\n                dfs(i, j, root)\n        return sorted(result)",
    "testCases": [
      {
        "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
        "output": "[\"eat\",\"oath\"]"
      },
      {
        "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
        "output": "[]"
      }
    ],
    "examples": [
      {
        "input": "board = [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']], words = ['oath','pea','eat','rain']",
        "output": "['eat', 'oath']",
        "explanation": "These words can be formed from adjacent cells"
      }
    ],
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 12",
      "1 <= words.length <= 3 * 10^4"
    ],
    "hints": [
      "Build a Trie from the word list",
      "DFS from each cell with Trie for pruning",
      "Mark cells visited during search"
    ],
    "relatedProblems": [
      "word-search",
      "unique-paths-iii",
      "sudoku-solver"
    ],
    "videoId": "asbcE9mZz_U",
    "problemStatement": "Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
    "difficulty": "Hard",
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "visualizationType": "tree",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Word Search II",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [1]",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 2 to path",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try 3 instead",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "approach": "Backtracking: Find all words from a dictionary that can be formed by adjacent cells in a grid.",
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def findWords(self, board, words):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def findWords_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n*4^L)",
        "spaceComplexity": "O(total chars in words)",
        "intuition": [
          "\ud83c\udfaf Build Trie from words for efficient prefix checking",
          "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
          "\ud83d\udca1 Mark visited cells to avoid reuse"
        ],
        "code": "def findWords(board, words):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Build Trie from words for efficient prefix checking\n    - \ud83e\udde0 DFS from each cell, prune when no matching prefix\n    - \ud83d\udca1 Mark visited cells to avoid reuse\n    \"\"\"\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n    \n    root = TrieNode()\n    for word in words:  # Iterate over elements.\n        node = root\n        for c in word:  # Iterate over elements.\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = word\n    \n    result = []\n    m, n = len(board), len(board[0])\n    \n    def dfs(i, j, node):\n        c = board[i][j]\n        if c not in node.children:\n            return\n        next_node = node.children[c]\n        if next_node.word:\n            result.append(next_node.word)  # Add to end.\n            next_node.word = None\n        \n        board[i][j] = '#'\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                dfs(ni, nj, next_node)\n        board[i][j] = c\n    \n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            dfs(i, j, root)\n    return sorted(result)"
      }
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    findWords(board, words) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} board, words\n     * @return {any}\n     */\n    findWords(board, words) {\n        const root = {};\n        const result = new Set();\n        const m = board.length;\n        const n = board[0].length;\n\n        words.forEach(w => w.split('').reduce((n, c) => n[c] = n[c] || {}, root).word = w);\n\n        for (let i = 0; i < m; i++) {\n          for (let j = 0; j < n; j++) {\n            dfs(i, j, root);\n          }\n        }\n\n        return Array.from(result);\n\n        class Solution {\n          /**\n           * @param {any} i, j, node\n           * @return {any}\n           */\n          dfs(i, j, node) {\n          const char = board[i][j];\n          const next = node[char];\n          if (!next) return;\n          if (next.word) {\n            result.add(next.word);\n          }\n          board[i][j] = '#';\n          for (const [di, dj] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {\n            if (i + di >= 0 && i + di < m && j + dj >= 0 && j + dj < n && board[i + di][j + dj] !== '#') {\n              dfs(i + di, j + dj, next);\n            }\n          }\n          board[i][j] = char;\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void insert(String w, int ref) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Trie {\n    Trie[] children = new Trie[26];\n    int ref = -1;\n\n    public void insert(String w, int ref) {\n        Trie node = this;\n        for (int i = 0; i < w.length(); ++i) {\n            int j = w.charAt(i) - 'a';\n            if (node.children[j] == null) {\n                node.children[j] = new Trie();\n            }\n            node = node.children[j];\n        }\n        node.ref = ref;\n    }\n}\n\nclass Solution {\n    private char[][] board;\n    private String[] words;\n    private List<String> ans = new ArrayList<>();\n\n    public List<String> findWords(char[][] board, String[] words) {\n        this.board = board;\n        this.words = words;\n        Trie tree = new Trie();\n        for (int i = 0; i < words.length; ++i) {\n            tree.insert(words[i], i);\n        }\n        int m = board.length, n = board[0].length;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dfs(tree, i, j);\n            }\n        }\n        return ans;\n    }\n\n    private void dfs(Trie node, int i, int j) {\n        int idx = board[i][j] - 'a';\n        if (node.children[idx] == null) {\n            return;\n        }\n        node = node.children[idx];\n        if (node.ref != -1) {\n            ans.add(words[node.ref]);\n            node.ref = -1;\n        }\n        char c = board[i][j];\n        board[i][j] = '#';\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] != '#') {\n                dfs(node, x, y);\n            }\n        }\n        board[i][j] = c;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n        , ref(-1) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Trie {\npublic:\n    vector<Trie*> children;\n    int ref;\n\n    Trie()\n        : children(26, nullptr)\n        , ref(-1) {}\n\n    void insert(const string& w, int ref) {\n        Trie* node = this;\n        for (char c : w) {\n            c -= 'a';\n            if (!node->children[c]) {\n                node->children[c] = new Trie();\n            }\n            node = node->children[c];\n        }\n        node->ref = ref;\n    }\n};\n\nclass Solution {\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        Trie* tree = new Trie();\n        for (int i = 0; i < words.size(); ++i) {\n            tree->insert(words[i], i);\n        }\n        vector<string> ans;\n        int m = board.size(), n = board[0].size();\n\n        function<void(Trie*, int, int)> dfs = [&](Trie* node, int i, int j) {\n            int idx = board[i][j] - 'a';\n            if (!node->children[idx]) {\n                return;\n            }\n            node = node->children[idx];\n            if (node->ref != -1) {\n                ans.emplace_back(words[node->ref]);\n                node->ref = -1;\n            }\n            int dirs[5] = {-1, 0, 1, 0, -1};\n            char c = board[i][j];\n            board[i][j] = '#';\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '#') {\n                    dfs(node, x, y);\n                }\n            }\n            board[i][j] = c;\n        };\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dfs(tree, i, j);\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) newTrie() *Trie {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype Trie struct {\n\tchildren [26]*Trie\n\tref      int\n}\n\nfunc (s *Solution) newTrie() *Trie {\n\treturn &Trie{ref: -1}\n}\nfunc (this *Trie) insert(w string, ref int) {\n\tnode := this\n\tfor _, c := range w {\n\t\tc -= 'a'\n\t\tif node.children[c] == nil {\n\t\t\tnode.children[c] = newTrie()\n\t\t}\n\t\tnode = node.children[c]\n\t}\n\tnode.ref = ref\n}\n\nfunc findWords(board [][]byte, words []string) (ans []string) {\n\ttrie := newTrie()\n\tfor i, w := range words {\n\t\ttrie.insert(w, i)\n\t}\n\tm, n := len(board), len(board[0])\n\tvar dfs func(*Trie, int, int)\n\tdfs = func(node *Trie, i, j int) {\n\t\tidx := board[i][j] - 'a'\n\t\tif node.children[idx] == nil {\n\t\t\treturn\n\t\t}\n\t\tnode = node.children[idx]\n\t\tif node.ref != -1 {\n\t\t\tans = append(ans, words[node.ref])\n\t\t\tnode.ref = -1\n\t\t}\n\t\tc := board[i][j]\n\t\tboard[i][j] = '#'\n\t\tdirs := [5]int{-1, 0, 1, 0, -1}\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tx, y := i+dirs[k], j+dirs[k+1]\n\t\t\tif x >= 0 && x < m && y >= 0 && y < n && board[x][y] != '#' {\n\t\t\t\tdfs(node, x, y)\n\t\t\t}\n\t\t}\n\t\tboard[i][j] = c\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tdfs(trie, i, j)\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::HashMap;\n\n#[derive(Default)]\nstruct TrieNode {\n    children: HashMap<char, TrieNode>,\n    word: Option<String>,\n}\n\nimpl TrieNode {\n    fn new() -> Self { Default::default() }\n    fn insert(&mut self, word: String) {\n        let mut curr = self;\n        for c in word.chars() {\n            curr = curr.children.entry(c).or_insert_with(TrieNode::new);\n        }\n        curr.word = Some(word);\n    }\n}\n\nimpl Solution {\n    pub fn find_words(board: Vec<Vec<char>>, words: Vec<String>) -> Vec<String> {\n        let mut trie = TrieNode::new();\n        for w in words { trie.insert(w); }\n        \n        let mut res = Vec::new();\n        let rows = board.len();\n        let cols = board[0].len();\n        let mut visited = vec![vec![false; cols]; rows];\n        \n        for r in 0..rows {\n            for c in 0..cols {\n                Self::dfs(&board, r, c, &mut trie, &mut res, &mut visited);\n            }\n        }\n        res.sort();\n        res.dedup();\n        res\n    }\n    \n    fn dfs(board: &Vec<Vec<char>>, r: usize, c: usize, node: &mut TrieNode, res: &mut Vec<String>, visited: &mut Vec<Vec<bool>>) {\n        if let Some(child) = node.children.get_mut(&board[r][c]) {\n            visited[r][c] = true;\n            if let Some(w) = child.word.take() {\n                res.push(w);\n            }\n            \n            let dirs = [(0,1), (0,-1), (1,0), (-1,0)];\n            for (dr, dc) in dirs {\n                let nr = r as i32 + dr;\n                let nc = c as i32 + dc;\n                if nr >= 0 && nr < board.len() as i32 && nc >= 0 && nc < board[0].len() as i32 {\n                    let nr = nr as usize;\n                    let nc = nc as usize;\n                    if !visited[nr][nc] {\n                        Self::dfs(board, nr, nc, child, res, visited);\n                    }\n                }\n            }\n            visited[r][c] = false;\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findWords(self, board, words):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findWords(board: string[][], words: string[]): string[] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    findWords(board: string[][], words: string[]): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "suggestedNextQuestion": {
      "slug": "permutations",
      "title": "Permutations",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    }
  },
  "binary-search-tree-iterator": {
    "title": "Binary Search Tree Iterator",
    "pattern": "Tree",
    "patternEmoji": "\ud83c\udf32",
    "timeComplexity": "O(1) avg next, O(h) hasNext",
    "spaceComplexity": "O(h)",
    "oneliner": "Implement an iterator over a BST that returns nodes in ascending order.",
    "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST).",
    "intuition": [
      "\ud83c\udfaf In-order traversal gives sorted order for BST",
      "\ud83e\udde0 Use stack to simulate recursive traversal",
      "\ud83d\udca1 Push left children, pop for next, then go right"
    ],
    "keyInsight": "Using a stack to store the path allows O(h) space instead of O(n) for full traversal.",
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def test_bst_iterator(self):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf In-order traversal gives sorted order for BST\n        - \ud83e\udde0 Use stack to simulate recursive traversal\n        - \ud83d\udca1 Push left children, pop for next, then go right\n        \"\"\"\n        class TreeNode:\n            def __init__(self, val=0, left=None, right=None):\n                self.val = val\n                self.left = left\n                self.right = right\n        \n        class BSTIterator:\n            def __init__(self, root):\n                self.stack = []  # Initialize stack for tracking.\n                self._push_left(root)\n            \n            def _push_left(self, node):\n                while node:\n                    self.stack.append(node)  # Add to end.\n                    node = node.left\n    \n            def next(self) -> int:\n                node = self.stack.pop()  # Remove and return last element.\n                self._push_left(node.right)\n                return node.val\n    \n            def hasNext(self) -> bool:\n                return len(self.stack) > 0\n        \n        # Build tree: [7, 3, 15, null, null, 9, 20]\n        root = TreeNode(7)  # Create a new Tree Node.\n        root.left = TreeNode(3)  # Process left child.\n        root.right = TreeNode(15, TreeNode(9), TreeNode(20))  # Process right child.\n        \n        iterator = BSTIterator(root)\n        results = []\n        results.append(iterator.next())    # 3\n        results.append(iterator.next())    # 7\n        results.append(iterator.hasNext()) # True\n        results.append(iterator.next())    # 9\n        \n        return results  # Return the final result.",
    "testCases": [
      {
        "input": "",
        "output": "[3, 7, True, 9]"
      }
    ],
    "examples": [
      {
        "input": "BSTIterator([7,3,15,null,null,9,20]), next()",
        "output": "3",
        "explanation": "Smallest element in BST"
      },
      {
        "input": "next(), next(), next()",
        "output": "3, 7, 9",
        "explanation": "In-order traversal order"
      }
    ],
    "constraints": [
      "Number of nodes is in [1, 10^5]",
      "-10^6 <= Node.val <= 10^6",
      "At most 10^5 calls to next and hasNext"
    ],
    "hints": [
      "Use a stack to simulate recursion",
      "Push all left children initially",
      "When popping, push right subtree's left path"
    ],
    "relatedProblems": [
      "binary-tree-inorder-traversal",
      "flatten-2d-vector",
      "zigzag-iterator"
    ],
    "videoId": "RXy5RzGF5wo",
    "problemStatement": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
    "difficulty": "Medium",
    "walkthrough": [
      "Check base case (null node)",
      "Process current node",
      "Recursively handle left subtree",
      "Recursively handle right subtree",
      "Combine results and return"
    ],
    "visualizationType": "tree",
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Binary Search Tree Iterator",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "approach": "Tree: Implement an iterator over a BST that returns nodes in ascending order.",
    "suggestedNextQuestion": {
      "slug": "delete-node-in-a-bst",
      "title": "Delete Node in a BST",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a family tree. Every node has a parent and children.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        # Initialize the iterator\n        pass\n\n    def next(self) -> int:\n        # Return the next smallest number\n        pass\n\n    def hasNext(self) -> bool:\n        # Return whether we have a next smallest number\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1) avg next, O(h) hasNext",
        "spaceComplexity": "O(h)",
        "intuition": [
          "\ud83c\udfaf In-order traversal gives sorted order for BST",
          "\ud83e\udde0 Use stack to simulate recursive traversal",
          "\ud83d\udca1 Push left children, pop for next, then go right"
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef test_bst_iterator():\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf In-order traversal gives sorted order for BST\n    - \ud83e\udde0 Use stack to simulate recursive traversal\n    - \ud83d\udca1 Push left children, pop for next, then go right\n    \"\"\"\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    class BSTIterator:\n        def __init__(self, root):\n            self.stack = []  # Initialize stack for tracking.\n            self._push_left(root)\n        \n        def _push_left(self, node):\n            while node:\n                self.stack.append(node)  # Add to end.\n                node = node.left\n\n        def next(self) -> int:\n            node = self.stack.pop()  # Remove and return last element.\n            self._push_left(node.right)\n            return node.val\n\n        def hasNext(self) -> bool:\n            return len(self.stack) > 0\n    \n    # Build tree: [7, 3, 15, null, null, 9, 20]\n    root = TreeNode(7)  # Create a new Tree Node.\n    root.left = TreeNode(3)  # Process left child.\n    root.right = TreeNode(15, TreeNode(9), TreeNode(20))  # Process right child.\n    \n    iterator = BSTIterator(root)\n    results = []\n    results.append(iterator.next())    # 3\n    results.append(iterator.next())    # 7\n    results.append(iterator.hasNext()) # True\n    results.append(iterator.next())    # 9\n    \n    return results  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Solution(TreeNode root) {\n        \n    }\n}",
        "code": "class Solution {\n    public Solution(TreeNode root) {\n        \n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() { }\n};",
        "code": "class Solution {\npublic:\n    Solution() { }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor(root *TreeNode) BSTIterator {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\ntype BSTIterator struct {\n\tstack []*TreeNode\n}\n\nfunc (s *Solution) Constructor(root *TreeNode) BSTIterator {\n\tvar stack []*TreeNode\n\tfor ; root != nil; root = root.Left {\n\t\tstack = append(stack, root)\n\t}\n\treturn BSTIterator{\n\t\tstack: stack,\n\t}\n}\n\nfunc (this *BSTIterator) Next() int {\n\tcur := this.stack[len(this.stack)-1]\n\tthis.stack = this.stack[:len(this.stack)-1]\n\tfor node := cur.Right; node != nil; node = node.Left {\n\t\tthis.stack = append(this.stack, node)\n\t}\n\treturn cur.Val\n}\n\nfunc (this *BSTIterator) HasNext() bool {\n\treturn len(this.stack) > 0\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * obj := Constructor(root);\n * param_1 := obj.Next();\n * param_2 := obj.HasNext();\n */"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nstruct BSTIterator {\n    vals: Vec<i32>,\n    index: usize,\n}\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\n/**\n * `&self` means the method takes an immutable reference.\n * If you need a mutable reference, change it to `&mut self` instead.\n */\nimpl BSTIterator {\n    fn inorder(root: &Option<Rc<RefCell<TreeNode>>>, res: &mut Vec<i32>) {\n        if let Some(node) = root {\n            let node = node.as_ref().borrow();\n            Self::inorder(&node.left, res);\n            res.push(node.val);\n            Self::inorder(&node.right, res);\n        }\n    }\n\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        let mut vals = vec![];\n        Self::inorder(&root, &mut vals);\n        BSTIterator { vals, index: 0 }\n    }\n\n    fn next(&mut self) -> i32 {\n        self.index += 1;\n        self.vals[self.index - 1]\n    }\n\n    fn has_next(&self) -> bool {\n        self.index != self.vals.len()\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass BSTIterator:\n    def __init__(self, root: TreeNode):\n        # Initialize the iterator\n        pass\n\n    def next(self) -> int:\n        # Return the next smallest number\n        pass\n\n    def hasNext(self) -> bool:\n        # Return whether we have a next smallest number\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    }
  },
  "transformed-array": {
    "title": "Transformed Array",
    "pattern": "Array",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Transform an array based on given rules and return the result.",
    "description": "Given an array, apply transformation rules to create a new array. Common transformations include prefix sums, differences, or element-wise operations.",
    "intuition": [
      "\ud83c\udfaf Iterate through array applying transformation",
      "\ud83e\udde0 Use auxiliary array to store results",
      "\ud83d\udca1 Handle edge cases for first/last elements"
    ],
    "keyInsight": "Array transformations are typically O(n) and require careful handling of boundary conditions.",
    "code": "class Solution:\n    def constructTransformedArray(self, nums):\n        \"\"\"\n        Intuition:\n        - \ud83c\udfaf Iterate through array applying transformation\n        - \ud83e\udde0 Use auxiliary array to store results\n        - \ud83d\udca1 Handle edge cases for first/last elements\n        \"\"\"\n        n = len(nums)\n        result = [0] * n\n        for i in range(n):  # Iterate through the range.\n            if nums[i] > 0:\n                result[i] = nums[(i + nums[i]) % n]\n            elif nums[i] < 0:\n                result[i] = nums[(i + nums[i]) % n]\n            else:\n                result[i] = nums[i]\n        return result  # Return the final result.",
    "testCases": [
      {
        "input": "nums = [3,-2,1,1]",
        "output": "[1, 1, 1, 3]"
      },
      {
        "input": "nums = [-1,4,-1]",
        "output": "[-1,-1,4]"
      }
    ],
    "examples": [
      {
        "input": "[6,2,3,4]",
        "output": "[6,3,3,4]",
        "explanation": "2 increments to 3 because it's a local minimum"
      }
    ],
    "constraints": [
      "1 <= arr.length <= 100",
      "1 <= arr[i] <= 100"
    ],
    "hints": [
      "Iterate until no changes are made",
      "Local minima increase, local maxima decrease",
      "First and last elements never change"
    ],
    "relatedProblems": [
      "running-sum-of-1d-array",
      "find-pivot-index",
      "product-of-array-except-self"
    ],
    "videoId": "b5vu-orCfYQ",
    "problemStatement": "You are given an integer array nums that represents a circular array. Your task is to create a new array result of the same size, following these rules:\nReturn the new array result.\nNote: Since nums is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.",
    "difficulty": "Easy",
    "walkthrough": [
      "For each element, calculate new index based on value",
      "If nums[i] > 0: new value = nums[(i + nums[i]) % n]",
      "If nums[i] < 0: new value = nums[(i + nums[i]) % n]",
      "If nums[i] == 0: new value stays as nums[i]",
      "Modulo handles circular array indexing"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Transformed Array",
        "transientMessage": "Input: [3, -2, 1, 1]",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 3",
        "transientMessage": "Step 1 of 4",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: -2",
        "transientMessage": "Step 2 of 4",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 1",
        "transientMessage": "Step 3 of 4",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 1",
        "transientMessage": "Step 4 of 4",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          3,
          -2,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "visualizationType": "array",
    "initialState": [
      3,
      -2,
      1,
      1
    ],
    "approach": "Array: Transform an array based on given rules and return the result.",
    "suggestedNextQuestion": {
      "slug": "valid-sudoku",
      "title": "Valid Sudoku",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
    "initialCode": "class Solution:\n    def constructTransformedArray(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def transform(nums):\n    # Depending on problem def, assuming typical map/filter\n    # Placeholder for unknown specific logic if custom\n    return [x*2 for x in nums]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "\ud83c\udfaf Iterate through array applying transformation",
          "\ud83e\udde0 Use auxiliary array to store results",
          "\ud83d\udca1 Handle edge cases for first/last elements"
        ],
        "code": "def constructTransformedArray(nums):\n    \"\"\"\n    Intuition:\n    - \ud83c\udfaf Iterate through array applying transformation\n    - \ud83e\udde0 Use auxiliary array to store results\n    - \ud83d\udca1 Handle edge cases for first/last elements\n    \"\"\"\n    n = len(nums)\n    result = [0] * n\n    for i in range(n):  # Iterate through the range.\n        if nums[i] > 0:\n            result[i] = nums[(i + nums[i]) % n]\n        elif nums[i] < 0:\n            result[i] = nums[(i + nums[i]) % n]\n        else:\n            result[i] = nums[i]\n    return result  # Return the final result."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    transformedArray(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    transformedArray(nums) { return nums.map(x => x); }; // Placeholder\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] constructTransformedArray(int[] nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] constructTransformedArray(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; ++i) {\n            ans[i] = nums[i] != 0 ? nums[(i + nums[i] % n + n) % n] : 0;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> constructTransformedArray(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> constructTransformedArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0; i < n; ++i) {\n            ans[i] = nums[i] ? nums[(i + nums[i] % n + n) % n] : 0;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) constructTransformedArray(nums []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) constructTransformedArray(nums []int) []int {\n\tn := len(nums)\n\tans := make([]int, n)\n\tfor i, x := range nums {\n\t\tif x != 0 {\n\t\t\tans[i] = nums[(i+x%n+n)%n]\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn transformed_array(nums: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution { pub fn transformed_array(nums: Vec<i32>) -> Vec<i32> { nums } }"
      },
      "python": {
        "initialCode": "class Solution:\n    def constructTransformedArray(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructTransformedArray(nums: number[]): number[]  {\n    const n = nums.length;\n    const ans: number[] = [];\n    for (let i = 0; i < n; ++i) {\n        ans.push(nums[i] ? nums[(i + (nums[i] % n) + n) % n] : 0);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    constructTransformedArray(nums: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    }
  },
  "encode-and-decode-strings": {
    "id": "encode-and-decode-strings",
    "slug": "encode-and-decode-strings",
    "title": "Encode and Decode Strings",
    "difficulty": "Medium",
    "category": "Array / String",
    "problemStatement": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent to the other end of the network, where it is decoded back to the original list of strings.",
    "videoUrl": "",
    "pattern": "String Encoding",
    "patternEmoji": "\ud83d\udd10",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Prefix each string with its length followed by a delimiter.",
    "intuition": [
      "We need a way to unambiguously separate strings during decoding",
      "Using length+delimiter ensures we can always find string boundaries"
    ],
    "visualizationType": "array",
    "initialState": [
      "hello",
      "world"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Encode and Decode Strings",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = hello",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = world",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "hello",
          "world"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    class Codec:\n        def encode(self, strs):\n        \"\"\"\n        Intuition:\n        - We need a way to unambiguously separate strings during decoding\n        - Using length+delimiter ensures we can always find string boundaries\n        \"\"\"\n            encoded = ''\n            for s in strs:  # Iterate over elements.\n                encoded += str(len(s)) + '#' + s\n            return encoded\n        \n        def decode(self, s):\n            decoded = []\n            i = 0\n            while i < len(s):\n                j = i\n                while s[j] != '#':\n                    j += 1\n                length = int(s[i:j])\n                decoded.append(s[j+1:j+1+length])  # Add to end.\n                i = j+1+length\n            return decoded",
    "keyInsight": "Length prefix with delimiter allows unambiguous parsing regardless of content.",
    "testCases": [
      {
        "input": "codec = Codec(); codec.decode(codec.encode([\"lint\",\"code\",\"love\",\"you\"]))",
        "output": "[\"lint\",\"code\",\"love\",\"you\"]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "String Encoding: Prefix each string with its length followed by a delimiter.",
    "videoId": "B1k_sxOSgv8",
    "mentalModel": "Like organizing items on a shelf. Fast to read, slow to shift.",
    "initialCode": "class Codec:\n    def encode(self, strs):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "class Codec:\n    def encode(self, strs):\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n    def decode(self, s):\n        res, i = [], 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            res.append(s[j+1 : j+1+length])\n            i = j + 1 + length\n        return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "We need a way to unambiguously separate strings during decoding",
          "Using length+delimiter ensures we can always find string boundaries"
        ],
        "code": "class Codec:\n    def encode(self, strs):\n    \"\"\"\n    Intuition:\n    - We need a way to unambiguously separate strings during decoding\n    - Using length+delimiter ensures we can always find string boundaries\n    \"\"\"\n        encoded = ''\n        for s in strs:  # Iterate over elements.\n            encoded += str(len(s)) + '#' + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            decoded.append(s[j+1:j+1+length])  # Add to end.\n            i = j+1+length\n        return decoded"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    encode(strs) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} strs\n     * @return {any}\n     */\n    encode(strs) {\n        return strs.map(str => `${str.length}:${str}`).join('');\n      };\n\n\n      var decode = function(s) {\n        const result = [];\n        let i = 0;\n\n        while (i < s.length) {\n          const colon = s.indexOf(':', i);\n          const len = parseInt(s.slice(i, colon));\n          result.push(s.slice(colon + 1, colon + 1 + len));\n          i = colon + 1 + len;\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int encode(int strs) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "public class Codec {\n\n    // Encodes a list of strings to a single string.\n    public String encode(List<String> strs) {\n        StringBuilder ans = new StringBuilder();\n        for (String s : strs) {\n            ans.append((char) s.length()).append(s);\n        }\n        return ans.toString();\n    }\n\n    // Decodes a single string to a list of strings.\n    public List<String> decode(String s) {\n        List<String> ans = new ArrayList<>();\n        int i = 0, n = s.length();\n        while (i < n) {\n            int size = s.charAt(i++);\n            ans.add(s.substring(i, i + size));\n            i += size;\n        }\n        return ans;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(strs));"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    int encode(int strs) {\n        // Your code here\n        return 0;\n    }\n};",
        "code": "class Codec {\npublic:\n    // Encodes a list of strings to a single string.\n    string encode(vector<string>& strs) {\n        string ans;\n        for (string s : strs) {\n            int size = s.size();\n            ans += string((const char*) &size, sizeof(size));\n            ans += s;\n        }\n        return ans;\n    }\n\n    // Decodes a single string to a list of strings.\n    vector<string> decode(string s) {\n        vector<string> ans;\n        int i = 0, n = s.size();\n        int size = 0;\n        while (i < n) {\n            memcpy(&size, s.data() + i, sizeof(size));\n            i += sizeof(size);\n            ans.push_back(s.substr(i, size));\n            i += size;\n        }\n        return ans;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec;\n// codec.decode(codec.encode(strs));"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) encode(strs int) int {\n    // Your code here\n    return 0\n}",
        "code": "type Codec struct {\n}\n\n// Encodes a list of strings to a single string.\nfunc (codec *Codec) Encode(strs []string) string {\n\tans := &bytes.Buffer{}\n\tfor _, s := range strs {\n\t\tt := fmt.Sprintf(\"%04d\", len(s))\n\t\tans.WriteString(t)\n\t\tans.WriteString(s)\n\t}\n\treturn ans.String()\n}\n\n// Decodes a single string to a list of strings.\nfunc (codec *Codec) Decode(strs string) []string {\n\tans := []string{}\n\ti, n := 0, len(strs)\n\tfor i < n {\n\t\tt := strs[i : i+4]\n\t\ti += 4\n\t\tsize, _ := strconv.Atoi(t)\n\t\tans = append(ans, strs[i:i+size])\n\t\ti += size\n\t}\n\treturn ans\n}\n\n// Your Codec object will be instantiated and called as such:\n// var codec Codec\n// codec.Decode(codec.Encode(strs));"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn encode(strs: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Codec;\n\nimpl Codec {\n    fn new() -> Self {\n        Codec {}\n    }\n    fn encode(&self, strs: Vec<String>) -> String {\n        let n = strs.len();\n        let mut res: String = \"\".to_string();\n        let v = Self::encode_usize(n);\n        res.push_str(&v);\n        for s in strs {\n            let n = s.len();\n            let v = Self::encode_usize(n);\n            res.push_str(&v);\n            res.push_str(&s);\n        }\n        res\n    }\n\n    fn decode(&self, s: String) -> Vec<String> {\n        let mut res = vec![];\n        let v: Vec<char> = s.chars().collect();\n        let n = Self::decode_usize(&v[0..4]);\n        let mut index = 4;\n        for _ in 0..n {\n            let m = Self::decode_usize(&v[index..index + 4]);\n            index += 4;\n            let ss: String = v[index..index + m].iter().collect();\n            index += m;\n            res.push(ss);\n        }\n        res\n    }\n\n    fn encode_usize(x: usize) -> String {\n        let x = x as u32;\n        vec![\n            (x >> 24 & 0xff) as u8 as char,\n            (x >> 16 & 0xff) as u8 as char,\n            (x >> 8 & 0xff) as u8 as char,\n            (x & 0xff) as u8 as char,\n        ]\n        .into_iter()\n        .collect()\n    }\n\n    fn decode_usize(v: &[char]) -> usize {\n        ((v[0] as u32) << 24 | (v[1] as u32) << 16 | (v[2] as u32) << 8 | (v[3] as u32)) as usize\n    }\n}\n\n#[test]\nfn test() {\n    let obj = Codec::new();\n    let strs = vec_string!(\"123\", \"321\");\n    let encoded = obj.encode(strs);\n    let decoded = obj.decode(encoded);\n    let res = vec_string!(\"123\", \"321\");\n    assert_eq!(decoded, res);\n}"
      },
      "python": {
        "initialCode": "class Codec:\n    def encode(self, strs):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    encode(strs: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    encode(strs: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent to the other end of the network, where it is decoded back to the original list of strings.",
    "relatedProblems": [
      "product-of-array-except-self",
      "longest-consecutive-sequence",
      "letter-combinations-of-a-phone-number"
    ],
    "suggestedNextQuestion": {
      "slug": "min-stack",
      "title": "Min Stack",
      "difficulty": "Medium",
      "pattern": "Stack (Two Stacks)"
    }
  },
  "two-sum-ii-input-array-is-sorted": {
    "id": "two-sum-ii-input-array-is-sorted",
    "slug": "two-sum-ii-input-array-is-sorted",
    "title": "Two Sum II - Input Array Is Sorted",
    "difficulty": "Medium",
    "category": "Two Pointers",
    "problemStatement": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.",
    "videoUrl": "",
    "pattern": "Two Pointers",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use two pointers starting from ends to find the pair.",
    "intuition": [
      "Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.",
      "If our sum is too small, we can increase it by moving the left pointer right."
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      7,
      11,
      15
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Two Sum II - Input Array Is Sorted",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 7",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 11",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 15",
        "transientMessage": "Iteration 4",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          2,
          7,
          11,
          15
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        Intuition:\n        - Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.\n        - If our sum is too small, we can increase it by moving the left pointer right.\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n\n            if current_sum == target:\n                return [left + 1, right + 1]  # 1-indexed\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n\n        return []  # This line should never be reached",
    "keyInsight": "The array is sorted, so we can use directionality.",
    "testCases": [
      {
        "input": "numbers = [2,7,11,15], target = 9",
        "output": "[1,2]"
      },
      {
        "input": "numbers = [2,3,4], target = 6",
        "output": "[1,3]"
      },
      {
        "input": "numbers = [-1,0], target = -1",
        "output": "[1,2]"
      }
    ],
    "walkthrough": [
      "Initialize two pointers (start/end or slow/fast)",
      "Move pointers based on problem conditions",
      "Process elements as pointers traverse",
      "Continue until pointers meet or condition satisfied",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Consider using two pointers from opposite ends",
      "\ud83d\udca1 Or use slow/fast pointer technique",
      "\ud83d\udd0d What condition moves each pointer?"
    ],
    "approach": "Two Pointers: Use two pointers starting from ends to find the pair.",
    "videoId": "cQ1Oz4ckceM",
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def twoSum(self, numbers, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l+1, r+1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.",
          "If our sum is too small, we can increase it by moving the left pointer right."
        ],
        "code": "def twoSum(numbers, target):\n    \"\"\"\n    Intuition:\n    - Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.\n    - If our sum is too small, we can increase it by moving the left pointer right.\n    \"\"\"\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []  # This line should never be reached"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[result]",
        "explanation": "Two pointers traverse from both ends."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[result]",
        "explanation": "Edge case with minimum input."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Array is sorted (if applicable)"
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    twoSum(numbers, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} numbers, target\n     * @return {any}\n     */\n    twoSum(numbers, target) {\n        const n = numbers.length;\n        for (let i = 0; ; ++i) {\n            const x = target - numbers[i];\n            let l = i + 1;\n            let r = n - 1;\n            while (l < r) {\n                const mid = (l + r) >> 1;\n                if (numbers[mid] >= x) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (numbers[l] === x) {\n                return [i + 1, l + 1];\n            }\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        for (int i = 0, n = numbers.length;; ++i) {\n            int x = target - numbers[i];\n            int l = i + 1, r = n - 1;\n            while (l < r) {\n                int mid = (l + r) >> 1;\n                if (numbers[mid] >= x) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            if (numbers[l] == x) {\n                return new int[] {i + 1, l + 1};\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        for (int i = 0, n = numbers.size();; ++i) {\n            int x = target - numbers[i];\n            int j = lower_bound(numbers.begin() + i + 1, numbers.end(), x) - numbers.begin();\n            if (j < n && numbers[j] == x) {\n                return {i + 1, j + 1};\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) twoSum(numbers []int, target int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) twoSum(numbers []int, target int) []int {\n\tfor i, n := 0, len(numbers); ; i++ {\n\t\tx := target - numbers[i]\n\t\tj := sort.SearchInts(numbers[i+1:], x) + i + 1\n\t\tif j < n && numbers[j] == x {\n\t\t\treturn []int{i + 1, j + 1}\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::cmp::Ordering;\n\nimpl Solution {\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\n        let n = numbers.len();\n        let mut l = 0;\n        let mut r = n - 1;\n        loop {\n            match (numbers[l] + numbers[r]).cmp(&target) {\n                Ordering::Less => {\n                    l += 1;\n                }\n                Ordering::Greater => {\n                    r -= 1;\n                }\n                Ordering::Equal => {\n                    break;\n                }\n            }\n        }\n        vec![(l as i32) + 1, (r as i32) + 1]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def twoSum(self, numbers, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    twoSum(numbers: number[], target: number): number[]  {\n    const n = numbers.length;\n    for (let i = 0; ; ++i) {\n        const x = target - numbers[i];\n        let l = i + 1;\n        let r = n - 1;\n        while (l < r) {\n            const mid = (l + r) >> 1;\n            if (numbers[mid] >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        if (numbers[l] === x) {\n            return [i + 1, l + 1];\n        }\n    }\n}\n}",
        "initialCode": "class Solution {\n    twoSum(numbers: number[], target: number): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.",
    "relatedProblems": [
      "is-subsequence",
      "squares-of-a-sorted-array",
      "remove-duplicates-from-sorted-array-ii"
    ],
    "suggestedNextQuestion": {
      "slug": "remove-duplicates-from-sorted-array-ii",
      "title": "Remove Duplicates from Sorted Array II",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    }
  },
  "longest-repeating-character-replacement": {
    "id": "longest-repeating-character-replacement",
    "slug": "longest-repeating-character-replacement",
    "title": "Longest Repeating Character Replacement",
    "difficulty": "Medium",
    "category": "Sliding Window",
    "problemStatement": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
    "videoUrl": "",
    "pattern": "Sliding Window",
    "patternEmoji": ">window<",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use sliding window with max frequency tracking to find longest valid substring.",
    "intuition": [
      "We can extend a window as long as (window length - max char frequency) \u2264 k",
      "When this condition breaks, shrink window from left until it's valid again"
    ],
    "visualizationType": "array",
    "initialState": [
      "A",
      "A",
      "B",
      "A",
      "B",
      "B",
      "A"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Repeating Character Replacement",
        "transientMessage": "Sliding window approach",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize window",
        "transientMessage": "left=0, right=0",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Expand window to 1",
        "transientMessage": "Window: [0, 1]",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Expand window to 2",
        "transientMessage": "Window: [0, 2]",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Expand window to 3",
        "transientMessage": "Window: [0, 3]",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 3
          }
        ],
        "indices": [
          0,
          1,
          2,
          3
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Expand window to 4",
        "transientMessage": "Window: [0, 4]",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 4
          }
        ],
        "indices": [
          0,
          1,
          2,
          3,
          4
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Expand window to 5",
        "transientMessage": "Window: [0, 5]",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 0
          },
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          0,
          1,
          2,
          3,
          4,
          5
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Shrink from left",
        "transientMessage": "Condition met, slide window",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          },
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update maximum/result",
        "transientMessage": "Track best answer",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Window traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "A",
          "A",
          "B",
          "A",
          "B",
          "B",
          "A"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def characterReplacement(s: str, k: int) -> int:\n        \"\"\"\n        Intuition:\n        - We can extend a window as long as (window length - max char frequency) \u2264 k\n        - When this condition breaks, shrink window from left until it's valid again\n        \"\"\"\n        left = 0\n        max_length = 0\n        max_freq = 0\n        char_count = {}\n\n        for right in range(len(s)):  # Iterate through the range.\n            # Update character frequency\n            char_count[s[right]] = char_count.get(s[right], 0) + 1\n            max_freq = max(max_freq, char_count[s[right]])  # Take the maximum value.\n\n            # If window is invalid, shrink from left\n            while (right - left + 1) - max_freq > k:\n                char_count[s[left]] -= 1\n                left += 1\n                # Note: max_freq might be outdated but doesn't affect correctness\n\n            # Update maximum length\n            max_length = max(max_length, right - left + 1)  # Take the maximum value.\n\n        return max_length",
    "keyInsight": "We track the maximum frequency in current window. Window is valid if (length - maxFreq) \u2264 k.",
    "testCases": [
      {
        "input": "s = \"ABAB\", k = 2",
        "output": "4"
      },
      {
        "input": "s = \"AABABBA\", k = 1",
        "output": "4"
      }
    ],
    "walkthrough": [
      "Initialize window boundaries (left, right)",
      "Expand window by moving right pointer",
      "Update window state with new element",
      "Shrink window when condition violated",
      "Track optimal result throughout"
    ],
    "hints": [
      "\ud83e\udde0 What defines a valid window?",
      "\ud83d\udca1 When should you expand vs shrink?",
      "\ud83d\udd0d Track window state efficiently"
    ],
    "approach": "Sliding Window: Use sliding window with max frequency tracking to find longest valid substring.",
    "videoId": "gqXU1UyA8pk",
    "suggestedNextQuestion": {
      "slug": "longest-substring-without-repeating-characters",
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class Solution:\n    def characterReplacement(s: str, k: int) -> int:\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def characterReplacement_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "We can extend a window as long as (window length - max char frequency) \u2264 k",
          "When this condition breaks, shrink window from left until it's valid again"
        ],
        "code": "def characterReplacement(s: str, k: int) -> int:\n    \"\"\"\n    Intuition:\n    - We can extend a window as long as (window length - max char frequency) \u2264 k\n    - When this condition breaks, shrink window from left until it's valid again\n    \"\"\"\n    left = 0\n    max_length = 0\n    max_freq = 0\n    char_count = {}\n    \n    for right in range(len(s)):  # Iterate through the range.\n        # Update character frequency\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        max_freq = max(max_freq, char_count[s[right]])  # Take the maximum value.\n        \n        # If window is invalid, shrink from left\n        while (right - left + 1) - max_freq > k:\n            char_count[s[left]] -= 1\n            left += 1\n            # Note: max_freq might be outdated but doesn't affect correctness\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)  # Take the maximum value.\n    \n    return max_length"
      }
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "Sliding window expands until duplicate, then shrinks."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "All same characters."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of printable ASCII characters"
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    characterReplacement(s, k) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s, k\n     * @return {any}\n     */\n    characterReplacement(s, k) {\n        const count = new Map();\n        let max = 0;\n        let left = 0;\n\n        return s.split('').reduce((maxLength, char, right) => {\n          count.set(char, (count.get(char) || 0) + 1);\n          max = Math.max(max, count.get(char));\n          if (right - left + 1 - max > k) {\n            count.set(s[left], count.get(s[left++]) - 1);\n      }\n      return Math.max(maxLength, right - left + 1);\n    }, 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int characterReplacement(String s, int k) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int characterReplacement(String s, int k) {\n        int[] cnt = new int[26];\n        int l = 0, mx = 0;\n        int n = s.length();\n        for (int r = 0; r < n; ++r) {\n            mx = Math.max(mx, ++cnt[s.charAt(r) - 'A']);\n            if (r - l + 1 - mx > k) {\n                --cnt[s.charAt(l++) - 'A'];\n            }\n        }\n        return n - l;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int characterReplacement(string s, int k) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int cnt[26]{};\n        int l = 0, mx = 0;\n        int n = s.length();\n        for (int r = 0; r < n; ++r) {\n            mx = max(mx, ++cnt[s[r] - 'A']);\n            if (r - l + 1 - mx > k) {\n                --cnt[s[l++] - 'A'];\n            }\n        }\n        return n - l;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) characterReplacement(s string, k int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) characterReplacement(s string, k int) int {\n\tcnt := [26]int{}\n\tl, mx := 0, 0\n\tfor r, c := range s {\n\t\tcnt[c-'A']++\n\t\tmx = max(mx, cnt[c-'A'])\n\t\tif r-l+1-mx > k {\n\t\t\tcnt[s[l]-'A']--\n\t\t\tl++\n\t\t}\n\t}\n\treturn len(s) - l\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn character_replacement(s: i32, k: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn character_replacement(s: String, k: i32) -> i32 {\n        let mut count = vec![0; 26];\n        let n = s.len();\n        let s: Vec<char> = s.chars().collect();\n        let mut start = 0;\n        let mut end = 0;\n        let mut res = 0;\n        while end < n {\n            if Self::sum(&count) <= k {\n                count[(s[end] as u8 - b'A') as usize] += 1;\n                end += 1;\n            } else {\n                count[(s[start] as u8 - b'A') as usize] -= 1;\n                start += 1;\n            }\n            if Self::sum(&count) <= k {\n                res = res.max(end - start);\n            }\n        }\n        res as i32\n    }\n\n    fn sum(count: &[i32]) -> i32 {\n        let max = count.iter().copied().max().unwrap();\n        count.iter().sum::<i32>() - max\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"ABAB\".to_string();\n    let k = 2;\n    let res = 4;\n    assert_eq!(Solution::character_replacement(s, k), res);\n    let s = \"AABABBA\".to_string();\n    let k = 1;\n    let res = 4;\n    assert_eq!(Solution::character_replacement(s, k), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def characterReplacement(s: str, k: int) -> int:\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    characterReplacement(s: string, k: number): number  {\n    const idx = (c: string) => c.charCodeAt(0) - 65;\n    const cnt: number[] = Array(26).fill(0);\n    const n = s.length;\n    let [l, mx] = [0, 0];\n    for (let r = 0; r < n; ++r) {\n        mx = Math.max(mx, ++cnt[idx(s[r])]);\n        if (r - l + 1 - mx > k) {\n            --cnt[idx(s[l++])];\n        }\n    }\n    return n - l;\n}\n}",
        "initialCode": "class Solution {\n    characterReplacement(s: string, k: number): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
    "relatedProblems": [
      "minimum-size-subarray-sum",
      "permutation-in-string"
    ]
  },
  "sliding-window-maximum": {
    "id": "sliding-window-maximum",
    "slug": "sliding-window-maximum",
    "title": "Sliding Window Maximum",
    "difficulty": "Hard",
    "category": "Sliding Window",
    "problemStatement": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.",
    "videoUrl": "",
    "pattern": "Monotonic Queue",
    "patternEmoji": ".dequeue",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(k)",
    "oneliner": "Use a deque to maintain decreasing elements in the current window.",
    "intuition": [
      "We want maximums from sliding windows - brute force is O(n*k)",
      "Use deque to store indices of array elements in decreasing order"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      3,
      -1,
      -3,
      5,
      3,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Find max in each window of size 3",
        "transientMessage": "Initialize empty deque",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Add index 0 (val=1)",
        "transientMessage": "Deque: [0]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Remove 1 < 3",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Add index 1 (val=3)",
        "transientMessage": "Deque: [1]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Add index 2 (val=-1)",
        "transientMessage": "Deque: [1, 2]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Window max: 3",
        "transientMessage": "Result: [3]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 1
          }
        ],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Add index 3 (val=-3)",
        "transientMessage": "Deque: [1, 2, 3]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Window max: 3",
        "transientMessage": "Result: [3, 3]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 1
          }
        ],
        "indices": [
          1,
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Remove index 1 (outside window)",
        "transientMessage": "Deque: [2, 3]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Remove -3 < 5",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 11,
        "visual": "Remove -1 < 5",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Add index 4 (val=5)",
        "transientMessage": "Deque: [4]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 13,
        "visual": "Window max: 5",
        "transientMessage": "Result: [3, 3, 5]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 4
          }
        ],
        "indices": [
          2,
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Add index 5 (val=3)",
        "transientMessage": "Deque: [4, 5]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 15,
        "visual": "Window max: 5",
        "transientMessage": "Result: [3, 3, 5, 5]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 4
          }
        ],
        "indices": [
          3,
          4,
          5
        ],
        "color": "success"
      },
      {
        "step": 16,
        "visual": "Remove 3 < 6",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 17,
        "visual": "Remove 5 < 6",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 18,
        "visual": "Add index 6 (val=6)",
        "transientMessage": "Deque: [6]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 19,
        "visual": "Window max: 6",
        "transientMessage": "Result: [3, 3, 5, 5, 6]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 6
          }
        ],
        "indices": [
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 20,
        "visual": "Remove 6 < 7",
        "transientMessage": "Smaller element removed",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 21,
        "visual": "Add index 7 (val=7)",
        "transientMessage": "Deque: [7]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          7
        ],
        "color": "accent"
      },
      {
        "step": 22,
        "visual": "Window max: 7",
        "transientMessage": "Result: [3, 3, 5, 5, 6, 7]",
        "arrayState": [
          1,
          3,
          -1,
          -3,
          5,
          3,
          6,
          7
        ],
        "pointers": [
          {
            "label": "max",
            "index": 7
          }
        ],
        "indices": [
          5,
          6,
          7
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        Intuition:\n        - We want maximums from sliding windows - brute force is O(n*k)\n        - Use deque to store indices of array elements in decreasing order\n        \"\"\"\n        dq = deque()  # Stores indices\n        result = []\n        \n        for i in range(len(nums)):  # Iterate through the range.\n            # Remove indices outside window\n            while dq and dq[0] <= i - k:\n                dq.popleft()  # Remove from front of queue.\n            \n            # Remove indices whose values are less than current\n            while dq and nums[dq[-1]] <= nums[i]:\n                dq.pop()  # Remove and return last element.\n            \n            dq.append(i)  # Add to end.\n            \n            # Add max to result when window is formed\n            if i >= k - 1:\n                result.append(nums[dq[0]])  # Add to end.\n        \n        return result  # Return the final result.",
    "keyInsight": "Deque maintains indices of elements in decreasing order - front always has maximum.",
    "testCases": [
      {
        "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
        "output": "[3,3,5,5,6,7]"
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Monotonic Queue: Use a deque to maintain decreasing elements in the current window.",
    "videoId": "DfljaUwZsOk",
    "mentalModel": "Like a grocery line. First come, first served (FIFO).",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxSlidingWindow(nums, k):\n    res = []\n    for i in range(len(nums) - k + 1):\n        window = nums[i:i+k]\n        res.append(max(window))\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "We want maximums from sliding windows - brute force is O(n*k)",
          "Use deque to store indices of array elements in decreasing order"
        ],
        "code": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    \"\"\"\n    Intuition:\n    - We want maximums from sliding windows - brute force is O(n*k)\n    - Use deque to store indices of array elements in decreasing order\n    \"\"\"\n    dq = deque()  # Stores indices\n    result = []\n    \n    for i in range(len(nums)):  # Iterate through the range.\n        # Remove indices outside window\n        while dq and dq[0] <= i - k:\n            dq.popleft()  # Remove from front of queue.\n        \n        # Remove indices whose values are less than current\n        while dq and nums[dq[-1]] <= nums[i]:\n            dq.pop()  # Remove and return last element.\n        \n        dq.append(i)  # Add to end.\n        \n        # Add max to result when window is formed\n        if i >= k - 1:\n            result.append(nums[dq[0]])  # Add to end.\n    \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(nums: number[], k: number): number[] {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(nums: number[], k: number): number[] {\n        // Implementation goes here\n        return [];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] solve(int[] nums, int k) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int[] solve(int[] nums, int k) {\n        return new int[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> solve(vector<int>& nums, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> solve(vector<int>& nums, int k) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxSlidingWindow(nums []int, k int) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxSlidingWindow(nums []int, k int) (ans []int) {\n\tq := hp{}\n\tfor i, v := range nums[:k-1] {\n\t\theap.Push(&q, pair{v, i})\n\t}\n\tfor i := k - 1; i < len(nums); i++ {\n\t\theap.Push(&q, pair{nums[i], i})\n\t\tfor q[0].i <= i-k {\n\t\t\theap.Pop(&q)\n\t\t}\n\t\tans = append(ans, q[0].v)\n\t}\n\treturn\n}\n\ntype pair struct{ v, i int }\n\ntype hp []pair\n\nfunc (h hp) Len() int { return len(h) }\nfunc (h hp) Less(i, j int) bool {\n\ta, b := h[i], h[j]\n\treturn a.v > b.v || (a.v == b.v && i < j)\n}\nfunc (h hp) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)   { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() any     { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [239] Sliding Window Maximum\n *\n * Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\n *\n * Example:\n *\n *\n * Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3\n * Output: [3,3,5,5,6,7]\n * Explanation:\n *\n * Window position                Max\n * ---------------               -----\n * [1  3  -1] -3  5  3  6  7       3\n *  1 [3  -1  -3] 5  3  6  7       3\n *  1  3 [-1  -3  5] 3  6  7       5\n *  1  3  -1 [-3  5  3] 6  7       5\n *  1  3  -1  -3 [5  3  6] 7       6\n *  1  3  -1  -3  5 [3  6  7]      7\n *\n *\n * Note: <br />\n * You may assume k is always valid, 1 &le; k &le; input array's size for non-empty array.\n *\n * Follow up:<br />\n * Could you solve it in linear time?\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/sliding-window-maximum/\n// discuss: https://leetcode.com/problems/sliding-window-maximum/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nuse std::collections::VecDeque;\nimpl Solution {\n    pub fn max_sliding_window(nums: Vec<i32>, k: i32) -> Vec<i32> {\n        let mut deq: VecDeque<(usize, i32)> = VecDeque::new();\n        let mut res = Vec::new();\n        for i in 0..nums.len() {\n            // maintain sliding window\n            if !deq.is_empty() && (*deq.front().unwrap()).0 as i32 <= (i as i32) - k {\n                deq.pop_front();\n                let mut max = i32::min_value();\n                let mut count = 0_usize;\n                for (j, &v) in deq.iter().enumerate() {\n                    if v.1 >= max {\n                        max = v.1;\n                        count = j;\n                    }\n                }\n                for _ in 0..count {\n                    deq.pop_front();\n                }\n            }\n            let num = nums[i];\n            if !deq.is_empty() && (*deq.front().unwrap()).1 <= num {\n                while !deq.is_empty() {\n                    deq.pop_front();\n                }\n            }\n            deq.push_back((i, num));\n            if i + 1 >= k as usize {\n                res.push((*deq.front().unwrap()).1);\n            }\n        }\n        res\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_239() {\n        assert_eq!(\n            Solution::max_sliding_window(vec![9, 10, 9, -7, -4, -8, 2, -6], 5),\n            vec![10, 10, 9, 2]\n        );\n        assert_eq!(\n            Solution::max_sliding_window(vec![1, 3, 1, 2, 0, 5], 3),\n            vec![3, 3, 2, 5]\n        );\n        assert_eq!(Solution::max_sliding_window(vec![7, 2, 4], 2), vec![7, 4]);\n        assert_eq!(Solution::max_sliding_window(vec![1, -1], 1), vec![1, -1]);\n        assert_eq!(\n            Solution::max_sliding_window(vec![1, 3, -1, -3, 5, 3, 6, 7], 3),\n            vec![3, 3, 5, 5, 6, 7]\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.",
    "relatedProblems": [
      "binary-tree-maximum-path-sum",
      "substring-with-concatenation-of-all-words",
      "alien-dictionary"
    ],
    "suggestedNextQuestion": {
      "slug": "basic-calculator",
      "title": "Basic Calculator",
      "difficulty": "Hard",
      "pattern": "Stack (Signs)"
    }
  },
  "non-overlapping-intervals": {
    "id": "non-overlapping-intervals",
    "slug": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "difficulty": "Medium",
    "category": "Intervals",
    "problemStatement": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nNote that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.",
    "videoUrl": "",
    "pattern": "Greedy Algorithm",
    "patternEmoji": "\ud83d\udcb0",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Sort by end time and greedily select non-overlapping intervals.",
    "intuition": [
      "To minimize removals, we want to keep as many non-overlapping intervals as possible.",
      "Greedy approach: always pick the interval that ends earliest to leave more room for others."
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      2,
      3,
      1,
      3,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Non-overlapping Intervals",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 2",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 3",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 1",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 3",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          2,
          3,
          1,
          3,
          3,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        Intuition:\n        - To minimize removals, we want to keep as many non-overlapping intervals as possible.\n        - Greedy approach: always pick the interval that ends earliest to leave more room for others.\n        \"\"\"\n        if not intervals:\n            return 0\n\n        # Sort by end time\n        intervals.sort(key=lambda x: x[1])\n\n        count = 0\n        end = intervals[0][1]\n\n        for i in range(1, len(intervals)):  # Iterate through the range.\n            # If current interval starts before previous ends\n            if intervals[i][0] < end:\n                count += 1  # Remove this interval\n            else:\n                end = intervals[i][1]  # Keep this interval\n\n        return count",
    "keyInsight": "Sort by end time and greedily keep intervals that don't overlap with the previously selected one.",
    "testCases": [
      {
        "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
        "output": "1"
      },
      {
        "input": "intervals = [[1,2],[1,2],[1,2]]",
        "output": "2"
      },
      {
        "input": "intervals = [[1,2],[2,3]]",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Greedy Algorithm: Sort by end time and greedily select non-overlapping intervals.",
    "videoId": "nONCGxWoUfM",
    "suggestedNextQuestion": {
      "slug": "partition-labels",
      "title": "Partition Labels",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def eraseOverlapIntervals(self, intervals):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def eraseOverlapIntervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    res = 0\n    for s, e in intervals:\n        if s >= end:\n            end = e\n        else:\n            res += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "To minimize removals, we want to keep as many non-overlapping intervals as possible.",
          "Greedy approach: always pick the interval that ends earliest to leave more room for others."
        ],
        "code": "def eraseOverlapIntervals(intervals):\n    \"\"\"\n    Intuition:\n    - To minimize removals, we want to keep as many non-overlapping intervals as possible.\n    - Greedy approach: always pick the interval that ends earliest to leave more room for others.\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):  # Iterate through the range.\n        # If current interval starts before previous ends\n        if intervals[i][0] < end:\n            count += 1  # Remove this interval\n        else:\n            end = intervals[i][1]  # Keep this interval\n    \n    return count"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    eraseOverlapIntervals(intervals) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} intervals\n     * @return {any}\n     */\n    eraseOverlapIntervals(intervals) {\n        let count = 0;\n\n        intervals.sort((a, b) => a[1] - b[1]);\n        let prevEnd = intervals[0][1];\n\n        for (let i = 1; i < intervals.length; i++) {\n          const [start, end] = intervals[i];\n          if (prevEnd > start) count++;\n          else prevEnd = end;\n      }\n\n    return count;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        int ans = intervals.length;\n        int pre = Integer.MIN_VALUE;\n        for (var e : intervals) {\n            int l = e[0], r = e[1];\n            if (pre <= l) {\n                --ans;\n                pre = r;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        ranges::sort(intervals, [](const vector<int>& a, const vector<int>& b) {\n            return a[1] < b[1];\n        });\n        int ans = intervals.size();\n        int pre = INT_MIN;\n        for (const auto& e : intervals) {\n            int l = e[0], r = e[1];\n            if (pre <= l) {\n                --ans;\n                pre = r;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) eraseOverlapIntervals(intervals [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) eraseOverlapIntervals(intervals [][]int) int {\n\tsort.Slice(intervals, func(i, j int) bool {\n\t\treturn intervals[i][1] < intervals[j][1]\n\t})\n\tans := len(intervals)\n\tpre := math.MinInt32\n\tfor _, e := range intervals {\n\t\tl, r := e[0], e[1]\n\t\tif pre <= l {\n\t\t\tans--\n\t\t\tpre = r\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn erase_overlap_intervals(intervals: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn erase_overlap_intervals(mut intervals: Vec<Vec<i32>>) -> i32 {\n        if intervals.is_empty() {\n            return 0;\n        }\n        let n = intervals.len();\n        intervals.sort_by_key(|v| v[1]);\n        let mut end = intervals[0][1];\n        let mut res = 0;\n        for i in 1..n {\n            if intervals[i][0] < end {\n                res += 1;\n            } else {\n                end = intervals[i][1];\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let intervals = vec_vec_i32![[1, 2], [2, 3], [3, 4], [1, 3]];\n    let res = 1;\n    assert_eq!(Solution::erase_overlap_intervals(intervals), res);\n    let intervals = vec_vec_i32![[1, 2], [1, 2], [1, 2]];\n    let res = 2;\n    assert_eq!(Solution::erase_overlap_intervals(intervals), res);\n    let intervals = vec_vec_i32![[1, 2], [2, 3]];\n    let res = 0;\n    assert_eq!(Solution::erase_overlap_intervals(intervals), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def eraseOverlapIntervals(self, intervals):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    eraseOverlapIntervals(intervals: number[][]): number  {\n    intervals.sort((a, b) => a[1] - b[1]);\n    let [ans, pre] = [intervals.length, -Infinity];\n    for (const [l, r] of intervals) {\n        if (pre <= l) {\n            --ans;\n            pre = r;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    eraseOverlapIntervals(intervals: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nNote that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.",
    "relatedProblems": [
      "jump-game-ii",
      "palindromic-substrings",
      "remove-duplicates-from-sorted-array-ii"
    ]
  },
  "meeting-rooms": {
    "id": "meeting-rooms",
    "slug": "meeting-rooms",
    "title": "Meeting Rooms",
    "difficulty": "Easy",
    "category": "Intervals",
    "problemStatement": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person can attend all meetings.",
    "videoUrl": "",
    "pattern": "Sorting",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Sort by start times and check for overlaps.",
    "intuition": [
      "If meetings overlap, person can't attend all.",
      "Sort by start time to easily compare adjacent meetings."
    ],
    "visualizationType": "array",
    "initialState": [
      [
        0,
        30
      ],
      [
        5,
        10
      ],
      [
        15,
        20
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Meeting Rooms",
        "transientMessage": "Input: [0,30, 5,10, 15,20]",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 0,30",
        "transientMessage": "Step 1 of 3",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 5,10",
        "transientMessage": "Step 2 of 3",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 15,20",
        "transientMessage": "Step 3 of 3",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def canAttendMeetings(self, intervals):\n        \"\"\"\n        Intuition:\n        - If meetings overlap, person can't attend all.\n        - Sort by start time to easily compare adjacent meetings.\n        \"\"\"\n        intervals.sort()\n        for i in range(1, len(intervals)):  # Iterate through the range.\n            if intervals[i][0] < intervals[i-1][1]:\n                return False  # Condition not met.\n        return True  # Condition satisfied.",
    "keyInsight": "After sorting, only adjacent meetings need overlap checking.",
    "testCases": [
      {
        "input": "intervals = [[0,30],[5,10],[15,20]]",
        "output": "false"
      },
      {
        "input": "intervals = [[7,10],[2,4]]",
        "output": "true"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Sorting: Sort by start times and check for overlaps.",
    "videoId": "PaJxqZVPhbg",
    "mentalModel": "Like arranging a hand of cards by rank and suit.",
    "initialCode": "class Solution:\n    def canAttendMeetings(self, intervals):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def canAttendMeetings(intervals):\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "If meetings overlap, person can't attend all.",
          "Sort by start time to easily compare adjacent meetings."
        ],
        "code": "def canAttendMeetings(intervals):\n    \"\"\"\n    Intuition:\n    - If meetings overlap, person can't attend all.\n    - Sort by start time to easily compare adjacent meetings.\n    \"\"\"\n    intervals.sort()\n    for i in range(1, len(intervals)):  # Iterate through the range.\n        if intervals[i][0] < intervals[i-1][1]:\n            return False  # Condition not met.\n    return True  # Condition satisfied."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    canAttendMeetings(intervals) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} intervals\n     * @return {any}\n     */\n    canAttendMeetings(intervals) {\n        intervals.sort((a, b) => a[0] - b[0]);\n\n        for (let i = 1; i < intervals.length; i++) {\n          if (intervals[i][0] < intervals[i - 1][1]) {\n            return false;\n          }\n      }\n\n    return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        for (int i = 1; i < intervals.length; ++i) {\n            if (intervals[i - 1][1] > intervals[i][0]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool canAttendMeetings(vector<vector<int>>& intervals) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool canAttendMeetings(vector<vector<int>>& intervals) {\n        ranges::sort(intervals, [](const auto& a, const auto& b) {\n            return a[0] < b[0];\n        });\n        for (int i = 1; i < intervals.size(); ++i) {\n            if (intervals[i - 1][1] > intervals[i][0]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canAttendMeetings(intervals [][]int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canAttendMeetings(intervals [][]int) bool {\n\tsort.Slice(intervals, func(i, j int) bool {\n\t\treturn intervals[i][0] < intervals[j][0]\n\t})\n\tfor i := 1; i < len(intervals); i++ {\n\t\tif intervals[i][0] < intervals[i-1][1] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_attend_meetings(mut intervals: Vec<Vec<i32>>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn can_attend_meetings(mut intervals: Vec<Vec<i32>>) -> bool {\n        intervals.sort_by(|a, b| a[0].cmp(&b[0]));\n        for i in 1..intervals.len() {\n            if intervals[i - 1][1] > intervals[i][0] {\n                return false;\n            }\n        }\n        true\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canAttendMeetings(self, intervals):\n        \"\"\"\n        Intuition:\n        - If meetings overlap, person can't attend all.\n        - Sort by start time to easily compare adjacent meetings.\n        \"\"\"\n        intervals.sort()\n        for i in range(1, len(intervals)):  # Iterate through the range.\n            if intervals[i][0] < intervals[i-1][1]:\n                return False  # Condition not met.\n        return True  # Condition satisfied."
      },
      "typescript": {
        "code": "class Solution {\n    canAttendMeetings(intervals: number[][]): boolean  {\n    intervals.sort((a, b) => a[0] - b[0]);\n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1]) {\n            return false;\n        }\n    }\n    return true;\n}\n}",
        "initialCode": "class Solution {\n    canAttendMeetings(intervals: number[][]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person can attend all meetings.",
    "relatedProblems": [
      "palindrome-number",
      "climbing-stairs",
      "valid-parentheses"
    ],
    "suggestedNextQuestion": {
      "slug": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    }
  },
  "meeting-rooms-ii": {
    "id": "meeting-rooms-ii",
    "slug": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "difficulty": "Medium",
    "category": "Intervals",
    "problemStatement": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
    "videoUrl": "",
    "pattern": "Two Pointers + Sorting",
    "patternEmoji": "\ud83d\udc49\ud83d\udc48\ud83d\udcc5",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Sort start/end times separately and use two pointers to track room usage.",
    "intuition": [
      "We don't need to know which meeting is in which room, just how many are happening simultaneously",
      "By sorting start and end times separately, we can efficiently track when meetings begin/end"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        0,
        30
      ],
      [
        5,
        10
      ],
      [
        15,
        20
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Meeting Rooms II",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 0,30",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 5,10",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 15,20",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            0,
            30
          ],
          [
            5,
            10
          ],
          [
            15,
            20
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        Intuition:\n        - We don't need to know which meeting is in which room, just how many are happening simultaneously\n        - By sorting start and end times separately, we can efficiently track when meetings begin/end\n        \"\"\"\n        if not intervals:\n            return 0\n\n        starts = sorted([interval[0] for interval in intervals])\n        ends = sorted([interval[1] for interval in intervals])\n\n        start_ptr = end_ptr = 0\n        rooms_needed = 0\n        max_rooms = 0\n\n        while start_ptr < len(intervals):\n            if starts[start_ptr] < ends[end_ptr]:\n                rooms_needed += 1\n                max_rooms = max(max_rooms, rooms_needed)  # Take the maximum value.\n                start_ptr += 1\n            else:\n                rooms_needed -= 1\n                end_ptr += 1\n\n        return max_rooms",
    "keyInsight": "Separating start/end times lets us process events chronologically without tracking specific meetings.",
    "testCases": [
      {
        "input": "intervals = [[0,30],[5,10],[15,20]]",
        "output": "2"
      },
      {
        "input": "intervals = [[7,10],[2,4]]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Two Pointers + Sorting: Sort start/end times separately and use two pointers to track room usage.",
    "videoId": "FdzJmTCVyJU",
    "suggestedNextQuestion": {
      "slug": "middle-of-the-linked-list",
      "title": "Middle of the Linked List",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like two people walking towards each other from opposite ends of a hallway to meet in the middle.",
    "initialCode": "class Solution:\n    def minMeetingRooms(self, intervals):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Try all pairs using nested loops.",
          "Compare each pair and check if condition is met."
        ],
        "code": "def minMeetingRooms(intervals):\n    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])\n    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "We don't need to know which meeting is in which room, just how many are happening simultaneously",
          "By sorting start and end times separately, we can efficiently track when meetings begin/end"
        ],
        "code": "def minMeetingRooms(intervals):\n    \"\"\"\n    Intuition:\n    - We don't need to know which meeting is in which room, just how many are happening simultaneously\n    - By sorting start and end times separately, we can efficiently track when meetings begin/end\n    \"\"\"\n    if not intervals:\n        return 0\n    \n    starts = sorted([interval[0] for interval in intervals])\n    ends = sorted([interval[1] for interval in intervals])\n    \n    start_ptr = end_ptr = 0\n    rooms_needed = 0\n    max_rooms = 0\n    \n    while start_ptr < len(intervals):\n        if starts[start_ptr] < ends[end_ptr]:\n            rooms_needed += 1\n            max_rooms = max(max_rooms, rooms_needed)  # Take the maximum value.\n            start_ptr += 1\n        else:\n            rooms_needed -= 1\n            end_ptr += 1\n    \n    return max_rooms"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4]",
        "output": "[result]",
        "explanation": "Two pointers traverse from both ends."
      },
      {
        "input": "nums = [0, 1]",
        "output": "[result]",
        "explanation": "Edge case with minimum input."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Array is sorted (if applicable)"
    ],
    "commonMistakes": [
      "Forgetting to handle the case when array is empty",
      "Off-by-one errors in pointer movement",
      "Not considering duplicates"
    ],
    "interviewTip": "Clarify if array is sorted. Mention time: O(n), space: O(1).",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minMeetingRooms(intervals) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} intervals\n     * @return {any}\n     */\n    minMeetingRooms(intervals) {\n        const starts = intervals.map(([start]) => start).sort((a, b) => a - b);\n        const ends = intervals.map(([, end]) => end).sort((a, b) => a - b);\n        let rooms = 0;\n        let startIndex = 0;\n        let endIndex = 0;\n        let result = 0;\n\n        while (startIndex < intervals.length) {\n          if (starts[startIndex] < ends[endIndex]) {\n            rooms++;\n            result = Math.max(result, rooms);\n            startIndex++;\n          } else {\n            rooms--;\n            endIndex++;\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        int m = 0;\n        for (var e : intervals) {\n            m = Math.max(m, e[1]);\n        }\n        int[] d = new int[m + 1];\n        for (var e : intervals) {\n            ++d[e[0]];\n            --d[e[1]];\n        }\n        int ans = 0, s = 0;\n        for (int v : d) {\n            s += v;\n            ans = Math.max(ans, s);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        int m = 0;\n        for (const auto& e : intervals) {\n            m = max(m, e[1]);\n        }\n        vector<int> d(m + 1);\n        for (const auto& e : intervals) {\n            d[e[0]]++;\n            d[e[1]]--;\n        }\n        int ans = 0, s = 0;\n        for (int v : d) {\n            s += v;\n            ans = max(ans, s);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minMeetingRooms(intervals [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minMeetingRooms(intervals [][]int) (ans int) {\n\tm := 0\n\tfor _, e := range intervals {\n\t\tm = max(m, e[1])\n\t}\n\n\td := make([]int, m+1)\n\tfor _, e := range intervals {\n\t\td[e[0]]++\n\t\td[e[1]]--\n\t}\n\n\ts := 0\n\tfor _, v := range d {\n\t\ts += v\n\t\tans = max(ans, s)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_meeting_rooms(intervals: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_meeting_rooms(intervals: Vec<Vec<i32>>) -> i32 {\n        let mut m = 0;\n        for e in &intervals {\n            m = m.max(e[1]);\n        }\n\n        let mut d = vec![0; (m + 1) as usize];\n        for e in intervals {\n            d[e[0] as usize] += 1;\n            d[e[1] as usize] -= 1;\n        }\n\n        let mut ans = 0;\n        let mut s = 0;\n        for v in d {\n            s += v;\n            ans = ans.max(s);\n        }\n\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minMeetingRooms(self, intervals):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minMeetingRooms(intervals: number[][]): number  {\n    const m = Math.max(...intervals.map(([_, r]) => r));\n    const d: number[] = Array(m + 1).fill(0);\n    for (const [l, r] of intervals) {\n        d[l]++;\n        d[r]--;\n    }\n    let [ans, s] = [0, 0];\n    for (const v of d) {\n        s += v;\n        ans = Math.max(ans, s);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    minMeetingRooms(intervals: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
    "relatedProblems": [
      "rotate-array",
      "construct-binary-tree-from-inorder-and-postorder-traversal",
      "binary-tree-zigzag-level-order-traversal"
    ]
  },
  "minimum-interval-to-include-each-query": {
    "id": "minimum-interval-to-include-each-query",
    "slug": "minimum-interval-to-include-each-query",
    "title": "Minimum Interval to Include Each Query",
    "difficulty": "Hard",
    "category": "Intervals",
    "problemStatement": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.",
    "videoUrl": "",
    "pattern": "Sorting + Min Heap",
    "patternEmoji": "\ud83d\udcca\u26a1",
    "timeComplexity": "O(n log n + m log m)",
    "spaceComplexity": "O(n + m)",
    "oneliner": "Sort intervals and queries, use min heap to track valid intervals.",
    "intuition": [
      "Process queries in sorted order to reuse previous computations",
      "Use min heap to efficiently find the smallest valid interval"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        1,
        4
      ],
      [
        2,
        4
      ],
      [
        3,
        6
      ],
      [
        4,
        4
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Minimum Interval to Include Each Query",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1,4",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2,4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3,6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4,4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            1,
            4
          ],
          [
            2,
            4
          ],
          [
            3,
            6
          ],
          [
            4,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def minInterval(self, intervals, queries):\n        \"\"\"\n        Intuition:\n        - Process queries in sorted order to reuse previous computations\n        - Use min heap to efficiently find the smallest valid interval\n        \"\"\"\n        intervals.sort()\n        queries_sorted = sorted((q, i) for i, q in enumerate(queries))\n        result = [-1] * len(queries)\n        min_heap = []  # (size, end)\n        i = 0\n        \n        for query, original_index in queries_sorted:  # Iterate over elements.\n            # Add all intervals that start <= query\n            while i < len(intervals) and intervals[i][0] <= query:\n                left, right = intervals[i]\n                heapq.heappush(min_heap, (right - left + 1, right))\n                i += 1\n            \n            # Remove intervals that end < query\n            while min_heap and min_heap[0][1] < query:\n                heapq.heappop(min_heap)  # Remove and return last element.\n            \n            # Answer is top of heap if exists\n            if min_heap:\n                result[original_index] = min_heap[0][0]\n        \n        return result  # Return the final result.",
    "keyInsight": "Sort both intervals and queries to process in order and reuse computations.",
    "testCases": [
      {
        "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
        "output": "[3,3,1,4]"
      },
      {
        "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
        "output": "[2,-1,4,6]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Sorting + Min Heap: Sort intervals and queries, use min heap to track valid intervals.",
    "videoId": "5hQ5WWW5awQ",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def minInterval_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n + m log m)",
        "spaceComplexity": "O(n + m)",
        "intuition": [
          "Process queries in sorted order to reuse previous computations",
          "Use min heap to efficiently find the smallest valid interval"
        ],
        "code": "import heapq\n\ndef minInterval(intervals, queries):\n    \"\"\"\n    Intuition:\n    - Process queries in sorted order to reuse previous computations\n    - Use min heap to efficiently find the smallest valid interval\n    \"\"\"\n    intervals.sort()\n    queries_sorted = sorted((q, i) for i, q in enumerate(queries))\n    result = [-1] * len(queries)\n    min_heap = []  # (size, end)\n    i = 0\n    \n    for query, original_index in queries_sorted:  # Iterate over elements.\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= query:\n            left, right = intervals[i]\n            heapq.heappush(min_heap, (right - left + 1, right))\n            i += 1\n        \n        # Remove intervals that end < query\n        while min_heap and min_heap[0][1] < query:\n            heapq.heappop(min_heap)  # Remove and return last element.\n        \n        # Answer is top of heap if exists\n        if min_heap:\n            result[original_index] = min_heap[0][0]\n    \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(queries: number[], intervals: [number, number][]): number[] {\n        // Your code here\n        return;\n    }\n}",
        "code": "typescript\nclass Solution {\n    solve(queries: number[], intervals: [number, number][]): number[] {\n        return [];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] solve(int[][] intervals, int[] queries) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] solve(int[][] intervals, int[] queries) {\n        return new int[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> solve(...) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> solve(...) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minInterval(intervals [][]int, queries []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minInterval(intervals [][]int, queries []int) []int {\n\tn, m := len(intervals), len(queries)\n\tsort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\n\tqs := make([][2]int, m)\n\tans := make([]int, m)\n\tfor i := range qs {\n\t\tqs[i] = [2]int{queries[i], i}\n\t\tans[i] = -1\n\t}\n\tsort.Slice(qs, func(i, j int) bool { return qs[i][0] < qs[j][0] })\n\tpq := hp{}\n\ti := 0\n\tfor _, q := range qs {\n\t\tx, j := q[0], q[1]\n\t\tfor i < n && intervals[i][0] <= x {\n\t\t\ta, b := intervals[i][0], intervals[i][1]\n\t\t\theap.Push(&pq, pair{b - a + 1, b})\n\t\t\ti++\n\t\t}\n\t\tfor len(pq) > 0 && pq[0].r < x {\n\t\t\theap.Pop(&pq)\n\t\t}\n\t\tif len(pq) > 0 {\n\t\t\tans[j] = pq[0].v\n\t\t}\n\t}\n\treturn ans\n}\n\ntype pair struct{ v, r int }\ntype hp []pair\n\nfunc (h hp) Len() int           { return len(h) }\nfunc (h hp) Less(i, j int) bool { return h[i].v < h[j].v }\nfunc (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::BinaryHeap;\nimpl Solution {\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\n        vec![-1; queries.len()] // Placeholder\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.",
    "relatedProblems": [
      "find-median-from-data-stream",
      "largest-rectangle-in-histogram",
      "basic-calculator"
    ],
    "suggestedNextQuestion": {
      "slug": "binary-tree-maximum-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "pattern": "DFS + Global Max"
    }
  },
  "daily-temperatures": {
    "id": "daily-temperatures",
    "slug": "daily-temperatures",
    "title": "Daily Temperatures",
    "difficulty": "Medium",
    "category": "Stack",
    "problemStatement": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "videoUrl": "",
    "pattern": "Monotonic Stack",
    "patternEmoji": "\u2198\ufe0f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use a stack to track indices of decreasing temperatures.",
    "intuition": [
      "We only need to look at future days with higher temperatures",
      "A stack helps us efficiently find the next warmer day"
    ],
    "visualizationType": "array",
    "initialState": [
      73,
      74,
      75,
      71,
      69,
      72,
      76,
      73
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Temps: [73, 74, 75, 71, 69, 72, 76, 73]",
        "transientMessage": "Monotonic decreasing stack",
        "arrayState": [
          73,
          74,
          75,
          71,
          69,
          72,
          76,
          73
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Push index 0",
        "transientMessage": "Stack: [0]",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "74 > 73",
        "transientMessage": "result[0] = 1 - 0 = 1",
        "arrayState": [
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          },
          {
            "label": "prev",
            "index": 0
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "Push index 1",
        "transientMessage": "Stack: [1]",
        "arrayState": [
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "75 > 74",
        "transientMessage": "result[1] = 2 - 1 = 1",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          },
          {
            "label": "prev",
            "index": 1
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Push index 2",
        "transientMessage": "Stack: [2]",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Push index 3",
        "transientMessage": "Stack: [2, 3]",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Push index 4",
        "transientMessage": "Stack: [2, 3, 4]",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "72 > 69",
        "transientMessage": "result[4] = 5 - 4 = 1",
        "arrayState": [
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          },
          {
            "label": "prev",
            "index": 4
          }
        ],
        "indices": [
          4,
          5
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "72 > 71",
        "transientMessage": "result[3] = 5 - 3 = 2",
        "arrayState": [
          1,
          1,
          0,
          2,
          1,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          },
          {
            "label": "prev",
            "index": 3
          }
        ],
        "indices": [
          3,
          5
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Push index 5",
        "transientMessage": "Stack: [2, 5]",
        "arrayState": [
          1,
          1,
          0,
          2,
          1,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "76 > 72",
        "transientMessage": "result[5] = 6 - 5 = 1",
        "arrayState": [
          1,
          1,
          0,
          2,
          1,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          },
          {
            "label": "prev",
            "index": 5
          }
        ],
        "indices": [
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "76 > 75",
        "transientMessage": "result[2] = 6 - 2 = 4",
        "arrayState": [
          1,
          1,
          4,
          2,
          1,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          },
          {
            "label": "prev",
            "index": 2
          }
        ],
        "indices": [
          2,
          6
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Push index 6",
        "transientMessage": "Stack: [6]",
        "arrayState": [
          1,
          1,
          4,
          2,
          1,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "accent"
      },
      {
        "step": 15,
        "visual": "Push index 7",
        "transientMessage": "Stack: [6, 7]",
        "arrayState": [
          1,
          1,
          4,
          2,
          1,
          1,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 7
          }
        ],
        "indices": [
          7
        ],
        "color": "accent"
      },
      {
        "step": 16,
        "visual": "Result: [1, 1, 4, 2, 1, 1, 0, 0]",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          1,
          4,
          2,
          1,
          1,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        \"\"\"\n        Intuition:\n        - We only need to look at future days with higher temperatures\n        - A stack helps us efficiently find the next warmer day\n        \"\"\"\n        answer = [0] * len(temperatures)\n        stack = []  # Stack of indices\n\n        for i, temp in enumerate(temperatures):  # Iterate over elements.\n            # While stack not empty and current temp > stack top temp\n            while stack and temp > temperatures[stack[-1]]:\n                prev_index = stack.pop()  # Remove and return last element.\n                answer[prev_index] = i - prev_index\n            stack.append(i)  # Add to end.\n\n        return answer",
    "keyInsight": "We process temperatures left to right, using a stack to remember previous days waiting for a warmer day.",
    "testCases": [
      {
        "input": "temperatures = [73,74,75,71,69,72,76,73]",
        "output": "[1,1,4,2,1,1,0,0]"
      },
      {
        "input": "temperatures = [30,40,50,60]",
        "output": "[1,1,1,0]"
      },
      {
        "input": "temperatures = [30,60,90]",
        "output": "[1,1,0]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Monotonic Stack: Use a stack to track indices of decreasing temperatures.",
    "videoId": "cTBiBSnjO3c",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def dailyTemperatures_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "We only need to look at future days with higher temperatures",
          "A stack helps us efficiently find the next warmer day"
        ],
        "code": "def dailyTemperatures(temperatures):\n    \"\"\"\n    Intuition:\n    - We only need to look at future days with higher temperatures\n    - A stack helps us efficiently find the next warmer day\n    \"\"\"\n    answer = [0] * len(temperatures)\n    stack = []  # Stack of indices\n    \n    for i, temp in enumerate(temperatures):  # Iterate over elements.\n        # While stack not empty and current temp > stack top temp\n        while stack and temp > temperatures[stack[-1]]:\n            prev_index = stack.pop()  # Remove and return last element.\n            answer[prev_index] = i - prev_index\n        stack.append(i)  # Add to end.\n    \n    return answer"
      }
    ],
    "examples": [
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "Valid parentheses matching."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched brackets."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of brackets: ()[]{}"
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    dailyTemperatures(temperatures) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} temperatures\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} temperatures\n     * @return {any}\n     */\n    dailyTemperatures(temperatures) {\n        const n = temperatures.length;\n        const ans = Array(n).fill(0);\n        const stk = [];\n        for (let i = n - 1; ~i; --i) {\n            while (stk.length && temperatures[stk.at(-1)] <= temperatures[i]) {\n                stk.pop();\n            }\n            if (stk.length) {\n                ans[i] = stk.at(-1) - i;\n            }\n            stk.push(i);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        Deque<Integer> stk = new ArrayDeque<>();\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stk.isEmpty() && temperatures[stk.peek()] <= temperatures[i]) {\n                stk.pop();\n            }\n            if (!stk.isEmpty()) {\n                ans[i] = stk.peek() - i;\n            }\n            stk.push(i);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n = temperatures.size();\n        stack<int> stk;\n        vector<int> ans(n);\n        for (int i = n - 1; ~i; --i) {\n            while (!stk.empty() && temperatures[stk.top()] <= temperatures[i]) {\n                stk.pop();\n            }\n            if (!stk.empty()) {\n                ans[i] = stk.top() - i;\n            }\n            stk.push(i);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) dailyTemperatures(temperatures []int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) dailyTemperatures(temperatures []int) []int {\n\tn := len(temperatures)\n\tans := make([]int, n)\n\tstk := []int{}\n\tfor i := n - 1; i >= 0; i-- {\n\t\tfor len(stk) > 0 && temperatures[stk[len(stk)-1]] <= temperatures[i] {\n\t\t\tstk = stk[:len(stk)-1]\n\t\t}\n\t\tif len(stk) > 0 {\n\t\t\tans[i] = stk[len(stk)-1] - i\n\t\t}\n\t\tstk = append(stk, i)\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn daily_temperatures(temperatures: Vec<i32>) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn daily_temperatures(temperatures: Vec<i32>) -> Vec<i32> {\n        let n = temperatures.len();\n        let mut stk: Vec<usize> = Vec::new();\n        let mut ans = vec![0; n];\n\n        for i in (0..n).rev() {\n            while let Some(&top) = stk.last() {\n                if temperatures[top] <= temperatures[i] {\n                    stk.pop();\n                } else {\n                    break;\n                }\n            }\n            if let Some(&top) = stk.last() {\n                ans[i] = (top - i) as i32;\n            }\n            stk.push(i);\n        }\n\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    dailyTemperatures(temperatures: number[]): number[]  {\n    const n = temperatures.length;\n    const ans: number[] = Array(n).fill(0);\n    const stk: number[] = [];\n    for (let i = n - 1; ~i; --i) {\n        while (stk.length && temperatures[stk.at(-1)!] <= temperatures[i]) {\n            stk.pop();\n        }\n        if (stk.length) {\n            ans[i] = stk.at(-1)! - i;\n        }\n        stk.push(i);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    dailyTemperatures(temperatures: number[]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.",
    "relatedProblems": [
      "largest-rectangle-in-histogram"
    ],
    "suggestedNextQuestion": {
      "slug": "largest-rectangle-in-histogram",
      "title": "Largest Rectangle in Histogram",
      "difficulty": "Hard",
      "pattern": "Monotonic Stack"
    }
  },
  "car-fleet": {
    "id": "car-fleet",
    "slug": "car-fleet",
    "title": "Car Fleet",
    "difficulty": "Medium",
    "category": "Stack",
    "problemStatement": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\nYou are given two integer arrays position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\nReturn the number of car fleets that will arrive at the destination.",
    "videoUrl": "",
    "pattern": "Stack",
    "patternEmoji": "\ud83e\udd5e",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Sort cars by position and use stack to count fleets based on arrival times.",
    "intuition": [
      "Cars closer to target with faster speeds may form fleets",
      "If a car arrives before or at same time as car ahead, they form a fleet"
    ],
    "visualizationType": "array",
    "initialState": [
      10,
      8,
      0,
      5,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Car Fleet",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 10",
        "transientMessage": "Iteration 1",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 8",
        "transientMessage": "Iteration 2",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 0",
        "transientMessage": "Iteration 3",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 5",
        "transientMessage": "Iteration 4",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 3",
        "transientMessage": "Iteration 5",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          10,
          8,
          0,
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def carFleet(self, target, position, speed):\n        \"\"\"\n        Intuition:\n        - Cars closer to target with faster speeds may form fleets\n        - If a car arrives before or at same time as car ahead, they form a fleet\n        \"\"\"\n        cars = sorted(zip(position, speed), reverse=True)\n        times = [(target - pos) / spd for pos, spd in cars]\n        fleets = 0\n        slowest_time = 0\n\n        for time in times:  # Iterate over elements.\n            if time > slowest_time:\n                fleets += 1\n                slowest_time = time\n\n        return fleets",
    "keyInsight": "Sort by position and compare arrival times. If a car arrives after the one ahead, it forms a new fleet.",
    "testCases": [
      {
        "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
        "output": "3"
      },
      {
        "input": "target = 10, position = [3], speed = [3]",
        "output": "1"
      },
      {
        "input": "target = 100, position = [0,2,4], speed = [4,2,1]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Initialize empty stack",
      "Iterate through elements",
      "Push/pop based on problem logic",
      "Maintain monotonic property if needed",
      "Process remaining stack elements if needed"
    ],
    "hints": [
      "\ud83e\udde0 What order should elements be processed?",
      "\ud83d\udca1 Consider monotonic stack if comparing neighbors",
      "\ud83d\udd0d When do you push vs pop?"
    ],
    "approach": "Stack: Sort cars by position and use stack to count fleets based on arrival times.",
    "videoId": "Pr6T-3yB9RM",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def carFleet(self, target, position, speed):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def carFleet_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Cars closer to target with faster speeds may form fleets",
          "If a car arrives before or at same time as car ahead, they form a fleet"
        ],
        "code": "def carFleet(target, position, speed):\n    \"\"\"\n    Intuition:\n    - Cars closer to target with faster speeds may form fleets\n    - If a car arrives before or at same time as car ahead, they form a fleet\n    \"\"\"\n    cars = sorted(zip(position, speed), reverse=True)\n    times = [(target - pos) / spd for pos, spd in cars]\n    fleets = 0\n    slowest_time = 0\n    \n    for time in times:  # Iterate over elements.\n        if time > slowest_time:\n            fleets += 1\n            slowest_time = time\n    \n    return fleets"
      }
    ],
    "examples": [
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "Valid parentheses matching."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched brackets."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of brackets: ()[]{}"
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    carFleet(target, position, speed) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} target, position, speed\n     * @return {any}\n     */\n    carFleet(target, position, speed) {\n        const cars = position.map((pos, i) => ({\n          position: pos,\n          timeToTarget: (target - pos) / speed[i]\n        }));\n        cars.sort((a, b) => b.position - a.position);\n\n        let slowestTime = 0;\n        let result = 0;\n        for (const car of cars) {\n          if (car.timeToTarget > slowestTime) {\n            result++;\n            slowestTime = car.timeToTarget;\n          }\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        int n = position.length;\n        Integer[] idx = new Integer[n];\n        Arrays.setAll(idx, i -> i);\n        Arrays.sort(idx, (i, j) -> position[j] - position[i]);\n        int ans = 0;\n        double pre = 0;\n        for (int i : idx) {\n            double t = 1.0 * (target - position[i]) / speed[i];\n            if (t > pre) {\n                ++ans;\n                pre = t;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        int n = position.size();\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int i, int j) {\n            return position[i] > position[j];\n        });\n        int ans = 0;\n        double pre = 0;\n        for (int i : idx) {\n            double t = 1.0 * (target - position[i]) / speed[i];\n            if (t > pre) {\n                ++ans;\n                pre = t;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) carFleet(target int, position []int, speed []int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) carFleet(target int, position []int, speed []int) (ans int) {\n\tn := len(position)\n\tidx := make([]int, n)\n\tfor i := range idx {\n\t\tidx[i] = i\n\t}\n\tsort.Slice(idx, func(i, j int) bool { return position[idx[j]] < position[idx[i]] })\n\tvar pre float64\n\tfor _, i := range idx {\n\t\tt := float64(target-position[i]) / float64(speed[i])\n\t\tif t > pre {\n\t\t\tans++\n\t\t\tpre = t\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn car_fleet(target: i32, position: i32, speed: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::collections::BTreeMap;\n\nimpl Solution {\n    fn car_fleet(target: i32, position: Vec<i32>, speed: Vec<i32>) -> i32 {\n        let mut btm: BTreeMap<i32, f64> = BTreeMap::new();\n        let n = position.len();\n        for i in 0..n {\n            btm.insert(\n                target - position[i],\n                (target - position[i]) as f64 / speed[i] as f64,\n            );\n        }\n        let mut res = 0;\n        let mut cur = 0.0;\n        for (_, t) in btm {\n            if t > cur {\n                res += 1;\n                cur = t;\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let target = 12;\n    let position = vec![10, 8, 0, 5, 3];\n    let speed = vec![2, 4, 1, 1, 3];\n    let res = 3;\n    assert_eq!(Solution::car_fleet(target, position, speed), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def carFleet(self, target, position, speed):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    carFleet(target: number, position: number[], speed: number[]): number  {\n    const n = position.length;\n    const idx = Array(n)\n        .fill(0)\n        .map((_, i) => i)\n        .sort((i, j) => position[j] - position[i]);\n    let ans = 0;\n    let pre = 0;\n    for (const i of idx) {\n        const t = (target - position[i]) / speed[i];\n        if (t > pre) {\n            ++ans;\n            pre = t;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    carFleet(target: number, position: number[], speed: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\nYou are given two integer arrays position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\nReturn the number of car fleets that will arrive at the destination.",
    "relatedProblems": [
      "evaluate-reverse-polish-notation",
      "valid-parentheses",
      "simplify-path"
    ],
    "suggestedNextQuestion": {
      "slug": "evaluate-reverse-polish-notation",
      "title": "Evaluate Reverse Polish Notation",
      "difficulty": "Medium",
      "pattern": "Stack"
    }
  },
  "largest-rectangle-in-histogram": {
    "id": "largest-rectangle-in-histogram",
    "slug": "largest-rectangle-in-histogram",
    "title": "Largest Rectangle in Histogram",
    "difficulty": "Hard",
    "category": "Stack",
    "problemStatement": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "videoUrl": "",
    "pattern": "Monotonic Stack",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use a stack to track increasing bar heights and calculate areas when heights decrease.",
    "intuition": [
      "For each bar, the largest rectangle is limited by the nearest smaller bars on left and right",
      "A stack helps efficiently find these boundaries by maintaining increasing heights"
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      1,
      5,
      6,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Largest Rectangle in Histogram",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 5",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 6",
        "transientMessage": "Iteration 4",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 3",
        "transientMessage": "Iteration 6",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          1,
          5,
          6,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        Intuition:\n        - For each bar, the largest rectangle is limited by the nearest smaller bars on left and right\n        - A stack helps efficiently find these boundaries by maintaining increasing heights\n        \"\"\"\n        stack = []  # Initialize stack for tracking.\n        max_area = 0\n        heights.append(0)  # Add sentinel to process remaining bars\n\n        for i in range(len(heights)):  # Iterate through the range.\n            while stack and heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]  # Remove and return last element.\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)  # Take the maximum value.\n            stack.append(i)  # Add to end.\n\n        heights.pop()  # Remove sentinel\n        return max_area",
    "keyInsight": "When a bar with smaller height is encountered, we can calculate the maximum area for all taller bars in the stack.",
    "testCases": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10"
      },
      {
        "input": "heights = [2,4]",
        "output": "4"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Monotonic Stack: Use a stack to track increasing bar heights and calculate areas when heights decrease.",
    "videoId": "zx5Sw9130L0",
    "mentalModel": "Like a stack of pancakes. Last one cooked is the first one eaten (LIFO).",
    "initialCode": "class Solution:\n    def largestRectangleArea(self, heights):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to simulate stack operations.",
          "For each element, look back through all previous elements."
        ],
        "code": "def largestRectangleArea_brute(nums):\n    n = len(nums)\n    result = [-1] * n\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if condition(nums[j], nums[i]):\n                result[i] = nums[j]\n                break\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "For each bar, the largest rectangle is limited by the nearest smaller bars on left and right",
          "A stack helps efficiently find these boundaries by maintaining increasing heights"
        ],
        "code": "def largestRectangleArea(heights):\n    \"\"\"\n    Intuition:\n    - For each bar, the largest rectangle is limited by the nearest smaller bars on left and right\n    - A stack helps efficiently find these boundaries by maintaining increasing heights\n    \"\"\"\n    stack = []  # Initialize stack for tracking.\n    max_area = 0\n    heights.append(0)  # Add sentinel to process remaining bars\n    \n    for i in range(len(heights)):  # Iterate through the range.\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]  # Remove and return last element.\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)  # Take the maximum value.\n        stack.append(i)  # Add to end.\n    \n    heights.pop()  # Remove sentinel\n    return max_area"
      }
    ],
    "examples": [
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": "Valid parentheses matching."
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": "Mismatched brackets."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of brackets: ()[]{}"
    ],
    "commonMistakes": [
      "Popping from empty stack",
      "Not clearing stack between operations",
      "Incorrect order of push/pop"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    largestRectangleArea(heights) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} heights\n     * @return {any}\n     */\n    largestRectangleArea(heights) {\n        const entries = [...heights, 0];\n        const stack = [];\n        let area = 0;\n\n        for (let i = 0; i < entries.length; i++) {\n          let updatedHeight = i;\n\n          while (stack.length && stack[stack.length - 1][1] > entries[i]) {\n            const [x, y] = stack.pop();\n            area = Math.max(area, (i - x) * y);\n            updatedHeight = x;\n          }\n\n          stack.push([updatedHeight, entries[i]]);\n      }\n\n    return area;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int res = 0, n = heights.length;\n        Deque<Integer> stk = new ArrayDeque<>();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        Arrays.fill(right, n);\n        for (int i = 0; i < n; ++i) {\n            while (!stk.isEmpty() && heights[stk.peek()] >= heights[i]) {\n                right[stk.pop()] = i;\n            }\n            left[i] = stk.isEmpty() ? -1 : stk.peek();\n            stk.push(i);\n        }\n        for (int i = 0; i < n; ++i) {\n            res = Math.max(res, heights[i] * (right[i] - left[i] - 1));\n        }\n        return res;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int largestRectangleArea(vector<int>& heights) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int res = 0, n = heights.size();\n        stack<int> stk;\n        vector<int> left(n, -1);\n        vector<int> right(n, n);\n        for (int i = 0; i < n; ++i) {\n            while (!stk.empty() && heights[stk.top()] >= heights[i]) {\n                right[stk.top()] = i;\n                stk.pop();\n            }\n            if (!stk.empty()) left[i] = stk.top();\n            stk.push(i);\n        }\n        for (int i = 0; i < n; ++i)\n            res = max(res, heights[i] * (right[i] - left[i] - 1));\n        return res;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) largestRectangleArea(heights []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) largestRectangleArea(heights []int) int {\n\tres, n := 0, len(heights)\n\tvar stk []int\n\tleft, right := make([]int, n), make([]int, n)\n\tfor i := range right {\n\t\tright[i] = n\n\t}\n\tfor i, h := range heights {\n\t\tfor len(stk) > 0 && heights[stk[len(stk)-1]] >= h {\n\t\t\tright[stk[len(stk)-1]] = i\n\t\t\tstk = stk[:len(stk)-1]\n\t\t}\n\t\tif len(stk) > 0 {\n\t\t\tleft[i] = stk[len(stk)-1]\n\t\t} else {\n\t\t\tleft[i] = -1\n\t\t}\n\t\tstk = append(stk, i)\n\t}\n\tfor i, h := range heights {\n\t\tres = max(res, h*(right[i]-left[i]-1))\n\t}\n\treturn res\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn largest_rectangle_area(heights: Vec<i32>) -> i32 {\n        let n = heights.len();\n        let mut left = vec![-1; n];\n        let mut right = vec![-1; n];\n        let mut stack: Vec<(usize, i32)> = Vec::new();\n        let mut ret = -1;\n\n        // Build left vector\n        for (i, h) in heights.iter().enumerate() {\n            while !stack.is_empty() && stack.last().unwrap().1 >= *h {\n                stack.pop();\n            }\n            if stack.is_empty() {\n                left[i] = -1;\n            } else {\n                left[i] = stack.last().unwrap().0 as i32;\n            }\n            stack.push((i, *h));\n        }\n\n        stack.clear();\n\n        // Build right vector\n        for (i, h) in heights.iter().enumerate().rev() {\n            while !stack.is_empty() && stack.last().unwrap().1 >= *h {\n                stack.pop();\n            }\n            if stack.is_empty() {\n                right[i] = n as i32;\n            } else {\n                right[i] = stack.last().unwrap().0 as i32;\n            }\n            stack.push((i, *h));\n        }\n\n        // Calculate the max area\n        for (i, h) in heights.iter().enumerate() {\n            ret = std::cmp::max(ret, (right[i] - left[i] - 1) * *h);\n        }\n\n        ret\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def largestRectangleArea(self, heights):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    largestRectangleArea(heights: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    largestRectangleArea(heights: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "relatedProblems": [
      "daily-temperatures"
    ],
    "suggestedNextQuestion": {
      "slug": "daily-temperatures",
      "title": "Daily Temperatures",
      "difficulty": "Medium",
      "pattern": "Monotonic Stack"
    }
  },
  "reorder-list": {
    "id": "reorder-list",
    "slug": "reorder-list",
    "title": "Reorder List",
    "difficulty": "Medium",
    "category": "Linked List",
    "problemStatement": "You are given the head of a singly linked-list. The list can be represented as:\nReorder the list to be on the following form:\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "videoUrl": "",
    "pattern": "Linked List Reversal + Merge",
    "patternEmoji": "\ud83d\udd04\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Split list in half, reverse second half, then merge alternately.",
    "intuition": [
      "Break the list into two halves at the middle point",
      "Reverse the second half and merge both halves alternately"
    ],
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      2,
      3,
      4,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reorder List",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 5",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    def reorderList(self, head):\n        \"\"\"\n        Intuition:\n        - Break the list into two halves at the middle point\n        - Reverse the second half and merge both halves alternately\n        \"\"\"\n        if not head or not head.next:\n            return head\n        \n        # Find the middle\n        slow = fast = head  # Initialize cycle detection pointers.\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse second half\n        prev, curr = None, slow.next\n        slow.next = None  # Break the list\n        while curr:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        \n        # Merge two halves\n        first, second = head, prev\n        while second:\n            temp1, temp2 = first.next, second.next\n            first.next = second\n            second.next = temp1\n            first, second = temp1, temp2\n        \n        return head",
    "keyInsight": "Use slow/fast pointers to find mid, then reverse and merge.",
    "testCases": [
      {
        "input": "head = [1,2,3,4]",
        "output": "[1,4,2,3]"
      },
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[1,5,2,4,3]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Linked List Reversal + Merge: Split list in half, reverse second half, then merge alternately.",
    "videoId": "S5bfdUTrKLM",
    "suggestedNextQuestion": {
      "slug": "reverse-linked-list-ii",
      "title": "Reverse Linked List II",
      "difficulty": "Medium",
      "pattern": "Linked List"
    },
    "mentalModel": "Like a treasure hunt where each clue (node) holds the location of the next clue.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Use extra array to store all values.",
          "Process in array, then rebuild list."
        ],
        "code": "def __init___brute(head):\n    # Convert to array\n    vals = []\n    curr = head\n    while curr:\n        vals.append(curr.val)\n        curr = curr.next\n    # Process array\n    # ... \n    # Rebuild list\n    dummy = ListNode()\n    curr = dummy\n    for v in vals:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Break the list into two halves at the middle point",
          "Reverse the second half and merge both halves alternately"
        ],
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reorderList(head):\n    \"\"\"\n    Intuition:\n    - Break the list into two halves at the middle point\n    - Reverse the second half and merge both halves alternately\n    \"\"\"\n    if not head or not head.next:\n        return head\n    \n    # Find the middle\n    slow = fast = head  # Initialize cycle detection pointers.\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Break the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n    \n    return head"
      }
    ],
    "examples": [
      {
        "input": "head = [1, 2, 3, 4, 5]",
        "output": "[result]",
        "explanation": "Process linked list nodes."
      },
      {
        "input": "head = [1]",
        "output": "[1]",
        "explanation": "Single node edge case."
      }
    ],
    "constraints": [
      "Number of nodes: [0, 10^4]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "commonMistakes": [
      "Losing reference to head",
      "Not handling single node case",
      "Creating cycles accidentally"
    ],
    "interviewTip": "Use dummy node to simplify edge cases. Mention in-place modification.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(head: ListNode | null) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(head: ListNode | null) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void reorderList(ListNode head) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public void reorderList(ListNode head) {\n        \n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void __init__() {\n        // Your code here\n    }\n}",
        "code": "class Solution {\npublic:\n    void __init__() {\n        // Constructor implementation goes here\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reorderList(head *ListNode) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc (s *Solution) reorderList(head *ListNode) {\n\tfast, slow := head, head\n\tfor fast.Next != nil && fast.Next.Next != nil {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\n\tcur := slow.Next\n\tslow.Next = nil\n\n\tvar pre *ListNode\n\tfor cur != nil {\n\t\tt := cur.Next\n\t\tcur.Next = pre\n\t\tpre, cur = cur, t\n\t}\n\tcur = head\n\n\tfor pre != nil {\n\t\tt := pre.Next\n\t\tpre.Next = cur.Next\n\t\tcur.Next = pre\n\t\tcur, pre = pre.Next, t\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for singly-linked list.\n// #[derive(PartialEq, Eq, Clone, Debug)]\n// pub struct ListNode {\n//   pub val: i32,\n//   pub next: Option<Box<ListNode>>\n// }\n//\n// impl ListNode {\n//   #[inline]\n//   fn new(val: i32) -> Self {\n//     ListNode {\n//       next: None,\n//       val\n//     }\n//   }\n// }\nuse std::collections::VecDeque;\nimpl Solution {\n    pub fn reorder_list(head: &mut Option<Box<ListNode>>) {\n        let mut tail = &mut head.as_mut().unwrap().next;\n        let mut head = tail.take();\n        let mut deque = VecDeque::new();\n        while head.is_some() {\n            let next = head.as_mut().unwrap().next.take();\n            deque.push_back(head);\n            head = next;\n        }\n        let mut flag = false;\n        while !deque.is_empty() {\n            *tail = if flag {\n                deque.pop_front().unwrap()\n            } else {\n                deque.pop_back().unwrap()\n            };\n            tail = &mut tail.as_mut().unwrap().next;\n            flag = !flag;\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(head: ListNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(head: ListNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given the head of a singly linked-list. The list can be represented as:\nReorder the list to be on the following form:\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-with-cooldown",
      "remove-duplicates-from-sorted-list-ii",
      "palindromic-substrings"
    ]
  },
  "find-the-duplicate-number": {
    "id": "find-the-duplicate-number",
    "slug": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "difficulty": "Medium",
    "category": "Linked List",
    "problemStatement": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and using only constant extra space.",
    "videoUrl": "",
    "pattern": "Floyd's Cycle Detection",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Treat array values as pointers and detect cycle using Floyd's algorithm.",
    "intuition": [
      "Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices",
      "Duplicate number creates a cycle - use slow/fast pointers to detect it"
    ],
    "visualizationType": "linkedlist",
    "initialState": [
      1,
      3,
      4,
      2,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Find the Duplicate Number",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 4",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          3,
          4,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Intuition:\n        - Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices\n        - Duplicate number creates a cycle - use slow/fast pointers to detect it\n        \"\"\"\n        # Phase 1: Detect cycle using Floyd's algorithm\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]        # Move one step\n            fast = nums[nums[fast]]  # Move two steps\n            if slow == fast:\n                break\n\n        # Phase 2: Find cycle entrance (duplicate number)\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow  # Return the result node.",
    "keyInsight": "Values in array can be treated as pointers to indices, creating a linked list with a cycle due to the duplicate.",
    "testCases": [
      {
        "input": "nums = [1,3,4,2,2]",
        "output": "2"
      },
      {
        "input": "nums = [3,1,3,4,2]",
        "output": "3"
      },
      {
        "input": "nums = [3,3,3,3,3]",
        "output": "3"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Floyd's Cycle Detection: Treat array values as pointers and detect cycle using Floyd's algorithm.",
    "videoId": "wjYnzkAhcNk",
    "suggestedNextQuestion": {
      "slug": "longest-mountain-in-array",
      "title": "Longest Mountain in Array",
      "difficulty": "Medium",
      "pattern": "Two Pointers"
    },
    "mentalModel": "Like a race track. If you keep running, you will eventually pass the start line again.",
    "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findDuplicate(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findDuplicate(nums):\n    # Brute force: nested loops\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] == nums[j]:\n                return nums[i]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices",
          "Duplicate number creates a cycle - use slow/fast pointers to detect it"
        ],
        "code": "def findDuplicate(nums):\n    \"\"\"\n    Intuition:\n    - Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices\n    - Duplicate number creates a cycle - use slow/fast pointers to detect it\n    \"\"\"\n    # Phase 1: Detect cycle using Floyd's algorithm\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]        # Move one step\n        fast = nums[nums[fast]]  # Move two steps\n        if slow == fast:\n            break\n    \n    # Phase 2: Find cycle entrance (duplicate number)\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow  # Return the result node."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(nums: number[]) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(nums: number[]) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findDuplicate(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findDuplicate(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findDuplicate(nums []int) int {\n\treturn sort.Search(len(nums), func(x int) bool {\n\t\tcnt := 0\n\t\tfor _, v := range nums {\n\t\t\tif v <= x {\n\t\t\t\tcnt++\n\t\t\t}\n\t\t}\n\t\treturn cnt > x\n\t})\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn find_duplicate(nums: Vec<i32>) -> i32 {\n        let mut left = 0;\n        let mut right = nums.len() - 1;\n\n        while left < right {\n            let mid = (left + right) >> 1;\n            let cnt = nums.iter().filter(|x| **x <= (mid as i32)).count();\n            if cnt > mid {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        left as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def findDuplicate(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n\n    findDuplicate(nums: number[]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and using only constant extra space.",
    "relatedProblems": [
      "binary-search-tree-iterator",
      "flatten-binary-tree-to-linked-list",
      "car-fleet"
    ]
  },
  "balanced-binary-tree": {
    "id": "balanced-binary-tree",
    "slug": "balanced-binary-tree",
    "title": "Balanced Binary Tree",
    "difficulty": "Easy",
    "category": "Binary Tree General",
    "problemStatement": "Given a binary tree, determine if it is height-balanced.",
    "videoUrl": "",
    "pattern": "Tree Recursion",
    "patternEmoji": "\ud83c\udf32",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Check balance condition recursively for each node.",
    "intuition": [
      "A tree is balanced if left and right subtrees are balanced",
      "And their heights differ by at most 1"
    ],
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Balanced Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Visit root node",
        "transientMessage": "Start from root (index 0)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Traverse left subtree",
        "transientMessage": "Process left child (index 1)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Traverse right subtree",
        "transientMessage": "Process right child (index 2)",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Continue recursively",
        "transientMessage": "Process remaining nodes",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3,
          4,
          5,
          6
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def isBalanced(self, root):\n        \"\"\"\n        Intuition:\n        - A tree is balanced if left and right subtrees are balanced\n        - And their heights differ by at most 1\n        \"\"\"\n        def check_height(self, node):\n            if not node:\n                return 0\n            \n            left_height = check_height(node.left)\n            if left_height == -1:\n                return -1\n                \n            right_height = check_height(node.right)\n            if right_height == -1:\n                return -1\n                \n            if abs(left_height - right_height) > 1:\n                return -1\n                \n            return max(left_height, right_height) + 1  # Take the maximum value.\n        \n        return check_height(root) != -1",
    "keyInsight": "Use -1 as sentinel value to propagate imbalance up the tree.",
    "testCases": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "true"
      },
      {
        "input": "root = [1,2,2,3,3,null,null,4,4]",
        "output": "false"
      },
      {
        "input": "root = []",
        "output": "true"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Tree Recursion: Check balance condition recursively for each node.",
    "videoId": "QfJsau0ItOY",
    "suggestedNextQuestion": {
      "slug": "count-complete-tree-nodes",
      "title": "Count Complete Tree Nodes",
      "difficulty": "Easy",
      "pattern": "Trees"
    },
    "mentalModel": "Like Russian dolls. Open one to find a smaller version inside, until you hit the center.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "A tree is balanced if left and right subtrees are balanced",
          "And their heights differ by at most 1"
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isBalanced(root):\n    \"\"\"\n    Intuition:\n    - A tree is balanced if left and right subtrees are balanced\n    - And their heights differ by at most 1\n    \"\"\"\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n            \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n            \n        if abs(left_height - right_height) > 1:\n            return -1\n            \n        return max(left_height, right_height) + 1  # Take the maximum value.\n    \n    return check_height(root) != -1"
      }
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Traverse tree structure."
      },
      {
        "input": "root = []",
        "output": "null",
        "explanation": "Empty tree edge case."
      }
    ],
    "constraints": [
      "Number of nodes: [0, 10^4]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__() {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isBalanced(root *TreeNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) isBalanced(root *TreeNode) bool {\n\tvar height func(*TreeNode) int\n\theight = func(root *TreeNode) int {\n\t\tif root == nil {\n\t\t\treturn 0\n\t\t}\n\t\tl, r := height(root.Left), height(root.Right)\n\t\tif l == -1 || r == -1 || abs(l-r) > 1 {\n\t\t\treturn -1\n\t\t}\n\t\tif l > r {\n\t\t\treturn 1 + l\n\t\t}\n\t\treturn 1 + r\n\t}\n\treturn height(root) >= 0\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn is_balanced(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        Self::dfs(&root) > -1\n    }\n\n    fn dfs(root: &Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        if root.is_none() {\n            return 0;\n        }\n        let node = root.as_ref().unwrap().borrow();\n        let left = Self::dfs(&node.left);\n        let right = Self::dfs(&node.right);\n        if left == -1 || right == -1 || (left - right).abs() > 1 {\n            return -1;\n        }\n        1 + left.max(right)\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given a binary tree, determine if it is height-balanced.",
    "relatedProblems": [
      "longest-common-prefix",
      "best-time-to-buy-and-sell-stock",
      "minimum-time-visiting-all-points"
    ]
  },
  "subtree-of-another-tree": {
    "id": "subtree-of-another-tree",
    "slug": "subtree-of-another-tree",
    "title": "Subtree of Another Tree",
    "difficulty": "Easy",
    "category": "Binary Tree General",
    "problemStatement": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
    "videoUrl": "",
    "pattern": "Tree Traversal + Subtree Matching",
    "patternEmoji": "\ud83c\udf32\ud83d\udd0d",
    "timeComplexity": "O(m\u00d7n)",
    "spaceComplexity": "O(m+n)",
    "oneliner": "Traverse main tree and check if any node matches the subRoot tree structure.",
    "intuition": [
      "We need to check if subRoot appears as a subtree in root.",
      "For each node in root, we can recursively check if the subtree matches subRoot."
    ],
    "visualizationType": "tree",
    "initialState": [
      3,
      4,
      5,
      1,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Compare root(3) with subRoot(4)",
        "transientMessage": "3 != 4. Check subtrees.",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "warning"
      },
      {
        "step": 2,
        "visual": "Check Left: node 4 matches subRoot 4",
        "transientMessage": "Roots match. Check children...",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "sub",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "4->1 matches 4->1",
        "transientMessage": "Left child matches",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "4->2 matches 4->2",
        "transientMessage": "Right child matches",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "R",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "All nodes match!",
        "transientMessage": "Subtree found! \u2705",
        "arrayState": [
          3,
          4,
          5,
          1,
          2
        ],
        "pointers": [
          {
            "label": "Found",
            "index": 1
          }
        ],
        "indices": [
          1,
          3,
          4
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def isSubtree(self, root, subRoot):\n        \"\"\"\n        Intuition:\n        - We need to check if subRoot appears as a subtree in root.\n        - For each node in root, we can recursively check if the subtree matches subRoot.\n        \"\"\"\n        if not root:  # Base case: Check if tree is empty.\n            return False  # Condition not met.\n        if isSameTree(root, subRoot):\n            return True  # Condition satisfied.\n        return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n    \n    def isSameTree(self, p, q):\n        if not p and not q:\n            return True  # Condition satisfied.\n        if not p or not q or p.val != q.val:\n            return False  # Condition not met.\n        return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
    "keyInsight": "For each node in the main tree, check if the subtree rooted at that node matches the target subtree.",
    "testCases": [
      {
        "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
        "output": "true"
      },
      {
        "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
        "output": "false"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Tree Traversal + Subtree Matching: Traverse main tree and check if any node matches the subRoot tree structure.",
    "videoId": "E36O5SWp-LE",
    "suggestedNextQuestion": {
      "slug": "balance-a-binary-search-tree",
      "title": "Balance a Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m\u00d7n)",
        "spaceComplexity": "O(m+n)",
        "intuition": [
          "We need to check if subRoot appears as a subtree in root.",
          "For each node in root, we can recursively check if the subtree matches subRoot."
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSubtree(root, subRoot):\n    \"\"\"\n    Intuition:\n    - We need to check if subRoot appears as a subtree in root.\n    - For each node in root, we can recursively check if the subtree matches subRoot.\n    \"\"\"\n    if not root:  # Base case: Check if tree is empty.\n        return False  # Condition not met.\n    if isSameTree(root, subRoot):\n        return True  # Condition satisfied.\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True  # Condition satisfied.\n    if not p or not q or p.val != q.val:\n        return False  # Condition not met.\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)"
      }
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Traverse tree structure."
      },
      {
        "input": "root = []",
        "output": "null",
        "explanation": "Empty tree edge case."
      }
    ],
    "constraints": [
      "Number of nodes: [0, 10^4]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(...) {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__() {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool __init__() {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\npublic:\n    bool __init__() {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isSubtree(root *TreeNode, subRoot *TreeNode) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) isSubtree(root *TreeNode, subRoot *TreeNode) bool {\n\tvar same func(p, q *TreeNode) bool\n\tsame = func(p, q *TreeNode) bool {\n\t\tif p == nil || q == nil {\n\t\t\treturn p == q\n\t\t}\n\t\treturn p.Val == q.Val && same(p.Left, q.Left) && same(p.Right, q.Right)\n\t}\n\tif root == nil {\n\t\treturn false\n\t}\n\treturn same(root, subRoot) || isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn new(val: i32) -> Self {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n//\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nimpl Solution {\n    pub fn is_subtree(\n        root: Option<Rc<RefCell<TreeNode>>>,\n        sub_root: Option<Rc<RefCell<TreeNode>>>,\n    ) -> bool {\n        if root.is_none() {\n            return false;\n        }\n        Self::same(&root, &sub_root)\n            || Self::is_subtree(\n                root.as_ref().unwrap().borrow().left.clone(),\n                sub_root.clone(),\n            )\n            || Self::is_subtree(\n                root.as_ref().unwrap().borrow().right.clone(),\n                sub_root.clone(),\n            )\n    }\n\n    fn same(p: &Option<Rc<RefCell<TreeNode>>>, q: &Option<Rc<RefCell<TreeNode>>>) -> bool {\n        match (p, q) {\n            (None, None) => true,\n            (Some(p), Some(q)) => {\n                let p = p.borrow();\n                let q = q.borrow();\n                p.val == q.val && Self::same(&p.left, &q.left) && Self::same(&p.right, &q.right)\n            }\n            _ => false,\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) {}\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
    "relatedProblems": [
      "palindrome-number",
      "count-complete-tree-nodes",
      "longest-common-prefix"
    ]
  },
  "lowest-common-ancestor-of-a-binary-search-tree": {
    "id": "lowest-common-ancestor-of-a-binary-search-tree",
    "slug": "lowest-common-ancestor-of-a-binary-search-tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "difficulty": "Medium",
    "category": "Binary Tree General",
    "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
    "videoUrl": "",
    "pattern": "BST Property",
    "patternEmoji": "\ud83c\udf32",
    "timeComplexity": "O(h)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use BST property to navigate toward LCA.",
    "intuition": [
      "In a BST, all left descendants are smaller and right descendants are larger.",
      "The LCA is the first node where p and q diverge to different subtrees."
    ],
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Lowest Common Ancestor of a Binary Search Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        Intuition:\n        - In a BST, all left descendants are smaller and right descendants are larger.\n        - The LCA is the first node where p and q diverge to different subtrees.\n        \"\"\"\n        while root:\n            if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n                root = root.left\n            elif p.val > root.val and q.val > root.val:\n                root = root.right\n            else:\n                return root\n        return None",
    "keyInsight": "Use BST ordering: if both nodes are on same side, move there. Otherwise current node is LCA.",
    "testCases": [
      {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
        "output": "6"
      },
      {
        "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
        "output": "2"
      },
      {
        "input": "root = [2,1], p = 2, q = 1",
        "output": "2"
      }
    ],
    "walkthrough": [
      "Start at root node of BST",
      "Use BST property: left < root < right",
      "If p.val < root.val AND q.val < root.val: go left",
      "If p.val > root.val AND q.val > root.val: go right",
      "Else: current node is the LCA (first divergence point)",
      "Return the LCA node's value"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "BST Property: Use BST property to navigate toward LCA.",
    "videoId": "gs2LMfuOR9k",
    "suggestedNextQuestion": {
      "slug": "lowest-common-ancestor-of-a-bst",
      "title": "Lowest Common Ancestor of a BST",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a phone book. If the name is after 'M', you ignore the entire first half.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    if p.val < root.val and q.val < root.val:\n        return lowestCommonAncestor(root.left, p, q)\n    elif p.val > root.val and q.val > root.val:\n        return lowestCommonAncestor(root.right, p, q)\n    return root"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "In a BST, all left descendants are smaller and right descendants are larger.",
          "The LCA is the first node where p and q diverge to different subtrees."
        ],
        "code": "def lowestCommonAncestor(root, p, q):\n    \"\"\"\n    Intuition:\n    - In a BST, all left descendants are smaller and right descendants are larger.\n    - The LCA is the first node where p and q diverge to different subtrees.\n    \"\"\"\n    while root:\n        if p.val < root.val and q.val < root.val:  # Traverse based on BST property.\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n    return None"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Your code here\n        return null;\n    }\n}",
        "code": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        return null;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // Your code here\n        return nullptr;\n    }\n}",
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        return nullptr; // Default return value\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tif root.Val > p.Val && root.Val > q.Val {\n\t\treturn lowestCommonAncestor(root.Left, p, q)\n\t}\n\tif root.Val < p.Val && root.Val < q.Val {\n\t\treturn lowestCommonAncestor(root.Right, p, q)\n\t}\n\treturn root\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn lowest_common_ancestor(root: Option<Rc<RefCell<TreeNode>>>, p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let p_val = p.unwrap().borrow().val;\n        let q_val = q.unwrap().borrow().val;\n        let mut curr = root;\n        while let Some(node) = curr.clone() {\n            let val = node.borrow().val;\n            if val > p_val && val > q_val {\n                curr = node.borrow().left.clone();\n            } else if val < p_val && val < q_val {\n                curr = node.borrow().right.clone();\n            } else {\n                return Some(node);\n            }\n        }\n        None\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(root: TreeNode | null) {}\n}",
        "initialCode": "class Solution {\n    __init__(root: TreeNode | null) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d",
    "relatedProblems": [
      "lowest-common-ancestor-of-a-bst"
    ]
  },
  "count-good-nodes-in-binary-tree": {
    "id": "count-good-nodes-in-binary-tree",
    "slug": "count-good-nodes-in-binary-tree",
    "title": "Count Good Nodes in Binary Tree",
    "difficulty": "Medium",
    "category": "Binary Tree General",
    "problemStatement": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.",
    "videoUrl": "",
    "pattern": "DFS Traversal",
    "patternEmoji": "\ud83c\udf32",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(h)",
    "oneliner": "Traverse tree while tracking max value seen so far.",
    "intuition": [
      "A node is good if its value is \u2265 all values in the path from root",
      "Track the maximum value encountered during DFS traversal"
    ],
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Count Good Nodes in Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def goodNodes(self, root):\n        \"\"\"\n        Intuition:\n        - A node is good if its value is \u2265 all values in the path from root\n        - Track the maximum value encountered during DFS traversal\n        \"\"\"\n        def dfs(node, max_so_far):\n            if not node:\n                return 0\n            count = 1 if node.val >= max_so_far else 0\n            new_max = max(max_so_far, node.val)  # Take the maximum value.\n            count += dfs(node.left, new_max)\n            count += dfs(node.right, new_max)\n            return count\n        return dfs(root, float('-inf'))",
    "keyInsight": "Use DFS with running maximum to determine if current node is good.",
    "testCases": [
      {
        "input": "root = [3,1,4,3,null,1,5]",
        "output": "4"
      },
      {
        "input": "root = [3,3,null,4,2]",
        "output": "3"
      },
      {
        "input": "root = [1]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "DFS Traversal: Traverse tree while tracking max value seen so far.",
    "videoId": "7cp5imvDzl4",
    "suggestedNextQuestion": {
      "slug": "course-schedule",
      "title": "Course Schedule",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def goodNodes(self, root):\n        pass\n\n        def dfs(node, max_so_far):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def goodNodes(root):\n    def dfs(node, maxVal):\n        if not node: return 0\n        res = 1 if node.val >= maxVal else 0\n        maxVal = max(maxVal, node.val)\n        res += dfs(node.left, maxVal)\n        res += dfs(node.right, maxVal)\n        return res\n    return dfs(root, root.val)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "intuition": [
          "A node is good if its value is \u2265 all values in the path from root",
          "Track the maximum value encountered during DFS traversal"
        ],
        "code": "def goodNodes(root):\n    \"\"\"\n    Intuition:\n    - A node is good if its value is \u2265 all values in the path from root\n    - Track the maximum value encountered during DFS traversal\n    \"\"\"\n    def dfs(node, max_so_far):\n        if not node:\n            return 0\n        count = 1 if node.val >= max_so_far else 0\n        new_max = max(max_so_far, node.val)  # Take the maximum value.\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        return count\n    return dfs(root, float('-inf'))"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(root) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(root) {\n        // Implementation goes here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__() {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) goodNodes(root *TreeNode) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc (s *Solution) goodNodes(root *TreeNode) (ans int) {\n\tvar dfs func(*TreeNode, int)\n\tdfs = func(root *TreeNode, mx int) {\n\t\tif root == nil {\n\t\t\treturn\n\t\t}\n\t\tif mx <= root.Val {\n\t\t\tans++\n\t\t\tmx = root.Val\n\t\t}\n\t\tdfs(root.Left, mx)\n\t\tdfs(root.Right, mx)\n\t}\n\tdfs(root, -10001)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\nuse rustgym_util::*;\n\ntrait Preorder {\n    fn preorder(&self, max: i32, count: &mut usize);\n}\n\nimpl Preorder for TreeLink {\n    fn preorder(&self, max: i32, count: &mut usize) {\n        if let Some(node) = self {\n            let node = node.borrow();\n            let val = node.val;\n            if val >= max {\n                *count += 1;\n            }\n            node.left.preorder(max.max(val), count);\n            node.right.preorder(max.max(val), count);\n        }\n    }\n}\n\nimpl Solution {\n    fn good_nodes(root: TreeLink) -> i32 {\n        let mut res = 0;\n        root.preorder(std::i32::MIN, &mut res);\n        res as i32\n    }\n}\n\n#[test]\nfn test() {\n    let root = tree!(3, tree!(1, tree!(3), None), tree!(4, tree!(1), tree!(5)));\n    let res = 4;\n    assert_eq!(Solution::good_nodes(root), res);\n    let root = tree!(3, tree!(3, tree!(4), tree!(2)), None);\n    let res = 3;\n    assert_eq!(Solution::good_nodes(root), res);\n    let root = tree!(1);\n    let res = 1;\n    assert_eq!(Solution::good_nodes(root), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def goodNodes(self, root):\n        pass\n\n        def dfs(node, max_so_far):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n\n    __init__(root: TreeNode | null): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.",
    "relatedProblems": [
      "minimum-size-subarray-sum",
      "construct-binary-tree-from-inorder-and-postorder-traversal",
      "longest-increasing-subsequence"
    ]
  },
  "serialize-and-deserialize-binary-tree": {
    "id": "serialize-and-deserialize-binary-tree",
    "slug": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Hard",
    "category": "Binary Tree General",
    "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
    "videoUrl": "",
    "pattern": "Tree Traversal",
    "patternEmoji": "\ud83c\udf32",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use preorder traversal with null markers for serialization and reconstruction.",
    "intuition": [
      "Preorder traversal (root, left, right) preserves tree structure",
      "Use special marker (like 'null') to represent missing nodes"
    ],
    "visualizationType": "tree",
    "initialState": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Serialize and Deserialize Binary Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def serializeDeserialize(self, root):\n        \"\"\"\n        Intuition:\n        - Preorder traversal (root, left, right) preserves tree structure\n        - Use special marker (like 'null') to represent missing nodes\n        \"\"\"\n        # Identity function - input tree equals output tree\n        return root",
    "keyInsight": "Preorder traversal with null markers uniquely represents any binary tree structure.",
    "testCases": [
      {
        "input": "root = [1,2,3,null,null,4,5]",
        "output": "[1, 2, 3, None, None, 4, 5]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "walkthrough": [
      "Serialize: Convert tree to string using preorder traversal",
      "Use 'null' marker for empty nodes",
      "Deserialize: Parse string back to tree",
      "Use recursion to rebuild tree structure",
      "Maintain index pointer during deserialization"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Tree Traversal: Use preorder traversal with null markers for serialization and reconstruction.",
    "videoId": "u4JAi2JJhI8",
    "mentalModel": "Like exploring a maze. You visit every corner systematically.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        # Encode a tree to a single string\n        pass\n    \n    def deserialize(self, data: str) -> TreeNode:\n        # Decode the string to a tree\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Preorder traversal (root, left, right) preserves tree structure",
          "Use special marker (like 'null') to represent missing nodes"
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef serializeDeserialize(root):\n    \"\"\"\n    Intuition:\n    - Preorder traversal (root, left, right) preserves tree structure\n    - Use special marker (like 'null') to represent missing nodes\n    \"\"\"\n    # Identity function - input tree equals output tree\n    return root"
      }
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Traverse tree structure."
      },
      {
        "input": "root = []",
        "output": "null",
        "explanation": "Empty tree edge case."
      }
    ],
    "constraints": [
      "Number of nodes: [0, 10^4]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n    \n    serialize(root) {}\n    \n    deserialize(data) {}\n}"
      },
      "java": {
        "initialCode": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n    public String serialize(TreeNode root) {\n        // Encode a tree to a single string\n        return \"\";\n    }\n\n    public TreeNode deserialize(String data) {\n        // Decode the string to a tree\n        return null;\n    }\n}\n",
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        List<String> ans = new ArrayList<>();\n        Deque<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (node != null) {\n                ans.add(node.val + \"\");\n                q.offer(node.left);\n                q.offer(node.right);\n            } else {\n                ans.add(\"#\");\n            }\n        }\n        return String.join(\",\", ans);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == null) {\n            return null;\n        }\n        String[] vals = data.split(\",\");\n        int i = 0;\n        TreeNode root = new TreeNode(Integer.valueOf(vals[i++]));\n        Deque<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            if (!\"#\".equals(vals[i])) {\n                node.left = new TreeNode(Integer.valueOf(vals[i]));\n                q.offer(node.left);\n            }\n            ++i;\n            if (!\"#\".equals(vals[i])) {\n                node.right = new TreeNode(Integer.valueOf(vals[i]));\n                q.offer(node.right);\n            }\n            ++i;\n        }\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.deserialize(codec.serialize(root));"
      },
      "cpp": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\npublic:\n    // Constructor\n    __init__() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() Codec {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n\ntype Codec struct {\n}\n\nfunc (s *Solution) Constructor() Codec {\n\treturn Codec{}\n}\n\n// Serializes a tree to a single string.\nfunc (this *Codec) serialize(root *TreeNode) string {\n\tif root == nil {\n\t\treturn \"\"\n\t}\n\tq := []*TreeNode{root}\n\tans := []string{}\n\tfor len(q) > 0 {\n\t\tnode := q[0]\n\t\tq = q[1:]\n\t\tif node != nil {\n\t\t\tans = append(ans, strconv.Itoa(node.Val))\n\t\t\tq = append(q, node.Left)\n\t\t\tq = append(q, node.Right)\n\t\t} else {\n\t\t\tans = append(ans, \"#\")\n\t\t}\n\t}\n\treturn strings.Join(ans, \",\")\n}\n\n// Deserializes your encoded data to tree.\nfunc (this *Codec) deserialize(data string) *TreeNode {\n\tif data == \"\" {\n\t\treturn nil\n\t}\n\tvals := strings.Split(data, \",\")\n\tv, _ := strconv.Atoi(vals[0])\n\ti := 1\n\troot := &TreeNode{Val: v}\n\tq := []*TreeNode{root}\n\tfor len(q) > 0 {\n\t\tnode := q[0]\n\t\tq = q[1:]\n\t\tif x, err := strconv.Atoi(vals[i]); err == nil {\n\t\t\tnode.Left = &TreeNode{Val: x}\n\t\t\tq = append(q, node.Left)\n\t\t}\n\t\ti++\n\t\tif x, err := strconv.Atoi(vals[i]); err == nil {\n\t\t\tnode.Right = &TreeNode{Val: x}\n\t\t\tq = append(q, node.Right)\n\t\t}\n\t\ti++\n\t}\n\treturn root\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * ser := Constructor();\n * deser := Constructor();\n * data := ser.serialize(root);\n * ans := deser.deserialize(data);\n */"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\nstruct Codec {\n    // Your data structure here\n}\n\nimpl Codec {\n    fn new() -> Self {\n        Codec {}\n    }\n\n    fn serialize(&self, root: Option<Rc<RefCell<TreeNode>>>) -> String {\n        // Encode a tree to a single string\n        String::new()\n    }\n\n    fn deserialize(&self, data: String) -> Option<Rc<RefCell<TreeNode>>> {\n        // Decode the string to a tree\n        None\n    }\n}\n",
        "code": "use rustgym_util::*;\nuse std::iter::Peekable;\nuse std::vec::IntoIter;\n\nstruct Codec;\n\nenum Tok {\n    Op(char),\n    Num(i32),\n}\n\nimpl Codec {\n    fn new() -> Self {\n        Codec {}\n    }\n\n    fn serialize(&self, root: TreeLink) -> String {\n        let mut res = \"\".to_string();\n        Self::serialize_tree(&root, &mut res);\n        res\n    }\n\n    fn serialize_tree(root: &TreeLink, s: &mut String) {\n        s.push('(');\n        if let Some(node) = root {\n            let node = node.borrow();\n            *s += &format!(\"{}\", node.val);\n            Self::serialize_tree(&node.left, s);\n            Self::serialize_tree(&node.right, s);\n        }\n        s.push(')');\n    }\n\n    fn deserialize(&self, data: String) -> TreeLink {\n        let tokens = Self::parse_tokens(data);\n        let mut it = tokens.into_iter().peekable();\n        Self::parse_tree(&mut it)\n    }\n\n    fn parse_tokens(data: String) -> Vec<Tok> {\n        let mut it = data.chars().peekable();\n        let mut res = vec![];\n        while let Some(c) = it.next() {\n            if c == '(' || c == ')' {\n                res.push(Tok::Op(c));\n            } else {\n                let mut sign = 1;\n                let mut x = 0;\n                if c == '-' {\n                    sign = -1;\n                } else {\n                    x = (c as u8 - b'0') as i32;\n                }\n                while let Some('0'..='9') = it.peek() {\n                    x *= 10;\n                    x += (it.next().unwrap() as u8 - b'0') as i32;\n                }\n                res.push(Tok::Num(sign * x));\n            }\n        }\n        res\n    }\n\n    fn parse_tree(it: &mut Peekable<IntoIter<Tok>>) -> TreeLink {\n        let mut res = None;\n        it.next();\n        match it.peek() {\n            Some(&Tok::Num(x)) => {\n                it.next();\n                res = tree!(x, Self::parse_tree(it), Self::parse_tree(it))\n            }\n            Some(Tok::Op(')')) => {}\n            _ => panic!(),\n        }\n        it.next();\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let codec = Codec::new();\n    let root = tree!(1, tree!(2), tree!(3, tree!(4), tree!(5)));\n    let res = tree!(1, tree!(2), tree!(3, tree!(4), tree!(5)));\n    assert_eq!(codec.deserialize(codec.serialize(root)), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root: TreeNode) -> str:\n        # Encode a tree to a single string\n        pass\n    \n    def deserialize(self, data: str) -> TreeNode:\n        # Decode the string to a tree\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.",
    "relatedProblems": [
      "text-justification",
      "trapping-rain-water",
      "max-points-on-a-line"
    ],
    "suggestedNextQuestion": {
      "slug": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "pattern": "Sliding Window + Hash Map"
    }
  },
  "max-area-of-island": {
    "id": "max-area-of-island",
    "slug": "max-area-of-island",
    "title": "Max Area of Island",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.",
    "videoUrl": "",
    "pattern": "DFS on Grid",
    "patternEmoji": "\ud83c\udf0a",
    "timeComplexity": "O(m\u00d7n)",
    "spaceComplexity": "O(m\u00d7n)",
    "oneliner": "Use DFS from each land cell to explore and count island areas.",
    "intuition": [
      "We need to explore connected components of 1s in a 2D grid",
      "DFS is perfect for exploring all connected land cells from a starting point"
    ],
    "visualizationType": "grid",
    "initialState": [
      [
        0,
        0,
        1,
        0
      ],
      [
        0,
        1,
        1,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Max Area of Island",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 0",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            0,
            0,
            1,
            0
          ],
          [
            0,
            1,
            1,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        Intuition:\n        - We need to explore connected components of 1s in a 2D grid\n        - DFS is perfect for exploring all connected land cells from a starting point\n        \"\"\"\n        if not grid:\n            return 0\n\n        def dfs(r, c):\n            if (r < 0 or c < 0 or r >= len(grid) or \n                c >= len(grid[0]) or grid[r][c] == 0):\n                return 0\n\n            grid[r][c] = 0  # Mark as visited\n            area = 1\n\n            # Explore all 4 directions\n            area += dfs(r+1, c)\n            area += dfs(r-1, c)\n            area += dfs(r, c+1)\n            area += dfs(r, c-1)\n\n            return area\n\n        max_area = 0\n        for r in range(len(grid)):  # Iterate through the range.\n            for c in range(len(grid[0])):  # Iterate through the range.\n                if grid[r][c] == 1:\n                    max_area = max(max_area, dfs(r, c))  # Take the maximum value.\n\n        return max_area",
    "keyInsight": "DFS explores connected components; we can modify grid to mark visited cells.",
    "testCases": [
      {
        "input": "grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]",
        "output": "6"
      },
      {
        "input": "grid = [[0,0,0,0,0,0,0,0]]",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "DFS on Grid: Use DFS from each land cell to explore and count island areas.",
    "videoId": "iJGr1OtmH0c",
    "suggestedNextQuestion": {
      "slug": "minimum-depth-of-binary-tree",
      "title": "Minimum Depth of Binary Tree",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def maxAreaOfIsland(self, grid):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def maxAreaOfIsland(grid):\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    def dfs(r, c):\n        if r<0 or r==rows or c<0 or c==cols or grid[r][c]==0 or (r,c) in visit:\n            return 0\n        visit.add((r, c))\n        return 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1)\n    \n    area = 0\n    for r in range(rows):\n        for c in range(cols):\n            area = max(area, dfs(r, c))\n    return area"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m\u00d7n)",
        "spaceComplexity": "O(m\u00d7n)",
        "intuition": [
          "We need to explore connected components of 1s in a 2D grid",
          "DFS is perfect for exploring all connected land cells from a starting point"
        ],
        "code": "def maxAreaOfIsland(grid):\n    \"\"\"\n    Intuition:\n    - We need to explore connected components of 1s in a 2D grid\n    - DFS is perfect for exploring all connected land cells from a starting point\n    \"\"\"\n    if not grid:\n        return 0\n    \n    def dfs(r, c):\n        if (r < 0 or c < 0 or r >= len(grid) or \n            c >= len(grid[0]) or grid[r][c] == 0):\n            return 0\n        \n        grid[r][c] = 0  # Mark as visited\n        area = 1\n        \n        # Explore all 4 directions\n        area += dfs(r+1, c)\n        area += dfs(r-1, c)\n        area += dfs(r, c+1)\n        area += dfs(r, c-1)\n        \n        return area\n    \n    max_area = 0\n    for r in range(len(grid)):  # Iterate through the range.\n        for c in range(len(grid[0])):  # Iterate through the range.\n            if grid[r][c] == 1:\n                max_area = max(max_area, dfs(r, c))  # Take the maximum value.\n    \n    return max_area"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    maxAreaOfIsland(grid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} grid\n     * @return {any}\n     */\n    maxAreaOfIsland(grid) {\n        const cache = new Set();\n        let max = 0;\n\n        for (let i = 0; i < grid.length; i++) {\n          for (let j = 0; j < grid[0].length; j++) {\n            max = Math.max(max, traverse(grid, cache, i, j));\n          }\n        }\n\n        return max;\n      };\n\n      class Solution {\n          /**\n           * @param {any} grid, cache, x, y\n           * @return {any}\n           */\n          traverse(grid, cache, x, y) {\n        let count = 0;\n        if (grid[x] && grid[x][y] === 1 && !cache.has(`${x},${y}`)) {\n          cache.add(`${x},${y}`);\n          count += [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\n            .map(([x, y]) => traverse(grid, cache, x, y))\n            .reduce((sum, count) => sum + count, 0) + 1;\n        }\n        return count;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private int m;\n    private int n;\n    private int[][] grid;\n\n    public int maxAreaOfIsland(int[][] grid) {\n        m = grid.length;\n        n = grid[0].length;\n        this.grid = grid;\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans = Math.max(ans, dfs(i, j));\n            }\n        }\n        return ans;\n    }\n\n    private int dfs(int i, int j) {\n        if (grid[i][j] == 0) {\n            return 0;\n        }\n        int ans = 1;\n        grid[i][j] = 0;\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k], y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n) {\n                ans += dfs(x, y);\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int dirs[5] = {-1, 0, 1, 0, -1};\n        int ans = 0;\n        function<int(int, int)> dfs = [&](int i, int j) {\n            if (grid[i][j] == 0) {\n                return 0;\n            }\n            int ans = 1;\n            grid[i][j] = 0;\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n) {\n                    ans += dfs(x, y);\n                }\n            }\n            return ans;\n        };\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans = max(ans, dfs(i, j));\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxAreaOfIsland(grid [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxAreaOfIsland(grid [][]int) (ans int) {\n\tm, n := len(grid), len(grid[0])\n\tdirs := [5]int{-1, 0, 1, 0, -1}\n\tvar dfs func(i, j int) int\n\tdfs = func(i, j int) int {\n\t\tif grid[i][j] == 0 {\n\t\t\treturn 0\n\t\t}\n\t\tans := 1\n\t\tgrid[i][j] = 0\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tx, y := i+dirs[k], j+dirs[k+1]\n\t\t\tif x >= 0 && x < m && y >= 0 && y < n {\n\t\t\t\tans += dfs(x, y)\n\t\t\t}\n\t\t}\n\t\treturn ans\n\t}\n\tfor i := range grid {\n\t\tfor j := range grid[i] {\n\t\t\tans = max(ans, dfs(i, j))\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_area_of_island(mut grid: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(grid: &mut Vec<Vec<i32>>, i: usize, j: usize) -> i32 {\n        if i == grid.len() || j == grid[0].len() || grid[i][j] == 0 {\n            return 0;\n        }\n        grid[i][j] = 0;\n        let mut res = 1 + Self::dfs(grid, i + 1, j) + Self::dfs(grid, i, j + 1);\n        if i != 0 {\n            res += Self::dfs(grid, i - 1, j);\n        }\n        if j != 0 {\n            res += Self::dfs(grid, i, j - 1);\n        }\n        res\n    }\n\n    pub fn max_area_of_island(mut grid: Vec<Vec<i32>>) -> i32 {\n        let m = grid.len();\n        let n = grid[0].len();\n        let mut res = 0;\n        for i in 0..m {\n            for j in 0..n {\n                res = res.max(Self::dfs(&mut grid, i, j));\n            }\n        }\n        res\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxAreaOfIsland(self, grid):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxAreaOfIsland(grid: number[][]): number  {\n    const m = grid.length;\n    const n = grid[0].length;\n    const dirs = [-1, 0, 1, 0, -1];\n    const dfs = (i: number, j: number): number => {\n        if (grid[i][j] === 0) {\n            return 0;\n        }\n        let ans = 1;\n        grid[i][j] = 0;\n        for (let k = 0; k < 4; ++k) {\n            const [x, y] = [i + dirs[k], j + dirs[k + 1]];\n            if (x >= 0 && x < m && y >= 0 && y < n) {\n                ans += dfs(x, y);\n            }\n        }\n        return ans;\n    };\n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(i, j));\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxAreaOfIsland(grid: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.",
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-ii",
      "longest-palindromic-substring",
      "decode-ways"
    ]
  },
  "pacific-atlantic-water-flow": {
    "id": "pacific-atlantic-water-flow",
    "slug": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "videoUrl": "",
    "pattern": "Multi-source BFS",
    "patternEmoji": "\ud83c\udf0a",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "oneliner": "Reverse the flow - start from oceans and find reachable cells.",
    "intuition": [
      "Water flows from high to low elevation, but we can reverse this thinking",
      "Start from ocean edges and work backwards to find all cells that can reach each ocean"
    ],
    "visualizationType": "matrix",
    "initialState": [
      [
        1,
        2,
        2,
        3,
        5
      ],
      [
        3,
        2,
        3,
        4,
        4
      ],
      [
        2,
        4,
        5,
        3,
        1
      ],
      [
        6,
        7,
        1,
        4,
        5
      ],
      [
        5,
        1,
        1,
        2,
        4
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Pacific Atlantic Water Flow",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 2",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 3",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 2",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            2,
            2,
            3,
            5
          ],
          [
            3,
            2,
            3,
            4,
            4
          ],
          [
            2,
            4,
            5,
            3,
            1
          ],
          [
            6,
            7,
            1,
            4,
            5
          ],
          [
            5,
            1,
            1,
            2,
            4
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def pacificAtlantic(self, heights):\n        \"\"\"\n        Intuition:\n        - Water flows from high to low elevation, but we can reverse this thinking\n        - Start from ocean edges and work backwards to find all cells that can reach each ocean\n        \"\"\"\n        if not heights or not heights[0]:\n            return []\n        \n        m, n = len(heights), len(heights[0])\n        \n        # Initialize queues for both oceans\n        pacific_queue = deque()\n        atlantic_queue = deque()\n        \n        # Add all edge cells to respective queues\n        for i in range(m):  # Iterate through the range.\n            pacific_queue.append((i, 0))  # Add to end.\n            atlantic_queue.append((i, n-1))  # Add to end.\n        for j in range(n):  # Iterate through the range.\n            pacific_queue.append((0, j))  # Add to end.\n            atlantic_queue.append((m-1, j))  # Add to end.\n        \n        def bfs(self, queue):\n            reachable = set()\n            while queue:  # Process nodes until queue is empty.\n                row, col = queue.popleft()  # Remove from front of queue.\n                reachable.add((row, col))\n                \n                # Check all 4 directions\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # Iterate over elements.\n                    new_row, new_col = row + dr, col + dc\n                    \n                    # Check bounds\n                    if (0 <= new_row < m and 0 <= new_col < n and \n                        (new_row, new_col) not in reachable and\n                        heights[new_row][new_col] >= heights[row][col]):\n                        queue.append((new_row, new_col))  # Add to end.\n            return reachable\n        \n        # Find cells reachable from each ocean\n        pacific_reachable = bfs(pacific_queue)\n        atlantic_reachable = bfs(atlantic_queue)\n        \n        # Find intersection\n        common_cells = pacific_reachable.intersection(atlantic_reachable)\n        \n        # Convert to list of lists\n        return [[r, c] for r, c in common_cells]",
    "keyInsight": "Instead of checking if each cell can reach an ocean, start from oceans and find all cells that can be reached (reverse thinking).",
    "testCases": [
      {
        "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
        "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
      },
      {
        "input": "heights = [[1]]",
        "output": "[[0,0]]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Multi-source BFS: Reverse the flow - start from oceans and find reachable cells.",
    "videoId": "s-VkcjHqkGI",
    "suggestedNextQuestion": {
      "slug": "redundant-connection",
      "title": "Redundant Connection",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def pacificAtlantic(heights):\n    ROWS, COLS = len(heights), len(heights[0])\n    pac, atl = set(), set()\n    \n    def dfs(r, c, visit, prevHeight):\n        if ((r, c) in visit or r < 0 or c < 0 or r == ROWS or c == COLS or\n            heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])\n        \n    for c in range(COLS):\n        dfs(0, c, pac, heights[0][c])\n        dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n        \n    for r in range(ROWS):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n        \n    return list(pac & atl)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)",
        "intuition": [
          "Water flows from high to low elevation, but we can reverse this thinking",
          "Start from ocean edges and work backwards to find all cells that can reach each ocean"
        ],
        "code": "from collections import deque\n\ndef pacificAtlantic(heights):\n    \"\"\"\n    Intuition:\n    - Water flows from high to low elevation, but we can reverse this thinking\n    - Start from ocean edges and work backwards to find all cells that can reach each ocean\n    \"\"\"\n    if not heights or not heights[0]:\n        return []\n    \n    m, n = len(heights), len(heights[0])\n    \n    # Initialize queues for both oceans\n    pacific_queue = deque()\n    atlantic_queue = deque()\n    \n    # Add all edge cells to respective queues\n    for i in range(m):  # Iterate through the range.\n        pacific_queue.append((i, 0))  # Add to end.\n        atlantic_queue.append((i, n-1))  # Add to end.\n    for j in range(n):  # Iterate through the range.\n        pacific_queue.append((0, j))  # Add to end.\n        atlantic_queue.append((m-1, j))  # Add to end.\n    \n    def bfs(queue):\n        reachable = set()\n        while queue:  # Process nodes until queue is empty.\n            row, col = queue.popleft()  # Remove from front of queue.\n            reachable.add((row, col))\n            \n            # Check all 4 directions\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # Iterate over elements.\n                new_row, new_col = row + dr, col + dc\n                \n                # Check bounds\n                if (0 <= new_row < m and 0 <= new_col < n and \n                    (new_row, new_col) not in reachable and\n                    heights[new_row][new_col] >= heights[row][col]):\n                    queue.append((new_row, new_col))  # Add to end.\n        return reachable\n    \n    # Find cells reachable from each ocean\n    pacific_reachable = bfs(pacific_queue)\n    atlantic_reachable = bfs(atlantic_queue)\n    \n    # Find intersection\n    common_cells = pacific_reachable.intersection(atlantic_reachable)\n    \n    # Convert to list of lists\n    return [[r, c] for r, c in common_cells]"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(heights: number[][]): number[][] {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(heights: number[][]): number[][] {\n        return [];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> solve(int[][] heights) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<List<Integer>> solve(int[][] heights) {\n        return new ArrayList<>();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> solve(vector<vector<int>>& heights) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> solve(vector<vector<int>>& heights) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) pacificAtlantic(heights [][]int) [][]int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) pacificAtlantic(heights [][]int) [][]int {\n\tm, n := len(heights), len(heights[0])\n\tvis1 := make([][]bool, m)\n\tvis2 := make([][]bool, m)\n\tfor i := range vis1 {\n\t\tvis1[i] = make([]bool, n)\n\t\tvis2[i] = make([]bool, n)\n\t}\n\tq1, q2 := [][2]int{}, [][2]int{}\n\tdirs := [5]int{-1, 0, 1, 0, -1}\n\n\tfor i := 0; i < m; i++ {\n\t\tq1 = append(q1, [2]int{i, 0})\n\t\tvis1[i][0] = true\n\t\tq2 = append(q2, [2]int{i, n - 1})\n\t\tvis2[i][n-1] = true\n\t}\n\tfor j := 0; j < n; j++ {\n\t\tq1 = append(q1, [2]int{0, j})\n\t\tvis1[0][j] = true\n\t\tq2 = append(q2, [2]int{m - 1, j})\n\t\tvis2[m-1][j] = true\n\t}\n\n\tbfs := func(q [][2]int, vis [][]bool) {\n\t\tfor len(q) > 0 {\n\t\t\tx, y := q[0][0], q[0][1]\n\t\t\tq = q[1:]\n\t\t\tfor k := 0; k < 4; k++ {\n\t\t\t\tnx, ny := x+dirs[k], y+dirs[k+1]\n\t\t\t\tif nx >= 0 && nx < m && ny >= 0 && ny < n &&\n\t\t\t\t\t!vis[nx][ny] && heights[nx][ny] >= heights[x][y] {\n\t\t\t\t\tvis[nx][ny] = true\n\t\t\t\t\tq = append(q, [2]int{nx, ny})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs(q1, vis1)\n\tbfs(q2, vis2)\n\n\tvar ans [][]int\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif vis1[i][j] && vis2[i][j] {\n\t\t\t\tans = append(ans, []int{i, j})\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::VecDeque;\n\nimpl Solution {\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let (m, n) = (heights.len(), heights[0].len());\n        let mut vis1 = vec![vec![false; n]; m];\n        let mut vis2 = vec![vec![false; n]; m];\n        let mut q1 = VecDeque::new();\n        let mut q2 = VecDeque::new();\n        let dirs = [-1, 0, 1, 0, -1];\n\n        for i in 0..m {\n            q1.push_back((i, 0));\n            vis1[i][0] = true;\n            q2.push_back((i, n - 1));\n            vis2[i][n - 1] = true;\n        }\n        for j in 0..n {\n            q1.push_back((0, j));\n            vis1[0][j] = true;\n            q2.push_back((m - 1, j));\n            vis2[m - 1][j] = true;\n        }\n\n        let bfs = |q: &mut VecDeque<(usize, usize)>, vis: &mut Vec<Vec<bool>>| {\n            while let Some((x, y)) = q.pop_front() {\n                for k in 0..4 {\n                    let nx = x as i32 + dirs[k];\n                    let ny = y as i32 + dirs[k + 1];\n                    if nx >= 0\n                        && nx < m as i32\n                        && ny >= 0\n                        && ny < n as i32\n                        && !vis[nx as usize][ny as usize]\n                        && heights[nx as usize][ny as usize] >= heights[x][y]\n                    {\n                        vis[nx as usize][ny as usize] = true;\n                        q.push_back((nx as usize, ny as usize));\n                    }\n                }\n            }\n        };\n\n        bfs(&mut q1, &mut vis1);\n        bfs(&mut q2, &mut vis2);\n\n        let mut ans = vec![];\n        for i in 0..m {\n            for j in 0..n {\n                if vis1[i][j] && vis2[i][j] {\n                    ans.push(vec![i as i32, j as i32]);\n                }\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(heights: number[][]): number[][] {\n        return [];\n    }\n}",
        "initialCode": "class Solution {\n    solve(heights: number[][]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "relatedProblems": [
      "walls-and-gates"
    ]
  },
  "rotting-oranges": {
    "id": "rotting-oranges",
    "slug": "rotting-oranges",
    "title": "Rotting Oranges",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You are given an m x n grid where each cell can have one of three values:\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "videoUrl": "",
    "pattern": "BFS",
    "patternEmoji": "\ud83e\udda0",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "oneliner": "Use BFS from all initial rotten oranges to simulate rotting.",
    "intuition": [
      "Rotten oranges spread simultaneously, so we need level-by-level processing.",
      "Start BFS from all rotten oranges at time 0."
    ],
    "visualizationType": "grid",
    "initialState": [
      [
        2,
        1,
        1
      ],
      [
        1,
        1,
        0
      ],
      [
        0,
        1,
        1
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Rotting Oranges",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 2",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            2,
            1,
            1
          ],
          [
            1,
            1,
            0
          ],
          [
            0,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def orangesRotting(self, grid):\n        \"\"\"\n        Intuition:\n        - Rotten oranges spread simultaneously, so we need level-by-level processing.\n        - Start BFS from all rotten oranges at time 0.\n        \"\"\"\n        if not grid:\n            return -1\n        \n        rows, cols = len(grid), len(grid[0])\n        fresh_count = 0\n        queue = deque()\n        \n        # Initialize queue with rotten oranges and count fresh ones\n        for r in range(rows):  # Iterate through the range.\n            for c in range(cols):  # Iterate through the range.\n                if grid[r][c] == 2:\n                    queue.append((r, c))  # Add to end.\n                elif grid[r][c] == 1:\n                    fresh_count += 1\n        \n        # If no fresh oranges, return 0\n        if fresh_count == 0:\n            return 0\n        \n        # BFS to rot oranges\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        minutes = 0\n        \n        while queue and fresh_count > 0:\n            minutes += 1\n            # Process all currently rotten oranges\n            for _ in range(len(queue)):  # Iterate through the range.\n                r, c = queue.popleft()  # Remove from front of queue.\n                \n                # Check all 4 directions\n                for dr, dc in directions:  # Iterate over elements.\n                    nr, nc = r + dr, c + dc\n                    \n                    # If neighbor is a fresh orange, rot it\n                    if (0 <= nr < rows and \n                        0 <= nc < cols and \n                        grid[nr][nc] == 1):\n                        grid[nr][nc] = 2\n                        fresh_count -= 1\n                        queue.append((nr, nc))  # Add to end.\n        \n        # If there are still fresh oranges, impossible\n        return minutes if fresh_count == 0 else -1",
    "keyInsight": "Multi-source BFS: all rotten oranges at time 0 start spreading simultaneously.",
    "testCases": [
      {
        "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
        "output": "4"
      },
      {
        "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
        "output": "-1"
      },
      {
        "input": "grid = [[0,2]]",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Initialize queue with starting node(s)",
      "Mark starting nodes as visited",
      "While queue not empty, process current level",
      "Add unvisited neighbors to queue",
      "Track level/distance as needed"
    ],
    "hints": [
      "\ud83e\udde0 BFS finds shortest path in unweighted graphs",
      "\ud83d\udca1 Process nodes level by level",
      "\ud83d\udd0d Track visited to avoid cycles"
    ],
    "approach": "BFS: Use BFS from all initial rotten oranges to simulate rotting.",
    "videoId": "y704fEOx0s0",
    "suggestedNextQuestion": {
      "slug": "snakes-and-ladders",
      "title": "Snakes and Ladders",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def orangesRotting(grid):\n    q = []\n    fresh = 0\n    rows, cols = len(grid), len(grid[0])\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1: fresh += 1\n            if grid[r][c] == 2: q.append((r, c))\n            \n    time = 0\n    while q and fresh > 0:\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                row, col = r + dr, c + dc\n                if (row < 0 or row == rows or col < 0 or col == cols or\n                    grid[row][col] != 1):\n                    continue\n                grid[row][col] = 2\n                q.append((row, col))\n                fresh -= 1\n        time += 1\n    return time if fresh == 0 else -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)",
        "intuition": [
          "Rotten oranges spread simultaneously, so we need level-by-level processing.",
          "Start BFS from all rotten oranges at time 0."
        ],
        "code": "from collections import deque\n\ndef orangesRotting(grid):\n    \"\"\"\n    Intuition:\n    - Rotten oranges spread simultaneously, so we need level-by-level processing.\n    - Start BFS from all rotten oranges at time 0.\n    \"\"\"\n    if not grid:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    fresh_count = 0\n    queue = deque()\n    \n    # Initialize queue with rotten oranges and count fresh ones\n    for r in range(rows):  # Iterate through the range.\n        for c in range(cols):  # Iterate through the range.\n            if grid[r][c] == 2:\n                queue.append((r, c))  # Add to end.\n            elif grid[r][c] == 1:\n                fresh_count += 1\n    \n    # If no fresh oranges, return 0\n    if fresh_count == 0:\n        return 0\n    \n    # BFS to rot oranges\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    minutes = 0\n    \n    while queue and fresh_count > 0:\n        minutes += 1\n        # Process all currently rotten oranges\n        for _ in range(len(queue)):  # Iterate through the range.\n            r, c = queue.popleft()  # Remove from front of queue.\n            \n            # Check all 4 directions\n            for dr, dc in directions:  # Iterate over elements.\n                nr, nc = r + dr, c + dc\n                \n                # If neighbor is a fresh orange, rot it\n                if (0 <= nr < rows and \n                    0 <= nc < cols and \n                    grid[nr][nc] == 1):\n                    grid[nr][nc] = 2\n                    fresh_count -= 1\n                    queue.append((nr, nc))  # Add to end.\n    \n    # If there are still fresh oranges, impossible\n    return minutes if fresh_count == 0 else -1"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(grid: number[][]): number {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(grid: number[][]): number {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(int[][] grid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int solve(int[][] grid) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(vector<vector<int>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(vector<vector<int>>& grid) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) orangesRotting(grid [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) orangesRotting(grid [][]int) int {\n\tm, n := len(grid), len(grid[0])\n\tq := [][2]int{}\n\tcnt := 0\n\tfor i, row := range grid {\n\t\tfor j, x := range row {\n\t\t\tif x == 1 {\n\t\t\t\tcnt++\n\t\t\t} else if x == 2 {\n\t\t\t\tq = append(q, [2]int{i, j})\n\t\t\t}\n\t\t}\n\t}\n\tdirs := [5]int{-1, 0, 1, 0, -1}\n\tfor ans := 1; len(q) > 0 && cnt > 0; ans++ {\n\t\tfor k := len(q); k > 0; k-- {\n\t\t\tp := q[0]\n\t\t\tq = q[1:]\n\t\t\tfor d := 0; d < 4; d++ {\n\t\t\t\tx, y := p[0]+dirs[d], p[1]+dirs[d+1]\n\t\t\t\tif x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1 {\n\t\t\t\t\tgrid[x][y] = 2\n\t\t\t\t\tq = append(q, [2]int{x, y})\n\t\t\t\t\tif cnt--; cnt == 0 {\n\t\t\t\t\t\treturn ans\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif cnt > 0 {\n\t\treturn -1\n\t}\n\treturn 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn oranges_rotting(mut grid: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "use std::collections::VecDeque;\n\nimpl Solution {\n    pub fn oranges_rotting(mut grid: Vec<Vec<i32>>) -> i32 {\n        let m = grid.len();\n        let n = grid[0].len();\n        let mut q = VecDeque::new();\n        let mut cnt = 0;\n        for i in 0..m {\n            for j in 0..n {\n                if grid[i][j] == 1 {\n                    cnt += 1;\n                } else if grid[i][j] == 2 {\n                    q.push_back((i, j));\n                }\n            }\n        }\n\n        let dirs = [-1, 0, 1, 0, -1];\n        for ans in 1.. {\n            if q.is_empty() || cnt == 0 {\n                break;\n            }\n            let mut size = q.len();\n            for _ in 0..size {\n                let (x, y) = q.pop_front().unwrap();\n                for d in 0..4 {\n                    let nx = x as isize + dirs[d] as isize;\n                    let ny = y as isize + dirs[d + 1] as isize;\n                    if nx >= 0 && nx < m as isize && ny >= 0 && ny < n as isize {\n                        let nx = nx as usize;\n                        let ny = ny as usize;\n                        if grid[nx][ny] == 1 {\n                            grid[nx][ny] = 2;\n                            q.push_back((nx, ny));\n                            cnt -= 1;\n                            if cnt == 0 {\n                                return ans;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if cnt > 0 {\n            -1\n        } else {\n            0\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(grid: number[][]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    solve(grid: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an m x n grid where each cell can have one of three values:\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "relatedProblems": [
      "snakes-and-ladders",
      "minimum-genetic-mutation",
      "word-ladder"
    ]
  },
  "walls-and-gates": {
    "id": "walls-and-gates",
    "slug": "walls-and-gates",
    "title": "Walls And Gates",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You are given an m x n grid rooms initialized with these three possible values:\n-1: A wall or an obstacle.\n0: A gate.\nINF: Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
    "videoUrl": "",
    "pattern": "Multi-source BFS",
    "patternEmoji": "\ud83c\udf0a",
    "timeComplexity": "O(m\u00d7n)",
    "spaceComplexity": "O(m\u00d7n)",
    "oneliner": "Start BFS from all gates simultaneously to find shortest distances.",
    "intuition": [
      "Instead of running BFS from each empty cell, run BFS from all gates at once",
      "This ensures we find the shortest distance to any gate in one pass"
    ],
    "visualizationType": "matrix",
    "initialState": [
      [
        2147483647,
        -1,
        0,
        2147483647
      ],
      [
        2147483647,
        2147483647,
        2147483647,
        -1
      ],
      [
        2147483647,
        -1,
        2147483647,
        -1
      ],
      [
        0,
        -1,
        2147483647,
        2147483647
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Walls And Gates",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 2147483647",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: -1",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 2147483647",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 2147483647",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            2147483647,
            -1,
            0,
            2147483647
          ],
          [
            2147483647,
            2147483647,
            2147483647,
            -1
          ],
          [
            2147483647,
            -1,
            2147483647,
            -1
          ],
          [
            0,
            -1,
            2147483647,
            2147483647
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import deque\n    \n    def wallsAndGates(self, rooms):\n        \"\"\"\n        Intuition:\n        - Instead of running BFS from each empty cell, run BFS from all gates at once\n        - This ensures we find the shortest distance to any gate in one pass\n        \"\"\"\n        if not rooms:\n            return\n        \n        m, n = len(rooms), len(rooms[0])\n        queue = deque()\n        \n        # Find all gates\n        for i in range(m):  # Iterate through the range.\n            for j in range(n):  # Iterate through the range.\n                if rooms[i][j] == 0:\n                    queue.append((i, j))  # Add to end.\n        \n        # Directions: up, down, left, right\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        \n        # Multi-source BFS\n        while queue:  # Process nodes until queue is empty.\n            row, col = queue.popleft()  # Remove from front of queue.\n            \n            for dr, dc in directions:  # Iterate over elements.\n                r, c = row + dr, col + dc\n                \n                # Check bounds and if cell is an unvisited room\n                if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                    rooms[r][c] = rooms[row][col] + 1\n                    queue.append((r, c))  # Add to end.",
    "keyInsight": "Use all gates as starting points in a single BFS to efficiently compute distances.",
    "testCases": [
      {
        "input": "rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
        "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Multi-source BFS: Start BFS from all gates simultaneously to find shortest distances.",
    "videoId": "e69C6xhiSQE",
    "suggestedNextQuestion": {
      "slug": "alien-dictionary",
      "title": "Alien Dictionary",
      "difficulty": "Hard",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a ripple in a pond, spreading out layer by layer from the center.",
    "initialCode": "class Solution:\n    def wallsAndGates(self, rooms):\n        pass",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def wallsAndGates(rooms):\n    rows, cols = len(rooms), len(rooms[0])\n    q = []\n    for r in range(rows):\n        for c in range(cols):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                \n    dist = 0\n    while q:\n        dist += 1\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:\n                row, col = r + dr, c + dc\n                if 0 <= row < rows and 0 <= col < cols and rooms[row][col] == 2147483647:\n                    rooms[row][col] = dist\n                    q.append((row, col))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m\u00d7n)",
        "spaceComplexity": "O(m\u00d7n)",
        "intuition": [
          "Instead of running BFS from each empty cell, run BFS from all gates at once",
          "This ensures we find the shortest distance to any gate in one pass"
        ],
        "code": "from collections import deque\n\ndef wallsAndGates(rooms):\n    \"\"\"\n    Intuition:\n    - Instead of running BFS from each empty cell, run BFS from all gates at once\n    - This ensures we find the shortest distance to any gate in one pass\n    \"\"\"\n    if not rooms:\n        return\n    \n    m, n = len(rooms), len(rooms[0])\n    queue = deque()\n    \n    # Find all gates\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if rooms[i][j] == 0:\n                queue.append((i, j))  # Add to end.\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Multi-source BFS\n    while queue:  # Process nodes until queue is empty.\n        row, col = queue.popleft()  # Remove from front of queue.\n        \n        for dr, dc in directions:  # Iterate over elements.\n            r, c = row + dr, col + dc\n            \n            # Check bounds and if cell is an unvisited room\n            if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                rooms[r][c] = rooms[row][col] + 1\n                queue.append((r, c))  # Add to end."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    wallsAndGates(rooms) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} rooms\n     * @return {any}\n     */\n    wallsAndGates(rooms) {\n        const rows = rooms.length;\n        const cols = rooms[0].length;\n        const queue = [];\n        const INF = 2147483647;\n\n        for (let i = 0; i < rows; i++) {\n          for (let j = 0; j < cols; j++) {\n            if (rooms[i][j] === 0) {\n              queue.push([i, j]);\n            }\n          }\n        }\n\n        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        while (queue.length) {\n          const [row, col] = queue.shift();\n\n          for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\n                && rooms[newRow][newCol] === INF) {\n              rooms[newRow][newCol] = rooms[row][col] + 1;\n              queue.push([newRow, newCol]);\n            }\n          }\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        // Your code here\n    }\n}",
        "code": "class Solution {\n    public void wallsAndGates(int[][] rooms) {\n        int m = rooms.length;\n        int n = rooms[0].length;\n        Deque<int[]> q = new LinkedList<>();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (rooms[i][j] == 0) {\n                    q.offer(new int[] {i, j});\n                }\n            }\n        }\n        int d = 0;\n        int[] dirs = {-1, 0, 1, 0, -1};\n        while (!q.isEmpty()) {\n            ++d;\n            for (int i = q.size(); i > 0; --i) {\n                int[] p = q.poll();\n                for (int j = 0; j < 4; ++j) {\n                    int x = p[0] + dirs[j];\n                    int y = p[1] + dirs[j + 1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && rooms[x][y] == Integer.MAX_VALUE) {\n                        rooms[x][y] = d;\n                        q.offer(new int[] {x, y});\n                    }\n                }\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    void wallsAndGates(vector<vector<int>>& rooms) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    void wallsAndGates(vector<vector<int>>& rooms) {\n        int m = rooms.size();\n        int n = rooms[0].size();\n        queue<pair<int, int>> q;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                if (rooms[i][j] == 0)\n                    q.emplace(i, j);\n        int d = 0;\n        vector<int> dirs = {-1, 0, 1, 0, -1};\n        while (!q.empty()) {\n            ++d;\n            for (int i = q.size(); i > 0; --i) {\n                auto p = q.front();\n                q.pop();\n                for (int j = 0; j < 4; ++j) {\n                    int x = p.first + dirs[j];\n                    int y = p.second + dirs[j + 1];\n                    if (x >= 0 && x < m && y >= 0 && y < n && rooms[x][y] == INT_MAX) {\n                        rooms[x][y] = d;\n                        q.emplace(x, y);\n                    }\n                }\n            }\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) wallsAndGates(rooms [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) wallsAndGates(rooms [][]int) {\n\tm, n := len(rooms), len(rooms[0])\n\tvar q [][]int\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif rooms[i][j] == 0 {\n\t\t\t\tq = append(q, []int{i, j})\n\t\t\t}\n\t\t}\n\t}\n\td := 0\n\tdirs := []int{-1, 0, 1, 0, -1}\n\tfor len(q) > 0 {\n\t\td++\n\t\tfor i := len(q); i > 0; i-- {\n\t\t\tp := q[0]\n\t\t\tq = q[1:]\n\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\tx, y := p[0]+dirs[j], p[1]+dirs[j+1]\n\t\t\t\tif x >= 0 && x < m && y >= 0 && y < n && rooms[x][y] == math.MaxInt32 {\n\t\t\t\t\trooms[x][y] = d\n\t\t\t\t\tq = append(q, []int{x, y})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn walls_and_gates(rooms: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn walls_and_gates(rooms: &mut Vec<Vec<i32>>) {\n        let n = rooms.len();\n        if n == 0 {\n            return;\n        }\n        let m = rooms[0].len();\n        if m == 0 {\n            return;\n        }\n        let mut queue: VecDeque<(usize, usize, i32)> = VecDeque::new();\n        for i in 0..n {\n            for j in 0..m {\n                if rooms[i][j] == 0 {\n                    queue.push_back((i, j, 0));\n                }\n            }\n        }\n        while let Some((i, j, dist)) = queue.pop_front() {\n            let dist = dist + 1;\n            if i > 0 && rooms[i - 1][j] > 0 && dist < rooms[i - 1][j] {\n                rooms[i - 1][j] = dist;\n                queue.push_back((i - 1, j, dist));\n            }\n            if j > 0 && rooms[i][j - 1] > 0 && dist < rooms[i][j - 1] {\n                rooms[i][j - 1] = dist;\n                queue.push_back((i, j - 1, dist));\n            }\n            if i + 1 < n && rooms[i + 1][j] > 0 && dist < rooms[i + 1][j] {\n                rooms[i + 1][j] = dist;\n                queue.push_back((i + 1, j, dist));\n            }\n            if j + 1 < m && rooms[i][j + 1] > 0 && dist < rooms[i][j + 1] {\n                rooms[i][j + 1] = dist;\n                queue.push_back((i, j + 1, dist));\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let inf = std::i32::MAX;\n    let mut rooms = vec_vec_i32![\n        [inf, -1, 0, inf],\n        [inf, inf, inf, -1],\n        [inf, -1, inf, -1],\n        [0, -1, inf, inf]\n    ];\n    let res = vec_vec_i32![[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]];\n    Solution::walls_and_gates(&mut rooms);\n    assert_eq!(rooms, res);\n}"
      },
      "python": {
        "initialCode": "from collections import deque\n\ndef wallsAndGates(rooms):\n    \"\"\"\n    Intuition:\n    - Instead of running BFS from each empty cell, run BFS from all gates at once\n    - This ensures we find the shortest distance to any gate in one pass\n    \"\"\"\n    if not rooms:\n        return\n    \n    m, n = len(rooms), len(rooms[0])\n    queue = deque()\n    \n    # Find all gates\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            if rooms[i][j] == 0:\n                queue.append((i, j))  # Add to end.\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Multi-source BFS\n    while queue:  # Process nodes until queue is empty.\n        row, col = queue.popleft()  # Remove from front of queue.\n        \n        for dr, dc in directions:  # Iterate over elements.\n            r, c = row + dr, col + dc\n            \n            # Check bounds and if cell is an unvisited room\n            if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                rooms[r][c] = rooms[row][col] + 1\n                queue.append((r, c))  # Add to end."
      },
      "typescript": {
        "code": "class Solution {\n    wallsAndGates(rooms: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    wallsAndGates(rooms: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given an m x n grid rooms initialized with these three possible values:\n-1: A wall or an obstacle.\n0: A gate.\nINF: Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
    "relatedProblems": [
      "pacific-atlantic-water-flow"
    ]
  },
  "redundant-connection": {
    "id": "redundant-connection",
    "slug": "redundant-connection",
    "title": "Redundant Connection",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
    "videoUrl": "",
    "pattern": "Union-Find (Disjoint Set)",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use Union-Find to detect when adding an edge creates a cycle.",
    "intuition": [
      "A tree with n nodes has exactly n-1 edges",
      "The redundant edge is the one that creates the first cycle"
    ],
    "visualizationType": "graph",
    "initialState": [
      [
        1,
        2
      ],
      [
        1,
        3
      ],
      [
        2,
        3
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Union-Find",
        "transientMessage": "edges=[[1,2],[1,3],[2,3]]",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 50
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 150
            }
          ],
          "edges": []
        },
        "pointers": [
          {
            "label": "parent",
            "value": "[1,2,3]"
          }
        ],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Union(1,2)",
        "transientMessage": "Merge sets",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 50,
              "highlight": true
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2",
              "highlight": true
            }
          ]
        },
        "pointers": [
          {
            "label": "parent",
            "value": "[1,1,3]"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Union(1,3)",
        "transientMessage": "Merge sets",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 50,
              "highlight": true
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3",
              "highlight": true
            }
          ]
        },
        "pointers": [
          {
            "label": "parent",
            "value": "[1,1,1]"
          }
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Cycle: [2,3]",
        "transientMessage": "Find(2)=Find(3)=1",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 50
            },
            {
              "id": "2",
              "label": "2",
              "x": 100,
              "y": 150
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "1",
              "to": "3"
            },
            {
              "from": "2",
              "to": "3",
              "highlight": true
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "[2,3]"
          }
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def findRedundantConnection(self, edges):\n        \"\"\"\n        Intuition:\n        - A tree with n nodes has exactly n-1 edges\n        - The redundant edge is the one that creates the first cycle\n        \"\"\"\n        parent = list(range(len(edges) + 1))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])  # Path compression\n            return parent[x]\n\n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX == rootY:\n                return False  # Cycle detected\n            parent[rootX] = rootY\n            return True  # Condition satisfied.\n\n        for edge in edges:  # Iterate over elements.\n            if not union(edge[0], edge[1]):\n                return edge\n        return []",
    "keyInsight": "When union operation fails, we've found our redundant edge.",
    "testCases": [
      {
        "input": "edges = [[1,2],[1,3],[2,3]]",
        "output": "[2,3]"
      },
      {
        "input": "edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",
        "output": "[1,4]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Union-Find (Disjoint Set): Use Union-Find to detect when adding an edge creates a cycle.",
    "videoId": "FXWRE67PLL0",
    "graphNodes": [
      {
        "id": 1,
        "label": "1"
      },
      {
        "id": 2,
        "label": "2"
      },
      {
        "id": 3,
        "label": "3"
      }
    ],
    "graphEdges": [
      {
        "from": 1,
        "to": 2
      },
      {
        "from": 1,
        "to": 3
      },
      {
        "from": 2,
        "to": 3
      }
    ],
    "suggestedNextQuestion": {
      "slug": "rotting-oranges",
      "title": "Rotting Oranges",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like a club guest list. It only checks if you are 'in' or 'out', duplicates aren't allowed.",
    "initialCode": "class Solution:\n    def findRedundantConnection(self, edges):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findRedundantConnection(edges):\n    par = [i for i in range(len(edges) + 1)]\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2: return False\n        par[p1] = p2\n        return True\n    \n    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "A tree with n nodes has exactly n-1 edges",
          "The redundant edge is the one that creates the first cycle"
        ],
        "code": "def findRedundantConnection(edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes has exactly n-1 edges\n    - The redundant edge is the one that creates the first cycle\n    \"\"\"\n    parent = list(range(len(edges) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX == rootY:\n            return False  # Cycle detected\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for edge in edges:  # Iterate over elements.\n        if not union(edge[0], edge[1]):\n            return edge\n    return []"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findRedundantConnection(edges) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[][]} edges\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} edges\n     * @return {any}\n     */\n    findRedundantConnection(edges) {\n        const n = edges.length;\n        const p = Array.from({ length: n }, (_, i) => i);\n        const find = x => {\n            if (p[x] !== x) {\n                p[x] = find(p[x]);\n            }\n            return p[x];\n        };\n        for (let i = 0; ; ++i) {\n            const pa = find(edges[i][0] - 1);\n            const pb = find(edges[i][1] - 1);\n            if (pa === pb) {\n                return edges[i];\n            }\n            p[pa] = pb;\n    }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    private int[] p;\n\n    public int[] findRedundantConnection(int[][] edges) {\n        int n = edges.length;\n        p = new int[n];\n        for (int i = 0; i < n; ++i) {\n            p[i] = i;\n        }\n        for (int i = 0;; ++i) {\n            int pa = find(edges[i][0] - 1);\n            int pb = find(edges[i][1] - 1);\n            if (pa == pb) {\n                return edges[i];\n            }\n            p[pa] = pb;\n        }\n    }\n\n    private int find(int x) {\n        if (p[x] != x) {\n            p[x] = find(p[x]);\n        }\n        return p[x];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        function<int(int)> find = [&](int x) {\n            return x == p[x] ? x : p[x] = find(p[x]);\n        };\n        for (int i = 0;; ++i) {\n            int pa = find(edges[i][0] - 1);\n            int pb = find(edges[i][1] - 1);\n            if (pa == pb) {\n                return edges[i];\n            }\n            p[pa] = pb;\n        }\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findRedundantConnection(edges [][]int) []int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findRedundantConnection(edges [][]int) []int {\n\tn := len(edges)\n\tp := make([]int, n)\n\tfor i := range p {\n\t\tp[i] = i\n\t}\n\tvar find func(int) int\n\tfind = func(x int) int {\n\t\tif p[x] != x {\n\t\t\tp[x] = find(p[x])\n\t\t}\n\t\treturn p[x]\n\t}\n\tfor i := 0; ; i++ {\n\t\tpa, pb := find(edges[i][0]-1), find(edges[i][1]-1)\n\t\tif pa == pb {\n\t\t\treturn edges[i]\n\t\t}\n\t\tp[pa] = pb\n\t}\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_redundant_connection(edges: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    n: usize,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let parent = (0..n).collect();\n        UnionFind { parent, n }\n    }\n\n    fn find(&mut self, i: usize) -> usize {\n        let j = self.parent[i];\n        if i == j {\n            i\n        } else {\n            let k = self.find(j);\n            self.parent[i] = k;\n            k\n        }\n    }\n\n    fn union(&mut self, i: usize, j: usize) -> bool {\n        let i = self.find(i);\n        let j = self.find(j);\n        if i == j {\n            true\n        } else {\n            self.parent[i] = j;\n            false\n        }\n    }\n}\n\nimpl Solution {\n    fn find_redundant_connection(edges: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = edges.len();\n        let mut uf = UnionFind::new(n);\n        for edge in edges {\n            let u = (edge[0] - 1) as usize;\n            let v = (edge[1] - 1) as usize;\n            if uf.union(u, v) {\n                return edge;\n            }\n        }\n        vec![]\n    }\n}\n\n#[test]\nfn test() {\n    let edges = vec_vec_i32![[1, 2], [1, 3], [2, 3]];\n    let res = vec![2, 3];\n    assert_eq!(Solution::find_redundant_connection(edges), res);\n    let edges = vec_vec_i32![[1, 2], [2, 3], [3, 4], [1, 4], [1, 5]];\n    let res = vec![1, 4];\n    assert_eq!(Solution::find_redundant_connection(edges), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findRedundantConnection(self, edges):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findRedundantConnection(edges: number[][]): number[]  {\n    const n = edges.length;\n    const p: number[] = Array.from({ length: n }, (_, i) => i);\n    const find = (x: number): number => {\n        if (p[x] !== x) {\n            p[x] = find(p[x]);\n        }\n        return p[x];\n    };\n    for (let i = 0; ; ++i) {\n        const pa = find(edges[i][0] - 1);\n        const pb = find(edges[i][1] - 1);\n        if (pa === pb) {\n            return edges[i];\n        }\n        p[pa] = pb;\n    }\n}\n}",
        "initialCode": "class Solution {\n    findRedundantConnection(edges: number[][]): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
    "relatedProblems": [
      "cheapest-flights-within-k-stops",
      "add-two-numbers",
      "lowest-common-ancestor-of-a-binary-search-tree"
    ]
  },
  "number-of-connected-components-in-an-undirected-graph": {
    "id": "number-of-connected-components-in-an-undirected-graph",
    "slug": "number-of-connected-components-in-an-undirected-graph",
    "title": "Number of Connected Components In An Undirected Graph",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
    "videoUrl": "",
    "pattern": "Union-Find / DFS",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(E * \u03b1(n))",
    "spaceComplexity": "O(n)",
    "oneliner": "Use Union-Find to group connected nodes and count components.",
    "intuition": [
      "Each node starts as its own component",
      "When we connect two nodes, we merge their components"
    ],
    "visualizationType": "graph",
    "initialState": [
      0,
      1,
      2,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Input Graph",
        "transientMessage": "n=5, edges=[[0,1],[1,2],[3,4]]",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0",
              "x": 100,
              "y": 100
            },
            {
              "id": "1",
              "label": "1",
              "x": 200,
              "y": 100
            },
            {
              "id": "2",
              "label": "2",
              "x": 300,
              "y": 100
            },
            {
              "id": "3",
              "label": "3",
              "x": 150,
              "y": 200
            },
            {
              "id": "4",
              "label": "4",
              "x": 250,
              "y": 200
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "3",
              "to": "4"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "DFS: 0\u21921\u21922",
        "transientMessage": "Component 1",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 100,
              "y": 100,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 100,
              "visited": true
            },
            {
              "id": "3",
              "label": "3",
              "x": 150,
              "y": 200
            },
            {
              "id": "4",
              "label": "4",
              "x": 250,
              "y": 200
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1",
              "highlight": true
            },
            {
              "from": "1",
              "to": "2",
              "highlight": true
            },
            {
              "from": "3",
              "to": "4"
            }
          ]
        },
        "pointers": [
          {
            "label": "count",
            "value": "1"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "DFS: 3\u21924",
        "transientMessage": "Component 2",
        "graphState": {
          "nodes": [
            {
              "id": "0",
              "label": "0 \u2713",
              "x": 100,
              "y": 100,
              "visited": true
            },
            {
              "id": "1",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 \u2713",
              "x": 300,
              "y": 100,
              "visited": true
            },
            {
              "id": "3",
              "label": "3 \u2713",
              "x": 150,
              "y": 200,
              "visited": true
            },
            {
              "id": "4",
              "label": "4 \u2713",
              "x": 250,
              "y": 200,
              "visited": true
            }
          ],
          "edges": [
            {
              "from": "0",
              "to": "1"
            },
            {
              "from": "1",
              "to": "2"
            },
            {
              "from": "3",
              "to": "4",
              "highlight": true
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "2"
          }
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def countComponents(self, n, edges):\n        \"\"\"\n        Intuition:\n        - Each node starts as its own component\n        - When we connect two nodes, we merge their components\n        \"\"\"\n        parent = list(range(n))\n        rank = [0] * n\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py: return\n            if rank[px] < rank[py]:\n                px, py = py, px\n            parent[py] = px\n            if rank[px] == rank[py]:\n                rank[px] += 1\n\n        for a, b in edges:  # Iterate over elements.\n            union(a, b)\n\n        return len(set(find(x) for x in range(n)))  # Iterate through the range.",
    "keyInsight": "Union-Find efficiently tracks connected components by merging groups.",
    "testCases": [
      {
        "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
        "output": "2"
      },
      {
        "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Union-Find / DFS: Use Union-Find to group connected nodes and count components.",
    "videoId": "8f1XPm4WOUc",
    "suggestedNextQuestion": {
      "slug": "number-of-islands",
      "title": "Number of Islands",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def countComponents(self, n, edges):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def countComponents(n, edges):\n    par = [i for i in range(n)]\n    rank = [1] * n\n    def find(n1):\n        res = n1\n        while res != par[res]:\n            par[res] = par[par[res]]\n            res = par[res]\n        return res\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2: return 0\n        if rank[p1] > rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        return 1\n    \n    res = n\n    for n1, n2 in edges:\n        res -= union(n1, n2)\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(E * \u03b1(n))",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Each node starts as its own component",
          "When we connect two nodes, we merge their components"
        ],
        "code": "def countComponents(n, edges):\n    \"\"\"\n    Intuition:\n    - Each node starts as its own component\n    - When we connect two nodes, we merge their components\n    \"\"\"\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py: return\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n    \n    for a, b in edges:  # Iterate over elements.\n        union(a, b)\n    \n    return len(set(find(x) for x in range(n)))  # Iterate through the range."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    countComponents(n, edges) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} n, edges\n     * @return {any}\n     */\n    countComponents(n, edges) {\n        const g = Array.from({ length: n }, () => []);\n        for (const [a, b] of edges) {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        const vis = Array(n).fill(false);\n        const dfs = i => {\n            if (vis[i]) {\n                return 0;\n            }\n            vis[i] = true;\n            for (const j of g[i]) {\n                dfs(j);\n        }\n        return 1;\n    };\n    return g.reduce((acc, _, i) => acc + dfs(i), 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int countComponents(int n, int[][] edges) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private List<Integer>[] g;\n    private boolean[] vis;\n\n    public int countComponents(int n, int[][] edges) {\n        g = new List[n];\n        vis = new boolean[n];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        for (var e : edges) {\n            int a = e[0], b = e[1];\n            g[a].add(b);\n            g[b].add(a);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += dfs(i);\n        }\n        return ans;\n    }\n\n    private int dfs(int i) {\n        if (vis[i]) {\n            return 0;\n        }\n        vis[i] = true;\n        for (int j : g[i]) {\n            dfs(j);\n        }\n        return 1;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int countComponents(int n, vector<vector<int>>& edges) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        vector<int> g[n];\n        for (auto& e : edges) {\n            int a = e[0], b = e[1];\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<bool> vis(n);\n        function<int(int)> dfs = [&](int i) {\n            if (vis[i]) {\n                return 0;\n            }\n            vis[i] = true;\n            for (int j : g[i]) {\n                dfs(j);\n            }\n            return 1;\n        };\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += dfs(i);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) countComponents(n int, edges [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) countComponents(n int, edges [][]int) (ans int) {\n\tg := make([][]int, n)\n\tfor _, e := range edges {\n\t\ta, b := e[0], e[1]\n\t\tg[a] = append(g[a], b)\n\t\tg[b] = append(g[b], a)\n\t}\n\tvis := make([]bool, n)\n\tvar dfs func(int) int\n\tdfs = func(i int) int {\n\t\tif vis[i] {\n\t\t\treturn 0\n\t\t}\n\t\tvis[i] = true\n\t\tfor _, j := range g[i] {\n\t\t\tdfs(j)\n\t\t}\n\t\treturn 1\n\t}\n\tfor i := range g {\n\t\tans += dfs(i)\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn count_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn count_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {\n        let mut p: Vec<usize> = (0..n as usize).collect();\n        let mut count = n;\n        for e in edges {\n            let root1 = Self::find(&mut p, e[0] as usize);\n            let root2 = Self::find(&mut p, e[1] as usize);\n            if root1 != root2 {\n                p[root1] = root2;\n                count -= 1;\n            }\n        }\n        count\n    }\n    fn find(p: &mut Vec<usize>, i: usize) -> usize {\n        if p[i] != i {\n            p[i] = Self::find(p, p[i]);\n        }\n        p[i]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def countComponents(self, n, edges):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    countComponents(n: number, edges: number[][]): number  {\n    const g: number[][] = Array.from({ length: n }, () => []);\n    for (const [a, b] of edges) {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    const vis: boolean[] = Array(n).fill(false);\n    const dfs = (i: number): number => {\n        if (vis[i]) {\n            return 0;\n        }\n        vis[i] = true;\n        for (const j of g[i]) {\n            dfs(j);\n        }\n        return 1;\n    };\n    return g.reduce((acc, _, i) => acc + dfs(i), 0);\n}\n}",
        "initialCode": "class Solution {\n    countComponents(n: number, edges: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
    "relatedProblems": [
      "detect-squares",
      "reverse-words-in-a-string",
      "populating-next-right-pointers-in-each-node-ii"
    ]
  },
  "graph-valid-tree": {
    "id": "graph-valid-tree",
    "slug": "graph-valid-tree",
    "title": "Graph Valid Tree",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
    "videoUrl": "",
    "pattern": "Union-Find",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use Union-Find to detect cycles and check connectivity.",
    "intuition": [
      "A tree with n nodes must have exactly n-1 edges",
      "Union-Find can detect cycles during union operations"
    ],
    "visualizationType": "tree",
    "initialState": [
      0,
      1,
      2,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Graph Valid Tree",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def validTree(self, n, edges):\n        \"\"\"\n        Intuition:\n        - A tree with n nodes must have exactly n-1 edges\n        - Union-Find can detect cycles during union operations\n        \"\"\"\n        if len(edges) != n - 1:\n            return False  # Condition not met.\n\n        parent = list(range(n))\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX == rootY:\n                return False  # Condition not met.\n            parent[rootX] = rootY\n            return True  # Condition satisfied.\n\n        for a, b in edges:  # Iterate over elements.\n            if not union(a, b):\n                return False  # Condition not met.\n\n        return True  # Condition satisfied.",
    "keyInsight": "A valid tree has exactly n-1 edges and no cycles.",
    "testCases": [
      {
        "input": "n = 5, edges = [[0,1], [0,2], [0,3], [1,4]]",
        "output": "true"
      },
      {
        "input": "n = 5, edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]",
        "output": "false"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Union-Find: Use Union-Find to detect cycles and check connectivity.",
    "videoId": "bXsUuownnoQ",
    "suggestedNextQuestion": {
      "slug": "integer-replacement",
      "title": "Integer Replacement",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like connecting cities with roads. You track which cities belong to the same network.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def validTree(self, n, edges):\n        pass\n\n        def find(x):\n            pass\n\n        def union(x, y):\n            pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def validTree(n, edges):\n    if not n: return True\n    adj = {i: [] for i in range(n)}\n    for n1, n2 in edges:\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n    \n    visit = set()\n    def dfs(i, prev):\n        if i in visit: return False\n        visit.add(i)\n        for j in adj[i]:\n            if j == prev: continue\n            if not dfs(j, i): return False\n        return True\n        \n    return dfs(0, -1) and n == len(visit)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "A tree with n nodes must have exactly n-1 edges",
          "Union-Find can detect cycles during union operations"
        ],
        "code": "def validTree(n, edges):\n    \"\"\"\n    Intuition:\n    - A tree with n nodes must have exactly n-1 edges\n    - Union-Find can detect cycles during union operations\n    \"\"\"\n    if len(edges) != n - 1:\n        return False  # Condition not met.\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return False  # Condition not met.\n        parent[rootX] = rootY\n        return True  # Condition satisfied.\n    \n    for a, b in edges:  # Iterate over elements.\n        if not union(a, b):\n            return False  # Condition not met.\n    \n    return True  # Condition satisfied."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() { }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean __init__(int n, int[][] edges) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean __init__(int n, int[][] edges) {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool validTree(int n, vector<vector<int>>& edges) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) validTree(n int, edges [][]int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) validTree(n int, edges [][]int) bool {\n\tp := make([]int, n)\n\tfor i := range p {\n\t\tp[i] = i\n\t}\n\tvar find func(int) int\n\tfind = func(x int) int {\n\t\tif p[x] != x {\n\t\t\tp[x] = find(p[x])\n\t\t}\n\t\treturn p[x]\n\t}\n\tfor _, e := range edges {\n\t\tpa, pb := find(e[0]), find(e[1])\n\t\tif pa == pb {\n\t\t\treturn false\n\t\t}\n\t\tp[pa] = pb\n\t\tn--\n\t}\n\treturn n == 1\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    n: usize,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let parent = (0..n).collect();\n        UnionFind { parent, n }\n    }\n    fn find(&mut self, i: usize) -> usize {\n        let j = self.parent[i];\n        if i == j {\n            i\n        } else {\n            let k = self.find(j);\n            self.parent[i] = k;\n            k\n        }\n    }\n\n    fn union(&mut self, i: usize, j: usize) -> bool {\n        let i = self.find(i);\n        let j = self.find(j);\n        if i != j {\n            self.parent[i] = j;\n            self.n -= 1;\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl Solution {\n    fn valid_tree(n: i32, edges: Vec<Vec<i32>>) -> bool {\n        let n = n as usize;\n        let mut uf = UnionFind::new(n);\n        for edge in edges {\n            let i = edge[0] as usize;\n            let j = edge[1] as usize;\n            if !uf.union(i, j) {\n                return false;\n            }\n        }\n        uf.n == 1\n    }\n}\n\n#[test]\nfn test() {\n    let n = 5;\n    let edges = vec_vec_i32![[0, 1], [0, 2], [0, 3], [1, 4]];\n    let res = true;\n    assert_eq!(Solution::valid_tree(n, edges), res);\n    let n = 5;\n    let edges = vec_vec_i32![[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]];\n    let res = false;\n    assert_eq!(Solution::valid_tree(n, edges), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def validTree(self, n, edges):\n        pass\n\n        def find(x):\n            pass\n\n        def union(x, y):\n            pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
    "relatedProblems": [
      "kth-largest-element-in-an-array",
      "partition-equal-subset-sum",
      "search-a-2d-matrix"
    ]
  },
  "reconstruct-itinerary": {
    "id": "reconstruct-itinerary",
    "slug": "reconstruct-itinerary",
    "title": "Reconstruct Itinerary",
    "difficulty": "Hard",
    "category": "Graph General",
    "problemStatement": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
    "videoUrl": "",
    "pattern": "Hierholzer's Algorithm / DFS",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(E log E)",
    "spaceComplexity": "O(V + E)",
    "oneliner": "Use DFS with lexical ordering to traverse all edges exactly once.",
    "intuition": [
      "This is an Eulerian path problem - we must visit each ticket (edge) exactly once",
      "Since we want lexical order, we sort destinations and use post-order DFS traversal"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        "JFK",
        "SFO"
      ],
      [
        "JFK",
        "ATL"
      ],
      [
        "SFO",
        "ATL"
      ],
      [
        "ATL",
        "JFK"
      ],
      [
        "ATL",
        "SFO"
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reconstruct Itinerary",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = JFK,SFO",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = JFK,ATL",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = SFO,ATL",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = ATL,JFK",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = ATL,SFO",
        "transientMessage": "Iteration 5",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            "JFK",
            "SFO"
          ],
          [
            "JFK",
            "ATL"
          ],
          [
            "SFO",
            "ATL"
          ],
          [
            "ATL",
            "JFK"
          ],
          [
            "ATL",
            "SFO"
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def findItinerary(self, tickets):\n        \"\"\"\n        Intuition:\n        - This is an Eulerian path problem - we must visit each ticket (edge) exactly once\n        - Since we want lexical order, we sort destinations and use post-order DFS traversal\n        \"\"\"\n        from collections import defaultdict\n        import heapq\n\n        # Build adjacency list with min-heap for lexical order\n        graph = defaultdict(list)\n        for src, dst in tickets:  # Iterate over elements.\n            heapq.heappush(graph[src], dst)\n\n        result = []\n\n        def dfs(node):\n            # Visit all neighbors in lexical order\n            while graph[node]:\n                next_node = heapq.heappop(graph[node])  # Remove and return last element.\n                dfs(next_node)\n            # Post-order: add to result after visiting children\n            result.append(node)  # Add to end.\n\n        dfs(\"JFK\")\n        return result[::-1]  # Reverse to get correct order",
    "keyInsight": "Use post-order DFS with lexical sorting to ensure correct itinerary order.",
    "testCases": [
      {
        "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
        "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
      },
      {
        "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
        "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Hierholzer's Algorithm / DFS: Use DFS with lexical ordering to traverse all edges exactly once.",
    "videoId": "ZyB_gQ8vqGA",
    "suggestedNextQuestion": {
      "slug": "swim-in-rising-water",
      "title": "Swim In Rising Water",
      "difficulty": "Hard",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def findItinerary(self, tickets):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def findItinerary(tickets):\n    adj = {src: [] for src, dst in tickets}\n    tickets.sort()\n    for src, dst in tickets:\n        adj.setdefault(src, []).append(dst)\n        \n    res = []\n    def dfs(src):\n        while adj.get(src, []):\n            next_dst = adj[src].pop(0)\n            dfs(next_dst)\n        res.append(src)\n    dfs(\"JFK\")\n    return res[::-1]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(E log E)",
        "spaceComplexity": "O(V + E)",
        "intuition": [
          "This is an Eulerian path problem - we must visit each ticket (edge) exactly once",
          "Since we want lexical order, we sort destinations and use post-order DFS traversal"
        ],
        "code": "def findItinerary(tickets):\n    \"\"\"\n    Intuition:\n    - This is an Eulerian path problem - we must visit each ticket (edge) exactly once\n    - Since we want lexical order, we sort destinations and use post-order DFS traversal\n    \"\"\"\n    from collections import defaultdict\n    import heapq\n    \n    # Build adjacency list with min-heap for lexical order\n    graph = defaultdict(list)\n    for src, dst in tickets:  # Iterate over elements.\n        heapq.heappush(graph[src], dst)\n    \n    result = []\n    \n    def dfs(node):\n        # Visit all neighbors in lexical order\n        while graph[node]:\n            next_node = heapq.heappop(graph[node])  # Remove and return last element.\n            dfs(next_node)\n        # Post-order: add to result after visiting children\n        result.append(node)  # Add to end.\n    \n    dfs(\"JFK\")\n    return result[::-1]  # Reverse to get correct order"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    findItinerary(tickets) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} tickets\n     * @return {any}\n     */\n    findItinerary(tickets) {\n        const graph = new Map();\n        const itinerary = [];\n\n        for (const [from, to] of tickets) {\n          if (!graph.has(from)) {\n            graph.set(from, []);\n          }\n          graph.get(from).push(to);\n        }\n\n        for (const [_, destinations] of graph) {\n          destinations.sort().reverse();\n        }\n\n        dfs('JFK');\n\n        return itinerary.reverse();\n\n        class Solution {\n          /**\n           * @param {any} airport\n           * @return {any}\n           */\n          dfs(airport) {\n          while (graph.has(airport) && graph.get(airport).length) {\n            dfs(graph.get(airport).pop());\n          }\n          itinerary.push(airport);\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private Map<String, List<String>> g = new HashMap<>();\n    private List<String> ans = new ArrayList<>();\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Collections.sort(tickets, (a, b) -> b.get(1).compareTo(a.get(1)));\n        for (List<String> ticket : tickets) {\n            g.computeIfAbsent(ticket.get(0), k -> new ArrayList<>()).add(ticket.get(1));\n        }\n        dfs(\"JFK\");\n        Collections.reverse(ans);\n        return ans;\n    }\n\n    private void dfs(String f) {\n        while (g.containsKey(f) && !g.get(f).isEmpty()) {\n            String t = g.get(f).remove(g.get(f).size() - 1);\n            dfs(t);\n        }\n        ans.add(f);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        sort(tickets.rbegin(), tickets.rend());\n        unordered_map<string, vector<string>> g;\n        for (const auto& ticket : tickets) {\n            g[ticket[0]].push_back(ticket[1]);\n        }\n        vector<string> ans;\n        auto dfs = [&](this auto&& dfs, string& f) -> void {\n            while (!g[f].empty()) {\n                string t = g[f].back();\n                g[f].pop_back();\n                dfs(t);\n            }\n            ans.emplace_back(f);\n        };\n        string f = \"JFK\";\n        dfs(f);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findItinerary(tickets [][]string) (ans []string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findItinerary(tickets [][]string) (ans []string) {\n\tsort.Slice(tickets, func(i, j int) bool {\n\t\treturn tickets[i][0] > tickets[j][0] || (tickets[i][0] == tickets[j][0] && tickets[i][1] > tickets[j][1])\n\t})\n\tg := make(map[string][]string)\n\tfor _, ticket := range tickets {\n\t\tg[ticket[0]] = append(g[ticket[0]], ticket[1])\n\t}\n\tvar dfs func(f string)\n\tdfs = func(f string) {\n\t\tfor len(g[f]) > 0 {\n\t\t\tt := g[f][len(g[f])-1]\n\t\t\tg[f] = g[f][:len(g[f])-1]\n\t\t\tdfs(t)\n\t\t}\n\t\tans = append(ans, f)\n\t}\n\tdfs(\"JFK\")\n\tfor i := 0; i < len(ans)/2; i++ {\n\t\tans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i]\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_itinerary(tickets: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\n\ntype G = HashMap<String, BinaryHeap<Reverse<String>>>;\n\nimpl Solution {\n    fn find_itinerary(tickets: Vec<Vec<String>>) -> Vec<String> {\n        let mut res: Vec<String> = vec![];\n        let mut g: G = HashMap::new();\n        for ticket in tickets {\n            g.entry(ticket[0].clone())\n                .or_default()\n                .push(Reverse(ticket[1].clone()));\n        }\n        let mut stack: Vec<String> = vec![\"JFK\".to_string()];\n        while !stack.is_empty() {\n            while g.contains_key(stack.last().unwrap())\n                && !g.get(stack.last().unwrap()).unwrap().is_empty()\n            {\n                let airports = g.get_mut(stack.last().unwrap()).unwrap();\n                let airport = airports.pop().unwrap().0;\n                stack.push(airport);\n            }\n            res.insert(0, stack.pop().unwrap());\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let tickets: Vec<Vec<String>> = vec_vec_string![\n        [\"MUC\", \"LHR\"],\n        [\"JFK\", \"MUC\"],\n        [\"SFO\", \"SJC\"],\n        [\"LHR\", \"SFO\"]\n    ];\n    let res: Vec<String> = vec_string![\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"];\n    assert_eq!(Solution::find_itinerary(tickets), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findItinerary(self, tickets):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findItinerary(tickets: string[][]): string[]  {\n    const g: Record<string, string[]> = {};\n    tickets.sort((a, b) => b[1].localeCompare(a[1]));\n    for (const [f, t] of tickets) {\n        g[f] = g[f] || [];\n        g[f].push(t);\n    }\n    const ans: string[] = [];\n    const dfs = (f: string) => {\n        while (g[f] && g[f].length) {\n            const t = g[f].pop()!;\n            dfs(t);\n        }\n        ans.push(f);\n    };\n    dfs('JFK');\n    return ans.reverse();\n}\n}",
        "initialCode": "class Solution {\n    findItinerary(tickets: string[][]): string[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
    "relatedProblems": [
      "distinct-subsequences",
      "largest-rectangle-in-histogram",
      "minimum-interval-to-include-each-query"
    ]
  },
  "min-cost-to-connect-all-points": {
    "id": "min-cost-to-connect-all-points",
    "slug": "min-cost-to-connect-all-points",
    "title": "Min Cost to Connect All Points",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
    "videoUrl": "",
    "pattern": "Minimum Spanning Tree (Kruskal's)",
    "patternEmoji": "\ud83d\udd17",
    "timeComplexity": "O(n\u00b2 log n)",
    "spaceComplexity": "O(n\u00b2)",
    "oneliner": "Use Kruskal's algorithm with Union-Find to find MST.",
    "intuition": [
      "We need to connect all points with minimum total cost",
      "This is a classic Minimum Spanning Tree problem"
    ],
    "visualizationType": "graph",
    "initialState": [
      [
        0,
        0
      ],
      [
        2,
        2
      ],
      [
        3,
        10
      ],
      [
        5,
        2
      ],
      [
        7,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Min Cost to Connect All Points",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 0,0",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2,2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3,10",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 5,2",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 7,0",
        "transientMessage": "Iteration 5",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            0,
            0
          ],
          [
            2,
            2
          ],
          [
            3,
            10
          ],
          [
            5,
            2
          ],
          [
            7,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    def minCostConnectPoints(self, points):\n        \"\"\"\n        Intuition:\n        - We need to connect all points with minimum total cost\n        - This is a classic Minimum Spanning Tree problem\n        \"\"\"\n        n = len(points)\n        if n <= 1:\n            return 0\n        \n        # Generate all edges with Manhattan distances\n        edges = []\n        for i in range(n):  # Iterate through the range.\n            for j in range(i+1, n):  # Iterate through the range.\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                edges.append((dist, i, j))  # Add to end.\n        \n        # Sort edges by distance\n        edges.sort()\n        \n        # Union-Find data structure\n        parent = list(range(n))\n        \n        def find(self, x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])  # Path compression\n            return parent[x]\n        \n        def union(self, x, y):\n            root_x, root_y = find(x), find(y)\n            if root_x != root_y:\n                parent[root_x] = root_y\n                return True  # Condition satisfied.\n            return False  # Condition not met.\n        \n        # Kruskal's algorithm\n        total_cost = 0\n        edges_used = 0\n        \n        for dist, u, v in edges:  # Iterate over elements.\n            if union(u, v):\n                total_cost += dist\n                edges_used += 1\n                if edges_used == n - 1:\n                    break\n        \n        return total_cost",
    "keyInsight": "Connect points using minimum Manhattan distances without forming cycles.",
    "testCases": [
      {
        "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
        "output": "20"
      },
      {
        "input": "points = [[3,12],[-2,5],[-4,1]]",
        "output": "18"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Minimum Spanning Tree (Kruskal's): Use Kruskal's algorithm with Union-Find to find MST.",
    "videoId": "f7JOBJIC-NA",
    "suggestedNextQuestion": {
      "slug": "populating-next-right-pointers-in-each-node-ii",
      "title": "Populating Next Right Pointers in Each Node II",
      "difficulty": "Medium",
      "pattern": "Trees"
    },
    "mentalModel": "Like a family tree. Every node has a parent and children.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n) per operation",
        "spaceComplexity": "O(h) recursion stack",
        "intuition": [
          "Traverse the entire tree for each query.",
          "No optimization, just direct exploration."
        ],
        "code": "def __init___brute(root):\n    if not root:\n        return None\n    # Visit every node\n    left = __init___brute(root.left)\n    right = __init___brute(root.right)\n    return combine(root.val, left, right)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2 log n)",
        "spaceComplexity": "O(n\u00b2)",
        "intuition": [
          "We need to connect all points with minimum total cost",
          "This is a classic Minimum Spanning Tree problem"
        ],
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef minCostConnectPoints(points):\n    \"\"\"\n    Intuition:\n    - We need to connect all points with minimum total cost\n    - This is a classic Minimum Spanning Tree problem\n    \"\"\"\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Generate all edges with Manhattan distances\n    edges = []\n    for i in range(n):  # Iterate through the range.\n        for j in range(i+1, n):  # Iterate through the range.\n            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            edges.append((dist, i, j))  # Add to end.\n    \n    # Sort edges by distance\n    edges.sort()\n    \n    # Union-Find data structure\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parent[root_x] = root_y\n            return True  # Condition satisfied.\n        return False  # Condition not met.\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    edges_used = 0\n    \n    for dist, u, v in edges:  # Iterate over elements.\n        if union(u, v):\n            total_cost += dist\n            edges_used += 1\n            if edges_used == n - 1:\n                break\n    \n    return total_cost"
      }
    ],
    "examples": [
      {
        "input": "root = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Traverse tree structure."
      },
      {
        "input": "root = []",
        "output": "null",
        "explanation": "Empty tree edge case."
      }
    ],
    "constraints": [
      "Number of nodes: [0, 10^4]",
      "-10^4 <= Node.val <= 10^4"
    ],
    "commonMistakes": [
      "Not handling null/empty tree",
      "Incorrect traversal order",
      "Stack overflow on deep trees"
    ],
    "interviewTip": "Ask: BST or general tree? Discuss iterative vs recursive trade-offs.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(points: number[][]) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(points: number[][]) {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minCostConnectPoints(points [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minCostConnectPoints(points [][]int) (ans int) {\n\tn := len(points)\n\tg := make([][]int, n)\n\tvis := make([]bool, n)\n\tdist := make([]int, n)\n\tfor i := range g {\n\t\tg[i] = make([]int, n)\n\t\tdist[i] = 1 << 30\n\t}\n\tfor i := range g {\n\t\tx1, y1 := points[i][0], points[i][1]\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tx2, y2 := points[j][0], points[j][1]\n\t\t\tt := abs(x1-x2) + abs(y1-y2)\n\t\t\tg[i][j] = t\n\t\t\tg[j][i] = t\n\t\t}\n\t}\n\tdist[0] = 0\n\tfor i := 0; i < n; i++ {\n\t\tj := -1\n\t\tfor k := 0; k < n; k++ {\n\t\t\tif !vis[k] && (j == -1 || dist[k] < dist[j]) {\n\t\t\t\tj = k\n\t\t\t}\n\t\t}\n\t\tvis[j] = true\n\t\tans += dist[j]\n\t\tfor k := 0; k < n; k++ {\n\t\t\tif !vis[k] {\n\t\t\t\tdist[k] = min(dist[k], g[j][k])\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\n\nuse std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    n: usize,\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let parent = (0..n).collect();\n        UnionFind { parent, n }\n    }\n\n    fn find(&mut self, i: usize) -> usize {\n        let j = self.parent[i];\n        if i == j {\n            i\n        } else {\n            let k = self.find(j);\n            self.parent[i] = k;\n            k\n        }\n    }\n\n    fn union(&mut self, mut i: usize, mut j: usize) -> bool {\n        i = self.find(i);\n        j = self.find(j);\n        if i != j {\n            self.parent[i] = j;\n            self.n -= 1;\n            true\n        } else {\n            false\n        }\n    }\n}\n\nimpl Solution {\n    fn min_cost_connect_points(points: Vec<Vec<i32>>) -> i32 {\n        let n = points.len();\n        let mut queue: BinaryHeap<(Reverse<i32>, usize, usize)> = BinaryHeap::new();\n        for i in 0..n {\n            for j in i + 1..n {\n                queue.push((Reverse(Self::dist(&points[i], &points[j])), i, j));\n            }\n        }\n        let mut uf = UnionFind::new(n);\n        let mut res = 0;\n        while let Some((Reverse(d), i, j)) = queue.pop() {\n            if uf.union(i, j) {\n                res += d;\n            }\n            if uf.n == 1 {\n                break;\n            }\n        }\n        res\n    }\n\n    fn dist(a: &[i32], b: &[i32]) -> i32 {\n        (a[0] - b[0]).abs() + (a[1] - b[1]).abs()\n    }\n}\n\n#[test]\nfn test() {\n    let points = vec_vec_i32![[0, 0], [2, 2], [3, 10], [5, 2], [7, 0]];\n    let res = 20;\n    assert_eq!(Solution::min_cost_connect_points(points), res);\n    let points = vec_vec_i32![[3, 12], [-2, 5], [-4, 1]];\n    let res = 18;\n    assert_eq!(Solution::min_cost_connect_points(points), res);\n    let points = vec_vec_i32![[0, 0], [1, 1], [1, 0], [-1, 1]];\n    let res = 4;\n    assert_eq!(Solution::min_cost_connect_points(points), res);\n    let points = vec_vec_i32![[-1000000, -1000000], [1000000, 1000000]];\n    let res = 4000000;\n    assert_eq!(Solution::min_cost_connect_points(points), res);\n    let points = vec_vec_i32![[0, 0]];\n    let res = 0;\n    assert_eq!(Solution::min_cost_connect_points(points), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n    \n    minCostConnectAllPoints(points: number[][]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
    "relatedProblems": [
      "interleaving-string",
      "merge-triplets-to-form-target-triplet",
      "remove-nth-node-from-end-of-list"
    ]
  },
  "network-delay-time": {
    "id": "network-delay-time",
    "slug": "network-delay-time",
    "title": "Network Delay Time",
    "difficulty": "Medium",
    "category": "Graph General",
    "problemStatement": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
    "videoUrl": "",
    "pattern": "Dijkstra's Algorithm",
    "patternEmoji": "\ud83d\udcd0",
    "timeComplexity": "O(E log V)",
    "spaceComplexity": "O(V + E)",
    "oneliner": "Use Dijkstra's algorithm to find shortest paths from source node.",
    "intuition": [
      "We need to find the shortest path from node k to all other nodes",
      "Dijkstra's algorithm works because all edge weights are non-negative"
    ],
    "visualizationType": "graph",
    "initialState": [
      1,
      2,
      3,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Weighted Graph",
        "transientMessage": "times=[[2,1,1],[2,3,1],[3,4,1]]",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 (src)",
              "x": 200,
              "y": 50
            },
            {
              "id": "3",
              "label": "3",
              "x": 300,
              "y": 150
            },
            {
              "id": "4",
              "label": "4",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "2",
              "to": "1",
              "weight": 1
            },
            {
              "from": "2",
              "to": "3",
              "weight": 1
            },
            {
              "from": "3",
              "to": "4",
              "weight": 1
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Dijkstra: dist[2]=0",
        "transientMessage": "All others = \u221e",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 (\u221e)",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 (0)",
              "x": 200,
              "y": 50,
              "highlight": true
            },
            {
              "id": "3",
              "label": "3 (\u221e)",
              "x": 300,
              "y": 150
            },
            {
              "id": "4",
              "label": "4 (\u221e)",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "2",
              "to": "1",
              "weight": 1
            },
            {
              "from": "2",
              "to": "3",
              "weight": 1
            },
            {
              "from": "3",
              "to": "4",
              "weight": 1
            }
          ]
        },
        "pointers": [
          {
            "label": "curr",
            "node": "2"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Relax: dist[1,3]=1",
        "transientMessage": "Update neighbors",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 (1)",
              "x": 100,
              "y": 150,
              "highlight": true
            },
            {
              "id": "2",
              "label": "2 (0)",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "3",
              "label": "3 (1)",
              "x": 300,
              "y": 150,
              "highlight": true
            },
            {
              "id": "4",
              "label": "4 (\u221e)",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "2",
              "to": "1",
              "weight": 1,
              "highlight": true
            },
            {
              "from": "2",
              "to": "3",
              "weight": 1,
              "highlight": true
            },
            {
              "from": "3",
              "to": "4",
              "weight": 1
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Relax: dist[4]=2",
        "transientMessage": "From node 3",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 (1) \u2713",
              "x": 100,
              "y": 150,
              "visited": true
            },
            {
              "id": "2",
              "label": "2 (0) \u2713",
              "x": 200,
              "y": 50,
              "visited": true
            },
            {
              "id": "3",
              "label": "3 (1) \u2713",
              "x": 300,
              "y": 150,
              "visited": true
            },
            {
              "id": "4",
              "label": "4 (2)",
              "x": 400,
              "y": 150,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "2",
              "to": "1",
              "weight": 1
            },
            {
              "from": "2",
              "to": "3",
              "weight": 1
            },
            {
              "from": "3",
              "to": "4",
              "weight": 1,
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Result: max=2",
        "transientMessage": "All nodes reachable",
        "graphState": {
          "nodes": [
            {
              "id": "1",
              "label": "1 (1)",
              "x": 100,
              "y": 150
            },
            {
              "id": "2",
              "label": "2 (0)",
              "x": 200,
              "y": 50
            },
            {
              "id": "3",
              "label": "3 (1)",
              "x": 300,
              "y": 150
            },
            {
              "id": "4",
              "label": "4 (2)",
              "x": 400,
              "y": 150
            }
          ],
          "edges": [
            {
              "from": "2",
              "to": "1",
              "weight": 1
            },
            {
              "from": "2",
              "to": "3",
              "weight": 1
            },
            {
              "from": "3",
              "to": "4",
              "weight": 1
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "2"
          }
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def networkDelayTime(self, times, n, k):\n        \"\"\"\n        Intuition:\n        - We need to find the shortest path from node k to all other nodes\n        - Dijkstra's algorithm works because all edge weights are non-negative\n        \"\"\"\n        # Build adjacency list\n        graph = [[] for _ in range(n + 1)]  # Iterate through the range.\n        for u, v, w in times:  # Iterate over elements.\n            graph[u].append((v, w))  # Add to end.\n        \n        # Distance array\n        dist = [float('inf')] * (n + 1)\n        dist[k] = 0\n        \n        # Priority queue\n        pq = [(0, k)]\n        \n        while pq:\n            d, node = heapq.heappop(pq)  # Remove and return last element.\n            \n            if d > dist[node]:\n                continue\n                \n            for neighbor, weight in graph[node]:  # Iterate over elements.\n                if dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(pq, (dist[neighbor], neighbor))\n        \n        # Find maximum delay\n        max_delay = max(dist[1:])  # Take the maximum value.\n        return max_delay if max_delay != float('inf') else -1",
    "keyInsight": "Use Dijkstra's algorithm to find shortest path from source to all nodes.",
    "testCases": [
      {
        "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
        "output": "2"
      },
      {
        "input": "times = [[1,2,1]], n = 2, k = 1",
        "output": "1"
      },
      {
        "input": "times = [[1,2,1]], n = 2, k = 2",
        "output": "-1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Dijkstra's Algorithm: Use Dijkstra's algorithm to find shortest paths from source node.",
    "videoId": "EaphyqKU4PQ",
    "suggestedNextQuestion": {
      "slug": "number-of-connected-components-in-an-undirected-graph",
      "title": "Number of Connected Components In An Undirected Graph",
      "difficulty": "Medium",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def networkDelayTime(times, n, k):\n    # Dijkstra\n    import heapq\n    edges = { i: [] for i in range(1, n+1)}\n    for u, v, w in times:\n        edges[u].append((v, w))\n    \n    minHeap = [(0, k)]\n    visit = set()\n    t = 0\n    while minHeap:\n        w1, n1 = heapq.heappop(minHeap)\n        if n1 in visit: continue\n        visit.add(n1)\n        t = max(t, w1)\n        for n2, w2 in edges[n1]:\n            if n2 not in visit:\n                heapq.heappush(minHeap, (w1 + w2, n2))\n    return t if len(visit) == n else -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(E log V)",
        "spaceComplexity": "O(V + E)",
        "intuition": [
          "We need to find the shortest path from node k to all other nodes",
          "Dijkstra's algorithm works because all edge weights are non-negative"
        ],
        "code": "import heapq\n\ndef networkDelayTime(times, n, k):\n    \"\"\"\n    Intuition:\n    - We need to find the shortest path from node k to all other nodes\n    - Dijkstra's algorithm works because all edge weights are non-negative\n    \"\"\"\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]  # Iterate through the range.\n    for u, v, w in times:  # Iterate over elements.\n        graph[u].append((v, w))  # Add to end.\n    \n    # Distance array\n    dist = [float('inf')] * (n + 1)\n    dist[k] = 0\n    \n    # Priority queue\n    pq = [(0, k)]\n    \n    while pq:\n        d, node = heapq.heappop(pq)  # Remove and return last element.\n        \n        if d > dist[node]:\n            continue\n            \n        for neighbor, weight in graph[node]:  # Iterate over elements.\n            if dist[node] + weight < dist[neighbor]:\n                dist[neighbor] = dist[node] + weight\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n    \n    # Find maximum delay\n    max_delay = max(dist[1:])  # Take the maximum value.\n    return max_delay if max_delay != float('inf') else -1"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(int[][] times, int N, int K) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int solve(int[][] times, int N, int K) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(vector<vector<int>>& times, int n, int k) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(vector<vector<int>>& times, int n, int k) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) networkDelayTime(times [][]int, n int, k int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) networkDelayTime(times [][]int, n int, k int) int {\n\tconst inf = 1 << 29\n\tg := make([][]int, n)\n\tfor i := range g {\n\t\tg[i] = make([]int, n)\n\t\tfor j := range g[i] {\n\t\t\tg[i][j] = inf\n\t\t}\n\t}\n\tfor _, e := range times {\n\t\tg[e[0]-1][e[1]-1] = e[2]\n\t}\n\n\tdist := make([]int, n)\n\tfor i := range dist {\n\t\tdist[i] = inf\n\t}\n\tdist[k-1] = 0\n\n\tvis := make([]bool, n)\n\tfor i := 0; i < n; i++ {\n\t\tt := -1\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif !vis[j] && (t == -1 || dist[t] > dist[j]) {\n\t\t\t\tt = j\n\t\t\t}\n\t\t}\n\t\tvis[t] = true\n\t\tfor j := 0; j < n; j++ {\n\t\t\tdist[j] = min(dist[j], dist[t]+g[t][j])\n\t\t}\n\t}\n\n\tif ans := slices.Max(dist); ans != inf {\n\t\treturn ans\n\t}\n\treturn -1\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn network_delay_time(times: i32, n: i32, k: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn network_delay_time(times: Vec<Vec<i32>>, n: i32, k: i32) -> i32 {\n        let n = n as usize;\n        let k = k as usize - 1;\n        let mut graph: Vec<Vec<(usize, i32)>> = vec![vec![]; n];\n        for time in times {\n            let u = time[0] as usize - 1;\n            let v = time[1] as usize - 1;\n            let t = time[2];\n            graph[u].push((v, t));\n        }\n        let mut visited = vec![std::i32::MAX; n];\n        let mut queue = VecDeque::new();\n        visited[k] = 0;\n        queue.push_back(k);\n        while let Some(u) = queue.pop_front() {\n            for &(v, t) in &graph[u] {\n                if t + visited[u] < visited[v] {\n                    visited[v] = t + visited[u];\n                    queue.push_back(v);\n                }\n            }\n        }\n        let max = visited.into_iter().max().unwrap();\n        if max == std::i32::MAX {\n            -1\n        } else {\n            max\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let times = vec_vec_i32![[2, 1, 1], [2, 3, 1], [3, 4, 1]];\n    let n = 4;\n    let k = 2;\n    let res = 2;\n    assert_eq!(Solution::network_delay_time(times, n, k), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(time: number[][], n: number, k: number): number {\n        return -1;\n    }\n}",
        "initialCode": "class Solution {\n    solve(time: number[][], n: number, k: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.",
    "relatedProblems": [
      "permutations",
      "add-two-numbers",
      "binary-tree-right-side-view"
    ]
  },
  "swim-in-rising-water": {
    "id": "swim-in-rising-water",
    "slug": "swim-in-rising-water",
    "title": "Swim in Rising Water",
    "difficulty": "Hard",
    "category": "Graph General",
    "problemStatement": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nIt starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nReturn the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
    "videoUrl": "",
    "pattern": "Binary Search + DFS",
    "patternEmoji": "\ud83d\udd0d\ud83d\udd78\ufe0f",
    "timeComplexity": "O(n\u00b2 log n)",
    "spaceComplexity": "O(n\u00b2)",
    "oneliner": "Binary search on time values, use DFS to check if path exists.",
    "intuition": [
      "We want the minimum time t where a path exists from (0,0) to (n-1,n-1)",
      "For a given time t, we can check connectivity using DFS/BFS"
    ],
    "visualizationType": "graph",
    "initialState": [
      [
        0,
        2
      ],
      [
        1,
        3
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Grid as Graph",
        "transientMessage": "Each cell is a node",
        "graphState": {
          "nodes": [
            {
              "id": "00",
              "label": "0",
              "x": 100,
              "y": 100
            },
            {
              "id": "01",
              "label": "1",
              "x": 200,
              "y": 100
            },
            {
              "id": "10",
              "label": "2",
              "x": 100,
              "y": 200
            },
            {
              "id": "11",
              "label": "3",
              "x": 200,
              "y": 200
            }
          ],
          "edges": [
            {
              "from": "00",
              "to": "01"
            },
            {
              "from": "00",
              "to": "10"
            },
            {
              "from": "01",
              "to": "11"
            },
            {
              "from": "10",
              "to": "11"
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Binary Search t=3",
        "transientMessage": "Can we reach end?",
        "graphState": {
          "nodes": [
            {
              "id": "00",
              "label": "0 (start)",
              "x": 100,
              "y": 100,
              "highlight": true
            },
            {
              "id": "01",
              "label": "1",
              "x": 200,
              "y": 100
            },
            {
              "id": "10",
              "label": "2",
              "x": 100,
              "y": 200
            },
            {
              "id": "11",
              "label": "3 (end)",
              "x": 200,
              "y": 200,
              "highlight": true
            }
          ],
          "edges": [
            {
              "from": "00",
              "to": "01"
            },
            {
              "from": "00",
              "to": "10"
            },
            {
              "from": "01",
              "to": "11"
            },
            {
              "from": "10",
              "to": "11"
            }
          ]
        },
        "pointers": [
          {
            "label": "t",
            "value": "3"
          }
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Result: t=3",
        "transientMessage": "Path found!",
        "graphState": {
          "nodes": [
            {
              "id": "00",
              "label": "0 \u2713",
              "x": 100,
              "y": 100,
              "visited": true
            },
            {
              "id": "01",
              "label": "1 \u2713",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "10",
              "label": "2",
              "x": 100,
              "y": 200
            },
            {
              "id": "11",
              "label": "3 \u2713",
              "x": 200,
              "y": 200,
              "visited": true
            }
          ],
          "edges": [
            {
              "from": "00",
              "to": "01",
              "highlight": true
            },
            {
              "from": "00",
              "to": "10"
            },
            {
              "from": "01",
              "to": "11",
              "highlight": true
            },
            {
              "from": "10",
              "to": "11"
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "3"
          }
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def swimInWater(self, grid):\n        \"\"\"\n        Intuition:\n        - We want the minimum time t where a path exists from (0,0) to (n-1,n-1)\n        - For a given time t, we can check connectivity using DFS/BFS\n        \"\"\"\n        n = len(grid)\n\n        def canReach(t):\n            if grid[0][0] > t: return False  # Condition not met.\n            stack = [(0, 0)]\n            visited = set()\n\n            while stack:\n                x, y = stack.pop()  # Remove and return last element.\n                if x == n-1 and y == n-1:\n                    return True  # Condition satisfied.\n                if (x, y) in visited:\n                    continue\n                visited.add((x, y))\n\n                for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:  # Iterate over elements.\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= t:\n                        stack.append((nx, ny))  # Add to end.\n            return False  # Condition not met.\n\n        left, right = 0, n * n - 1\n        while left < right:\n            mid = (left + right) // 2\n            if canReach(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left",
    "keyInsight": "Binary search on the answer. For each candidate time, check if destination is reachable.",
    "testCases": [
      {
        "input": "grid = [[0,2],[1,3]]",
        "output": "3"
      },
      {
        "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
        "output": "16"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Binary Search + DFS: Binary search on time values, use DFS to check if path exists.",
    "videoId": "amvrKlMLuGY",
    "suggestedNextQuestion": {
      "slug": "word-ladder",
      "title": "Word Ladder",
      "difficulty": "Hard",
      "pattern": "Graphs"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def swimInWater(self, grid):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def swimInWater_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2 log n)",
        "spaceComplexity": "O(n\u00b2)",
        "intuition": [
          "We want the minimum time t where a path exists from (0,0) to (n-1,n-1)",
          "For a given time t, we can check connectivity using DFS/BFS"
        ],
        "code": "def swimInWater(grid):\n    \"\"\"\n    Intuition:\n    - We want the minimum time t where a path exists from (0,0) to (n-1,n-1)\n    - For a given time t, we can check connectivity using DFS/BFS\n    \"\"\"\n    n = len(grid)\n    \n    def canReach(t):\n        if grid[0][0] > t: return False  # Condition not met.\n        stack = [(0, 0)]\n        visited = set()\n        \n        while stack:\n            x, y = stack.pop()  # Remove and return last element.\n            if x == n-1 and y == n-1:\n                return True  # Condition satisfied.\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            \n            for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:  # Iterate over elements.\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= t:\n                    stack.append((nx, ny))  # Add to end.\n        return False  # Condition not met.\n    \n    left, right = 0, n * n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if canReach(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 3",
        "output": "2",
        "explanation": "Target found at index 2."
      },
      {
        "input": "nums = [1, 2, 3], target = 0",
        "output": "-1",
        "explanation": "Target not found."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "Array is sorted"
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    swimInWater(grid) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} grid\n     * @return {any}\n     */\n    swimInWater(grid) {\n        const n = grid.length;\n        let left = grid[0][0];\n        let right = n * n - 1;\n\n        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n        const canReachDestination = (time) => {\n          if (grid[0][0] > time) return false;\n\n          const visited = Array(n).fill().map(() => Array(n).fill(false));\n          const queue = [[0, 0]];\n          visited[0][0] = true;\n\n          while (queue.length > 0) {\n            const [row, col] = queue.shift();\n\n            if (row === n - 1 && col === n - 1) {\n              return true;\n            }\n\n            for (const [dr, dc] of directions) {\n              const newRow = row + dr;\n              const newCol = col + dc;\n\n              if (\n                newRow >= 0 && newRow < n && newCol >= 0 && newCol < n\n                && !visited[newRow][newCol] && grid[newRow][newCol] <= time\n              ) {\n                queue.push([newRow, newCol]);\n                visited[newRow][newCol] = true;\n              }\n            }\n          }\n\n          return false;\n        };\n\n        while (left < right) {\n          const mid = Math.floor((left + right) / 2);\n\n          if (canReachDestination(mid)) {\n            right = mid;\n          } else {\n            left = mid + 1;\n          }\n      }\n\n    return left;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int swimInWater(int[][] grid) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int m = n * n;\n        int[] p = new int[m];\n        Arrays.setAll(p, i -> i);\n        IntUnaryOperator find = new IntUnaryOperator() {\n            @Override\n            public int applyAsInt(int x) {\n                if (p[x] != x) p[x] = applyAsInt(p[x]);\n                return p[x];\n            }\n        };\n\n        int[] hi = new int[m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                hi[grid[i][j]] = i * n + j;\n            }\n        }\n\n        int[] dirs = {-1, 0, 1, 0, -1};\n\n        for (int t = 0; t < m; t++) {\n            int id = hi[t];\n            int x = id / n, y = id % n;\n            for (int k = 0; k < 4; k++) {\n                int nx = x + dirs[k], ny = y + dirs[k + 1];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] <= t) {\n                    int a = find.applyAsInt(x * n + y);\n                    int b = find.applyAsInt(nx * n + ny);\n                    p[a] = b;\n                }\n            }\n            if (find.applyAsInt(0) == find.applyAsInt(m - 1)) {\n                return t;\n            }\n        }\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int swimInWater(vector<vector<int>>& grid) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = n * n;\n        vector<int> p(m);\n        iota(p.begin(), p.end(), 0);\n\n        auto find = [&](this auto&& find, int x) -> int {\n            if (p[x] != x) {\n                p[x] = find(p[x]);\n            }\n            return p[x];\n        };\n\n        vector<int> hi(m);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                hi[grid[i][j]] = i * n + j;\n            }\n        }\n\n        array<int, 5> dirs{-1, 0, 1, 0, -1};\n\n        for (int t = 0; t < m; ++t) {\n            int id = hi[t];\n            int x = id / n, y = id % n;\n            for (int k = 0; k < 4; ++k) {\n                int nx = x + dirs[k], ny = y + dirs[k + 1];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] <= t) {\n                    int a = find(x * n + y);\n                    int b = find(nx * n + ny);\n                    p[a] = b;\n                }\n            }\n            if (find(0) == find(m - 1)) {\n                return t;\n            }\n        }\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) swimInWater(grid [][]int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) swimInWater(grid [][]int) int {\n\tn := len(grid)\n\tm := n * n\n\tp := make([]int, m)\n\tfor i := range p {\n\t\tp[i] = i\n\t}\n\tvar find func(int) int\n\tfind = func(x int) int {\n\t\tif p[x] != x {\n\t\t\tp[x] = find(p[x])\n\t\t}\n\t\treturn p[x]\n\t}\n\thi := make([]int, m)\n\tfor i := range grid {\n\t\tfor j, h := range grid[i] {\n\t\t\thi[h] = i*n + j\n\t\t}\n\t}\n\tdirs := []int{-1, 0, 1, 0, -1}\n\tfor t := 0; t < m; t++ {\n\t\tid := hi[t]\n\t\tx, y := id/n, id%n\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tnx, ny := x+dirs[k], y+dirs[k+1]\n\t\t\tif nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] <= t {\n\t\t\t\ta := find(x*n + y)\n\t\t\t\tb := find(nx*n + ny)\n\t\t\t\tp[a] = b\n\t\t\t}\n\t\t}\n\t\tif find(0) == find(m-1) {\n\t\t\treturn t\n\t\t}\n\t}\n\treturn 0\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn swim_in_water(grid: Vec<Vec<i32>>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn swim_in_water(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = n * n;\n        let mut p: Vec<usize> = (0..m).collect();\n        let mut hi = vec![0usize; m];\n\n        for i in 0..n {\n            for j in 0..n {\n                hi[grid[i][j] as usize] = i * n + j;\n            }\n        }\n\n        fn find(x: usize, p: &mut Vec<usize>) -> usize {\n            if p[x] != x {\n                p[x] = find(p[x], p);\n            }\n            p[x]\n        }\n\n        let dirs = [-1isize, 0, 1, 0, -1];\n\n        for t in 0..m {\n            let id = hi[t];\n            let x = id / n;\n            let y = id % n;\n\n            for k in 0..4 {\n                let nx = x as isize + dirs[k];\n                let ny = y as isize + dirs[k + 1];\n                if nx >= 0 && nx < n as isize && ny >= 0 && ny < n as isize {\n                    let nx = nx as usize;\n                    let ny = ny as usize;\n                    if grid[nx][ny] as usize <= t {\n                        let a = find(x * n + y, &mut p);\n                        let b = find(nx * n + ny, &mut p);\n                        p[a] = b;\n                    }\n                }\n            }\n\n            if find(0, &mut p) == find(m - 1, &mut p) {\n                return t as i32;\n            }\n        }\n\n        0\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def swimInWater(self, grid):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    swimInWater(grid: number[][]): number  {\n    const n = grid.length;\n    const m = n * n;\n    const p = Array.from({ length: m }, (_, i) => i);\n    const hi = new Array<number>(m);\n    const find = (x: number): number => (p[x] === x ? x : (p[x] = find(p[x])));\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            hi[grid[i][j]] = i * n + j;\n        }\n    }\n\n    const dirs = [-1, 0, 1, 0, -1];\n\n    for (let t = 0; t < m; ++t) {\n        const id = hi[t];\n        const x = Math.floor(id / n);\n        const y = id % n;\n\n        for (let k = 0; k < 4; ++k) {\n            const nx = x + dirs[k];\n            const ny = y + dirs[k + 1];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] <= t) {\n                p[find(x * n + y)] = find(nx * n + ny);\n            }\n        }\n        if (find(0) === find(m - 1)) {\n            return t;\n        }\n    }\n\n    return 0;\n}\n}",
        "initialCode": "class Solution {\n    swimInWater(grid: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nIt starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nReturn the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
    "relatedProblems": [
      "n-queens",
      "n-queens-ii",
      "trapping-rain-water"
    ]
  },
  "alien-dictionary": {
    "id": "alien-dictionary",
    "slug": "alien-dictionary",
    "title": "Alien Dictionary",
    "difficulty": "Hard",
    "category": "Graph General",
    "problemStatement": "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.",
    "videoUrl": "",
    "pattern": "Topological Sort",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(C)",
    "spaceComplexity": "O(1)",
    "oneliner": "Build graph from adjacent words, then topological sort.",
    "intuition": [
      "Compare adjacent words to find letter order relationships.",
      "Use topological sort to determine valid letter sequence."
    ],
    "visualizationType": "graph",
    "initialState": [
      "wrt",
      "wrf",
      "er",
      "ett",
      "rftt"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Build Order Graph",
        "transientMessage": "Compare adjacent words",
        "graphState": {
          "nodes": [
            {
              "id": "w",
              "label": "w",
              "x": 100,
              "y": 100
            },
            {
              "id": "e",
              "label": "e",
              "x": 150,
              "y": 200
            },
            {
              "id": "r",
              "label": "r",
              "x": 200,
              "y": 100
            },
            {
              "id": "t",
              "label": "t",
              "x": 300,
              "y": 100
            },
            {
              "id": "f",
              "label": "f",
              "x": 250,
              "y": 200
            }
          ],
          "edges": []
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "t\u2192f, w\u2192e",
        "transientMessage": "First differences",
        "graphState": {
          "nodes": [
            {
              "id": "w",
              "label": "w",
              "x": 100,
              "y": 100,
              "highlight": true
            },
            {
              "id": "e",
              "label": "e",
              "x": 150,
              "y": 200
            },
            {
              "id": "r",
              "label": "r",
              "x": 200,
              "y": 100
            },
            {
              "id": "t",
              "label": "t",
              "x": 300,
              "y": 100,
              "highlight": true
            },
            {
              "id": "f",
              "label": "f",
              "x": 250,
              "y": 200
            }
          ],
          "edges": [
            {
              "from": "t",
              "to": "f",
              "highlight": true
            },
            {
              "from": "w",
              "to": "e",
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "r\u2192t, e\u2192r",
        "transientMessage": "More edges found",
        "graphState": {
          "nodes": [
            {
              "id": "w",
              "label": "w",
              "x": 100,
              "y": 100
            },
            {
              "id": "e",
              "label": "e",
              "x": 150,
              "y": 200
            },
            {
              "id": "r",
              "label": "r",
              "x": 200,
              "y": 100
            },
            {
              "id": "t",
              "label": "t",
              "x": 300,
              "y": 100
            },
            {
              "id": "f",
              "label": "f",
              "x": 250,
              "y": 200
            }
          ],
          "edges": [
            {
              "from": "t",
              "to": "f"
            },
            {
              "from": "w",
              "to": "e"
            },
            {
              "from": "r",
              "to": "t",
              "highlight": true
            },
            {
              "from": "e",
              "to": "r",
              "highlight": true
            }
          ]
        },
        "pointers": [],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Result: \"wertf\"",
        "transientMessage": "Topological sort",
        "graphState": {
          "nodes": [
            {
              "id": "w",
              "label": "w (1)",
              "x": 100,
              "y": 100,
              "visited": true
            },
            {
              "id": "e",
              "label": "e (2)",
              "x": 150,
              "y": 200,
              "visited": true
            },
            {
              "id": "r",
              "label": "r (3)",
              "x": 200,
              "y": 100,
              "visited": true
            },
            {
              "id": "t",
              "label": "t (4)",
              "x": 300,
              "y": 100,
              "visited": true
            },
            {
              "id": "f",
              "label": "f (5)",
              "x": 250,
              "y": 200,
              "visited": true
            }
          ],
          "edges": [
            {
              "from": "t",
              "to": "f"
            },
            {
              "from": "w",
              "to": "e"
            },
            {
              "from": "r",
              "to": "t"
            },
            {
              "from": "e",
              "to": "r"
            }
          ]
        },
        "pointers": [
          {
            "label": "answer",
            "value": "\"wertf\""
          }
        ],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import defaultdict, deque\n    \n    def alienOrder(self, words):\n        \"\"\"\n        Intuition:\n        - Compare adjacent words to find letter order relationships.\n        - Use topological sort to determine valid letter sequence.\n        \"\"\"\n        # Build graph\n        graph = defaultdict(set)\n        indegree = defaultdict(int)\n        \n        # Add all unique letters\n        for word in words:  # Iterate over elements.\n            for char in word:  # Iterate over elements.\n                indegree[char] = 0\n        \n        # Find letter relationships\n        for i in range(len(words) - 1):  # Iterate through the range.\n            word1, word2 = words[i], words[i+1]\n            min_len = min(len(word1), len(word2))  # Take the minimum value.\n            \n            # Check invalid case: prefix issue\n            if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n                return \"\"\n                \n            # Find first differing character\n            for j in range(min_len):  # Iterate through the range.\n                if word1[j] != word2[j]:\n                    # Add edge if not already present\n                    if word2[j] not in graph[word1[j]]:\n                        graph[word1[j]].add(word2[j])\n                        indegree[word2[j]] += 1\n                    break\n        \n        # Topological sort (Kahn's algorithm)\n        queue = deque([char for char in indegree if indegree[char] == 0])\n        result = []\n        \n        while queue:  # Process nodes until queue is empty.\n            char = queue.popleft()  # Remove from front of queue.\n            result.append(char)  # Add to end.\n            \n            for neighbor in graph[char]:  # Iterate over elements.\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)  # Add to end.\n        \n        # Check for cycles\n        return ''.join(result) if len(result) == len(indegree) else \"\"",
    "keyInsight": "Adjacent words reveal ordering; topological sort handles dependencies.",
    "testCases": [
      {
        "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
        "output": "\"wertf\""
      },
      {
        "input": "words = [\"z\",\"x\"]",
        "output": "\"zx\""
      },
      {
        "input": "words = [\"z\",\"x\",\"z\"]",
        "output": "\"\""
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Topological Sort: Build graph from adjacent words, then topological sort.",
    "videoId": "6kTZYvNNyps",
    "graphNodes": [
      {
        "id": "w",
        "label": "w"
      },
      {
        "id": "e",
        "label": "e"
      },
      {
        "id": "r",
        "label": "r"
      },
      {
        "id": "t",
        "label": "t"
      },
      {
        "id": "f",
        "label": "f"
      }
    ],
    "graphEdges": [
      {
        "from": "t",
        "to": "f"
      },
      {
        "from": "w",
        "to": "e"
      },
      {
        "from": "r",
        "to": "t"
      },
      {
        "from": "e",
        "to": "r"
      }
    ],
    "suggestedNextQuestion": {
      "slug": "binary-tree-maximum-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "pattern": "Graphs"
    },
    "mentalModel": "Like putting on clothes. Socks before shoes. Order matters based on dependencies.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def alienOrder(words):\n    adj = { c:set() for w in words for c in w }\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i+1]\n        minLen = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                adj[w1[j]].add(w2[j])\n                break\n                \n    visit = {} # False=visited, True=path\n    res = []\n    def dfs(c):\n        if c in visit:\n            return visit[c]\n        visit[c] = True\n        for nei in adj[c]:\n            if dfs(nei): return True\n        visit[c] = False\n        res.append(c)\n    \n    for c in adj:\n        if dfs(c): return \"\"\n    return \"\".join(res[::-1])"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(C)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Compare adjacent words to find letter order relationships.",
          "Use topological sort to determine valid letter sequence."
        ],
        "code": "from collections import defaultdict, deque\n\ndef alienOrder(words):\n    \"\"\"\n    Intuition:\n    - Compare adjacent words to find letter order relationships.\n    - Use topological sort to determine valid letter sequence.\n    \"\"\"\n    # Build graph\n    graph = defaultdict(set)\n    indegree = defaultdict(int)\n    \n    # Add all unique letters\n    for word in words:  # Iterate over elements.\n        for char in word:  # Iterate over elements.\n            indegree[char] = 0\n    \n    # Find letter relationships\n    for i in range(len(words) - 1):  # Iterate through the range.\n        word1, word2 = words[i], words[i+1]\n        min_len = min(len(word1), len(word2))  # Take the minimum value.\n        \n        # Check invalid case: prefix issue\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n            \n        # Find first differing character\n        for j in range(min_len):  # Iterate through the range.\n            if word1[j] != word2[j]:\n                # Add edge if not already present\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    indegree[word2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([char for char in indegree if indegree[char] == 0])\n    result = []\n    \n    while queue:  # Process nodes until queue is empty.\n        char = queue.popleft()  # Remove from front of queue.\n        result.append(char)  # Add to end.\n        \n        for neighbor in graph[char]:  # Iterate over elements.\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)  # Add to end.\n    \n    # Check for cycles\n    return ''.join(result) if len(result) == len(indegree) else \"\""
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(words: string[]): string[] {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(words: string[]): string[] {\n        return [];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String[] solve(String[] words) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    public String[] solve(String[] words) {\n        return new String[0];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<string> solve(vector<string>& words) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<string> solve(vector<string>& words) {\n        return {};\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) alienOrder(words []string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) alienOrder(words []string) string {\n\tg := [26][26]bool{}\n\ts := [26]bool{}\n\tcnt := 0\n\tn := len(words)\n\tfor i := 0; i < n-1; i++ {\n\t\tfor _, c := range words[i] {\n\t\t\tif cnt == 26 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc -= 'a'\n\t\t\tif !s[c] {\n\t\t\t\tcnt++\n\t\t\t\ts[c] = true\n\t\t\t}\n\t\t}\n\t\tm := len(words[i])\n\t\tfor j := 0; j < m; j++ {\n\t\t\tif j >= len(words[i+1]) {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tc1, c2 := words[i][j]-'a', words[i+1][j]-'a'\n\t\t\tif c1 == c2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif g[c2][c1] {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\tg[c1][c2] = true\n\t\t\tbreak\n\t\t}\n\t}\n\tfor _, c := range words[n-1] {\n\t\tif cnt == 26 {\n\t\t\tbreak\n\t\t}\n\t\tc -= 'a'\n\t\tif !s[c] {\n\t\t\tcnt++\n\t\t\ts[c] = true\n\t\t}\n\t}\n\n\tinDegree := [26]int{}\n\tfor _, out := range g {\n\t\tfor i, v := range out {\n\t\t\tif v {\n\t\t\t\tinDegree[i]++\n\t\t\t}\n\t\t}\n\t}\n\tq := []int{}\n\tfor i, in := range inDegree {\n\t\tif in == 0 && s[i] {\n\t\t\tq = append(q, i)\n\t\t}\n\t}\n\tans := \"\"\n\tfor len(q) > 0 {\n\t\tt := q[0]\n\t\tq = q[1:]\n\t\tans += string(t + 'a')\n\t\tfor i, v := range g[t] {\n\t\t\tif v {\n\t\t\t\tinDegree[i]--\n\t\t\t\tif inDegree[i] == 0 && s[i] {\n\t\t\t\t\tq = append(q, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif len(ans) < cnt {\n\t\treturn \"\"\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn alien_order(words: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\nuse std::collections::VecDeque;\n\nimpl Solution {\n    fn alien_order(words: Vec<String>) -> String {\n        let mut alphabet = vec![false; 256];\n        for s in words.iter() {\n            for b in s.chars() {\n                alphabet[b as usize] = true;\n            }\n        }\n        let k: usize = alphabet.iter().map(|&b| if b { 1 } else { 0 }).sum();\n        let mut edges: Vec<Vec<u8>> = vec![vec![]; 256];\n        for w in words.windows(2) {\n            if w[0] == w[1] {\n                continue;\n            }\n            if w[0].starts_with(&w[1]) {\n                return \"\".to_string();\n            }\n            if let Some((t, h)) = w[0]\n                .bytes()\n                .zip(w[1].bytes())\n                .skip_while(|(t, h)| t == h)\n                .take(1)\n                .next()\n            {\n                edges[t as usize].push(h);\n            }\n        }\n        let mut indegree: Vec<usize> = vec![0; 256];\n        for i in 0..256 {\n            for &h in &edges[i] {\n                indegree[h as usize] += 1;\n            }\n        }\n        let mut queue: VecDeque<u8> = VecDeque::new();\n        for i in 0..256 {\n            if alphabet[i] && indegree[i] == 0 {\n                queue.push_back(i as u8);\n            }\n        }\n\n        let mut res = \"\".to_string();\n        while let Some(t) = queue.pop_front() {\n            res.push(t as char);\n            let n = edges[t as usize].len();\n            for i in 0..n {\n                let h = edges[t as usize][i];\n                indegree[h as usize] -= 1;\n                if indegree[h as usize] == 0 {\n                    queue.push_back(h);\n                }\n            }\n        }\n        if k == res.len() {\n            res\n        } else {\n            \"\".to_string()\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let words = vec_string![\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"];\n    let res = \"wertf\".to_string();\n    assert_eq!(Solution::alien_order(words), res);\n    let words = vec_string![\"z\", \"x\"];\n    let res = \"zx\".to_string();\n    assert_eq!(Solution::alien_order(words), res);\n    let words = vec_string![\"z\", \"x\", \"z\"];\n    let res = \"\".to_string();\n    assert_eq!(Solution::alien_order(words), res);\n    let words = vec_string![\"abc\", \"ab\"];\n    let res = \"\".to_string();\n    assert_eq!(Solution::alien_order(words), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    solve(): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.",
    "relatedProblems": [
      "course-schedule-ii"
    ]
  },
  "subsets-ii": {
    "id": "subsets-ii",
    "slug": "subsets-ii",
    "title": "Subsets II",
    "difficulty": "Medium",
    "category": "Backtracking",
    "problemStatement": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
    "videoUrl": "",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(2^n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use backtracking with sorting to skip duplicates.",
    "intuition": [
      "Sort the array first to group duplicates together",
      "Skip over duplicate elements during backtracking to avoid duplicate subsets"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Subsets II",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [1]",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 2 to path",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try 2 instead",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        Intuition:\n        - Sort the array first to group duplicates together\n        - Skip over duplicate elements during backtracking to avoid duplicate subsets\n        \"\"\"\n        nums.sort()\n        result = []\n\n        def backtrack(start, path):\n            result.append(path[:])  # Add to end.\n\n            for i in range(start, len(nums)):  # Iterate through the range.\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                path.append(nums[i])  # Add to end.\n                backtrack(i + 1, path)\n                path.pop()  # Remove and return last element.\n\n        backtrack(0, [])\n        return result  # Return the final result.",
    "keyInsight": "Sort first, then skip duplicates by checking if current element equals previous element in the same level of recursion.",
    "testCases": [
      {
        "input": "nums = [1,2,2]",
        "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]"
      }
    ],
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "hints": [
      "\ud83e\udde0 Explore all possibilities systematically",
      "\ud83d\udca1 Prune invalid branches early",
      "\ud83d\udd0d Track current state and restore after"
    ],
    "approach": "Backtracking: Use backtracking with sorting to skip duplicates.",
    "videoId": "Vn2v6ajA7U0",
    "suggestedNextQuestion": {
      "slug": "word-search",
      "title": "Word Search",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def subsetsWithDup(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def subsetsWithDup_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the array first to group duplicates together",
          "Skip over duplicate elements during backtracking to avoid duplicate subsets"
        ],
        "code": "def subsetsWithDup(nums):\n    \"\"\"\n    Intuition:\n    - Sort the array first to group duplicates together\n    - Skip over duplicate elements during backtracking to avoid duplicate subsets\n    \"\"\"\n    nums.sort()\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])  # Add to end.\n        \n        for i in range(start, len(nums)):  # Iterate through the range.\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])  # Add to end.\n            backtrack(i + 1, path)\n            path.pop()  # Remove and return last element.\n    \n    backtrack(0, [])\n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3], [1,3,2], ...]",
        "explanation": "Generate all permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10",
      "All elements are unique"
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    subsetsWithDup(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    subsetsWithDup(nums) {\n        nums.sort((a, b) => a - b);\n        const n = nums.length;\n        const t = [];\n        const ans = [];\n        const dfs = i => {\n            if (i >= n) {\n                ans.push([...t]);\n                return;\n            }\n            t.push(nums[i]);\n            dfs(i + 1);\n            t.pop();\n            while (i + 1 < n && nums[i] === nums[i + 1]) {\n                i++;\n        }\n        dfs(i + 1);\n    };\n    dfs(0);\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] nums;\n\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        this.nums = nums;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i >= nums.length) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        t.add(nums[i]);\n        dfs(i + 1);\n        int x = t.remove(t.size() - 1);\n        while (i + 1 < nums.length && nums[i + 1] == x) {\n            ++i;\n        }\n        dfs(i + 1);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        ranges::sort(nums);\n        vector<vector<int>> ans;\n        vector<int> t;\n        int n = nums.size();\n        auto dfs = [&](this auto&& dfs, int i) {\n            if (i >= n) {\n                ans.push_back(t);\n                return;\n            }\n            t.push_back(nums[i]);\n            dfs(i + 1);\n            t.pop_back();\n            while (i + 1 < n && nums[i + 1] == nums[i]) {\n                ++i;\n            }\n            dfs(i + 1);\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) subsetsWithDup(nums []int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) subsetsWithDup(nums []int) (ans [][]int) {\n\tslices.Sort(nums)\n\tn := len(nums)\n\tt := []int{}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i >= n {\n\t\t\tans = append(ans, slices.Clone(t))\n\t\t\treturn\n\t\t}\n\t\tt = append(t, nums[i])\n\t\tdfs(i + 1)\n\t\tt = t[:len(t)-1]\n\t\tfor i+1 < n && nums[i+1] == nums[i] {\n\t\t\ti++\n\t\t}\n\t\tdfs(i + 1)\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn subsets_with_dup(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut nums = nums;\n        nums.sort();\n        let mut ans = Vec::new();\n        let mut t = Vec::new();\n\n        fn dfs(i: usize, nums: &Vec<i32>, t: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {\n            if i >= nums.len() {\n                ans.push(t.clone());\n                return;\n            }\n            t.push(nums[i]);\n            dfs(i + 1, nums, t, ans);\n            t.pop();\n            let mut i = i;\n            while i + 1 < nums.len() && nums[i + 1] == nums[i] {\n                i += 1;\n            }\n            dfs(i + 1, nums, t, ans);\n        }\n\n        dfs(0, &nums, &mut t, &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def subsetsWithDup(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    subsetsWithDup(nums: number[]): number[][]  {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const t: number[] = [];\n    const ans: number[][] = [];\n    const dfs = (i: number): void => {\n        if (i >= n) {\n            ans.push([...t]);\n            return;\n        }\n        t.push(nums[i]);\n        dfs(i + 1);\n        t.pop();\n        while (i + 1 < n && nums[i] === nums[i + 1]) {\n            i++;\n        }\n        dfs(i + 1);\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    subsetsWithDup(nums: number[]): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
    "relatedProblems": [
      "subsets",
      "word-search-ii",
      "n-queens"
    ]
  },
  "combination-sum-ii": {
    "id": "combination-sum-ii",
    "slug": "combination-sum-ii",
    "title": "Combination Sum II",
    "difficulty": "Medium",
    "category": "Backtracking",
    "problemStatement": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.",
    "videoUrl": "",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(2^n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use backtracking with sorting to avoid duplicates.",
    "intuition": [
      "Sort the array to group duplicates together",
      "Use backtracking to explore combinations, skipping duplicates"
    ],
    "visualizationType": "array",
    "initialState": [
      10,
      1,
      2,
      7,
      6,
      1,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Combination Sum II",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add 10 to path",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [10]",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try 2 instead",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          10,
          1,
          2,
          7,
          6,
          1,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        Intuition:\n        - Sort the array to group duplicates together\n        - Use backtracking to explore combinations, skipping duplicates\n        \"\"\"\n        def backtrack(start, target, path):\n            if target == 0:\n                result.append(path[:])  # Add to end.\n                return\n            if target < 0:\n                return\n\n            for i in range(start, len(candidates)):  # Iterate through the range.\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue  # Skip duplicates\n\n                path.append(candidates[i])  # Add to end.\n                backtrack(i + 1, target - candidates[i], path)\n                path.pop()  # Remove and return last element.\n\n        candidates.sort()\n        result = []\n        backtrack(0, target, [])\n        return result  # Return the final result.",
    "keyInsight": "Sort to group duplicates, then skip same values in same level.",
    "testCases": [
      {
        "input": "candidates = [10,1,2,7,6,1,5], target = 8",
        "output": "[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
      },
      {
        "input": "candidates = [2,5,2,1,2], target = 5",
        "output": "[\n[1,2,2],\n[5]\n]"
      }
    ],
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "hints": [
      "\ud83e\udde0 Explore all possibilities systematically",
      "\ud83d\udca1 Prune invalid branches early",
      "\ud83d\udd0d Track current state and restore after"
    ],
    "approach": "Backtracking: Use backtracking with sorting to avoid duplicates.",
    "videoId": "rSA3t6BDDwg",
    "suggestedNextQuestion": {
      "slug": "combinations",
      "title": "Combinations",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def combinationSum2(self, candidates, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def combinationSum2_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the array to group duplicates together",
          "Use backtracking to explore combinations, skipping duplicates"
        ],
        "code": "def combinationSum2(candidates, target):\n    \"\"\"\n    Intuition:\n    - Sort the array to group duplicates together\n    - Use backtracking to explore combinations, skipping duplicates\n    \"\"\"\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path[:])  # Add to end.\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(candidates)):  # Iterate through the range.\n            if i > start and candidates[i] == candidates[i-1]:\n                continue  # Skip duplicates\n            \n            path.append(candidates[i])  # Add to end.\n            backtrack(i + 1, target - candidates[i], path)\n            path.pop()  # Remove and return last element.\n    \n    candidates.sort()\n    result = []\n    backtrack(0, target, [])\n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3], [1,3,2], ...]",
        "explanation": "Generate all permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10",
      "All elements are unique"
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    combinationSum2(candidates, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nclass Solution {\n    /**\n     * @param {any} candidates, target\n     * @return {any}\n     */\n    combinationSum2(candidates, target) {\n        candidates.sort((a, b) => a - b);\n        const ans = [];\n        const t = [];\n        const dfs = (i, s) => {\n            if (s === 0) {\n                ans.push(t.slice());\n                return;\n            }\n            if (i >= candidates.length || s < candidates[i]) {\n                return;\n            }\n            for (let j = i; j < candidates.length; ++j) {\n                if (j > i && candidates[j] === candidates[j - 1]) {\n                    continue;\n                }\n                t.push(candidates[j]);\n                dfs(j + 1, s - candidates[j]);\n                t.pop();\n        }\n    };\n    dfs(0, target);\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    private List<Integer> t = new ArrayList<>();\n    private int[] candidates;\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        this.candidates = candidates;\n        dfs(0, target);\n        return ans;\n    }\n\n    private void dfs(int i, int s) {\n        if (s == 0) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        if (i >= candidates.length || s < candidates[i]) {\n            return;\n        }\n        for (int j = i; j < candidates.length; ++j) {\n            if (j > i && candidates[j] == candidates[j - 1]) {\n                continue;\n            }\n            t.add(candidates[j]);\n            dfs(j + 1, s - candidates[j]);\n            t.remove(t.size() - 1);\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> ans;\n        vector<int> t;\n        function<void(int, int)> dfs = [&](int i, int s) {\n            if (s == 0) {\n                ans.emplace_back(t);\n                return;\n            }\n            if (i >= candidates.size() || s < candidates[i]) {\n                return;\n            }\n            for (int j = i; j < candidates.size(); ++j) {\n                if (j > i && candidates[j] == candidates[j - 1]) {\n                    continue;\n                }\n                t.emplace_back(candidates[j]);\n                dfs(j + 1, s - candidates[j]);\n                t.pop_back();\n            }\n        };\n        dfs(0, target);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) combinationSum2(candidates []int, target int) (ans [][]int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) combinationSum2(candidates []int, target int) (ans [][]int) {\n\tsort.Ints(candidates)\n\tt := []int{}\n\tvar dfs func(i, s int)\n\tdfs = func(i, s int) {\n\t\tif s == 0 {\n\t\t\tans = append(ans, slices.Clone(t))\n\t\t\treturn\n\t\t}\n\t\tif i >= len(candidates) || s < candidates[i] {\n\t\t\treturn\n\t\t}\n\t\tfor j := i; j < len(candidates); j++ {\n\t\t\tif j > i && candidates[j] == candidates[j-1] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt = append(t, candidates[j])\n\t\t\tdfs(j+1, s-candidates[j])\n\t\t\tt = t[:len(t)-1]\n\t\t}\n\t}\n\tdfs(0, target)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    fn dfs(i: usize, s: i32, candidates: &Vec<i32>, t: &mut Vec<i32>, ans: &mut Vec<Vec<i32>>) {\n        if s == 0 {\n            ans.push(t.clone());\n            return;\n        }\n        if i >= candidates.len() || s < candidates[i] {\n            return;\n        }\n        for j in i..candidates.len() {\n            if j > i && candidates[j] == candidates[j - 1] {\n                continue;\n            }\n            t.push(candidates[j]);\n            Self::dfs(j + 1, s - candidates[j], candidates, t, ans);\n            t.pop();\n        }\n    }\n\n    pub fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        candidates.sort();\n        let mut ans = Vec::new();\n        Self::dfs(0, target, &candidates, &mut vec![], &mut ans);\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def combinationSum2(self, candidates, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    combinationSum2(candidates: number[], target: number): number[][]  {\n    candidates.sort((a, b) => a - b);\n    const ans: number[][] = [];\n    const t: number[] = [];\n    const dfs = (i: number, s: number) => {\n        if (s === 0) {\n            ans.push(t.slice());\n            return;\n        }\n        if (i >= candidates.length || s < candidates[i]) {\n            return;\n        }\n        for (let j = i; j < candidates.length; j++) {\n            if (j > i && candidates[j] === candidates[j - 1]) {\n                continue;\n            }\n            t.push(candidates[j]);\n            dfs(j + 1, s - candidates[j]);\n            t.pop();\n        }\n    };\n    dfs(0, target);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    combinationSum2(candidates: number[], target: number): number[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.",
    "relatedProblems": [
      "letter-case-permutation",
      "word-search-ii",
      "combinations"
    ]
  },
  "palindrome-partitioning": {
    "id": "palindrome-partitioning",
    "slug": "palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "difficulty": "Medium",
    "category": "Backtracking",
    "problemStatement": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
    "videoUrl": "",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(N * 2^N)",
    "spaceComplexity": "O(N)",
    "oneliner": "Use backtracking to explore all possible partitions.",
    "intuition": [
      "We need to try all possible ways to split the string.",
      "At each step, check if current substring is palindrome before proceeding."
    ],
    "visualizationType": "array",
    "initialState": [
      "a",
      "a",
      "b"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Palindrome Partitioning",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add a to path",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [a]",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add a to path",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try b instead",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          "a",
          "a",
          "b"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def partition(self, s):\n        \"\"\"\n        Intuition:\n        - We need to try all possible ways to split the string.\n        - At each step, check if current substring is palindrome before proceeding.\n        \"\"\"\n        def is_palindrome(string):\n            return string == string[::-1]  # Reverse the sequence.\n\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])  # Add to end.\n                return\n\n            for end in range(start, len(s)):  # Iterate through the range.\n                if is_palindrome(s[start:end+1]):\n                    path.append(s[start:end+1])  # Add to end.\n                    backtrack(end + 1, path)\n                    path.pop()  # Remove and return last element.\n\n        result = []\n        backtrack(0, [])\n        return result  # Return the final result.",
    "keyInsight": "Use backtracking to generate all valid partitions by checking palindromes at each step.",
    "testCases": [
      {
        "input": "s = \"aab\"",
        "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
      },
      {
        "input": "s = \"a\"",
        "output": "[[\"a\"]]"
      }
    ],
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "hints": [
      "\ud83e\udde0 Explore all possibilities systematically",
      "\ud83d\udca1 Prune invalid branches early",
      "\ud83d\udd0d Track current state and restore after"
    ],
    "approach": "Backtracking: Use backtracking to explore all possible partitions.",
    "videoId": "3jvWodd7ht0",
    "suggestedNextQuestion": {
      "slug": "permutations",
      "title": "Permutations",
      "difficulty": "Medium",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def partition(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def partition_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N * 2^N)",
        "spaceComplexity": "O(N)",
        "intuition": [
          "We need to try all possible ways to split the string.",
          "At each step, check if current substring is palindrome before proceeding."
        ],
        "code": "def partition(s):\n    \"\"\"\n    Intuition:\n    - We need to try all possible ways to split the string.\n    - At each step, check if current substring is palindrome before proceeding.\n    \"\"\"\n    def is_palindrome(string):\n        return string == string[::-1]  # Reverse the sequence.\n    \n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])  # Add to end.\n            return\n        \n        for end in range(start, len(s)):  # Iterate through the range.\n            if is_palindrome(s[start:end+1]):\n                path.append(s[start:end+1])  # Add to end.\n                backtrack(end + 1, path)\n                path.pop()  # Remove and return last element.\n    \n    result = []\n    backtrack(0, [])\n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3], [1,3,2], ...]",
        "explanation": "Generate all permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10",
      "All elements are unique"
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    partition(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    partition(s) {\n        return backtrack([], s);\n      };\n\n      class Solution {\n          /**\n           * @param {any} order, string, result = []\n           * @return {any}\n           */\n          backtrack(order, string, result = []) {\n        if (!string.length) {\n          result.push(order);\n        }\n\n        for (let index = 1; index <= string.length; index++) {\n          const sliced = string.slice(0, index);\n          if (isPalindrome(sliced)) {\n            backtrack([...order, sliced], string.slice(index), result);\n          }\n        }\n\n        return result;\n      }\n\n      function isPalindrome(input) {\n        let right = input.length - 1;\n        let left = 0;\n\n        while (left < right) {\n          if (input[left] !== input[right]) {\n            return false;\n          }\n          left++;\n          right--;\n        }\n\n        return true;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<String>> partition(String s) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private int n;\n    private String s;\n    private boolean[][] f;\n    private List<String> t = new ArrayList<>();\n    private List<List<String>> ans = new ArrayList<>();\n\n    public List<List<String>> partition(String s) {\n        n = s.length();\n        f = new boolean[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(f[i], true);\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                f[i][j] = s.charAt(i) == s.charAt(j) && f[i + 1][j - 1];\n            }\n        }\n        this.s = s;\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == s.length()) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        for (int j = i; j < n; ++j) {\n            if (f[i][j]) {\n                t.add(s.substring(i, j + 1));\n                dfs(j + 1);\n                t.remove(t.size() - 1);\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<string>> partition(string s) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        int n = s.size();\n        bool f[n][n];\n        memset(f, true, sizeof(f));\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                f[i][j] = s[i] == s[j] && f[i + 1][j - 1];\n            }\n        }\n        vector<vector<string>> ans;\n        vector<string> t;\n        auto dfs = [&](this auto&& dfs, int i) -> void {\n            if (i == n) {\n                ans.emplace_back(t);\n                return;\n            }\n            for (int j = i; j < n; ++j) {\n                if (f[i][j]) {\n                    t.emplace_back(s.substr(i, j - i + 1));\n                    dfs(j + 1);\n                    t.pop_back();\n                }\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) partition(s string) (ans [][]string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) partition(s string) (ans [][]string) {\n\tn := len(s)\n\tf := make([][]bool, n)\n\tfor i := range f {\n\t\tf[i] = make([]bool, n)\n\t\tfor j := range f[i] {\n\t\t\tf[i][j] = true\n\t\t}\n\t}\n\tfor i := n - 1; i >= 0; i-- {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tf[i][j] = s[i] == s[j] && f[i+1][j-1]\n\t\t}\n\t}\n\tt := []string{}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i == n {\n\t\t\tans = append(ans, append([]string(nil), t...))\n\t\t\treturn\n\t\t}\n\t\tfor j := i; j < n; j++ {\n\t\t\tif f[i][j] {\n\t\t\t\tt = append(t, s[i:j+1])\n\t\t\t\tdfs(j + 1)\n\t\t\t\tt = t[:len(t)-1]\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn partition(s: String) -> Vec<Vec<String>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [131] Palindrome Partitioning\n *\n * Given a string s, partition s such that every substring of the partition is a palindrome.\n *\n * Return all possible palindrome partitioning of s.\n *\n * Example:\n *\n *\n * Input: \"aab\"\n * Output:\n * [\n *   [\"aa\",\"b\"],\n *   [\"a\",\"a\",\"b\"]\n * ]\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/palindrome-partitioning/\n// discuss: https://leetcode.com/problems/palindrome-partitioning/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n/*\n\u8bb0 n \u4e2a\u5b57\u7b26\u7684\u56de\u6587\u62c6\u5206\u65b9\u5f0f\u662f f(n) \u79cd, \u5219:\n\nf(n) = (0..n).iter().fold(0, |acc, i| {\n   if is_palindrome(s[i..n]) { acc + f(i-1) } else { acc }\n})\n\n\u6309\u8fd9\u79cd\u65b9\u5f0f\u5411\u4e0a\u9012\u63a8\u5373\u53ef, \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(N^3), \u7a7a\u95f4\u590d\u6742\u5ea6 O(N), \u663e\u7136, is_palindrome \u8fd9\u4e00\u6b65\u4ecd\u7136\u6709\u91cd\u590d\u8ba1\u7b97\n\nis_palindrome(s[i..n]) = s[i] == s[n] && is_palindrome(s[i+1..n-1])\n\n\u5b58\u50a8\u6240\u6709 i, n \u7684 is_palindrome \u7ed3\u679c, \u5219\u53ef\u4ee5\u4f18\u5316 is_palindrome \u7684\u65f6\u95f4\u5230 O(1)\n\n\u6700\u540e\u7684\u590d\u6742\u5ea6: \u65f6\u95f4 O(N^2), \u7a7a\u95f4 O(N^2)\n*/\nimpl Solution {\n    pub fn partition(s: String) -> Vec<Vec<String>> {\n        let s = s.chars().collect::<Vec<_>>();\n        if s.is_empty() {\n            return Vec::new();\n        }\n        let mut palindrome_cache = vec![vec![None; s.len()]; s.len()];\n        let mut res: Vec<Vec<Vec<(usize, usize)>>> = Vec::with_capacity(s.len());\n        res.push(vec![vec![(0, 1)]]);\n        for n in 1..s.len() {\n            let mut curr: Vec<Vec<(usize, usize)>> = Vec::new();\n            for i in 0..n + 1 {\n                if Solution::is_palindrome(&mut palindrome_cache, &s, i, n) {\n                    if i > 0 {\n                        for vec in res[i - 1].iter() {\n                            let mut new_vec = vec.clone();\n                            new_vec.push((i, n + 1));\n                            curr.push(new_vec);\n                        }\n                    } else {\n                        curr.push(vec![(i, n + 1)]);\n                    }\n                }\n            }\n            res.push(curr);\n        }\n        (*res[s.len() - 1])\n            .into_iter()\n            .map(|vec| {\n                vec.iter()\n                    .map(|&range| s[range.0..range.1].iter().collect::<String>())\n                    .collect::<Vec<_>>()\n            })\n            .collect()\n    }\n\n    fn is_palindrome(\n        cache: &mut Vec<Vec<Option<bool>>>,\n        s: &Vec<char>,\n        i: usize,\n        j: usize,\n    ) -> bool {\n        if j <= i {\n            return true;\n        }\n        if let Some(result) = cache[i][j] {\n            result\n        } else {\n            let result = s[i] == s[j]\n                && (i + 1 > s.len() || j < 1 || Solution::is_palindrome(cache, s, i + 1, j - 1));\n            cache[i][j] = Some(result);\n            result\n        }\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_131() {\n        assert_eq!(\n            Solution::partition(\"aab\".to_owned()),\n            vec![vec_string![\"aa\", \"b\"], vec_string![\"a\", \"a\", \"b\"],]\n        );\n        assert_eq!(\n            Solution::partition(\"aaa\".to_owned()),\n            vec![\n                vec_string![\"aaa\"],\n                vec_string![\"a\", \"aa\"],\n                vec_string![\"aa\", \"a\"],\n                vec_string![\"a\", \"a\", \"a\"],\n            ]\n        );\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def partition(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    partition(s: string): string[][]  {\n    const n = s.length;\n    const f: boolean[][] = Array.from({ length: n }, () => Array(n).fill(true));\n    for (let i = n - 1; i >= 0; --i) {\n        for (let j = i + 1; j < n; ++j) {\n            f[i][j] = s[i] === s[j] && f[i + 1][j - 1];\n        }\n    }\n    const ans: string[][] = [];\n    const t: string[] = [];\n    const dfs = (i: number) => {\n        if (i === n) {\n            ans.push(t.slice());\n            return;\n        }\n        for (let j = i; j < n; ++j) {\n            if (f[i][j]) {\n                t.push(s.slice(i, j + 1));\n                dfs(j + 1);\n                t.pop();\n            }\n        }\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    partition(s: string): string[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
    "relatedProblems": [
      "word-search-ii",
      "subsets-ii",
      "permutations"
    ]
  },
  "n-queens": {
    "id": "n-queens",
    "slug": "n-queens",
    "title": "N-Queens",
    "difficulty": "Hard",
    "category": "Backtracking",
    "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "videoUrl": "",
    "pattern": "Backtracking",
    "patternEmoji": "\ud83d\udd04",
    "timeComplexity": "O(N!)",
    "spaceComplexity": "O(N\u00b2)",
    "oneliner": "Place queens row by row, backtracking when conflicts arise.",
    "intuition": [
      "Queens can attack horizontally, vertically, and diagonally",
      "Place one queen per row and check for conflicts before proceeding"
    ],
    "visualizationType": "grid",
    "initialState": [
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ],
      [
        ".",
        ".",
        ".",
        "."
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: N-Queens",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add .,.,.,. to path",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [.,.,.,.]",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add .,.,.,. to path",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try .,.,.,. instead",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ],
          [
            ".",
            ".",
            ".",
            "."
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def solveNQueens(self, n):\n        \"\"\"\n        Intuition:\n        - Queens can attack horizontally, vertically, and diagonally\n        - Place one queen per row and check for conflicts before proceeding\n        \"\"\"\n        def is_safe(board, row, col):\n            for i in range(row):  # Iterate through the range.\n                if board[i] == col or \\\n                   board[i] - i == col - row or \\\n                   board[i] + i == col + row:\n                    return False  # Condition not met.\n            return True  # Condition satisfied.\n\n        def backtrack(board, row):\n            if row == n:\n                result.append(['.' * col + 'Q' + '.' * (n-col-1) for col in board])  # Add to end.\n                return\n            for col in range(n):  # Iterate through the range.\n                if is_safe(board, row, col):\n                    board[row] = col\n                    backtrack(board, row + 1)\n\n        result = []\n        backtrack([-1] * n, 0)\n        return result  # Return the final result.",
    "keyInsight": "Use 1D array where index=row and value=column for efficient conflict checking",
    "testCases": [
      {
        "input": "n = 4",
        "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
      },
      {
        "input": "n = 1",
        "output": "[[\"Q\"]]"
      }
    ],
    "walkthrough": [
      "Define choice space for current position",
      "Make a choice and recurse",
      "Check if current state is valid",
      "If solution found, record it",
      "Undo choice and try next option"
    ],
    "hints": [
      "\ud83e\udde0 Explore all possibilities systematically",
      "\ud83d\udca1 Prune invalid branches early",
      "\ud83d\udd0d Track current state and restore after"
    ],
    "approach": "Backtracking: Place queens row by row, backtracking when conflicts arise.",
    "videoId": "Ph95IHmRp5M",
    "suggestedNextQuestion": {
      "slug": "n-queens-ii",
      "title": "N-Queens II",
      "difficulty": "Hard",
      "pattern": "Backtracking"
    },
    "mentalModel": "Like try-and-error in a lock combination. You try a number, if it fails, you 'backtrack' and try the next one.",
    "initialCode": "class Solution:\n    def solveNQueens(self, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all permutations/combinations.",
          "Filter valid ones at the end."
        ],
        "code": "def solveNQueens_brute(nums):\n    result = []\n    def backtrack(path):\n        if len(path) == len(nums):\n            if is_valid(path):\n                result.append(path[:])\n            return\n        for num in nums:\n            if num not in path:\n                path.append(num)\n                backtrack(path)\n                path.pop()\n    backtrack([])\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(N!)",
        "spaceComplexity": "O(N\u00b2)",
        "intuition": [
          "Queens can attack horizontally, vertically, and diagonally",
          "Place one queen per row and check for conflicts before proceeding"
        ],
        "code": "def solveNQueens(n):\n    \"\"\"\n    Intuition:\n    - Queens can attack horizontally, vertically, and diagonally\n    - Place one queen per row and check for conflicts before proceeding\n    \"\"\"\n    def is_safe(board, row, col):\n        for i in range(row):  # Iterate through the range.\n            if board[i] == col or \\\n               board[i] - i == col - row or \\\n               board[i] + i == col + row:\n                return False  # Condition not met.\n        return True  # Condition satisfied.\n    \n    def backtrack(board, row):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n-col-1) for col in board])  # Add to end.\n            return\n        for col in range(n):  # Iterate through the range.\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(board, row + 1)\n    \n    result = []\n    backtrack([-1] * n, 0)\n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[[1,2,3], [1,3,2], ...]",
        "explanation": "Generate all permutations."
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": "Single element."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10",
      "All elements are unique"
    ],
    "commonMistakes": [
      "Not undoing choices properly",
      "Missing pruning conditions",
      "Duplicates in result"
    ],
    "interviewTip": "Explain pruning strategy. Discuss how to avoid duplicates.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    solveNQueens(n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} n\n     * @return {any}\n     */\n    solveNQueens(n) {\n        const result = [];\n        backtrack(result, n);\n        return result;\n      };\n\n      class Solution {\n          /**\n           * @param {any} result, n, board = [], size = 0\n           * @return {any}\n           */\n          backtrack(result, n, board = [], size = 0) {\n        if (n === size) {\n          result.push(board.map(s => `${'.'.repeat(s)}Q${'.'.repeat(n - s - 1)}`));\n        } else {\n          for (let rows = 0; rows < n; rows++) {\n            const isValid = !board.some((i, j) => {\n              return i === rows || i === rows + size - j || i === rows - size + j;\n            });\n            if (isValid) {\n              board.push(rows);\n              backtrack(result, n, board, size + 1);\n              board.pop();\n            }\n          }\n        }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    private List<List<String>> ans = new ArrayList<>();\n    private int[] col;\n    private int[] dg;\n    private int[] udg;\n    private String[][] g;\n    private int n;\n\n    public List<List<String>> solveNQueens(int n) {\n        this.n = n;\n        col = new int[n];\n        dg = new int[n << 1];\n        udg = new int[n << 1];\n        g = new String[n][n];\n        for (int i = 0; i < n; ++i) {\n            Arrays.fill(g[i], \".\");\n        }\n        dfs(0);\n        return ans;\n    }\n\n    private void dfs(int i) {\n        if (i == n) {\n            List<String> t = new ArrayList<>();\n            for (int j = 0; j < n; ++j) {\n                t.add(String.join(\"\", g[j]));\n            }\n            ans.add(t);\n            return;\n        }\n        for (int j = 0; j < n; ++j) {\n            if (col[j] + dg[i + j] + udg[n - i + j] == 0) {\n                g[i][j] = \"Q\";\n                col[j] = dg[i + j] = udg[n - i + j] = 1;\n                dfs(i + 1);\n                col[j] = dg[i + j] = udg[n - i + j] = 0;\n                g[i][j] = \".\";\n            }\n        }\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<vector<string>> solveNQueens(int n) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<int> col(n);\n        vector<int> dg(n << 1);\n        vector<int> udg(n << 1);\n        vector<vector<string>> ans;\n        vector<string> t(n, string(n, '.'));\n        function<void(int)> dfs = [&](int i) -> void {\n            if (i == n) {\n                ans.push_back(t);\n                return;\n            }\n            for (int j = 0; j < n; ++j) {\n                if (col[j] + dg[i + j] + udg[n - i + j] == 0) {\n                    t[i][j] = 'Q';\n                    col[j] = dg[i + j] = udg[n - i + j] = 1;\n                    dfs(i + 1);\n                    col[j] = dg[i + j] = udg[n - i + j] = 0;\n                    t[i][j] = '.';\n                }\n            }\n        };\n        dfs(0);\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) solveNQueens(n int) (ans [][]string) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) solveNQueens(n int) (ans [][]string) {\n\tcol := make([]int, n)\n\tdg := make([]int, n<<1)\n\tudg := make([]int, n<<1)\n\tt := make([][]byte, n)\n\tfor i := range t {\n\t\tt[i] = make([]byte, n)\n\t\tfor j := range t[i] {\n\t\t\tt[i][j] = '.'\n\t\t}\n\t}\n\tvar dfs func(int)\n\tdfs = func(i int) {\n\t\tif i == n {\n\t\t\ttmp := make([]string, n)\n\t\t\tfor i := range tmp {\n\t\t\t\ttmp[i] = string(t[i])\n\t\t\t}\n\t\t\tans = append(ans, tmp)\n\t\t\treturn\n\t\t}\n\t\tfor j := 0; j < n; j++ {\n\t\t\tif col[j]+dg[i+j]+udg[n-i+j] == 0 {\n\t\t\t\tcol[j], dg[i+j], udg[n-i+j] = 1, 1, 1\n\t\t\t\tt[i][j] = 'Q'\n\t\t\t\tdfs(i + 1)\n\t\t\t\tt[i][j] = '.'\n\t\t\t\tcol[j], dg[i+j], udg[n-i+j] = 0, 0, 0\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0)\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [51] N-Queens\n *\n * The n-queens puzzle is the problem of placing n queens on an n*n chessboard such that no two queens attack each other.\n *\n * <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/8-queens.png\" style=\"width: 258px; height: 276px;\" />\n *\n * Given an integer n, return all distinct solutions to the n-queens puzzle.\n *\n * Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n *\n * Example:\n *\n *\n * Input: 4\n * Output: [\n *  [\".Q..\",  // Solution 1\n *   \"...Q\",\n *   \"Q...\",\n *   \"..Q.\"],\n *\n *  [\"..Q.\",  // Solution 2\n *   \"Q...\",\n *   \"...Q\",\n *   \".Q..\"]\n * ]\n * Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\n *\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/n-queens/\n// discuss: https://leetcode.com/problems/n-queens/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nimpl Solution {\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n        let mut board = vec![vec!['.'; n as usize]; n as usize];\n        let mut solution = Vec::new();\n        Solution::schedule_queens(&mut board, &mut solution, n as usize, 0);\n        solution\n    }\n\n    fn schedule_queens(\n        board: &mut Vec<Vec<char>>,\n        solution: &mut Vec<Vec<String>>,\n        len: usize,\n        row: usize,\n    ) {\n        for col in 0..len {\n            if !Solution::collision(&board, len, row, col) {\n                board[row][col] = 'Q';\n                if row == len - 1 {\n                    solution.push(board.iter().map(|vec| vec.iter().collect()).collect());\n                } else {\n                    Solution::schedule_queens(board, solution, len, row + 1);\n                }\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    #[inline(always)]\n    fn collision(board: &Vec<Vec<char>>, len: usize, x: usize, y: usize) -> bool {\n        for i in 0..x {\n            if board[i][y] == 'Q' {\n                return true;\n            }\n        }\n        let (mut i, mut j) = (x as i32 - 1, y as i32 - 1);\n        while i >= 0 && j >= 0 {\n            if board[i as usize][j as usize] == 'Q' {\n                return true;\n            }\n            i -= 1;\n            j -= 1;\n        }\n        let (mut i, mut j) = (x as i32 - 1, y as i32 + 1);\n        while i >= 0 && j < len as i32 {\n            if board[i as usize][j as usize] == 'Q' {\n                return true;\n            }\n            i -= 1;\n            j += 1;\n        }\n        false\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_51() {\n        assert_eq!(\n            Solution::solve_n_queens(4),\n            vec![\n                vec![\".Q..\", \"...Q\", \"Q...\", \"..Q.\"],\n                vec![\"..Q.\", \"Q...\", \"...Q\", \".Q..\"]\n            ]\n        );\n        assert_eq!(Solution::solve_n_queens(8).len(), 92);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solveNQueens(self, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solveNQueens(n: number): string[][]  {\n    const col: number[] = Array(n).fill(0);\n    const dg: number[] = Array(n << 1).fill(0);\n    const udg: number[] = Array(n << 1).fill(0);\n    const ans: string[][] = [];\n    const t: string[][] = Array.from({ length: n }, () => Array(n).fill('.'));\n    const dfs = (i: number) => {\n        if (i === n) {\n            ans.push(t.map(x => x.join('')));\n            return;\n        }\n        for (let j = 0; j < n; ++j) {\n            if (col[j] + dg[i + j] + udg[n - i + j] === 0) {\n                t[i][j] = 'Q';\n                col[j] = dg[i + j] = udg[n - i + j] = 1;\n                dfs(i + 1);\n                col[j] = dg[i + j] = udg[n - i + j] = 0;\n                t[i][j] = '.';\n            }\n        }\n    };\n    dfs(0);\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    solveNQueens(n: number): string[][] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.",
    "relatedProblems": [
      "word-search-ii",
      "palindrome-partitioning",
      "subsets-ii"
    ]
  },
  "koko-eating-bananas": {
    "id": "koko-eating-bananas",
    "slug": "koko-eating-bananas",
    "title": "Koko Eating Bananas",
    "difficulty": "Medium",
    "category": "Binary Search",
    "problemStatement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
    "videoUrl": "",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(n log(max(piles)))",
    "spaceComplexity": "O(1)",
    "oneliner": "Binary search on eating speed k between 1 and max(piles).",
    "intuition": [
      "We want to find the minimum eating speed k - this suggests optimization.",
      "If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search."
    ],
    "visualizationType": "array",
    "initialState": [
      3,
      6,
      7,
      11
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Koko Eating Bananas",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 6",
        "transientMessage": "Iteration 2",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 7",
        "transientMessage": "Iteration 3",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 11",
        "transientMessage": "Iteration 4",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          3,
          6,
          7,
          11
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import math\n    \n    def minEatingSpeed(self, piles, h):\n        \"\"\"\n        Intuition:\n        - We want to find the minimum eating speed k - this suggests optimization.\n        - If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search.\n        \"\"\"\n        left, right = 1, max(piles)  # Take the maximum value.\n        result = right\n        \n        while left <= right:\n            k = (left + right) // 2\n            hours = 0\n            for pile in piles:  # Iterate over elements.\n                hours += math.ceil(pile / k)\n            \n            if hours <= h:\n                result = k\n                right = k - 1\n            else:\n                left = k + 1\n                \n        return result  # Return the final result.",
    "keyInsight": "Binary search works because if speed k is sufficient, then k+1, k+2, ... are all sufficient (we want minimum).",
    "testCases": [
      {
        "input": "piles = [3,6,7,11], h = 8",
        "output": "4"
      },
      {
        "input": "piles = [30,11,23,4,20], h = 5",
        "output": "30"
      },
      {
        "input": "piles = [30,11,23,4,20], h = 6",
        "output": "23"
      }
    ],
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "hints": [
      "\ud83e\udde0 What property makes this problem sortable?",
      "\ud83d\udca1 Define clear boundaries for search space",
      "\ud83d\udd0d What should mid represent?"
    ],
    "approach": "Binary Search: Binary search on eating speed k between 1 and max(piles).",
    "videoId": "U2SozAs9RzA",
    "suggestedNextQuestion": {
      "slug": "search-a-2d-matrix",
      "title": "Search a 2D Matrix",
      "difficulty": "Medium",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def minEatingSpeed_brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log(max(piles)))",
        "spaceComplexity": "O(1)",
        "intuition": [
          "We want to find the minimum eating speed k - this suggests optimization.",
          "If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search."
        ],
        "code": "import math\n\ndef minEatingSpeed(piles, h):\n    \"\"\"\n    Intuition:\n    - We want to find the minimum eating speed k - this suggests optimization.\n    - If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search.\n    \"\"\"\n    left, right = 1, max(piles)  # Take the maximum value.\n    result = right\n    \n    while left <= right:\n        k = (left + right) // 2\n        hours = 0\n        for pile in piles:  # Iterate over elements.\n            hours += math.ceil(pile / k)\n        \n        if hours <= h:\n            result = k\n            right = k - 1\n        else:\n            left = k + 1\n            \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 3",
        "output": "2",
        "explanation": "Target found at index 2."
      },
      {
        "input": "nums = [1, 2, 3], target = 0",
        "output": "-1",
        "explanation": "Target not found."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "Array is sorted"
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__(piles: number[], h: number): void {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__(piles: number[], h: number): void {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int __init__() {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {}\n};",
        "code": "class Solution {\npublic:\n    Solution() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minEatingSpeed(piles []int, h int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minEatingSpeed(piles []int, h int) int {\n\treturn 1 + sort.Search(slices.Max(piles), func(k int) bool {\n\t\tk++\n\t\ts := 0\n\t\tfor _, x := range piles {\n\t\t\ts += (x + k - 1) / k\n\t\t}\n\t\treturn s <= h\n\t})\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_eating_speed(piles: Vec<i32>, h: i32) -> i32 {\n        let mut l = 1;\n        let mut r = *piles.iter().max().unwrap_or(&0);\n        while l < r {\n            let mid = (l + r) >> 1;\n            let mut s = 0;\n            for x in piles.iter() {\n                s += (x + mid - 1) / mid;\n            }\n            if s <= h {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        l\n    }\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(piles: number[], h: number): void {\n        // Implementation goes here\n    }\n}",
        "initialCode": "class Solution {\n    __init__(piles: number[], h: number): void {\n        // Your code here\n    }\n}"
      }
    },
    "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
    "relatedProblems": [
      "search-a-2d-matrix",
      "median-of-two-sorted-arrays",
      "search-in-rotated-sorted-array"
    ]
  },
  "time-based-key-value-store": {
    "id": "time-based-key-value-store",
    "slug": "time-based-key-value-store",
    "title": "Time Based Key-Value Store",
    "difficulty": "Medium",
    "category": "Binary Search",
    "problemStatement": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\nImplement the TimeMap class:",
    "videoUrl": "",
    "pattern": "Binary Search",
    "patternEmoji": "\ud83d\udd0d",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use binary search on sorted timestamps to find the latest valid value.",
    "intuition": [
      "Store values with timestamps in a sorted list for each key",
      "Use binary search to efficiently find the largest timestamp \u2264 target"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        "foo",
        "bar",
        1
      ],
      [
        "foo",
        "bar2",
        4
      ],
      [
        "foo",
        "bar3",
        6
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Time Based Key-Value Store",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = foo,bar,1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = foo,bar2,4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = foo,bar3,6",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            "foo",
            "bar",
            1
          ],
          [
            "foo",
            "bar2",
            4
          ],
          [
            "foo",
            "bar3",
            6
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    class TimeMap:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - Store values with timestamps in a sorted list for each key\n        - Use binary search to efficiently find the largest timestamp \u2264 target\n        \"\"\"\n            self.store = {}\n        \n        def set(self, key: str, value: str, timestamp: int) -> None:\n            if key not in self.store:\n                self.store[key] = []\n            self.store[key].append([value, timestamp])  # Add to end.\n        \n        def get(self, key: str, timestamp: int) -> str:\n            res = \"\"\n            values = self.store.get(key, [])\n            \n            l, r = 0, len(values) - 1  # Initialize two pointers.\n            while l <= r:\n                m = (l + r) // 2\n                if values[m][1] <= timestamp:\n                    res = values[m][0]\n                    l = m + 1\n                else:\n                    r = m - 1\n            return res  # Return the final result.",
    "keyInsight": "Timestamps are stored in increasing order, enabling binary search.",
    "testCases": [
      {
        "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 1)",
        "output": "'bar'"
      },
      {
        "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 3)",
        "output": "'bar'"
      },
      {
        "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.set('foo', 'bar2', 4); timeMap.get('foo', 4)",
        "output": "'bar2'"
      }
    ],
    "walkthrough": [
      "Set left and right pointers to search bounds",
      "While left < right, calculate mid point",
      "Check condition and narrow search space",
      "Adjust left or right based on comparison",
      "Return result when converged"
    ],
    "hints": [
      "\ud83e\udde0 What property makes this problem sortable?",
      "\ud83d\udca1 Define clear boundaries for search space",
      "\ud83d\udd0d What should mid represent?"
    ],
    "approach": "Binary Search: Use binary search on sorted timestamps to find the latest valid value.",
    "videoId": "fu2cD_6E8Hw",
    "suggestedNextQuestion": {
      "slug": "median-of-two-sorted-arrays",
      "title": "Median of Two Sorted Arrays",
      "difficulty": "Hard",
      "pattern": "Binary Search"
    },
    "mentalModel": "Like looking up a word in a dictionary. You open the middle, see if the word is before or after, and discard half the book instantly.",
    "initialCode": "class TimeMap:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # Store the key with value at the given timestamp\n        pass\n\n    def get(self, key: str, timestamp: int) -> str:\n        # Return the value at the given timestamp, or \"\" if not found\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Linear scan through all elements.",
          "Check each element one by one."
        ],
        "code": "def __init___brute(nums, target):\n    for i, num in enumerate(nums):\n        if num == target:\n            return i\n    return -1"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Store values with timestamps in a sorted list for each key",
          "Use binary search to efficiently find the largest timestamp \u2264 target"
        ],
        "code": "class TimeMap:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Store values with timestamps in a sorted list for each key\n    - Use binary search to efficiently find the largest timestamp \u2264 target\n    \"\"\"\n        self.store = {}\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])  # Add to end.\n    \n    def get(self, key: str, timestamp: int) -> str:\n        res = \"\"\n        values = self.store.get(key, [])\n        \n        l, r = 0, len(values) - 1  # Initialize two pointers.\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3, 4, 5], target = 3",
        "output": "2",
        "explanation": "Target found at index 2."
      },
      {
        "input": "nums = [1, 2, 3], target = 0",
        "output": "-1",
        "explanation": "Target not found."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "Array is sorted"
    ],
    "commonMistakes": [
      "Infinite loop due to wrong mid calculation",
      "Off-by-one in left/right bounds",
      "Not handling empty array"
    ],
    "interviewTip": "Mention O(log n). Discuss edge handling: left-most vs right-most.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {\n        // Implement initialization logic here\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Solution() {\n        \n    }\n}",
        "code": "class Solution {\n    public Solution() {\n        \n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\npublic:\n    __init__() {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() TimeMap {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype TimeMap struct {\n\tktv map[string][]pair\n}\n\nfunc (s *Solution) Constructor() TimeMap {\n\treturn TimeMap{map[string][]pair{}}\n}\n\nfunc (this *TimeMap) Set(key string, value string, timestamp int) {\n\tthis.ktv[key] = append(this.ktv[key], pair{timestamp, value})\n}\n\nfunc (this *TimeMap) Get(key string, timestamp int) string {\n\tpairs := this.ktv[key]\n\ti := sort.Search(len(pairs), func(i int) bool { return pairs[i].t > timestamp })\n\tif i > 0 {\n\t\treturn pairs[i-1].v\n\t}\n\treturn \"\"\n}\n\ntype pair struct {\n\tt int\n\tv string\n}\n\n/**\n * Your TimeMap object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Set(key,value,timestamp);\n * param_2 := obj.Get(key,timestamp);\n */"
      },
      "rust": {
        "initialCode": "struct TimeMap {\n    // Your data structure here\n}\n\nimpl TimeMap {\n    fn new() -> Self {\n        TimeMap {}\n    }\n    \n    fn set(&mut self, key: String, value: String, timestamp: i32) {\n        // Store the key with value at the given timestamp\n    }\n    \n    fn get(&self, key: String, timestamp: i32) -> String {\n        // Return the value at the given timestamp, or \"\" if not found\n        String::new()\n    }\n}\n",
        "code": "use std::collections::HashMap;\n\ntype Pair = (i32, String);\n\n#[derive(Default)]\nstruct TimeMap {\n    map: HashMap<String, Vec<Pair>>,\n}\n\nimpl TimeMap {\n    fn new() -> Self {\n        TimeMap {\n            map: HashMap::new(),\n        }\n    }\n    fn set(&mut self, key: String, value: String, timestamp: i32) {\n        self.map.entry(key).or_default().push((timestamp, value));\n    }\n    fn get(&mut self, key: String, timestamp: i32) -> String {\n        let values = self.map.entry(key).or_default();\n        match values.binary_search_by_key(&timestamp, |v| v.0) {\n            Ok(i) => values[i].1.to_string(),\n            Err(i) => {\n                if i > 0 {\n                    values[i - 1].1.to_string()\n                } else {\n                    \"\".to_string()\n                }\n            }\n        }\n    }\n}\n\n#[test]\nfn test() {\n    let mut kv: TimeMap = TimeMap::new();\n    kv.set(\"foo\".to_string(), \"bar\".to_string(), 1);\n    assert_eq!(kv.get(\"foo\".to_string(), 1), \"bar\".to_string());\n    assert_eq!(kv.get(\"foo\".to_string(), 3), \"bar\".to_string());\n    kv.set(\"foo\".to_string(), \"bar2\".to_string(), 4);\n    assert_eq!(kv.get(\"foo\".to_string(), 4), \"bar2\".to_string());\n    assert_eq!(kv.get(\"foo\".to_string(), 5), \"bar2\".to_string());\n}"
      },
      "python": {
        "initialCode": "class TimeMap:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # Store the key with value at the given timestamp\n        pass\n\n    def get(self, key: str, timestamp: int) -> str:\n        # Return the value at the given timestamp, or \"\" if not found\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__() {}\n}",
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\nImplement the TimeMap class:",
    "relatedProblems": [
      "search-in-rotated-sorted-array",
      "search-a-2d-matrix",
      "search-insert-position"
    ]
  },
  "kth-largest-element-in-a-stream": {
    "id": "kth-largest-element-in-a-stream",
    "slug": "kth-largest-element-in-a-stream",
    "title": "Kth Largest Element in a Stream",
    "difficulty": "Easy",
    "category": "Heap",
    "problemStatement": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\nYou are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.\nImplement the KthLargest class:",
    "videoUrl": "",
    "pattern": "Min Heap",
    "patternEmoji": "\u2b07\ufe0f",
    "timeComplexity": "O(n log k)",
    "spaceComplexity": "O(k)",
    "oneliner": "Use a min-heap of size k to track the kth largest element.",
    "intuition": [
      "We only need to keep track of the k largest elements seen so far",
      "A min-heap of size k will have the kth largest at its root"
    ],
    "visualizationType": "array",
    "initialState": [
      4,
      5,
      8,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Kth Largest Element in a Stream",
        "transientMessage": "Input: [4, 5, 8, 2]",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 4",
        "transientMessage": "Step 1 of 4",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 5",
        "transientMessage": "Step 2 of 4",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 8",
        "transientMessage": "Step 3 of 4",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 2",
        "transientMessage": "Step 4 of 4",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          4,
          5,
          8,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    class KthLargest:\n        def __init__(self, k: int, nums: list[int]):\n        \"\"\"\n        Intuition:\n        - We only need to keep track of the k largest elements seen so far\n        - A min-heap of size k will have the kth largest at its root\n        \"\"\"\n            self.k = k\n            self.heap = nums[:]\n            heapq.heapify(self.heap)  # Convert list into a heap.\n            \n            # Maintain heap size as k\n            while len(self.heap) > k:\n                heapq.heappop(self.heap)  # Remove and return last element.\n        \n        def add(self, val: int) -> int:\n            heapq.heappush(self.heap, val)\n            \n            # Maintain heap size as k\n            if len(self.heap) > self.k:\n                heapq.heappop(self.heap)  # Remove and return last element.\n                \n            return self.heap[0]",
    "keyInsight": "Min-heap of size k keeps kth largest at root; only store k elements.",
    "testCases": [
      {
        "input": "commands = [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]; args = [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
        "output": "[null, 4, 5, 5, 8, 8]"
      },
      {
        "input": "commands = [\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]; args = [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
        "output": "[null, 7, 7, 7, 8]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Min Heap: Use a min-heap of size k to track the kth largest element.",
    "videoId": "hOjcdrqMoQ8",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        # Initialize your data structure here\n        pass\n\n    def add(self, val: int) -> int:\n        # Add a new element to the stream and return the Kth largest element\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def __init___brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "intuition": [
          "We only need to keep track of the k largest elements seen so far",
          "A min-heap of size k will have the kth largest at its root"
        ],
        "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n    \"\"\"\n    Intuition:\n    - We only need to keep track of the k largest elements seen so far\n    - A min-heap of size k will have the kth largest at its root\n    \"\"\"\n        self.k = k\n        self.heap = nums[:]\n        heapq.heapify(self.heap)  # Convert list into a heap.\n        \n        # Maintain heap size as k\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        # Maintain heap size as k\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)  # Remove and return last element.\n            \n        return self.heap[0]"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor(k: number, nums: number[]) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor(k: number, nums: number[]) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int add(int val) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public Solution(int k, int[] nums) {\n        \n    }\n    \n    public int add(int val) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    Solution() {\n        // Constructor implementation goes here\n    }\n};",
        "code": "class Solution {\npublic:\n    Solution() {\n        // Constructor implementation goes here\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor(k int, nums []int) KthLargest {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype KthLargest struct {\n\tk    int\n\tminQ hp\n}\n\nfunc (s *Solution) Constructor(k int, nums []int) KthLargest {\n\tminQ := hp{}\n\tthis := KthLargest{k, minQ}\n\tfor _, x := range nums {\n\t\tthis.Add(x)\n\t}\n\treturn this\n}\n\nfunc (this *KthLargest) Add(val int) int {\n\theap.Push(&this.minQ, val)\n\tif this.minQ.Len() > this.k {\n\t\theap.Pop(&this.minQ)\n\t}\n\treturn this.minQ.IntSlice[0]\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h *hp) Less(i, j int) bool { return h.IntSlice[i] < h.IntSlice[j] }\nfunc (h *hp) Pop() interface{} {\n\told := h.IntSlice\n\tn := len(old)\n\tx := old[n-1]\n\th.IntSlice = old[0 : n-1]\n\treturn x\n}\nfunc (h *hp) Push(x interface{}) {\n\th.IntSlice = append(h.IntSlice, x.(int))\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * obj := Constructor(k, nums);\n * param_1 := obj.Add(val);\n */"
      },
      "rust": {
        "initialCode": "struct KthLargest {\n    // Your data structure here\n}\n\nimpl KthLargest {\n    fn new(k: i32, nums: Vec<i32>) -> Self {\n        KthLargest {}\n    }\n    \n    fn add(&mut self, val: i32) -> i32 {\n        // Add a new element to the stream and return the Kth largest element\n        0\n    }\n}\n",
        "code": "use std::cmp::Reverse;\nuse std::collections::BinaryHeap;\n\nstruct KthLargest {\n    pq: BinaryHeap<Reverse<i32>>,\n    k: usize,\n}\n\nimpl KthLargest {\n    fn new(k: i32, nums: Vec<i32>) -> Self {\n        let mut pq: BinaryHeap<Reverse<i32>> = BinaryHeap::new();\n        let k = k as usize;\n        for x in nums {\n            pq.push(Reverse(x));\n            if pq.len() > k {\n                pq.pop();\n            }\n        }\n        KthLargest { pq, k }\n    }\n\n    fn add(&mut self, val: i32) -> i32 {\n        self.pq.push(Reverse(val));\n        if self.pq.len() > self.k {\n            self.pq.pop();\n        }\n        let x = *self.pq.peek().unwrap();\n        x.0\n    }\n}\n\n#[test]\nfn test() {\n    let k = 3;\n    let nums = vec![4, 5, 8, 2];\n    let mut obj = KthLargest::new(k, nums);\n    assert_eq!(obj.add(3), 4);\n    assert_eq!(obj.add(5), 5);\n    assert_eq!(obj.add(10), 5);\n    assert_eq!(obj.add(9), 8);\n    assert_eq!(obj.add(4), 8);\n}"
      },
      "python": {
        "initialCode": "class KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        # Initialize your data structure here\n        pass\n\n    def add(self, val: int) -> int:\n        # Add a new element to the stream and return the Kth largest element\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() { }\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\nYou are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.\nImplement the KthLargest class:",
    "relatedProblems": [
      "maximum-depth-of-binary-tree",
      "majority-element",
      "search-insert-position"
    ],
    "suggestedNextQuestion": {
      "slug": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "Two Pointers"
    }
  },
  "last-stone-weight": {
    "id": "last-stone-weight",
    "slug": "last-stone-weight",
    "title": "Last Stone Weight",
    "difficulty": "Easy",
    "category": "Heap",
    "problemStatement": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.",
    "videoUrl": "",
    "pattern": "Heap (Priority Queue)",
    "patternEmoji": "\u2b07\ufe0f",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use a max heap to efficiently retrieve the two heaviest stones.",
    "intuition": [
      "We always need the two heaviest stones, so we need efficient access to the maximum elements.",
      "A max heap allows us to retrieve the maximum element in O(log n) time."
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      7,
      4,
      1,
      8,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Last Stone Weight",
        "transientMessage": "Input: [2, 7, 4, 1, 8, 1]",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Process the array",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Processing element 0: 2",
        "transientMessage": "Step 1 of 5",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Processing element 1: 7",
        "transientMessage": "Step 2 of 5",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Processing element 2: 4",
        "transientMessage": "Step 3 of 5",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Processing element 3: 1",
        "transientMessage": "Step 4 of 5",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Processing element 4: 8",
        "transientMessage": "Step 5 of 5",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result computed!",
        "arrayState": [
          2,
          7,
          4,
          1,
          8,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import heapq\n    \n    def lastStoneWeight(self, stones):\n        \"\"\"\n        Intuition:\n        - We always need the two heaviest stones, so we need efficient access to the maximum elements.\n        - A max heap allows us to retrieve the maximum element in O(log n) time.\n        \"\"\"\n        # Convert to negative values for max heap simulation\n        heap = [-stone for stone in stones]\n        heapq.heapify(heap)  # Convert list into a heap.\n        \n        while len(heap) > 1:\n            # Get two heaviest stones\n            first = -heapq.heappop(heap)  # Remove and return last element.\n            second = -heapq.heappop(heap)  # Remove and return last element.\n            \n            # If they're not equal, push back the difference\n            if first != second:\n                heapq.heappush(heap, -(first - second))\n        \n        return -heap[0] if heap else 0",
    "keyInsight": "Python's heapq is a min heap, so we negate values to simulate a max heap.",
    "testCases": [
      {
        "input": "stones = [2,7,4,1,8,1]",
        "output": "1"
      },
      {
        "input": "stones = [1]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Heap (Priority Queue): Use a max heap to efficiently retrieve the two heaviest stones.",
    "videoId": "B-QCq79-Vfw",
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Sort the entire array.",
          "Pick top K elements from sorted result."
        ],
        "code": "def lastStoneWeight_brute(nums, k):\n    # Sort and take first k\n    return sorted(nums)[:k]"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "We always need the two heaviest stones, so we need efficient access to the maximum elements.",
          "A max heap allows us to retrieve the maximum element in O(log n) time."
        ],
        "code": "import heapq\n\ndef lastStoneWeight(stones):\n    \"\"\"\n    Intuition:\n    - We always need the two heaviest stones, so we need efficient access to the maximum elements.\n    - A max heap allows us to retrieve the maximum element in O(log n) time.\n    \"\"\"\n    # Convert to negative values for max heap simulation\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)  # Convert list into a heap.\n    \n    while len(heap) > 1:\n        # Get two heaviest stones\n        first = -heapq.heappop(heap)  # Remove and return last element.\n        second = -heapq.heappop(heap)  # Remove and return last element.\n        \n        # If they're not equal, push back the difference\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    return -heap[0] if heap else 0"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(stones: number[]): number {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(stones: number[]): number {\n        \n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int solve(int[] stones) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int solve(int[] stones) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int solve(vector<int>& stones) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int solve(vector<int>& stones) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) lastStoneWeight(stones []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) lastStoneWeight(stones []int) int {\n\tq := &hp{stones}\n\theap.Init(q)\n\tfor q.Len() > 1 {\n\t\ty, x := q.pop(), q.pop()\n\t\tif x != y {\n\t\t\tq.push(y - x)\n\t\t}\n\t}\n\tif q.Len() > 0 {\n\t\treturn q.IntSlice[0]\n\t}\n\treturn 0\n}\n\ntype hp struct{ sort.IntSlice }\n\nfunc (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] }\nfunc (h *hp) Push(v any)        { h.IntSlice = append(h.IntSlice, v.(int)) }\nfunc (h *hp) Pop() any {\n\ta := h.IntSlice\n\tv := a[len(a)-1]\n\th.IntSlice = a[:len(a)-1]\n\treturn v\n}\nfunc (h *hp) push(v int) { heap.Push(h, v) }\nfunc (h *hp) pop() int   { return heap.Pop(h).(int) }"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [1127] Last Stone Weight\n *\n * We have a collection of rocks, each rock has a positive integer weight.\n *\n * Each turn, we choose the two heaviest rocks and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:\n *\n *\n * \tIf x == y, both stones are totally destroyed;\n * \tIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\n *\n *\n * At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)\n *\n *  \n *\n * Example 1:\n *\n *\n * Input: [2,7,4,1,8,1]\n * Output: 1\n * Explanation:\n * We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\n * we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\n * we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\n * we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.\n *\n *  \n *\n * Note:\n *\n * <ol>\n * \t1 <= stones.length <= 30\n * \t1 <= stones[i] <= 1000\n * </ol>\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/last-stone-weight/\n// discuss: https://leetcode.com/problems/last-stone-weight/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\nuse std::collections::BinaryHeap;\nimpl Solution {\n    pub fn last_stone_weight(stones: Vec<i32>) -> i32 {\n        let mut heap = BinaryHeap::new();\n        heap.extend(stones);\n        loop {\n            if let Some(rock1) = heap.pop() {\n                if let Some(rock2) = heap.pop() {\n                    if rock1 > rock2 {\n                        heap.push(rock1 - rock2);\n                    }\n                } else {\n                    return rock1;\n                }\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_1127() {\n        assert_eq!(Solution::last_stone_weight(vec![2, 7, 4, 1, 8, 1]), 1);\n        assert_eq!(Solution::last_stone_weight(vec![2]), 2);\n        assert_eq!(Solution::last_stone_weight(vec![2, 2]), 0);\n        assert_eq!(Solution::last_stone_weight(vec![1, 2, 2]), 1);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(stones: number[]): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    solve(stones: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.",
    "relatedProblems": [
      "longest-common-prefix",
      "convert-sorted-array-to-binary-search-tree",
      "diameter-of-binary-tree"
    ],
    "suggestedNextQuestion": {
      "slug": "reverse-linked-list",
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "pattern": "Iterative Pointer Swap"
    }
  },
  "design-twitter": {
    "id": "design-twitter",
    "slug": "design-twitter",
    "title": "Design Twitter",
    "difficulty": "Medium",
    "category": "Heap",
    "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:",
    "videoUrl": "",
    "pattern": "Hash Map + Heap",
    "patternEmoji": "\ud83d\uddc2\ufe0f+\ud83d\udd25",
    "timeComplexity": "O(n log k)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use hash maps for users/tweets and a min-heap for news feed.",
    "intuition": [
      "Need fast lookup for users and their follows \u2192 Hash Map",
      "Need top 10 most recent tweets \u2192 Min-Heap of size 10"
    ],
    "visualizationType": "array",
    "initialState": [
      "User 1 follows User 2",
      "User 2 posts tweet",
      "User 1 gets news feed"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Design Twitter",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = User 1 follows User 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = User 2 posts tweet",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = User 1 gets news feed",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "User 1 follows User 2",
          "User 2 posts tweet",
          "User 1 gets news feed"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    import heapq\n    class Twitter:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - Need fast lookup for users and their follows \u2192 Hash Map\n        - Need top 10 most recent tweets \u2192 Min-Heap of size 10\n        \"\"\"\n            self.time = 0\n            self.tweets = {}\n            self.follows = {}\n        \n        def postTweet(self, userId, tweetId):\n            self.time += 1\n            if userId not in self.tweets:\n                self.tweets[userId] = []\n            self.tweets[userId].append((-self.time, tweetId))  # Add to end.\n        \n        def getNewsFeed(self, userId):\n            heap = []\n            users = {userId} | self.follows.get(userId, set())\n            for user in users:  # Iterate over elements.\n                for tweet in self.tweets.get(user, [])[-10:]:  # Iterate over elements.\n                    heapq.heappush(heap, tweet)\n                    if len(heap) > 10:\n                        heapq.heappop(heap)  # Remove and return last element.\n            return [tweetId for _, tweetId in sorted(heap)]\n        \n        def follow(self, followerId, followeeId):\n            if followerId not in self.follows:\n                self.follows[followerId] = set()\n            self.follows[followerId].add(followeeId)\n        \n        def unfollow(self, followerId, followeeId):\n            if followerId in self.follows and followeeId in self.follows[followerId]:\n                self.follows[followerId].remove(followeeId)",
    "keyInsight": "Use negative timestamps for min-heap to get most recent tweets.",
    "testCases": [
      {
        "input": "twitter = Twitter(); twitter.postTweet(1, 5); twitter.getNewsFeed(1)",
        "output": "[5]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Hash Map + Heap: Use hash maps for users/tweets and a min-heap for news feed.",
    "videoId": "pNichitDD2E",
    "suggestedNextQuestion": {
      "slug": "detect-squares",
      "title": "Detect Squares",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a VIP club line where the most important person (max/min) always skips to the front.",
    "initialCode": "class Twitter:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        # Compose a new tweet with ID tweetId by the user userId\n        pass\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Retrieve the 10 most recent tweet IDs in the user's news feed\n        pass\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        # Follower follows a followee\n        pass\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        # Follower unfollows a followee\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Need fast lookup for users and their follows \u2192 Hash Map",
          "Need top 10 most recent tweets \u2192 Min-Heap of size 10"
        ],
        "code": "import heapq\nclass Twitter:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - Need fast lookup for users and their follows \u2192 Hash Map\n    - Need top 10 most recent tweets \u2192 Min-Heap of size 10\n    \"\"\"\n        self.time = 0\n        self.tweets = {}\n        self.follows = {}\n    \n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        if userId not in self.tweets:\n            self.tweets[userId] = []\n        self.tweets[userId].append((-self.time, tweetId))  # Add to end.\n    \n    def getNewsFeed(self, userId):\n        heap = []\n        users = {userId} | self.follows.get(userId, set())\n        for user in users:  # Iterate over elements.\n            for tweet in self.tweets.get(user, [])[-10:]:  # Iterate over elements.\n                heapq.heappush(heap, tweet)\n                if len(heap) > 10:\n                    heapq.heappop(heap)  # Remove and return last element.\n        return [tweetId for _, tweetId in sorted(heap)]\n    \n    def follow(self, followerId, followeeId):\n        if followerId not in self.follows:\n            self.follows[followerId] = set()\n        self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        if followerId in self.follows and followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)"
      }
    ],
    "examples": [
      {
        "input": "nums = [2, 7, 11, 15], target = 9",
        "output": "[0, 1]",
        "explanation": "Hash map stores complements."
      },
      {
        "input": "nums = [3, 3], target = 6",
        "output": "[0, 1]",
        "explanation": "Same values, different indices."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Only one valid answer exists"
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    __init__() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    __init__() {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public Solution() {\n        // constructor logic goes here\n    }\n}",
        "code": "class Solution {\n    public Solution() {\n        // constructor logic goes here\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Twitter {\npublic:\n    Twitter() {\n        // Initialize your data structure here\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        // Compose a new tweet with ID tweetId by the user userId\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        // Retrieve the 10 most recent tweet IDs in the user's news feed\n        return {};\n    }\n    \n    void follow(int followerId, int followeeId) {\n        // Follower follows a followee\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        // Follower unfollows a followee\n    }\n};\n",
        "code": "class Twitter {\npublic:\n    Twitter() {}\n    void postTweet(int userId, int tweetId) {}\n    vector<int> getNewsFeed(int userId) { return {}; }\n    void follow(int followerId, int followeeId) {}\n    void unfollow(int followerId, int followeeId) {}\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() Twitter {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype Twitter struct {\n    // simplified\n}\nfunc (s *Solution) Constructor() Twitter {\n    return Twitter{}\n}\nfunc (this *Twitter) PostTweet(userId int, tweetId int) {}\nfunc (this *Twitter) GetNewsFeed(userId int) []int { return []int{} }\nfunc (this *Twitter) Follow(followerId int, followeeId int) {}\nfunc (this *Twitter) Unfollow(followerId int, followeeId int) {}"
      },
      "rust": {
        "initialCode": "struct Twitter {\n    // Your data structure here\n}\n\nimpl Twitter {\n    fn new() -> Self {\n        Twitter {}\n    }\n    \n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\n        // Compose a new tweet with ID tweetId by the user userId\n    }\n    \n    fn get_news_feed(&self, user_id: i32) -> Vec<i32> {\n        // Retrieve the 10 most recent tweet IDs in the user's news feed\n        vec![]\n    }\n    \n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\n        // Follower follows a followee\n    }\n    \n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\n        // Follower unfollows a followee\n    }\n}\n",
        "code": "use std::cmp::Reverse;\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\ntype Tweet = (Reverse<usize>, i32);\n\n#[derive(Default)]\nstruct Twitter {\n    time: usize,\n    users: HashMap<i32, HashSet<i32>>,\n    tweets: HashMap<i32, Vec<Tweet>>,\n    limit: usize,\n}\n\nimpl Twitter {\n    fn new() -> Self {\n        let time = 0;\n        let users = HashMap::new();\n        let tweets = HashMap::new();\n        let limit = 10;\n        Twitter {\n            time,\n            users,\n            tweets,\n            limit,\n        }\n    }\n\n    fn post_tweet(&mut self, user_id: i32, tweet_id: i32) {\n        self.time += 1;\n        let tweet: Tweet = (Reverse(self.time), tweet_id);\n        self.tweets.entry(user_id).or_default().push(tweet);\n    }\n\n    fn get_news_feed(&mut self, user_id: i32) -> Vec<i32> {\n        let mut pq: BinaryHeap<Tweet> = BinaryHeap::with_capacity(self.limit + 1);\n        let mut res: Vec<i32> = vec![];\n        let followers = self.users.entry(user_id).or_default();\n        followers.insert(user_id);\n        for &user in followers.iter() {\n            let tweets = self.tweets.entry(user).or_default();\n            for tweet in tweets {\n                pq.push(*tweet);\n                if pq.len() > self.limit {\n                    pq.pop();\n                }\n            }\n        }\n        while !pq.is_empty() {\n            let earliest = pq.pop().unwrap();\n            res.push(earliest.1);\n        }\n        res.reverse();\n        res\n    }\n\n    fn follow(&mut self, follower_id: i32, followee_id: i32) {\n        self.users\n            .entry(follower_id)\n            .or_default()\n            .insert(followee_id);\n    }\n\n    fn unfollow(&mut self, follower_id: i32, followee_id: i32) {\n        self.users\n            .entry(follower_id)\n            .or_default()\n            .remove(&followee_id);\n    }\n}\n\n#[test]\nfn test() {\n    let mut twitter = Twitter::new();\n    twitter.post_tweet(1, 5);\n    assert_eq!(twitter.get_news_feed(1), vec![5]);\n    twitter.follow(1, 2);\n    twitter.post_tweet(2, 6);\n    assert_eq!(twitter.get_news_feed(1), vec![6, 5]);\n    twitter.unfollow(1, 2);\n    assert_eq!(twitter.get_news_feed(1), vec![5]);\n}"
      },
      "python": {
        "initialCode": "class Twitter:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        # Compose a new tweet with ID tweetId by the user userId\n        pass\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Retrieve the 10 most recent tweet IDs in the user's news feed\n        pass\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        # Follower follows a followee\n        pass\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        # Follower unfollows a followee\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    constructor() {}\n}",
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:",
    "relatedProblems": [
      "valid-sudoku",
      "maximal-square",
      "unique-paths-ii"
    ]
  },
  "sum-of-two-integers": {
    "id": "sum-of-two-integers",
    "slug": "sum-of-two-integers",
    "title": "Sum of Two Integers",
    "difficulty": "Medium",
    "category": "Bit Manipulation",
    "problemStatement": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
    "videoUrl": "",
    "pattern": "Bit Manipulation",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use XOR for sum without carry and AND+shift for carry.",
    "intuition": [
      "XOR gives us the sum of two bits without considering carry",
      "AND operation identifies where carries occur, then shift left to add them"
    ],
    "visualizationType": "array",
    "initialState": [
      5,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Sum of Two Integers",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 5",
        "transientMessage": "Iteration 1",
        "arrayState": [
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          5,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          5,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def getSum(self, a, b):\n        \"\"\"\n        Intuition:\n        - XOR gives us the sum of two bits without considering carry\n        - AND operation identifies where carries occur, then shift left to add them\n        \"\"\"\n        mask = 0xFFFFFFFF\n        MAX_INT = 0x7FFFFFFF\n\n        while b != 0:\n            carry = (a & b) << 1  # AND (Carry bits).\n            a = (a ^ b) & mask  # XOR (Sum without carry).\n            b = carry & mask\n\n        return a if a <= MAX_INT else ~(a ^ mask)",
    "keyInsight": "Binary addition can be simulated using XOR (sum) and AND+shift (carry) operations.",
    "testCases": [
      {
        "input": "a = 1, b = 2",
        "output": "3"
      },
      {
        "input": "a = 2, b = 3",
        "output": "5"
      }
    ],
    "walkthrough": [
      "Identify bits pattern in problem",
      "Use bitwise operators (AND, OR, XOR, shift)",
      "Iterate through bits if needed",
      "Combine results using bit operations",
      "Return final bit result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Bit Manipulation: Use XOR for sum without carry and AND+shift for carry.",
    "videoId": "gVUrDV4tZfY",
    "mentalModel": "Like digital DNA. You are flipping the fundamental switches (0s and 1s) that make up the number.",
    "initialCode": "class Solution:\n    def getSum(self, a, b):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def getSum(a, b):\n    mask = 0xffffffff\n    while (b & mask) > 0:\n        carry = (a & b) << 1\n        a = a ^ b\n        b = carry\n    return (a & mask) if b > 0 else a"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "XOR gives us the sum of two bits without considering carry",
          "AND operation identifies where carries occur, then shift left to add them"
        ],
        "code": "def getSum(a, b):\n    \"\"\"\n    Intuition:\n    - XOR gives us the sum of two bits without considering carry\n    - AND operation identifies where carries occur, then shift left to add them\n    \"\"\"\n    mask = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1  # AND (Carry bits).\n        a = (a ^ b) & mask  # XOR (Sum without carry).\n        b = carry & mask\n    \n    return a if a <= MAX_INT else ~(a ^ mask)"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    getSum(a, b) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} a, b\n     * @return {any}\n     */\n    getSum(a, b) {\n        const sum = a ^ b;\n        const carry = (a & b) << 1;\n\n        if (!carry) {\n          return sum;\n      }\n\n    return getSum(sum, carry);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int getSum(int a, int b) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int getSum(int a, int b) {\n        return b == 0 ? a : getSum(a ^ b, (a & b) << 1);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int getSum(int a, int b) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int getSum(int a, int b) {\n        while (b) {\n            unsigned int carry = (unsigned int) (a & b) << 1;\n            a = a ^ b;\n            b = carry;\n        }\n        return a;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) getSum(a int, b int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) getSum(a int, b int) int {\n\tfor b != 0 {\n\t\ts := a ^ b\n\t\tb = (a & b) << 1\n\t\ta = s\n\t}\n\treturn a\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn get_sum(a: i32, b: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn get_sum(a: i32, b: i32) -> i32 {\n        if b == 0 {\n            a\n        } else {\n            Self::get_sum(a ^ b, (a & b) << 1)\n        }\n    }\n}\n\n#[test]\nfn test() {\n    assert_eq!(Solution::get_sum(1, 2), 3);\n    assert_eq!(Solution::get_sum(-2, 3), 1);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def getSum(self, a, b):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    getSum(a: any, b: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    getSum(a: any, b: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
    "relatedProblems": [
      "number-of-1-bits",
      "minimum-operations-to-reduce-an-integer-to-0",
      "reverse-bits"
    ],
    "suggestedNextQuestion": {
      "slug": "minimum-operations-to-reduce-an-integer-to-0",
      "title": "Minimum Operations to Reduce an Integer to 0",
      "difficulty": "Medium",
      "pattern": "Bit Manipulation"
    }
  },
  "reverse-integer": {
    "id": "reverse-integer",
    "slug": "reverse-integer",
    "title": "Reverse Integer",
    "difficulty": "Medium",
    "category": "Bit Manipulation",
    "problemStatement": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "videoUrl": "",
    "pattern": "Math",
    "patternEmoji": "\ud83d\udd22",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Build reversed number digit by digit, checking overflow early.",
    "intuition": [
      "Extract digits using modulo and division operations",
      "Check for overflow before it happens using math"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Reverse Integer",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          2,
          3
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def reverse(self, x):\n        \"\"\"\n        Intuition:\n        - Extract digits using modulo and division operations\n        - Check for overflow before it happens using math\n        \"\"\"\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        sign = -1 if x < 0 else 1\n        x_abs = abs(x)\n        reversed_num = 0\n\n        while x_abs != 0:\n            digit = x_abs % 10\n\n            # Check for overflow before multiplying\n            if reversed_num > (INT_MAX - digit) // 10:\n                return 0\n\n            reversed_num = reversed_num * 10 + digit\n            x_abs //= 10\n\n        return sign * reversed_num",
    "keyInsight": "Process digits one by one and build result, but check overflow before each multiplication.",
    "testCases": [
      {
        "input": "x = 123",
        "output": "321"
      },
      {
        "input": "x = -123",
        "output": "-321"
      },
      {
        "input": "x = 120",
        "output": "21"
      }
    ],
    "walkthrough": [
      "Identify mathematical pattern or formula",
      "Handle edge cases (zero, negative, overflow)",
      "Apply mathematical operations",
      "Optimize with mathematical properties",
      "Return computed result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Math: Build reversed number digit by digit, checking overflow early.",
    "videoId": "HAgLH58IgJQ",
    "mentalModel": "Like finding the underlying formula that governs the universe, rather than simulating every step.",
    "initialCode": "class Solution:\n    def reverse(self, x):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def reverse(x):\n    sign = -1 if x < 0 else 1\n    x *= sign\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    return 0 if res > 2**31 else sign * res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Extract digits using modulo and division operations",
          "Check for overflow before it happens using math"
        ],
        "code": "def reverse(x):\n    \"\"\"\n    Intuition:\n    - Extract digits using modulo and division operations\n    - Check for overflow before it happens using math\n    \"\"\"\n    INT_MAX, INT_MIN = 2**31 - 1, -2**31\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    reversed_num = 0\n    \n    while x_abs != 0:\n        digit = x_abs % 10\n        \n        # Check for overflow before multiplying\n        if reversed_num > (INT_MAX - digit) // 10:\n            return 0\n            \n        reversed_num = reversed_num * 10 + digit\n        x_abs //= 10\n    \n    return sign * reversed_num"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    reverse(x) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} x\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} x\n     * @return {any}\n     */\n    reverse(x) {\n        const mi = -(2 ** 31);\n        const mx = 2 ** 31 - 1;\n        let ans = 0;\n        for (; x != 0; x = ~~(x / 10)) {\n            if (ans < ~~(mi / 10) || ans > ~~(mx / 10)) {\n                return 0;\n            }\n            ans = ans * 10 + (x % 10);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int reverse(int x) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int reverse(int x) {\n        int ans = 0;\n        for (; x != 0; x /= 10) {\n            if (ans < Integer.MIN_VALUE / 10 || ans > Integer.MAX_VALUE / 10) {\n                return 0;\n            }\n            ans = ans * 10 + x % 10;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int reverse(int x) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int reverse(int x) {\n        int ans = 0;\n        for (; x; x /= 10) {\n            if (ans < INT_MIN / 10 || ans > INT_MAX / 10) {\n                return 0;\n            }\n            ans = ans * 10 + x % 10;\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) reverse(x int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) reverse(x int) (ans int) {\n\tfor ; x != 0; x /= 10 {\n\t\tif ans < math.MinInt32/10 || ans > math.MaxInt32/10 {\n\t\t\treturn 0\n\t\t}\n\t\tans = ans*10 + x%10\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn reverse(mut x: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn reverse(mut x: i32) -> i32 {\n        let is_minus = x < 0;\n        match x\n            .abs()\n            .to_string()\n            .chars()\n            .rev()\n            .collect::<String>()\n            .parse::<i32>()\n        {\n            Ok(x) => x * (if is_minus { -1 } else { 1 }),\n            Err(_) => 0,\n        }\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def reverse(self, x):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    reverse(x: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    reverse(x: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).",
    "relatedProblems": [
      "factorial-trailing-zeroes",
      "missing-number"
    ],
    "suggestedNextQuestion": {
      "slug": "factorial-trailing-zeroes",
      "title": "Factorial Trailing Zeroes",
      "difficulty": "Medium",
      "pattern": "Math"
    }
  },
  "powx-n": {
    "id": "powx-n",
    "slug": "powx-n",
    "title": "Pow(x, n)",
    "difficulty": "Medium",
    "category": "Math",
    "problemStatement": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
    "videoUrl": "",
    "pattern": "Binary Exponentiation",
    "patternEmoji": "\u26a1",
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use binary exponentiation to reduce multiplication steps.",
    "intuition": [
      "Instead of multiplying x n times, break n into powers of 2",
      "Use the property: x^n = (x^(n/2))^2 to halve the problem size"
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      10
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Pow(x, n)",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 10",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          10
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Compute result phase 7",
        "transientMessage": "Building solution",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [
          1,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          2,
          10
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def myPow(self, x, n):\n        \"\"\"\n        Intuition:\n        - Instead of multiplying x n times, break n into powers of 2\n        - Use the property: x^n = (x^(n/2))^2 to halve the problem size\n        \"\"\"\n        if n == 0:\n            return 1\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1\n        while n:\n            if n % 2 == 1:\n                result *= x\n            x *= x\n            n //= 2\n        return result  # Return the final result.",
    "keyInsight": "Repeated squaring reduces exponential time to logarithmic.",
    "testCases": [
      {
        "input": "x = 2.00000, n = 10",
        "output": "1024.00000"
      },
      {
        "input": "x = 2.10000, n = 3",
        "output": "9.26100"
      },
      {
        "input": "x = 2.00000, n = -2",
        "output": "0.25000"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Binary Exponentiation: Use binary exponentiation to reduce multiplication steps.",
    "videoId": "g9YQyYi4IQQ",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def myPow(self, x, n):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def myPow(x, n):\n    def helper(x, n):\n        if x == 0: return 0\n        if n == 0: return 1\n        res = helper(x, n // 2)\n        res = res * res\n        return x * res if n % 2 else res\n    res = helper(x, abs(n))\n    return res if n >= 0 else 1 / res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Instead of multiplying x n times, break n into powers of 2",
          "Use the property: x^n = (x^(n/2))^2 to halve the problem size"
        ],
        "code": "def myPow(x, n):\n    \"\"\"\n    Intuition:\n    - Instead of multiplying x n times, break n into powers of 2\n    - Use the property: x^n = (x^(n/2))^2 to halve the problem size\n    \"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    myPow(x, n) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} x, n\n     * @return {any}\n     */\n    myPow(x, n) {\n        const qpow = (a, n) => {\n            let ans = 1;\n            for (; n; n >>>= 1) {\n                if (n & 1) {\n                    ans *= a;\n                }\n                a *= a;\n        }\n        return ans;\n    };\n    return n >= 0 ? qpow(x, n) : 1 / qpow(x, -n);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public double myPow(double x, int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public double myPow(double x, int n) {\n        return n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long) n);\n    }\n\n    private double qpow(double a, long n) {\n        double ans = 1;\n        for (; n > 0; n >>= 1) {\n            if ((n & 1) == 1) {\n                ans = ans * a;\n            }\n            a = a * a;\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    double myPow(double x, int n) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        auto qpow = [](double a, long long n) {\n            double ans = 1;\n            for (; n; n >>= 1) {\n                if (n & 1) {\n                    ans *= a;\n                }\n                a *= a;\n            }\n            return ans;\n        };\n        return n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long long) n);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) myPow(x float64, n int) float64 {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) myPow(x float64, n int) float64 {\n\tqpow := func(a float64, n int) float64 {\n\t\tans := 1.0\n\t\tfor ; n > 0; n >>= 1 {\n\t\t\tif n&1 == 1 {\n\t\t\t\tans *= a\n\t\t\t}\n\t\t\ta *= a\n\t\t}\n\t\treturn ans\n\t}\n\tif n >= 0 {\n\t\treturn qpow(x, n)\n\t}\n\treturn 1 / qpow(x, -n)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn my_pow(x: f64, n: i32) -> f64 {\n        let mut x = x;\n        let n = n as i64;\n        if n >= 0 {\n            Self::quick_pow(&mut x, n)\n        } else {\n            1.0 / Self::quick_pow(&mut x, -n)\n        }\n    }\n\n    #[allow(dead_code)]\n    fn quick_pow(x: &mut f64, mut n: i64) -> f64 {\n        // `n` should greater or equal to zero\n        let mut ret = 1.0;\n        while n != 0 {\n            if (n & 0x1) == 1 {\n                ret *= *x;\n            }\n            *x *= *x;\n            n >>= 1;\n        }\n        ret\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def myPow(self, x, n):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    myPow(x: number, n: number): number  {\n    const qpow = (a: number, n: number): number => {\n        let ans = 1;\n        for (; n; n >>>= 1) {\n            if (n & 1) {\n                ans *= a;\n            }\n            a *= a;\n        }\n        return ans;\n    };\n    return n >= 0 ? qpow(x, n) : 1 / qpow(x, -n);\n}\n}",
        "initialCode": "class Solution {\n    myPow(x: number, n: number): number {\n        // Your code here\n        return 0;\n    }\n}"
      }
    },
    "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
    "relatedProblems": [
      "sort-list",
      "snakes-and-ladders",
      "combination-sum"
    ],
    "suggestedNextQuestion": {
      "slug": "maximum-subarray",
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "pattern": "Kadane's Algorithm"
    }
  },
  "multiply-strings": {
    "id": "multiply-strings",
    "slug": "multiply-strings",
    "title": "Multiply Strings",
    "difficulty": "Medium",
    "category": "Math",
    "problemStatement": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "videoUrl": "",
    "pattern": "Simulation",
    "patternEmoji": "\ud83c\udfad",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m+n)",
    "oneliner": "Simulate multiplication digit by digit like elementary school math.",
    "intuition": [
      "Multiply each digit of num1 with each digit of num2",
      "Handle carries and position shifts properly"
    ],
    "visualizationType": "array",
    "initialState": [
      0,
      0,
      0,
      0,
      0
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Multiply Strings",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 0",
        "transientMessage": "Iteration 1",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 0",
        "transientMessage": "Iteration 2",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 0",
        "transientMessage": "Iteration 3",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 0",
        "transientMessage": "Iteration 4",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 0",
        "transientMessage": "Iteration 5",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        Intuition:\n        - Multiply each digit of num1 with each digit of num2\n        - Handle carries and position shifts properly\n        \"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        result = [0] * (m + n)\n\n        for i in range(m-1, -1, -1):  # Iterate through the range.\n            for j in range(n-1, -1, -1):  # Iterate through the range.\n                mul = int(num1[i]) * int(num2[j])\n                pos1, pos2 = i + j, i + j + 1\n                total = mul + result[pos2]\n\n                result[pos2] = total % 10\n                result[pos1] += total // 10\n\n        # Skip leading zeros\n        start = 0\n        while start < len(result) and result[start] == 0:\n            start += 1\n\n        return ''.join(map(str, result[start:])) if start < len(result) else '0'",
    "keyInsight": "Use an array to store intermediate results and handle carries properly.",
    "testCases": [
      {
        "input": "num1 = \"2\", num2 = \"3\"",
        "output": "\"6\""
      },
      {
        "input": "num1 = \"123\", num2 = \"456\"",
        "output": "\"56088\""
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Simulation: Simulate multiplication digit by digit like elementary school math.",
    "videoId": "1vZswirL8Y8",
    "mentalModel": "Like following a recipe step-by-step. Do exactly what the problem says.",
    "initialCode": "class Solution:\n    def multiply(self, num1, num2):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def multiply(num1, num2):\n    if \"0\" in [num1, num2]: return \"0\"\n    res = [0] * (len(num1) + len(num2))\n    num1, num2 = num1[::-1], num2[::-1]\n    \n    for i1 in range(len(num1)):\n        for i2 in range(len(num2)):\n            digit = int(num1[i1]) * int(num2[i2])\n            res[i1 + i2] += digit\n            res[i1 + i2 + 1] += (res[i1 + i2] // 10)\n            res[i1 + i2] = res[i1 + i2] % 10\n            \n    res, beg = res[::-1], 0\n    while beg < len(res) and res[beg] == 0:\n        beg += 1\n    return \"\".join(map(str, res[beg:]))"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m+n)",
        "intuition": [
          "Multiply each digit of num1 with each digit of num2",
          "Handle carries and position shifts properly"
        ],
        "code": "def multiply(num1, num2):\n    \"\"\"\n    Intuition:\n    - Multiply each digit of num1 with each digit of num2\n    - Handle carries and position shifts properly\n    \"\"\"\n    if num1 == '0' or num2 == '0':\n        return '0'\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):  # Iterate through the range.\n        for j in range(n-1, -1, -1):  # Iterate through the range.\n            mul = int(num1[i]) * int(num2[j])\n            pos1, pos2 = i + j, i + j + 1\n            total = mul + result[pos2]\n            \n            result[pos2] = total % 10\n            result[pos1] += total // 10\n    \n    # Skip leading zeros\n    start = 0\n    while start < len(result) and result[start] == 0:\n        start += 1\n    \n    return ''.join(map(str, result[start:])) if start < len(result) else '0'"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    multiply(num1, num2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nclass Solution {\n    /**\n     * @param {any} num1, num2\n     * @return {any}\n     */\n    multiply(num1, num2) {\n        if (num1 === '0' || num2 === '0') return '0';\n\n        const result = Array(num1.length + num2.length).fill(0);\n        const code_0 = '0'.charCodeAt(0);\n\n        const num1_len = num1.length;\n        const num2_len = num2.length;\n\n        for (let i = 0; i < num1_len; ++i) {\n            const multiplier_1 = num1.charCodeAt(num1_len - i - 1) - code_0;\n            for (let j = 0; j < num2_len; ++j) {\n                const multiplier_2 = num2.charCodeAt(num2_len - j - 1) - code_0;\n                result[i + j] += multiplier_1 * multiplier_2;\n            }\n    }\n\n    result.reduce((carry, value, index) => {\n        const sum = carry + value;\n        result[index] = sum % 10;\n        return (sum / 10) | 0;\n    }, 0);\n\n    return result\n        .slice(0, result.findLastIndex(d => d !== 0) + 1)\n        .reverse()\n        .join('');\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public String multiply(String num1, String num2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        if (\"0\".equals(num1) || \"0\".equals(num2)) {\n            return \"0\";\n        }\n        int m = num1.length(), n = num2.length();\n        int[] arr = new int[m + n];\n        for (int i = m - 1; i >= 0; --i) {\n            int a = num1.charAt(i) - '0';\n            for (int j = n - 1; j >= 0; --j) {\n                int b = num2.charAt(j) - '0';\n                arr[i + j + 1] += a * b;\n            }\n        }\n        for (int i = arr.length - 1; i > 0; --i) {\n            arr[i - 1] += arr[i] / 10;\n            arr[i] %= 10;\n        }\n        int i = arr[0] == 0 ? 1 : 0;\n        StringBuilder ans = new StringBuilder();\n        for (; i < arr.length; ++i) {\n            ans.append(arr[i]);\n        }\n        return ans.toString();\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    string multiply(string num1, string num2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        int m = num1.size(), n = num2.size();\n        vector<int> arr(m + n);\n        for (int i = m - 1; i >= 0; --i) {\n            int a = num1[i] - '0';\n            for (int j = n - 1; j >= 0; --j) {\n                int b = num2[j] - '0';\n                arr[i + j + 1] += a * b;\n            }\n        }\n        for (int i = arr.size() - 1; i; --i) {\n            arr[i - 1] += arr[i] / 10;\n            arr[i] %= 10;\n        }\n        int i = arr[0] ? 0 : 1;\n        string ans;\n        for (; i < arr.size(); ++i) {\n            ans += '0' + arr[i];\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) multiply(num1 string, num2 string) string {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) multiply(num1 string, num2 string) string {\n\tif num1 == \"0\" || num2 == \"0\" {\n\t\treturn \"0\"\n\t}\n\tm, n := len(num1), len(num2)\n\tarr := make([]int, m+n)\n\tfor i := m - 1; i >= 0; i-- {\n\t\ta := int(num1[i] - '0')\n\t\tfor j := n - 1; j >= 0; j-- {\n\t\t\tb := int(num2[j] - '0')\n\t\t\tarr[i+j+1] += a * b\n\t\t}\n\t}\n\tfor i := len(arr) - 1; i > 0; i-- {\n\t\tarr[i-1] += arr[i] / 10\n\t\tarr[i] %= 10\n\t}\n\ti := 0\n\tif arr[0] == 0 {\n\t\ti = 1\n\t}\n\tans := []byte{}\n\tfor ; i < len(arr); i++ {\n\t\tans = append(ans, byte('0'+arr[i]))\n\t}\n\treturn string(ans)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn multiply(num1: String, num2: String) -> String {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn multiply(num1: String, num2: String) -> String {\n        if num1 == \"0\" || num2 == \"0\" {\n            return String::from(\"0\");\n        }\n        let (num1, num2) = (num1.as_bytes(), num2.as_bytes());\n        let (n, m) = (num1.len(), num2.len());\n        let mut res = vec![];\n        for i in 0..n {\n            let a = num1[n - i - 1] - b'0';\n            let mut sum = 0;\n            let mut j = 0;\n            while j < m || sum != 0 {\n                if i + j == res.len() {\n                    res.push(0);\n                }\n                let b = num2.get(m - j - 1).unwrap_or(&b'0') - b'0';\n                sum += a * b + res[i + j];\n                res[i + j] = sum % 10;\n                sum /= 10;\n                j += 1;\n            }\n        }\n        res.into_iter()\n            .rev()\n            .map(|v| char::from(v + b'0'))\n            .collect()\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def multiply(self, num1, num2):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    multiply(num1: string, num2: string): string  {\n    if (num1 === '0' || num2 === '0') {\n        return '0';\n    }\n    const m: number = num1.length;\n    const n: number = num2.length;\n    const arr: number[] = Array(m + n).fill(0);\n    for (let i: number = m - 1; i >= 0; i--) {\n        const a: number = +num1[i];\n        for (let j: number = n - 1; j >= 0; j--) {\n            const b: number = +num2[j];\n            arr[i + j + 1] += a * b;\n        }\n    }\n    for (let i: number = arr.length - 1; i > 0; i--) {\n        arr[i - 1] += Math.floor(arr[i] / 10);\n        arr[i] %= 10;\n    }\n    let i: number = 0;\n    while (i < arr.length && arr[i] === 0) {\n        i++;\n    }\n    return arr.slice(i).join('');\n}\n}",
        "initialCode": "class Solution {\n    multiply(num1: string, num2: string): string {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "relatedProblems": [
      "plus-one",
      "zigzag-conversion"
    ],
    "suggestedNextQuestion": {
      "slug": "zigzag-conversion",
      "title": "Zigzag Conversion",
      "difficulty": "Medium",
      "pattern": "Simulation"
    }
  },
  "detect-squares": {
    "id": "detect-squares",
    "slug": "detect-squares",
    "title": "Detect Squares",
    "difficulty": "Medium",
    "category": "Math",
    "problemStatement": "You are given a stream of points on the X-Y plane. Design an algorithm that:\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\nImplement the DetectSquares class:",
    "videoUrl": "",
    "pattern": "Geometry + Hash Map",
    "patternEmoji": "\ud83d\udcd0\ud83d\udcca",
    "timeComplexity": "O(n) per query",
    "spaceComplexity": "O(n)",
    "oneliner": "For each existing point, check if it can form a square with the query point and two others.",
    "intuition": [
      "To form a square with query point (x,y), we need three other points that create equal sides and right angles",
      "For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        3,
        10
      ],
      [
        11,
        2
      ],
      [
        3,
        2
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Detect Squares",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          [
            3,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 3,10",
        "arrayState": [
          [
            3,
            10
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            3,
            10
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 11,2",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 3,2",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          [
            3,
            2
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          [
            3,
            2
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          [
            3,
            2
          ]
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            3,
            10
          ],
          [
            11,
            2
          ],
          [
            3,
            2
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import defaultdict\n    \n    class DetectSquares:\n        def __init__(self):\n        \"\"\"\n        Intuition:\n        - To form a square with query point (x,y), we need three other points that create equal sides and right angles\n        - For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length\n        \"\"\"\n            self.point_counts = defaultdict(int)\n            \n        def add(self, point):\n            self.point_counts[tuple(point)] += 1\n            \n        def count(self, point):\n            px, py = point\n            count = 0\n            \n            # For each existing point\n            for (x, y), freq in self.point_counts.items():  # Iterate over elements.\n                # Skip if not diagonal candidate\n                if abs(px - x) != abs(py - y) or px == x or py == y:\n                    continue\n                    \n                # Check if other two corners exist\n                count += freq * self.point_counts[(px, y)] * self.point_counts[(x, py)]\n                \n            return count",
    "keyInsight": "Use hash map to store point frequencies and check diagonal relationships.",
    "testCases": [
      {
        "input": "detectSquares = DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10])",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Geometry + Hash Map: For each existing point, check if it can form a square with the query point and two others.",
    "videoId": "bahebearrDc",
    "suggestedNextQuestion": {
      "slug": "group-anagrams",
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "pattern": "Arrays & Hashing"
    },
    "mentalModel": "Like a coat check. You give a unique token (key) and get your specific item (value) back instantly.",
    "initialCode": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    \n    def add(self, point: list[int]) -> None:\n        # Add a point to the data structure\n        pass\n    \n    def count(self, point: list[int]) -> int:\n        # Count axis-aligned squares with given query point\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Use nested loops to find pairs/groups.",
          "Compare elements directly without using extra space."
        ],
        "code": "def __init___brute(nums):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if condition(nums[i], nums[j]):\n                return [i, j]\n    return []"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n) per query",
        "spaceComplexity": "O(n)",
        "intuition": [
          "To form a square with query point (x,y), we need three other points that create equal sides and right angles",
          "For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length"
        ],
        "code": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n    \"\"\"\n    Intuition:\n    - To form a square with query point (x,y), we need three other points that create equal sides and right angles\n    - For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length\n    \"\"\"\n        self.point_counts = defaultdict(int)\n        \n    def add(self, point):\n        self.point_counts[tuple(point)] += 1\n        \n    def count(self, point):\n        px, py = point\n        count = 0\n        \n        # For each existing point\n        for (x, y), freq in self.point_counts.items():  # Iterate over elements.\n            # Skip if not diagonal candidate\n            if abs(px - x) != abs(py - y) or px == x or py == y:\n                continue\n                \n            # Check if other two corners exist\n            count += freq * self.point_counts[(px, y)] * self.point_counts[(x, py)]\n            \n        return count"
      }
    ],
    "examples": [
      {
        "input": "[\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]",
        "output": "[null, null, null, null, 1, 0, null, 2]",
        "explanation": "DetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // return 1. You can choose:\n//   - The first, second, and third points\ndetectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.\ndetectSquares.add([11, 2]);    // Adding duplicate points is allowed.\ndetectSquares.count([11, 10]); // return 2. You can choose:\n//   - The first, second, and third points\n//   - The first, third, and fourth points"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Only one valid answer exists"
    ],
    "commonMistakes": [
      "Not handling duplicate keys",
      "Forgetting to check if key exists",
      "Using unhashable types as keys"
    ],
    "interviewTip": "Trade-off: O(n) space for O(1) lookup. Discuss collision handling.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    DetectSquares() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} \n     * @return {any}\n     */\n    DetectSquares() {\n        this.points = new Map();\n      };\n\n\n      DetectSquares.prototype.add = function(point) {\n        const [x, y] = point;\n        const key = `${x},${y}`;\n        this.points.set(key, (this.points.get(key) || 0) + 1);\n      };\n\n\n      DetectSquares.prototype.count = function(point) {\n        const [x, y] = point;\n        let result = 0;\n\n        for (const [key, count] of this.points) {\n          const [px, py] = key.split(',').map(Number);\n          if (px === x || py === y || Math.abs(px - x) !== Math.abs(py - y)) continue;\n\n          const point1 = `${x},${py}`;\n          const point2 = `${px},${y}`;\n          result += count * (this.points.get(point1) || 0) * (this.points.get(point2) || 0);\n      }\n\n    return result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int __init__() {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class DetectSquares {\n    private Map<Integer, Map<Integer, Integer>> cnt = new HashMap<>();\n\n    public DetectSquares() {\n    }\n\n    public void add(int[] point) {\n        int x = point[0], y = point[1];\n        cnt.computeIfAbsent(x, k -> new HashMap<>()).merge(y, 1, Integer::sum);\n    }\n\n    public int count(int[] point) {\n        int x1 = point[0], y1 = point[1];\n        if (!cnt.containsKey(x1)) {\n            return 0;\n        }\n        int ans = 0;\n        for (var e : cnt.entrySet()) {\n            int x2 = e.getKey();\n            if (x2 != x1) {\n                int d = x2 - x1;\n                var cnt1 = cnt.get(x1);\n                var cnt2 = e.getValue();\n                ans += cnt2.getOrDefault(y1, 0) * cnt1.getOrDefault(y1 + d, 0)\n                    * cnt2.getOrDefault(y1 + d, 0);\n                ans += cnt2.getOrDefault(y1, 0) * cnt1.getOrDefault(y1 - d, 0)\n                    * cnt2.getOrDefault(y1 - d, 0);\n            }\n        }\n        return ans;\n    }\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares obj = new DetectSquares();\n * obj.add(point);\n * int param_2 = obj.count(point);\n */"
      },
      "cpp": {
        "initialCode": "class Solution {\npublic:\n    int __init__() {\n        // Your code here\n        return 0;\n    }\n};",
        "code": "class DetectSquares {\npublic:\n    DetectSquares() {\n    }\n\n    void add(vector<int> point) {\n        int x = point[0], y = point[1];\n        ++cnt[x][y];\n    }\n\n    int count(vector<int> point) {\n        int x1 = point[0], y1 = point[1];\n        if (!cnt.count(x1)) {\n            return 0;\n        }\n        int ans = 0;\n        for (auto& [x2, cnt2] : cnt) {\n            if (x2 != x1) {\n                int d = x2 - x1;\n                auto& cnt1 = cnt[x1];\n                ans += cnt2[y1] * cnt1[y1 + d] * cnt2[y1 + d];\n                ans += cnt2[y1] * cnt1[y1 - d] * cnt2[y1 - d];\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    unordered_map<int, unordered_map<int, int>> cnt;\n};\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * DetectSquares* obj = new DetectSquares();\n * obj->add(point);\n * int param_2 = obj->count(point);\n */"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) Constructor() DetectSquares {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\ntype DetectSquares struct {\n\tcnt map[int]map[int]int\n}\n\nfunc (s *Solution) Constructor() DetectSquares {\n\treturn DetectSquares{map[int]map[int]int{}}\n}\n\nfunc (this *DetectSquares) Add(point []int) {\n\tx, y := point[0], point[1]\n\tif _, ok := this.cnt[x]; !ok {\n\t\tthis.cnt[x] = map[int]int{}\n\t}\n\tthis.cnt[x][y]++\n}\n\nfunc (this *DetectSquares) Count(point []int) (ans int) {\n\tx1, y1 := point[0], point[1]\n\tif cnt1, ok := this.cnt[x1]; ok {\n\t\tfor x2, cnt2 := range this.cnt {\n\t\t\tif x2 != x1 {\n\t\t\t\td := x2 - x1\n\t\t\t\tans += cnt2[y1] * cnt1[y1+d] * cnt2[y1+d]\n\t\t\t\tans += cnt2[y1] * cnt1[y1-d] * cnt2[y1-d]\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n/**\n * Your DetectSquares object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Add(point);\n * param_2 := obj.Count(point);\n */"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn __init__() -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct DetectSquares {\n    map: std::collections::HashMap<(i32, i32), i32>\n}\nimpl DetectSquares {\n    fn new() -> Self { DetectSquares { map: std::collections::HashMap::new() } }\n    fn add(&mut self, point: Vec<i32>) {\n        *self.map.entry((point[0], point[1])).or_insert(0) += 1;\n    }\n    fn count(&self, point: Vec<i32>) -> i32 { 0 }\n}"
      },
      "python": {
        "initialCode": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n        # Initialize your data structure here\n        pass\n    \n    def add(self, point: list[int]) -> None:\n        # Add a point to the data structure\n        pass\n    \n    def count(self, point: list[int]) -> int:\n        # Count axis-aligned squares with given query point\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    __init__(...) {\n        \n    }\n}",
        "initialCode": "class Solution {\n    __init__(...) {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "You are given a stream of points on the X-Y plane. Design an algorithm that:\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\nImplement the DetectSquares class:",
    "relatedProblems": [
      "rotate-image",
      "powx-n",
      "lowest-common-ancestor-of-a-bst"
    ]
  },
  "min-cost-climbing-stairs": {
    "id": "min-cost-climbing-stairs",
    "slug": "min-cost-climbing-stairs",
    "title": "Min Cost Climbing Stairs",
    "difficulty": "Easy",
    "category": "1-D Dynamic Programming",
    "problemStatement": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use DP to track min cost to reach each step, only keeping last two values.",
    "intuition": [
      "To reach step i, you must have come from step i-1 or i-2",
      "The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)"
    ],
    "visualizationType": "array",
    "initialState": [
      10,
      15,
      20
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Input: [10, 15, 20]",
        "transientMessage": "Dynamic programming approach",
        "arrayState": [
          10,
          15,
          20
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP array",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "dp",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "dp[0] = 10",
        "transientMessage": "Update state",
        "arrayState": [
          10,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "success"
      },
      {
        "step": 4,
        "visual": "dp[1] = 15",
        "transientMessage": "Update state",
        "arrayState": [
          10,
          15,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "dp[2] = 20",
        "transientMessage": "Update state",
        "arrayState": [
          10,
          15,
          20
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Final DP: [10, 15, 20]",
        "transientMessage": "Complete!",
        "arrayState": [
          10,
          15,
          20
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def minCostClimbingStairs(self, cost):\n        \"\"\"\n        Intuition:\n        - To reach step i, you must have come from step i-1 or i-2\n        - The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)\n        \"\"\"\n        prev2, prev1 = cost[0], cost[1]\n        for i in range(2, len(cost)):  # Iterate through the range.\n            current = cost[i] + min(prev1, prev2)  # Take the minimum value.\n            prev2, prev1 = prev1, current\n        return min(prev1, prev2)  # Take the minimum value.",
    "keyInsight": "We only need to remember the minimum cost to reach the previous two steps.",
    "testCases": [
      {
        "input": "cost = [10,15,20]",
        "output": "15"
      },
      {
        "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
        "output": "6"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use DP to track min cost to reach each step, only keeping last two values.",
    "videoId": "ktmzAZWkEZ0",
    "suggestedNextQuestion": {
      "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
      "title": "Best Time to Buy And Sell Stock With Cooldown",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def minCostClimbingStairs(self, cost):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def minCostClimbingStairs_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "To reach step i, you must have come from step i-1 or i-2",
          "The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)"
        ],
        "code": "def minCostClimbingStairs(cost):\n    \"\"\"\n    Intuition:\n    - To reach step i, you must have come from step i-1 or i-2\n    - The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)\n    \"\"\"\n    prev2, prev1 = cost[0], cost[1]\n    for i in range(2, len(cost)):  # Iterate through the range.\n        current = cost[i] + min(prev1, prev2)  # Take the minimum value.\n        prev2, prev1 = prev1, current\n    return min(prev1, prev2)  # Take the minimum value."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    minCostClimbingStairs(cost) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} cost\n     * @return {any}\n     */\n    minCostClimbingStairs(cost) {\n        const n = cost.length;\n        const f = Array(n).fill(-1);\n        const dfs = i => {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i] < 0) {\n                f[i] = cost[i] + Math.min(dfs(i + 1), dfs(i + 2));\n            }\n            return f[i];\n        };\n        return Math.min(dfs(0), dfs(1));\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private Integer[] f;\n    private int[] cost;\n\n    public int minCostClimbingStairs(int[] cost) {\n        this.cost = cost;\n        f = new Integer[cost.length];\n        return Math.min(dfs(0), dfs(1));\n    }\n\n    private int dfs(int i) {\n        if (i >= cost.length) {\n            return 0;\n        }\n        if (f[i] == null) {\n            f[i] = cost[i] + Math.min(dfs(i + 1), dfs(i + 2));\n        }\n        return f[i];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int minCostClimbingStairs(vector<int>& cost) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        int f[n];\n        memset(f, -1, sizeof(f));\n        auto dfs = [&](this auto&& dfs, int i) -> int {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i] < 0) {\n                f[i] = cost[i] + min(dfs(i + 1), dfs(i + 2));\n            }\n            return f[i];\n        };\n        return min(dfs(0), dfs(1));\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) minCostClimbingStairs(cost []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) minCostClimbingStairs(cost []int) int {\n\tn := len(cost)\n\tf := make([]int, n)\n\tfor i := range f {\n\t\tf[i] = -1\n\t}\n\tvar dfs func(int) int\n\tdfs = func(i int) int {\n\t\tif i >= n {\n\t\t\treturn 0\n\t\t}\n\t\tif f[i] < 0 {\n\t\t\tf[i] = cost[i] + min(dfs(i+1), dfs(i+2))\n\t\t}\n\t\treturn f[i]\n\t}\n\treturn min(dfs(0), dfs(1))\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn min_cost_climbing_stairs(cost: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn min_cost_climbing_stairs(cost: Vec<i32>) -> i32 {\n        let n = cost.len();\n        let mut f = vec![-1; n];\n\n        fn dfs(i: usize, cost: &Vec<i32>, f: &mut Vec<i32>, n: usize) -> i32 {\n            if i >= n {\n                return 0;\n            }\n            if f[i] < 0 {\n                let next1 = dfs(i + 1, cost, f, n);\n                let next2 = dfs(i + 2, cost, f, n);\n                f[i] = cost[i] + next1.min(next2);\n            }\n            f[i]\n        }\n\n        dfs(0, &cost, &mut f, n).min(dfs(1, &cost, &mut f, n))\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def minCostClimbingStairs(self, cost):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    minCostClimbingStairs(cost: number[]): number  {\n    const n = cost.length;\n    const f: number[] = Array(n).fill(-1);\n    const dfs = (i: number): number => {\n        if (i >= n) {\n            return 0;\n        }\n        if (f[i] < 0) {\n            f[i] = cost[i] + Math.min(dfs(i + 1), dfs(i + 2));\n        }\n        return f[i];\n    };\n    return Math.min(dfs(0), dfs(1));\n}\n}",
        "initialCode": "class Solution {\n    minCostClimbingStairs(cost: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
    "relatedProblems": [
      "target-sum",
      "longest-common-subsequence",
      "burst-balloons"
    ]
  },
  "house-robber-ii": {
    "id": "house-robber-ii",
    "slug": "house-robber-ii",
    "title": "House Robber II",
    "difficulty": "Medium",
    "category": "1-D Dynamic Programming",
    "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Split into two subproblems: exclude first or last house.",
    "intuition": [
      "Houses form a circle, so we can't rob both first and last houses together",
      "Solve two linear versions: one excluding first house, one excluding last house"
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: House Robber II",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 2",
        "arrayState": [
          2,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 3",
        "arrayState": [
          2,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          2,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 2",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [],
        "indices": [
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          2,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def rob(self, nums):\n        \"\"\"\n        Intuition:\n        - Houses form a circle, so we can't rob both first and last houses together\n        - Solve two linear versions: one excluding first house, one excluding last house\n        \"\"\"\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            prev2 = prev1 = 0\n            for money in houses:  # Iterate over elements.\n                current = max(prev1, prev2 + money)  # Take the maximum value.\n                prev2, prev1 = prev1, current\n            return prev1\n\n        # Return max of two scenarios: exclude first or exclude last\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))  # Take the maximum value.",
    "keyInsight": "Circular constraint means we can't rob first and last houses together. Solve 2 linear problems.",
    "testCases": [
      {
        "input": "nums = [2,3,2]",
        "output": "3"
      },
      {
        "input": "nums = [1,2,3,1]",
        "output": "4"
      },
      {
        "input": "nums = [1,2,3]",
        "output": "3"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Split into two subproblems: exclude first or last house.",
    "videoId": "rWAJCfYYOvM",
    "suggestedNextQuestion": {
      "slug": "interleaving-string",
      "title": "Interleaving String",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def rob(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def rob_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Houses form a circle, so we can't rob both first and last houses together",
          "Solve two linear versions: one excluding first house, one excluding last house"
        ],
        "code": "def rob(nums):\n    \"\"\"\n    Intuition:\n    - Houses form a circle, so we can't rob both first and last houses together\n    - Solve two linear versions: one excluding first house, one excluding last house\n    \"\"\"\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2 = prev1 = 0\n        for money in houses:  # Iterate over elements.\n            current = max(prev1, prev2 + money)  # Take the maximum value.\n            prev2, prev1 = prev1, current\n        return prev1\n    \n    # Return max of two scenarios: exclude first or exclude last\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))  # Take the maximum value."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "      class Solution {\n    rob(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    rob(nums) {\n        if (nums.length === 1) {\n          return nums[0];\n        }\n\n        return Math.max(\n          handlePermutation(nums, 0, nums.length - 1),\n          handlePermutation(nums, 1, nums.length)\n        );\n      };\n\n      class Solution {\n          /**\n           * @param {any} nums, start, end\n           * @return {any}\n           */\n          handlePermutation(nums, start, end) {\n        let previous = 0, current = 0;\n\n        for (let i = start; i < end; i++) {\n          const temp = previous;\n          previous = current;\n          current = Math.max(temp + nums[i], previous);\n        }\n\n        return Math.max(current, previous);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int rob(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) {\n            return nums[0];\n        }\n        return Math.max(rob(nums, 0, n - 2), rob(nums, 1, n - 1));\n    }\n\n    private int rob(int[] nums, int l, int r) {\n        int f = 0, g = 0;\n        for (; l <= r; ++l) {\n            int ff = Math.max(f, g);\n            g = f + nums[l];\n            f = ff;\n        }\n        return Math.max(f, g);\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int rob(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return nums[0];\n        }\n        return max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));\n    }\n\n    int robRange(vector<int>& nums, int l, int r) {\n        int f = 0, g = 0;\n        for (; l <= r; ++l) {\n            int ff = max(f, g);\n            g = f + nums[l];\n            f = ff;\n        }\n        return max(f, g);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) rob(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) rob(nums []int) int {\n\tn := len(nums)\n\tif n == 1 {\n\t\treturn nums[0]\n\t}\n\treturn max(robRange(nums, 0, n-2), robRange(nums, 1, n-1))\n}\n\nfunc robRange(nums []int, l, r int) int {\n\tf, g := 0, 0\n\tfor _, x := range nums[l : r+1] {\n\t\tf, g = max(f, g), f+x\n\t}\n\treturn max(f, g)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 1 {\n            return nums[0];\n        }\n        let rob_range = |l, r| {\n            let mut f = [0, 0];\n            for i in l..r {\n                f = [f[0].max(f[1]), f[0] + nums[i]];\n            }\n            f[0].max(f[1])\n        };\n        rob_range(0, n - 1).max(rob_range(1, n))\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def rob(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    rob(nums: number[]): number  {\n    const n = nums.length;\n    if (n === 1) {\n        return nums[0];\n    }\n    const robRange = (l: number, r: number): number => {\n        let [f, g] = [0, 0];\n        for (; l <= r; ++l) {\n            [f, g] = [Math.max(f, g), f + nums[l]];\n        }\n        return Math.max(f, g);\n    };\n    return Math.max(robRange(0, n - 2), robRange(1, n - 1));\n}\n}",
        "initialCode": "class Solution {\n    rob(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "relatedProblems": [
      "burst-balloons",
      "min-cost-climbing-stairs",
      "target-sum"
    ]
  },
  "palindromic-substrings": {
    "id": "palindromic-substrings",
    "slug": "palindromic-substrings",
    "title": "Palindromic Substrings",
    "difficulty": "Medium",
    "category": "1-D Dynamic Programming",
    "problemStatement": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.",
    "videoUrl": "",
    "pattern": "Expand Around Centers",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(n\u00b2)",
    "spaceComplexity": "O(1)",
    "oneliner": "Check odd/even length palindromes by expanding around each center.",
    "intuition": [
      "Every palindrome has a center - either a character (odd length) or between two characters (even length)",
      "For each possible center, expand outward while characters match"
    ],
    "visualizationType": "tree",
    "initialState": [
      "a",
      "b",
      "a"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Palindromic Substrings",
        "transientMessage": "Tree traversal approach",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start at root",
        "transientMessage": "Root value: 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "root",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Check left subtree",
        "transientMessage": "Left child at index 1",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse on left.left",
        "transientMessage": "Node value: 4",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Recurse on left.right",
        "transientMessage": "Node value: 5",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "L",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 6,
        "visual": "Check right subtree",
        "transientMessage": "Right child at index 2",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Recurse on right.left",
        "transientMessage": "Node value: 6",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Recurse on right.right",
        "transientMessage": "Node value: 7",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [
          {
            "label": "R",
            "index": 6
          }
        ],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Combine results",
        "transientMessage": "Aggregate from subtrees",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Traversal complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def countSubstrings(s: str) -> int:\n        \"\"\"\n        Intuition:\n        - Every palindrome has a center - either a character (odd length) or between two characters (even length)\n        - For each possible center, expand outward while characters match\n        \"\"\"\n        count = 0\n        for i in range(len(s)):  # Iterate through the range.\n            # Odd length palindromes\n            l, r = i, i  # Initialize two pointers.\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                count += 1\n                l -= 1\n                r += 1\n            # Even length palindromes\n            l, r = i, i + 1  # Initialize two pointers.\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                count += 1\n                l -= 1\n                r += 1\n        return count",
    "keyInsight": "Instead of checking all substrings, expand from each possible center.",
    "testCases": [
      {
        "input": "s = \"abc\"",
        "output": "3"
      },
      {
        "input": "s = \"aaa\"",
        "output": "6"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Expand Around Centers: Check odd/even length palindromes by expanding around each center.",
    "videoId": "4RACzI5-du8",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def countSubstrings(s: str) -> int:\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def countSubstrings(s):\n    res = 0\n    for i in range(len(s)):\n        # Odd\n        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        # Even\n        l, r = i, i+1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b2)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Every palindrome has a center - either a character (odd length) or between two characters (even length)",
          "For each possible center, expand outward while characters match"
        ],
        "code": "def countSubstrings(s: str) -> int:\n    \"\"\"\n    Intuition:\n    - Every palindrome has a center - either a character (odd length) or between two characters (even length)\n    - For each possible center, expand outward while characters match\n    \"\"\"\n    count = 0\n    for i in range(len(s)):  # Iterate through the range.\n        # Odd length palindromes\n        l, r = i, i  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n        # Even length palindromes\n        l, r = i, i + 1  # Initialize two pointers.\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n    return count"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    constructor() {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    constructor() {}\n    \n    countSubstrings(s: string): number {\n        return 0;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int countSubstrings(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int countSubstrings(String s) {\n        return 0;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int __init__(...) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\npublic:\n    int __init__(...) {\n        return 0;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) countSubstrings(s string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) countSubstrings(s string) int {\n\tans, n := 0, len(s)\n\tfor k := 0; k < n*2-1; k++ {\n\t\ti, j := k/2, (k+1)/2\n\t\tfor i >= 0 && j < n && s[i] == s[j] {\n\t\t\tans++\n\t\t\ti, j = i-1, j+1\n\t\t}\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode { val, left: None, right: None }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n",
        "code": "struct Solution;\n\nimpl Solution {\n    fn count_substrings(s: String) -> i32 {\n        let n = s.len();\n        let s: Vec<char> = s.chars().collect();\n        let mut res = 0;\n        let mut dp = vec![vec![false; n + 1]; n + 1];\n        for i in (0..n).rev() {\n            for j in i..n {\n                if j == i\n                    || j == i + 1 && s[i] == s[j]\n                    || j > i + 1 && s[i] == s[j] && dp[i + 1][j - 1]\n                {\n                    dp[i][j] = true;\n                    res += 1;\n                }\n            }\n        }\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"abc\".to_string();\n    let res = 3;\n    assert_eq!(Solution::count_substrings(s), res);\n    let s = \"aaa\".to_string();\n    let res = 6;\n    assert_eq!(Solution::count_substrings(s), res);\n}"
      },
      "python": {
        "initialCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def countSubstrings(s: str) -> int:\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    countSubstrings(s: string): number {\n        return 0;\n    }\n}",
        "initialCode": "class Solution {\n    countSubstrings(s: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.",
    "relatedProblems": [
      "valid-sudoku",
      "count-good-nodes-in-binary-tree",
      "construct-quad-tree"
    ],
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    }
  },
  "maximum-product-subarray": {
    "id": "maximum-product-subarray",
    "slug": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "category": "1-D Dynamic Programming",
    "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track both max and min products at each step due to negative numbers.",
    "intuition": [
      "Negative numbers can flip a small negative product to a large positive one",
      "We need to track both maximum and minimum products at each position"
    ],
    "visualizationType": "array",
    "initialState": [
      2,
      3,
      -2,
      4
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Maximum Product Subarray",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2",
        "transientMessage": "Iteration 1",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 3",
        "transientMessage": "Iteration 2",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = -2",
        "transientMessage": "Iteration 3",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 4",
        "transientMessage": "Iteration 4",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          2,
          3,
          -2,
          4
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def maxProduct(self, nums):\n        \"\"\"\n        Intuition:\n        - Negative numbers can flip a small negative product to a large positive one\n        - We need to track both maximum and minimum products at each position\n        \"\"\"\n        if not nums:\n            return 0\n\n        maxProd = minProd = result = nums[0]\n\n        for i in range(1, len(nums)):  # Iterate through the range.\n            num = nums[i]\n\n            # Store current maxProd before updating\n            tempMax = max(num, maxProd * num, minProd * num)  # Take the maximum value.\n            minProd = min(num, maxProd * num, minProd * num)  # Take the minimum value.\n            maxProd = tempMax\n\n            result = max(result, maxProd)  # Take the maximum value.\n\n        return result  # Return the final result.",
    "keyInsight": "Negative numbers can turn the smallest product into the largest, so we track both max and min.",
    "testCases": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6"
      },
      {
        "input": "nums = [-2,0,-1]",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Track both max and min products at each step due to negative numbers.",
    "videoId": "lXVy6YWFcRM",
    "suggestedNextQuestion": {
      "slug": "minimum-path-sum",
      "title": "Minimum Path Sum",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def maxProduct(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def maxProduct_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Negative numbers can flip a small negative product to a large positive one",
          "We need to track both maximum and minimum products at each position"
        ],
        "code": "def maxProduct(nums):\n    \"\"\"\n    Intuition:\n    - Negative numbers can flip a small negative product to a large positive one\n    - We need to track both maximum and minimum products at each position\n    \"\"\"\n    if not nums:\n        return 0\n    \n    maxProd = minProd = result = nums[0]\n    \n    for i in range(1, len(nums)):  # Iterate through the range.\n        num = nums[i]\n        \n        # Store current maxProd before updating\n        tempMax = max(num, maxProd * num, minProd * num)  # Take the maximum value.\n        minProd = min(num, maxProd * num, minProd * num)  # Take the minimum value.\n        maxProd = tempMax\n        \n        result = max(result, maxProd)  # Take the maximum value.\n    \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProduct(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    maxProduct(nums) {\n        let [f, g, ans] = [nums[0], nums[0], nums[0]];\n        for (let i = 1; i < nums.length; ++i) {\n            const [ff, gg] = [f, g];\n            f = Math.max(nums[i], ff * nums[i], gg * nums[i]);\n            g = Math.min(nums[i], ff * nums[i], gg * nums[i]);\n            ans = Math.max(ans, f);\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProduct(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxProduct(int[] nums) {\n        int f = nums[0], g = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            int ff = f, gg = g;\n            f = Math.max(nums[i], Math.max(ff * nums[i], gg * nums[i]));\n            g = Math.min(nums[i], Math.min(ff * nums[i], gg * nums[i]));\n            ans = Math.max(ans, f);\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProduct(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int f = nums[0], g = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            int ff = f, gg = g;\n            f = max({nums[i], ff * nums[i], gg * nums[i]});\n            g = min({nums[i], ff * nums[i], gg * nums[i]});\n            ans = max(ans, f);\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProduct(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProduct(nums []int) int {\n\tf, g, ans := nums[0], nums[0], nums[0]\n\tfor _, x := range nums[1:] {\n\t\tff, gg := f, g\n\t\tf = max(x, max(ff*x, gg*x))\n\t\tg = min(x, min(ff*x, gg*x))\n\t\tans = max(ans, f)\n\t}\n\treturn ans\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_product(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_product(nums: Vec<i32>) -> i32 {\n        let mut f = nums[0];\n        let mut g = nums[0];\n        let mut ans = nums[0];\n        for &x in nums.iter().skip(1) {\n            let (ff, gg) = (f, g);\n            f = x.max(x * ff).max(x * gg);\n            g = x.min(x * ff).min(x * gg);\n            ans = ans.max(f);\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProduct(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProduct(nums: number[]): number  {\n    let [f, g, ans] = [nums[0], nums[0], nums[0]];\n    for (let i = 1; i < nums.length; ++i) {\n        const [ff, gg] = [f, g];\n        f = Math.max(nums[i], ff * nums[i], gg * nums[i]);\n        g = Math.min(nums[i], ff * nums[i], gg * nums[i]);\n        ans = Math.max(ans, f);\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    maxProduct(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.",
    "relatedProblems": [
      "triangle",
      "coin-change-ii",
      "best-time-to-buy-and-sell-stock-with-cooldown"
    ]
  },
  "partition-equal-subset-sum": {
    "id": "partition-equal-subset-sum",
    "slug": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "difficulty": "Medium",
    "category": "1-D Dynamic Programming",
    "problemStatement": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n * sum)",
    "spaceComplexity": "O(sum)",
    "oneliner": "Use DP to check if we can achieve sum/2 with given numbers.",
    "intuition": [
      "If total sum is odd, partition is impossible.",
      "Transform into subset sum problem: find if subset sums to target=sum/2."
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      5,
      11,
      5
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Partition Equal Subset Sum",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add 1 to path",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [1]",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add 5 to path",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try 11 instead",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          5,
          11,
          5
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def canPartition(self, nums):\n        \"\"\"\n        Intuition:\n        - If total sum is odd, partition is impossible.\n        - Transform into subset sum problem: find if subset sums to target=sum/2.\n        \"\"\"\n        total = sum(nums)  # Calculate sum of all elements.\n        if total % 2 != 0:\n            return False  # Condition not met.\n        target = total // 2\n        dp = [False] * (target + 1)  # Initialize DP table to store results.\n        dp[0] = True\n        for num in nums:  # Iterate over elements.\n            for j in range(target, num - 1, -1):  # Iterate through the range.\n                dp[j] = dp[j] or dp[j - num]\n        return dp[target]",
    "keyInsight": "This is a 0/1 knapsack variant - we either include or exclude each number.",
    "testCases": [
      {
        "input": "nums = [1,5,11,5]",
        "output": "true"
      },
      {
        "input": "nums = [1,2,3,5]",
        "output": "false"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use DP to check if we can achieve sum/2 with given numbers.",
    "videoId": "IsvocB5BJhw",
    "suggestedNextQuestion": {
      "slug": "target-sum",
      "title": "Target Sum",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def canPartition(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def canPartition_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n * sum)",
        "spaceComplexity": "O(sum)",
        "intuition": [
          "If total sum is odd, partition is impossible.",
          "Transform into subset sum problem: find if subset sums to target=sum/2."
        ],
        "code": "def canPartition(nums):\n    \"\"\"\n    Intuition:\n    - If total sum is odd, partition is impossible.\n    - Transform into subset sum problem: find if subset sums to target=sum/2.\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if total % 2 != 0:\n        return False  # Condition not met.\n    target = total // 2\n    dp = [False] * (target + 1)  # Initialize DP table to store results.\n    dp[0] = True\n    for num in nums:  # Iterate over elements.\n        for j in range(target, num - 1, -1):  # Iterate through the range.\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    canPartition(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    canPartition(nums) {\n        const s = nums.reduce((a, b) => a + b, 0);\n        if (s % 2 === 1) {\n            return false;\n        }\n        const n = nums.length;\n        const m = s >> 1;\n        const f = Array.from({ length: n + 1 }, () => Array(m + 1).fill(false));\n        f[0][0] = true;\n        for (let i = 1; i <= n; ++i) {\n            const x = nums[i - 1];\n            for (let j = 0; j <= m; ++j) {\n                f[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n            }\n    }\n    return f[n][m];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean canPartition(int[] nums) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        // int s = Arrays.stream(nums).sum();\n        int s = 0;\n        for (int x : nums) {\n            s += x;\n        }\n        if (s % 2 == 1) {\n            return false;\n        }\n        int n = nums.length;\n        int m = s >> 1;\n        boolean[][] f = new boolean[n + 1][m + 1];\n        f[0][0] = true;\n        for (int i = 1; i <= n; ++i) {\n            int x = nums[i - 1];\n            for (int j = 0; j <= m; ++j) {\n                f[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n            }\n        }\n        return f[n][m];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool canPartition(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int s = accumulate(nums.begin(), nums.end(), 0);\n        if (s % 2 == 1) {\n            return false;\n        }\n        int n = nums.size();\n        int m = s >> 1;\n        bool f[n + 1][m + 1];\n        memset(f, false, sizeof(f));\n        f[0][0] = true;\n        for (int i = 1; i <= n; ++i) {\n            int x = nums[i - 1];\n            for (int j = 0; j <= m; ++j) {\n                f[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n            }\n        }\n        return f[n][m];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) canPartition(nums []int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) canPartition(nums []int) bool {\n\ts := 0\n\tfor _, x := range nums {\n\t\ts += x\n\t}\n\tif s%2 == 1 {\n\t\treturn false\n\t}\n\tn, m := len(nums), s>>1\n\tf := make([][]bool, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]bool, m+1)\n\t}\n\tf[0][0] = true\n\tfor i := 1; i <= n; i++ {\n\t\tx := nums[i-1]\n\t\tfor j := 0; j <= m; j++ {\n\t\t\tf[i][j] = f[i-1][j] || (j >= x && f[i-1][j-x])\n\t\t}\n\t}\n\treturn f[n][m]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn can_partition(nums: Vec<i32>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn can_partition(nums: Vec<i32>) -> bool {\n        let s: i32 = nums.iter().sum();\n        if s % 2 != 0 {\n            return false;\n        }\n        let m = (s / 2) as usize;\n        let n = nums.len();\n        let mut f = vec![vec![false; m + 1]; n + 1];\n        f[0][0] = true;\n\n        for i in 1..=n {\n            let x = nums[i - 1] as usize;\n            for j in 0..=m {\n                f[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n            }\n        }\n\n        f[n][m]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def canPartition(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    canPartition(nums: number[]): boolean  {\n    const s = nums.reduce((a, b) => a + b, 0);\n    if (s % 2 === 1) {\n        return false;\n    }\n    const n = nums.length;\n    const m = s >> 1;\n    const f: boolean[][] = Array.from({ length: n + 1 }, () => Array(m + 1).fill(false));\n    f[0][0] = true;\n    for (let i = 1; i <= n; ++i) {\n        const x = nums[i - 1];\n        for (let j = 0; j <= m; ++j) {\n            f[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n        }\n    }\n    return f[n][m];\n}\n}",
        "initialCode": "class Solution {\n    canPartition(nums: number[]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "relatedProblems": [
      "regular-expression-matching",
      "min-cost-climbing-stairs",
      "best-time-to-buy-and-sell-stock-with-cooldown"
    ]
  },
  "longest-common-subsequence": {
    "id": "longest-common-subsequence",
    "slug": "longest-common-subsequence",
    "title": "Longest Common Subsequence",
    "difficulty": "Medium",
    "category": "2-D Dynamic Programming",
    "problemStatement": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nA common subsequence of two strings is a subsequence that is common to both strings.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "oneliner": "Build a 2D table to store LCS lengths for all substrings.",
    "intuition": [
      "If characters match, LCS is 1 + diagonal value",
      "If characters don't match, take max of left or top cell"
    ],
    "visualizationType": "grid",
    "initialState": [
      [
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        0,
        0,
        0,
        0,
        0,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Common Subsequence",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 0,0,0,0,0,0",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 0,0,0,0,0,0",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 0,0,0,0,0,0",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 0,0,0,0,0,0",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def longestCommonSubsequence(self, text1, text2):\n        \"\"\"\n        Intuition:\n        - If characters match, LCS is 1 + diagonal value\n        - If characters don't match, take max of left or top cell\n        \"\"\"\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n\n        for i in range(1, m + 1):  # Iterate through the range.\n            for j in range(1, n + 1):  # Iterate through the range.\n                if text1[i-1] == text2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Take the maximum value.\n\n        return dp[m][n]",
    "keyInsight": "When characters match, we add 1 to the LCS of previous substrings. When they don't match, we take the best LCS from either skipping current character in text1 or text2.",
    "testCases": [
      {
        "input": "text1 = \"abcde\", text2 = \"ace\"",
        "output": "3"
      },
      {
        "input": "text1 = \"abc\", text2 = \"abc\"",
        "output": "3"
      },
      {
        "input": "text1 = \"abc\", text2 = \"def\"",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Build a 2D table to store LCS lengths for all substrings.",
    "videoId": "Ua0GhsJSlWM",
    "suggestedNextQuestion": {
      "slug": "longest-increasing-subsequence",
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def longestCommonSubsequence(self, text1, text2):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def longestCommonSubsequence_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)",
        "intuition": [
          "If characters match, LCS is 1 + diagonal value",
          "If characters don't match, take max of left or top cell"
        ],
        "code": "def longestCommonSubsequence(text1, text2):\n    \"\"\"\n    Intuition:\n    - If characters match, LCS is 1 + diagonal value\n    - If characters don't match, take max of left or top cell\n    \"\"\"\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Take the maximum value.\n    \n    return dp[m][n]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    longestCommonSubsequence(text1, text2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} text1, text2\n     * @return {any}\n     */\n    longestCommonSubsequence(text1, text2) {\n        const m = text1.length;\n        const n = text2.length;\n        const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n        for (let i = 1; i <= m; ++i) {\n            for (let j = 1; j <= n; ++j) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    f[i][j] = f[i - 1][j - 1] + 1;\n                } else {\n                    f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n                }\n            }\n    }\n    return f[m][n];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] f = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    f[i][j] = f[i - 1][j - 1] + 1;\n                } else {\n                    f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n                }\n            }\n        }\n        return f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int longestCommonSubsequence(string text1, string text2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size(), n = text2.size();\n        int f[m + 1][n + 1];\n        memset(f, 0, sizeof f);\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (text1[i - 1] == text2[j - 1]) {\n                    f[i][j] = f[i - 1][j - 1] + 1;\n                } else {\n                    f[i][j] = max(f[i - 1][j], f[i][j - 1]);\n                }\n            }\n        }\n        return f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestCommonSubsequence(text1 string, text2 string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestCommonSubsequence(text1 string, text2 string) int {\n\tm, n := len(text1), len(text2)\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif text1[i-1] == text2[j-1] {\n\t\t\t\tf[i][j] = f[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tf[i][j] = max(f[i-1][j], f[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_common_subsequence(text1: String, text2: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn longest_common_subsequence(text1: String, text2: String) -> i32 {\n        let (m, n) = (text1.len(), text2.len());\n        let (text1, text2) = (text1.as_bytes(), text2.as_bytes());\n        let mut f = vec![vec![0; n + 1]; m + 1];\n        for i in 1..=m {\n            for j in 1..=n {\n                f[i][j] = if text1[i - 1] == text2[j - 1] {\n                    f[i - 1][j - 1] + 1\n                } else {\n                    f[i - 1][j].max(f[i][j - 1])\n                };\n            }\n        }\n        f[m][n]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def longestCommonSubsequence(self, text1, text2):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    longestCommonSubsequence(text1: string, text2: string): number  {\n    const m = text1.length;\n    const n = text2.length;\n    const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (text1[i - 1] === text2[j - 1]) {\n                f[i][j] = f[i - 1][j - 1] + 1;\n            } else {\n                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n            }\n        }\n    }\n    return f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    longestCommonSubsequence(text1: string, text2: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nA common subsequence of two strings is a subsequence that is common to both strings.",
    "relatedProblems": [
      "regular-expression-matching",
      "min-cost-climbing-stairs",
      "best-time-to-buy-and-sell-stock-with-cooldown"
    ]
  },
  "best-time-to-buy-and-sell-stock-with-cooldown": {
    "id": "best-time-to-buy-and-sell-stock-with-cooldown",
    "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "difficulty": "Medium",
    "category": "2-D Dynamic Programming",
    "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track max profit for holding/selling states with cooldown constraint.",
    "intuition": [
      "We can be in one of three states: holding stock, selling stock, or cooldown",
      "Use DP to track maximum profit for each state transition"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      0,
      2
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Best Time to Buy and Sell Stock with Cooldown",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          1,
          2,
          3,
          0,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 1",
        "arrayState": [
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 2",
        "arrayState": [
          1,
          2,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          2,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 3",
        "arrayState": [
          1,
          2,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          1,
          2,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          1,
          2,
          3,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          1,
          2,
          3,
          3,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 2",
        "arrayState": [
          1,
          2,
          3,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          1,
          2,
          3,
          3,
          2
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          1,
          2,
          3,
          3,
          2
        ],
        "pointers": [],
        "indices": [
          4
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          2,
          3,
          3,
          2
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def maxProfit(self, prices):\n        \"\"\"\n        Intuition:\n        - We can be in one of three states: holding stock, selling stock, or cooldown\n        - Use DP to track maximum profit for each state transition\n        \"\"\"\n        if not prices:\n            return 0\n\n        hold = -prices[0]  # Max profit when holding stock\n        sold = 0           # Max profit when just sold\n        rest = 0           # Max profit when in cooldown/rest\n\n        for i in range(1, len(prices)):  # Iterate through the range.\n            prev_hold = hold\n            prev_sold = sold\n            prev_rest = rest\n\n            hold = max(prev_hold, prev_rest - prices[i])  # Hold or buy today\n            sold = prev_hold + prices[i]                  # Sell today\n            rest = max(prev_rest, prev_sold)              # Rest or continue cooldown\n\n        return max(sold, rest)  # Max profit when ending with sell or rest",
    "keyInsight": "Track three states: holding stock, just sold, cooldown. State transitions enforce the cooldown rule.",
    "testCases": [
      {
        "input": "prices = [1,2,3,0,2]",
        "output": "3"
      },
      {
        "input": "prices = [1]",
        "output": "0"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Track max profit for holding/selling states with cooldown constraint.",
    "videoId": "I7j0F7AHpb8",
    "suggestedNextQuestion": {
      "slug": "coin-change",
      "title": "Coin Change",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Buy low, sell high. You are looking for the biggest difference between a valley and a subsequent peak.",
    "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def maxProfit_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "We can be in one of three states: holding stock, selling stock, or cooldown",
          "Use DP to track maximum profit for each state transition"
        ],
        "code": "def maxProfit(prices):\n    \"\"\"\n    Intuition:\n    - We can be in one of three states: holding stock, selling stock, or cooldown\n    - Use DP to track maximum profit for each state transition\n    \"\"\"\n    if not prices:\n        return 0\n    \n    hold = -prices[0]  # Max profit when holding stock\n    sold = 0           # Max profit when just sold\n    rest = 0           # Max profit when in cooldown/rest\n    \n    for i in range(1, len(prices)):  # Iterate through the range.\n        prev_hold = hold\n        prev_sold = sold\n        prev_rest = rest\n        \n        hold = max(prev_hold, prev_rest - prices[i])  # Hold or buy today\n        sold = prev_hold + prices[i]                  # Sell today\n        rest = max(prev_rest, prev_sold)              # Rest or continue cooldown\n    \n    return max(sold, rest)  # Max profit when ending with sell or rest"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxProfit(prices) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} prices\n     * @return {any}\n     */\n    maxProfit(prices) {\n        let result = 0;\n        let remaining = 0;\n\n        for (let i = 0, limit = -Infinity; i < prices.length; i++) {\n          limit = Math.max(limit, remaining - prices[i]);\n          remaining = Math.max(remaining, result);\n          result = limit + prices[i];\n      }\n\n    return Math.max(result, remaining);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxProfit(int[] prices) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private int[] prices;\n    private Integer[][] f;\n\n    public int maxProfit(int[] prices) {\n        this.prices = prices;\n        f = new Integer[prices.length][2];\n        return dfs(0, 0);\n    }\n\n    private int dfs(int i, int j) {\n        if (i >= prices.length) {\n            return 0;\n        }\n        if (f[i][j] != null) {\n            return f[i][j];\n        }\n        int ans = dfs(i + 1, j);\n        if (j > 0) {\n            ans = Math.max(ans, prices[i] + dfs(i + 2, 0));\n        } else {\n            ans = Math.max(ans, -prices[i] + dfs(i + 1, 1));\n        }\n        return f[i][j] = ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxProfit(vector<int>& prices) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int n = prices.size();\n        int f[n][2];\n        memset(f, -1, sizeof(f));\n        function<int(int, int)> dfs = [&](int i, int j) {\n            if (i >= n) {\n                return 0;\n            }\n            if (f[i][j] != -1) {\n                return f[i][j];\n            }\n            int ans = dfs(i + 1, j);\n            if (j) {\n                ans = max(ans, prices[i] + dfs(i + 2, 0));\n            } else {\n                ans = max(ans, -prices[i] + dfs(i + 1, 1));\n            }\n            return f[i][j] = ans;\n        };\n        return dfs(0, 0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxProfit(prices []int) int {\n\tn := len(prices)\n\tf := make([][2]int, n)\n\tfor i := range f {\n\t\tf[i] = [2]int{-1, -1}\n\t}\n\tvar dfs func(i, j int) int\n\tdfs = func(i, j int) int {\n\t\tif i >= n {\n\t\t\treturn 0\n\t\t}\n\t\tif f[i][j] != -1 {\n\t\t\treturn f[i][j]\n\t\t}\n\t\tans := dfs(i+1, j)\n\t\tif j > 0 {\n\t\t\tans = max(ans, prices[i]+dfs(i+2, 0))\n\t\t} else {\n\t\t\tans = max(ans, -prices[i]+dfs(i+1, 1))\n\t\t}\n\t\tf[i][j] = ans\n\t\treturn ans\n\t}\n\treturn dfs(0, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "/**\n * [309] Best Time to Buy and Sell Stock with Cooldown\n *\n * Say you have an array for which the i^th element is the price of a given stock on day i.\n *\n * Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n *\n *\n * \tYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n * \tAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n *\n *\n * Example:\n *\n *\n * Input: [1,2,3,0,2]\n * Output: 3\n * Explanation: transactions = [buy, sell, cooldown, buy, sell]\n *\n */\npub struct Solution {}\n\n// problem: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\n// discuss: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/?currentPage=1&orderBy=most_votes&query=\n\n// submission codes start here\n\n/*\ndp[i]: max profit with selling at day i\ndp2[i]: max profit till day i\n\ndp[i] = max(dp[i-1] + p[i] - p[i-1], dp2[i-2], dp2[i-3] + p[i] - p[i-1])\n*/\nimpl Solution {\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\n        if prices.len() < 2 {\n            return 0;\n        }\n        if prices.len() == 2 {\n            return i32::max(0, prices[1] - prices[0]);\n        }\n        let mut dp = vec![0; prices.len()];\n        let mut dp2 = vec![0; prices.len()];\n        let mut max = 0;\n        dp[0] = 0;\n        dp2[0] = 0;\n        dp[1] = prices[1] - prices[0];\n        dp2[1] = i32::max(dp2[0], dp[1]);\n        dp[2] = i32::max(prices[2] - prices[1], prices[2] - prices[0]);\n        dp2[2] = i32::max(dp2[1], dp[2]);\n        for i in 3..prices.len() {\n            dp[i] = i32::max(\n                dp[i - 1] + prices[i] - prices[i - 1],\n                i32::max(dp2[i - 2], dp2[i - 3] + prices[i] - prices[i - 1]),\n            );\n            dp2[i] = i32::max(dp2[i - 1], dp[i]);\n        }\n        let mut temp = 0;\n        for &m in dp.iter() {\n            if m > temp {\n                temp = m;\n            }\n        }\n        temp\n    }\n}\n\n// submission codes end\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_309() {\n        assert_eq!(Solution::max_profit(vec![1, 2, 3, 0, 2]), 3);\n        assert_eq!(Solution::max_profit(vec![4, 2, 7, 1, 11]), 10);\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxProfit(self, prices):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxProfit(prices: number[]): number  {\n    const n = prices.length;\n    const f: number[][] = Array.from({ length: n }, () => Array.from({ length: 2 }, () => -1));\n    const dfs = (i: number, j: number): number => {\n        if (i >= n) {\n            return 0;\n        }\n        if (f[i][j] !== -1) {\n            return f[i][j];\n        }\n        let ans = dfs(i + 1, j);\n        if (j) {\n            ans = Math.max(ans, prices[i] + dfs(i + 2, 0));\n        } else {\n            ans = Math.max(ans, -prices[i] + dfs(i + 1, 1));\n        }\n        return (f[i][j] = ans);\n    };\n    return dfs(0, 0);\n}\n}",
        "initialCode": "class Solution {\n    maxProfit(prices: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
    "relatedProblems": [
      "regular-expression-matching",
      "coin-change-ii",
      "maximum-product-subarray"
    ]
  },
  "coin-change-ii": {
    "id": "coin-change-ii",
    "slug": "coin-change-ii",
    "title": "Coin Change II",
    "difficulty": "Medium",
    "category": "2-D Dynamic Programming",
    "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83e\uddee",
    "timeComplexity": "O(amount \u00d7 len(coins))",
    "spaceComplexity": "O(amount)",
    "oneliner": "Build up combinations count for each amount using previous results.",
    "intuition": [
      "For each coin, we can either use it or not use it - this creates subproblems",
      "We can build solutions for larger amounts using solutions for smaller amounts"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      0,
      0,
      0,
      0,
      0
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Coin Change II",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          1,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = 1",
        "arrayState": [
          1,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = 1",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          1,
          1,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = 2",
        "arrayState": [
          1,
          1,
          2,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          1,
          1,
          2,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = 3",
        "arrayState": [
          1,
          1,
          2,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          1,
          1,
          2,
          3,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = 4",
        "arrayState": [
          1,
          1,
          2,
          3,
          4,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          1,
          1,
          2,
          3,
          4,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          1,
          1,
          2,
          3,
          4,
          0
        ],
        "pointers": [],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          1,
          1,
          2,
          3,
          4,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def change(self, amount, coins):\n        \"\"\"\n        Intuition:\n        - For each coin, we can either use it or not use it - this creates subproblems\n        - We can build solutions for larger amounts using solutions for smaller amounts\n        \"\"\"\n        dp = [0] * (amount + 1)  # Initialize DP table to store results.\n        dp[0] = 1  # One way to make 0 amount\n\n        for coin in coins:  # Iterate over elements.\n            for i in range(coin, amount + 1):  # Iterate through the range.\n                dp[i] += dp[i - coin]\n\n        return dp[amount]",
    "keyInsight": "For each coin, we update all amounts >= coin by adding ways to make (amount - coin).",
    "testCases": [
      {
        "input": "amount = 5, coins = [1,2,5]",
        "output": "4"
      },
      {
        "input": "amount = 3, coins = [2]",
        "output": "0"
      },
      {
        "input": "amount = 10, coins = [10]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Build up combinations count for each amount using previous results.",
    "videoId": "Mjy4hd2xgrs",
    "suggestedNextQuestion": {
      "slug": "counting-bits",
      "title": "Counting Bits",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def change(self, amount, coins):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def change_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(amount \u00d7 len(coins))",
        "spaceComplexity": "O(amount)",
        "intuition": [
          "For each coin, we can either use it or not use it - this creates subproblems",
          "We can build solutions for larger amounts using solutions for smaller amounts"
        ],
        "code": "def change(amount, coins):\n    \"\"\"\n    Intuition:\n    - For each coin, we can either use it or not use it - this creates subproblems\n    - We can build solutions for larger amounts using solutions for smaller amounts\n    \"\"\"\n    dp = [0] * (amount + 1)  # Initialize DP table to store results.\n    dp[0] = 1  # One way to make 0 amount\n    \n    for coin in coins:  # Iterate over elements.\n        for i in range(coin, amount + 1):  # Iterate through the range.\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    change(amount, coins) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} amount, coins\n     * @return {any}\n     */\n    change(amount, coins) {\n        const dp = new Array(amount + 1).fill(0);\n        dp[0] = 1;\n\n        for (const coin of coins) {\n          for (let i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n          }\n      }\n\n    return dp[amount];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int change(int amount, int[] coins) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int change(int amount, int[] coins) {\n        int m = coins.length, n = amount;\n        int[][] f = new int[m + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    f[i][j] += f[i][j - coins[i - 1]];\n                }\n            }\n        }\n        return f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int change(int amount, vector<int>& coins) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        int m = coins.size(), n = amount;\n        unsigned f[m + 1][n + 1];\n        memset(f, 0, sizeof(f));\n        f[0][0] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= coins[i - 1]) {\n                    f[i][j] += f[i][j - coins[i - 1]];\n                }\n            }\n        }\n        return f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) change(amount int, coins []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) change(amount int, coins []int) int {\n\tm, n := len(coins), amount\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tf[0][0] = 1\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 0; j <= n; j++ {\n\t\t\tf[i][j] = f[i-1][j]\n\t\t\tif j >= coins[i-1] {\n\t\t\t\tf[i][j] += f[i][j-coins[i-1]]\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn change(amount: i32, coins: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn change(amount: i32, coins: Vec<i32>) -> i32 {\n        let mut dp = vec![0; (amount + 1) as usize];\n        dp[0] = 1;\n        for coin in coins {\n            for i in coin..=amount {\n                dp[i as usize] += dp[(i - coin) as usize];\n            }\n        }\n        dp[amount as usize]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def change(self, amount, coins):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    change(amount: number, coins: number[]): number  {\n    const [m, n] = [coins.length, amount];\n    const f: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    f[0][0] = 1;\n    for (let i = 1; i <= m; ++i) {\n        for (let j = 0; j <= n; ++j) {\n            f[i][j] = f[i - 1][j];\n            if (j >= coins[i - 1]) {\n                f[i][j] += f[i][j - coins[i - 1]];\n            }\n        }\n    }\n    return f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    change(amount: number, coins: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.",
    "relatedProblems": [
      "house-robber-ii",
      "best-time-to-buy-and-sell-stock-with-cooldown",
      "min-cost-climbing-stairs"
    ]
  },
  "target-sum": {
    "id": "target-sum",
    "slug": "target-sum",
    "title": "Target Sum",
    "difficulty": "Medium",
    "category": "2-D Dynamic Programming",
    "problemStatement": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nReturn the number of different expressions that you can build, which evaluates to target.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n * sum)",
    "spaceComplexity": "O(sum)",
    "oneliner": "Use DP to count ways to reach target sum with +/- signs.",
    "intuition": [
      "Transform into subset sum problem: find subsets that sum to (total+target)/2",
      "Use DP to count combinations, not just feasibility"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      1,
      1,
      1
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Target Sum",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 1",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          1,
          1,
          1,
          1
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def findTargetSumWays(self, nums, target):\n        \"\"\"\n        Intuition:\n        - Transform into subset sum problem: find subsets that sum to (total+target)/2\n        - Use DP to count combinations, not just feasibility\n        \"\"\"\n        total = sum(nums)  # Calculate sum of all elements.\n        if abs(target) > total or (total + target) % 2 != 0:\n            return 0\n        s = (total + target) // 2\n        dp = [0] * (s + 1)  # Initialize DP table to store results.\n        dp[0] = 1\n        for num in nums:  # Iterate over elements.\n            for j in range(s, num - 1, -1):  # Iterate through the range.\n                dp[j] += dp[j - num]\n        return dp[s]",
    "keyInsight": "This is a subset sum counting problem in disguise.",
    "testCases": [
      {
        "input": "nums = [1,1,1,1,1], target = 3",
        "output": "5"
      },
      {
        "input": "nums = [1], target = 1",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use DP to count ways to reach target sum with +/- signs.",
    "videoId": "g0npyaQtAQM",
    "suggestedNextQuestion": {
      "slug": "triangle",
      "title": "Triangle",
      "difficulty": "Medium",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def findTargetSumWays(self, nums, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def findTargetSumWays_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n * sum)",
        "spaceComplexity": "O(sum)",
        "intuition": [
          "Transform into subset sum problem: find subsets that sum to (total+target)/2",
          "Use DP to count combinations, not just feasibility"
        ],
        "code": "def findTargetSumWays(nums, target):\n    \"\"\"\n    Intuition:\n    - Transform into subset sum problem: find subsets that sum to (total+target)/2\n    - Use DP to count combinations, not just feasibility\n    \"\"\"\n    total = sum(nums)  # Calculate sum of all elements.\n    if abs(target) > total or (total + target) % 2 != 0:\n        return 0\n    s = (total + target) // 2\n    dp = [0] * (s + 1)  # Initialize DP table to store results.\n    dp[0] = 1\n    for num in nums:  # Iterate over elements.\n        for j in range(s, num - 1, -1):  # Iterate through the range.\n            dp[j] += dp[j - num]\n    return dp[s]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    findTargetSumWays(nums, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nclass Solution {\n    /**\n     * @param {any} nums, target\n     * @return {any}\n     */\n    findTargetSumWays(nums, target) {\n        const s = nums.reduce((a, b) => a + b, 0);\n        if (s < target || (s - target) % 2) {\n            return 0;\n        }\n        const [m, n] = [nums.length, ((s - target) / 2) | 0];\n        const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n        f[0][0] = 1;\n        for (let i = 1; i <= m; i++) {\n            for (let j = 0; j <= n; j++) {\n                f[i][j] = f[i - 1][j];\n                if (j >= nums[i - 1]) {\n                    f[i][j] += f[i - 1][j - nums[i - 1]];\n                }\n            }\n    }\n    return f[m][n];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int s = Arrays.stream(nums).sum();\n        if (s < target || (s - target) % 2 != 0) {\n            return 0;\n        }\n        int m = nums.length;\n        int n = (s - target) / 2;\n        int[][] f = new int[m + 1][n + 1];\n        f[0][0] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= nums[i - 1]) {\n                    f[i][j] += f[i - 1][j - nums[i - 1]];\n                }\n            }\n        }\n        return f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int s = accumulate(nums.begin(), nums.end(), 0);\n        if (s < target || (s - target) % 2) {\n            return 0;\n        }\n        int m = nums.size();\n        int n = (s - target) / 2;\n        int f[m + 1][n + 1];\n        memset(f, 0, sizeof(f));\n        f[0][0] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (j >= nums[i - 1]) {\n                    f[i][j] += f[i - 1][j - nums[i - 1]];\n                }\n            }\n        }\n        return f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) findTargetSumWays(nums []int, target int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) findTargetSumWays(nums []int, target int) int {\n\ts := 0\n\tfor _, x := range nums {\n\t\ts += x\n\t}\n\tif s < target || (s-target)%2 != 0 {\n\t\treturn 0\n\t}\n\tm, n := len(nums), (s-target)/2\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tf[0][0] = 1\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 0; j <= n; j++ {\n\t\t\tf[i][j] = f[i-1][j]\n\t\t\tif j >= nums[i-1] {\n\t\t\t\tf[i][j] += f[i-1][j-nums[i-1]]\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {\n        let s: i32 = nums.iter().sum();\n        if s < target || (s - target) % 2 != 0 {\n            return 0;\n        }\n        let m = nums.len();\n        let n = ((s - target) / 2) as usize;\n        let mut f = vec![vec![0; n + 1]; m + 1];\n        f[0][0] = 1;\n        for i in 1..=m {\n            for j in 0..=n {\n                f[i][j] = f[i - 1][j];\n                if j as i32 >= nums[i - 1] {\n                    f[i][j] += f[i - 1][j - nums[i - 1] as usize];\n                }\n            }\n        }\n        f[m][n]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def findTargetSumWays(self, nums, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    findTargetSumWays(nums: number[], target: number): number  {\n    const s = nums.reduce((a, b) => a + b, 0);\n    if (s < target || (s - target) % 2) {\n        return 0;\n    }\n    const [m, n] = [nums.length, ((s - target) / 2) | 0];\n    const f: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    f[0][0] = 1;\n    for (let i = 1; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            f[i][j] = f[i - 1][j];\n            if (j >= nums[i - 1]) {\n                f[i][j] += f[i - 1][j - nums[i - 1]];\n            }\n        }\n    }\n    return f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    findTargetSumWays(nums: number[], target: number): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nReturn the number of different expressions that you can build, which evaluates to target.",
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-with-cooldown",
      "house-robber-ii",
      "burst-balloons"
    ]
  },
  "longest-increasing-path-in-a-matrix": {
    "id": "longest-increasing-path-in-a-matrix",
    "slug": "longest-increasing-path-in-a-matrix",
    "title": "Longest Increasing Path in a Matrix",
    "difficulty": "Hard",
    "category": "2-D Dynamic Programming",
    "problemStatement": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
    "videoUrl": "",
    "pattern": "DFS with Memoization",
    "patternEmoji": "\ud83d\udd0d\ud83d\udcbe",
    "timeComplexity": "O(m\u00d7n)",
    "spaceComplexity": "O(m\u00d7n)",
    "oneliner": "Use DFS from each cell with memoization to avoid recomputation.",
    "intuition": [
      "From each cell, explore all increasing paths in 4 directions",
      "Cache results to prevent recalculating the same subproblems"
    ],
    "visualizationType": "grid",
    "initialState": [
      [
        1,
        1,
        1
      ],
      [
        1,
        1,
        1
      ],
      [
        1,
        1,
        1
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Longest Increasing Path in a Matrix",
        "transientMessage": "Grid-based BFS/DFS approach",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize visited set",
        "transientMessage": "Track visited cells",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Start at (0, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "start",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Explore neighbors",
        "transientMessage": "Check up, down, left, right",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 0
          }
        ],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Visit (0, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 0,
            "col": 1
          }
        ],
        "indices": [
          [
            0,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Visit (1, 0)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 0
          }
        ],
        "indices": [
          [
            1,
            0
          ]
        ],
        "color": "accent"
      },
      {
        "step": 7,
        "visual": "Visit (1, 1)",
        "transientMessage": "Cell value: 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "curr",
            "row": 1,
            "col": 1
          }
        ],
        "indices": [
          [
            1,
            1
          ]
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "First island complete",
        "transientMessage": "Found island #1, count = 1",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [
          [
            0,
            0
          ],
          [
            0,
            1
          ],
          [
            1,
            0
          ],
          [
            1,
            1
          ]
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Continue scanning grid",
        "transientMessage": "Find next unvisited land cell",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "scan",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Found another island",
        "transientMessage": "Island #2 at (2, 2)",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 2,
            "col": 2
          }
        ],
        "indices": [
          [
            2,
            2
          ]
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Continue to next island",
        "transientMessage": "Island #3 at (3, 3)",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [
          {
            "label": "island",
            "row": 3,
            "col": 3
          }
        ],
        "indices": [
          [
            3,
            3
          ],
          [
            3,
            4
          ]
        ],
        "color": "success"
      },
      {
        "step": 12,
        "visual": "Grid traversal complete",
        "transientMessage": "Total islands: 3",
        "arrayState": [
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ],
          [
            1,
            1,
            1
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        Intuition:\n        - From each cell, explore all increasing paths in 4 directions\n        - Cache results to prevent recalculating the same subproblems\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        memo = {}\n\n        def dfs(i, j):\n            if (i, j) in memo:\n                return memo[(i, j)]\n\n            max_path = 1\n            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n            for di, dj in directions:  # Iterate over elements.\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                    max_path = max(max_path, 1 + dfs(ni, nj))  # Take the maximum value.\n\n            memo[(i, j)] = max_path\n            return max_path\n\n        result = 0\n        for i in range(m):  # Iterate through the range.\n            for j in range(n):  # Iterate through the range.\n                result = max(result, dfs(i, j))  # Take the maximum value.\n\n        return result  # Return the final result.",
    "keyInsight": "Each cell's longest path is 1 + max of its increasing neighbors' paths.",
    "testCases": [
      {
        "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
        "output": "4"
      },
      {
        "input": "matrix = [[3,4,5],[3,2,6],[2,2,1]]",
        "output": "4"
      },
      {
        "input": "matrix = [[1]]",
        "output": "1"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "DFS with Memoization: Use DFS from each cell with memoization to avoid recomputation.",
    "videoId": "wCc_nd-GiEc",
    "suggestedNextQuestion": {
      "slug": "regular-expression-matching",
      "title": "Regular Expression Matching",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a maze by walking as far as you can down one path, then backtracking when you hit a dead end.",
    "initialCode": "class Solution:\n    def longestIncreasingPath(self, matrix):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def longestIncreasingPath(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    dp = {}\n    def dfs(r, c, prevVal):\n        if r<0 or r==rows or c<0 or c==cols or matrix[r][c] <= prevVal:\n            return 0\n        if (r, c) in dp: return dp[(r, c)]\n        \n        res = 1\n        res = max(res, 1 + dfs(r+1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r-1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c+1, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c-1, matrix[r][c]))\n        dp[(r, c)] = res\n        return res\n        \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, -1)\n    return max(dp.values()) if dp else 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m\u00d7n)",
        "spaceComplexity": "O(m\u00d7n)",
        "intuition": [
          "From each cell, explore all increasing paths in 4 directions",
          "Cache results to prevent recalculating the same subproblems"
        ],
        "code": "def longestIncreasingPath(matrix):\n    \"\"\"\n    Intuition:\n    - From each cell, explore all increasing paths in 4 directions\n    - Cache results to prevent recalculating the same subproblems\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        max_path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for di, dj in directions:  # Iterate over elements.\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj))  # Take the maximum value.\n        \n        memo[(i, j)] = max_path\n        return max_path\n    \n    result = 0\n    for i in range(m):  # Iterate through the range.\n        for j in range(n):  # Iterate through the range.\n            result = max(result, dfs(i, j))  # Take the maximum value.\n    \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "        class Solution {\n    longestIncreasingPath(matrix) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} matrix\n     * @return {any}\n     */\n    longestIncreasingPath(matrix) {\n        if (!matrix.length) return 0;\n        const m = matrix.length;\n        const n = matrix[0].length;\n        const cache = new Array(m).fill().map(() => new Array(n));\n        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n        return Math.max(...new Array(m).fill().map((_, i) =>\n          new Array(n).fill().map((_, j) => dfs(i, j))).flat());\n\n        class Solution {\n          /**\n           * @param {any} i, j\n           * @return {any}\n           */\n          dfs(i, j) {\n          return cache[i][j] || (cache[i][j] = 1 + Math.max(...directions.map(([di, dj]) => {\n            const [a, b] = [i + di, j + dj];\n            return a >= 0 && a < m && b >= 0 && b < n && matrix[a][b] > matrix[i][j]\n              ? dfs(a, b) : 0;\n          })));\n      }\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int longestIncreasingPath(int[][] matrix) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    private int m;\n    private int n;\n    private int[][] matrix;\n    private int[][] f;\n\n    public int longestIncreasingPath(int[][] matrix) {\n        m = matrix.length;\n        n = matrix[0].length;\n        f = new int[m][n];\n        this.matrix = matrix;\n        int ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans = Math.max(ans, dfs(i, j));\n            }\n        }\n        return ans;\n    }\n\n    private int dfs(int i, int j) {\n        if (f[i][j] != 0) {\n            return f[i][j];\n        }\n        int[] dirs = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; ++k) {\n            int x = i + dirs[k];\n            int y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n                f[i][j] = Math.max(f[i][j], dfs(x, y));\n            }\n        }\n        return ++f[i][j];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        int f[m][n];\n        memset(f, 0, sizeof(f));\n        int ans = 0;\n        int dirs[5] = {-1, 0, 1, 0, -1};\n\n        function<int(int, int)> dfs = [&](int i, int j) -> int {\n            if (f[i][j]) {\n                return f[i][j];\n            }\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n                    f[i][j] = max(f[i][j], dfs(x, y));\n                }\n            }\n            return ++f[i][j];\n        };\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                ans = max(ans, dfs(i, j));\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) longestIncreasingPath(matrix [][]int) (ans int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) longestIncreasingPath(matrix [][]int) (ans int) {\n\tm, n := len(matrix), len(matrix[0])\n\tf := make([][]int, m)\n\tfor i := range f {\n\t\tf[i] = make([]int, n)\n\t}\n\tdirs := [5]int{-1, 0, 1, 0, -1}\n\tvar dfs func(i, j int) int\n\tdfs = func(i, j int) int {\n\t\tif f[i][j] != 0 {\n\t\t\treturn f[i][j]\n\t\t}\n\t\tfor k := 0; k < 4; k++ {\n\t\t\tx, y := i+dirs[k], j+dirs[k+1]\n\t\t\tif 0 <= x && x < m && 0 <= y && y < n && matrix[x][y] > matrix[i][j] {\n\t\t\t\tf[i][j] = max(f[i][j], dfs(x, y))\n\t\t\t}\n\t\t}\n\t\tf[i][j]++\n\t\treturn f[i][j]\n\t}\n\tfor i := 0; i < m; i++ {\n\t\tfor j := 0; j < n; j++ {\n\t\t\tans = max(ans, dfs(i, j))\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn longest_increasing_path(matrix: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn longest_increasing_path(matrix: Vec<Vec<i32>>) -> i32 {\n        let n = matrix.len();\n        if n == 0 {\n            return 0;\n        }\n        let m = matrix[0].len();\n        let mut memo = vec![vec![0; m]; n];\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if memo[i][j] == 0 {\n                    memo[i][j] = Self::dfs(i, j, &mut memo, &matrix);\n                    res = res.max(memo[i][j]);\n                }\n            }\n        }\n        res\n    }\n\n    fn dfs(i: usize, j: usize, memo: &mut Vec<Vec<i32>>, matrix: &[Vec<i32>]) -> i32 {\n        if memo[i][j] != 0 {\n            return memo[i][j];\n        }\n        let n = matrix.len();\n        let m = matrix[0].len();\n        let mut res = 1;\n        if i > 0 && matrix[i - 1][j] > matrix[i][j] {\n            res = res.max(Self::dfs(i - 1, j, memo, matrix) + 1);\n        }\n        if j > 0 && matrix[i][j - 1] > matrix[i][j] {\n            res = res.max(Self::dfs(i, j - 1, memo, matrix) + 1);\n        }\n        if i + 1 < n && matrix[i + 1][j] > matrix[i][j] {\n            res = res.max(Self::dfs(i + 1, j, memo, matrix) + 1);\n        }\n        if j + 1 < m && matrix[i][j + 1] > matrix[i][j] {\n            res = res.max(Self::dfs(i, j + 1, memo, matrix) + 1);\n        }\n        memo[i][j] = res;\n        res\n    }\n}\n\n#[test]\nfn test() {\n    let matrix = vec_vec_i32![[9, 9, 4], [6, 6, 8], [2, 1, 1]];\n    let res = 4;\n    assert_eq!(Solution::longest_increasing_path(matrix), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def longestIncreasingPath(self, matrix):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    longestIncreasingPath(matrix: number[][]): number  {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const f: number[][] = Array(m)\n        .fill(0)\n        .map(() => Array(n).fill(0));\n    const dirs = [-1, 0, 1, 0, -1];\n    const dfs = (i: number, j: number): number => {\n        if (f[i][j] > 0) {\n            return f[i][j];\n        }\n        for (let k = 0; k < 4; ++k) {\n            const x = i + dirs[k];\n            const y = j + dirs[k + 1];\n            if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n                f[i][j] = Math.max(f[i][j], dfs(x, y));\n            }\n        }\n        return ++f[i][j];\n    };\n    let ans = 0;\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            ans = Math.max(ans, dfs(i, j));\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    longestIncreasingPath(matrix: number[][]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
    "relatedProblems": [
      "word-ladder",
      "largest-rectangle-in-histogram",
      "reconstruct-itinerary"
    ]
  },
  "distinct-subsequences": {
    "id": "distinct-subsequences",
    "slug": "distinct-subsequences",
    "title": "Distinct Subsequences",
    "difficulty": "Hard",
    "category": "2-D Dynamic Programming",
    "problemStatement": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "oneliner": "Use DP to count ways to form t[0:j] using s[0:i].",
    "intuition": [
      "For each character in s, we can either include or exclude it",
      "If characters match, we add paths from diagonal (include) and above (exclude)"
    ],
    "visualizationType": "array",
    "initialState": [
      [
        "",
        "r",
        "a",
        "b",
        "b",
        "i",
        "t"
      ],
      [
        "r",
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        "a",
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        "b",
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        "b",
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        "i",
        0,
        0,
        0,
        0,
        0,
        0
      ],
      [
        "t",
        0,
        0,
        0,
        0,
        0,
        0
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Distinct Subsequences",
        "transientMessage": "Dynamic Programming approach",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "i",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "t",
            0,
            0,
            0,
            0,
            0,
            0
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize DP table",
        "transientMessage": "Set base cases",
        "arrayState": [
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Compute dp[0]",
        "transientMessage": "dp[0] = ,r,a,b,b,i,t",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          0,
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0,
          0
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Compute dp[1]",
        "transientMessage": "dp[1] = r,0,0,0,0,0,0",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[0], dp[0]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Compute dp[2]",
        "transientMessage": "dp[2] = a,0,0,0,0,0,0",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[1], dp[0]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute dp[3]",
        "transientMessage": "dp[3] = b,0,0,0,0,0,0",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "accent"
      },
      {
        "step": 10,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[2], dp[1]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          2,
          3
        ],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Compute dp[4]",
        "transientMessage": "dp[4] = b,0,0,0,0,0,0",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 12,
        "visual": "Update from previous states",
        "transientMessage": "Using dp[3], dp[2]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          3,
          4
        ],
        "color": "success"
      },
      {
        "step": 13,
        "visual": "DP table complete",
        "transientMessage": "Final answer in dp[n-1]",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [],
        "indices": [
          6
        ],
        "color": "success"
      },
      {
        "step": 14,
        "visual": "Return result",
        "transientMessage": "Complete!",
        "arrayState": [
          [
            "",
            "r",
            "a",
            "b",
            "b",
            "i",
            "t"
          ],
          [
            "r",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "a",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          [
            "b",
            0,
            0,
            0,
            0,
            0,
            0
          ],
          0,
          0
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def numDistinct(self, s, t):\n        \"\"\"\n        Intuition:\n        - For each character in s, we can either include or exclude it\n        - If characters match, we add paths from diagonal (include) and above (exclude)\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n\n        # Empty t can be formed in 1 way\n        for i in range(m + 1):  # Iterate through the range.\n            dp[i][0] = 1\n\n        for i in range(1, m + 1):  # Iterate through the range.\n            for j in range(1, n + 1):  # Iterate through the range.\n                # Always carry forward ways without using s[i-1]\n                dp[i][j] = dp[i-1][j]\n\n                # If chars match, add ways using s[i-1]\n                if s[i-1] == t[j-1]:\n                    dp[i][j] += dp[i-1][j-1]\n\n        return dp[m][n]",
    "keyInsight": "At each step, we can either use or ignore the current character of s.",
    "testCases": [
      {
        "input": "s = \"rabbbit\", t = \"rabbit\"",
        "output": "3"
      },
      {
        "input": "s = \"babgbag\", t = \"bag\"",
        "output": "5"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use DP to count ways to form t[0:j] using s[0:i].",
    "videoId": "-RDzMJ33nx8",
    "suggestedNextQuestion": {
      "slug": "longest-increasing-path-in-a-matrix",
      "title": "Longest Increasing Path In a Matrix",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def numDistinct(self, s, t):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def numDistinct_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m*n)",
        "spaceComplexity": "O(m*n)",
        "intuition": [
          "For each character in s, we can either include or exclude it",
          "If characters match, we add paths from diagonal (include) and above (exclude)"
        ],
        "code": "def numDistinct(s, t):\n    \"\"\"\n    Intuition:\n    - For each character in s, we can either include or exclude it\n    - If characters match, we add paths from diagonal (include) and above (exclude)\n    \"\"\"\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    \n    # Empty t can be formed in 1 way\n    for i in range(m + 1):  # Iterate through the range.\n        dp[i][0] = 1\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            # Always carry forward ways without using s[i-1]\n            dp[i][j] = dp[i-1][j]\n            \n            # If chars match, add ways using s[i-1]\n            if s[i-1] == t[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    numDistinct(s, t) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s, t\n     * @return {any}\n     */\n    numDistinct(s, t) {\n        const nums = new Array(t.length + 1).fill(0);\n        nums[0] = 1;\n\n        for (let i = 0; i < s.length; i++) {\n          for (let j = nums.length - 1; j >= 0; j--) {\n            if (s[i] === t[j]) {\n              nums[j + 1] += nums[j];\n            }\n          }\n      }\n\n    return nums[t.length];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int numDistinct(String s, String t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public int numDistinct(String s, String t) {\n        int m = s.length(), n = t.length();\n        int[][] f = new int[m + 1][n + 1];\n        for (int i = 0; i < m + 1; ++i) {\n            f[i][0] = 1;\n        }\n        for (int i = 1; i < m + 1; ++i) {\n            for (int j = 1; j < n + 1; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    f[i][j] += f[i - 1][j - 1];\n                }\n            }\n        }\n        return f[m][n];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int numDistinct(string s, string t) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        int m = s.size(), n = t.size();\n        unsigned long long f[m + 1][n + 1];\n        memset(f, 0, sizeof(f));\n        for (int i = 0; i < m + 1; ++i) {\n            f[i][0] = 1;\n        }\n        for (int i = 1; i < m + 1; ++i) {\n            for (int j = 1; j < n + 1; ++j) {\n                f[i][j] = f[i - 1][j];\n                if (s[i - 1] == t[j - 1]) {\n                    f[i][j] += f[i - 1][j - 1];\n                }\n            }\n        }\n        return f[m][n];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) numDistinct(s string, t string) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) numDistinct(s string, t string) int {\n\tm, n := len(s), len(t)\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tfor i := 0; i <= m; i++ {\n\t\tf[i][0] = 1\n\t}\n\tfor i := 1; i <= m; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tf[i][j] = f[i-1][j]\n\t\t\tif s[i-1] == t[j-1] {\n\t\t\t\tf[i][j] += f[i-1][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn f[m][n]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn num_distinct(s: String, t: String) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    #[allow(dead_code)]\n    pub fn num_distinct(s: String, t: String) -> i32 {\n        let n = s.len();\n        let m = t.len();\n        let mut dp: Vec<Vec<u64>> = vec![vec![0; m + 1]; n + 1];\n\n        // Initialize the dp vector\n        for i in 0..=n {\n            dp[i][0] = 1;\n        }\n\n        // Begin the actual dp process\n        for i in 1..=n {\n            for j in 1..=m {\n                dp[i][j] = if s.as_bytes()[i - 1] == t.as_bytes()[j - 1] {\n                    dp[i - 1][j] + dp[i - 1][j - 1]\n                } else {\n                    dp[i - 1][j]\n                };\n            }\n        }\n\n        dp[n][m] as i32\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def numDistinct(self, s, t):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    numDistinct(s: string, t: string): number  {\n    const m = s.length;\n    const n = t.length;\n    const f: number[][] = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    for (let i = 0; i <= m; ++i) {\n        f[i][0] = 1;\n    }\n    for (let i = 1; i <= m; ++i) {\n        for (let j = 1; j <= n; ++j) {\n            f[i][j] = f[i - 1][j];\n            if (s[i - 1] === t[j - 1]) {\n                f[i][j] += f[i - 1][j - 1];\n            }\n        }\n    }\n    return f[m][n];\n}\n}",
        "initialCode": "class Solution {\n    numDistinct(s: string, t: string): number {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
    "relatedProblems": [
      "house-robber-ii",
      "coin-change-ii",
      "regular-expression-matching"
    ]
  },
  "burst-balloons": {
    "id": "burst-balloons",
    "slug": "burst-balloons",
    "title": "Burst Balloons",
    "difficulty": "Hard",
    "category": "2-D Dynamic Programming",
    "problemStatement": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n\u00b3)",
    "spaceComplexity": "O(n\u00b2)",
    "oneliner": "Use DP with interval merging, considering last balloon to burst.",
    "intuition": [
      "Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.",
      "This makes subproblems independent and allows for optimal substructure."
    ],
    "visualizationType": "array",
    "initialState": [
      3,
      1,
      5,
      8
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Burst Balloons",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1",
        "transientMessage": "Iteration 2",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 5",
        "transientMessage": "Iteration 3",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 8",
        "transientMessage": "Iteration 4",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          3,
          1,
          5,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def maxCoins(self, nums):\n        \"\"\"\n        Intuition:\n        - Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.\n        - This makes subproblems independent and allows for optimal substructure.\n        \"\"\"\n        n = len(nums)\n        nums = [1] + nums + [1]\n        dp = [[0] * (n + 2) for _ in range(n + 2)]  # Initialize DP table to store results.\n\n        for length in range(1, n + 1):  # Iterate through the range.\n            for left in range(1, n - length + 2):  # Iterate through the range.\n                right = left + length - 1\n                for k in range(left, right + 1):  # Iterate through the range.\n                    coins = nums[left - 1] * nums[k] * nums[right + 1]\n                    coins += dp[left][k - 1] + dp[k + 1][right]\n                    dp[left][right] = max(dp[left][right], coins)  # Take the maximum value.\n\n        return dp[1][n]",
    "keyInsight": "Choosing the last balloon to burst in a range makes left and right subproblems independent.",
    "testCases": [
      {
        "input": "nums = [3,1,5,8]",
        "output": "167"
      },
      {
        "input": "nums = [1,5]",
        "output": "10"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use DP with interval merging, considering last balloon to burst.",
    "videoId": "VFskby7lUbw",
    "suggestedNextQuestion": {
      "slug": "distinct-subsequences",
      "title": "Distinct Subsequences",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    },
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def maxCoins(self, nums):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def maxCoins_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n\u00b3)",
        "spaceComplexity": "O(n\u00b2)",
        "intuition": [
          "Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.",
          "This makes subproblems independent and allows for optimal substructure."
        ],
        "code": "def maxCoins(nums):\n    \"\"\"\n    Intuition:\n    - Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.\n    - This makes subproblems independent and allows for optimal substructure.\n    \"\"\"\n    n = len(nums)\n    nums = [1] + nums + [1]\n    dp = [[0] * (n + 2) for _ in range(n + 2)]  # Initialize DP table to store results.\n    \n    for length in range(1, n + 1):  # Iterate through the range.\n        for left in range(1, n - length + 2):  # Iterate through the range.\n            right = left + length - 1\n            for k in range(left, right + 1):  # Iterate through the range.\n                coins = nums[left - 1] * nums[k] * nums[right + 1]\n                coins += dp[left][k - 1] + dp[k + 1][right]\n                dp[left][right] = max(dp[left][right], coins)  # Take the maximum value.\n    \n    return dp[1][n]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    maxCoins(nums) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} nums\n     * @return {any}\n     */\n    maxCoins(nums) {\n        const track = [1, ...nums, 1];\n        const dp = new Array(nums.length + 2).fill().map(() => new Array(nums.length + 2).fill(0));\n\n        for (let count = 1; count <= nums.length; count++) {\n          for (let i = 1; i <= nums.length - count + 1; i++) {\n            const j = i + count - 1;\n            for (let k = i; k <= j; k++) {\n              dp[i - 1][j + 1] = Math.max(\n                dp[i - 1][j + 1],\n                dp[i - 1][k] + dp[k][j + 1] + track[i - 1] * track[k] * track[j + 1]\n              );\n            }\n          }\n      }\n\n    return dp[0][nums.length + 1];\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public int maxCoins(int[] nums) {\n        // Your code here\n        return 0;\n    }\n}",
        "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n + 2];\n        arr[0] = 1;\n        arr[n + 1] = 1;\n        System.arraycopy(nums, 0, arr, 1, n);\n        int[][] f = new int[n + 2][n + 2];\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 2; j <= n + 1; j++) {\n                for (int k = i + 1; k < j; k++) {\n                    f[i][j] = Math.max(f[i][j], f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j]);\n                }\n            }\n        }\n        return f[0][n + 1];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    int maxCoins(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    int maxCoins(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> arr(n + 2, 1);\n        for (int i = 0; i < n; ++i) {\n            arr[i + 1] = nums[i];\n        }\n\n        vector<vector<int>> f(n + 2, vector<int>(n + 2, 0));\n        for (int i = n - 1; i >= 0; --i) {\n            for (int j = i + 2; j <= n + 1; ++j) {\n                for (int k = i + 1; k < j; ++k) {\n                    f[i][j] = max(f[i][j], f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j]);\n                }\n            }\n        }\n        return f[0][n + 1];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) maxCoins(nums []int) int {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) maxCoins(nums []int) int {\n    n := len(nums)\n    arr := make([]int, n+2)\n    arr[0] = 1\n    arr[n+1] = 1\n    copy(arr[1:], nums)\n    \n    f := make([][]int, n+2)\n    for i := range f {\n        f[i] = make([]int, n+2)\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        for j := i + 2; j <= n+1; j++ {\n            for k := i + 1; k < j; k++ {\n                f[i][j] = max(f[i][j], f[i][k] + f[k][j] + arr[i]*arr[k]*arr[j])\n            }\n        }\n    }\n\n    return f[0][n+1]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn max_coins(nums: Vec<i32>) -> i32 {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn max_coins(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut arr = vec![1; n + 2];\n        for i in 0..n {\n            arr[i + 1] = nums[i];\n        }\n\n        let mut f = vec![vec![0; n + 2]; n + 2];\n        for i in (0..n).rev() {\n            for j in i + 2..n + 2 {\n                for k in i + 1..j {\n                    f[i][j] = f[i][j].max(f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j]);\n                }\n            }\n        }\n        f[0][n + 1]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def maxCoins(self, nums):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    maxCoins(nums: number[]): number  {\n    const n = nums.length;\n    const arr = Array(n + 2).fill(1);\n    for (let i = 0; i < n; i++) {\n        arr[i + 1] = nums[i];\n    }\n\n    const f: number[][] = Array.from({ length: n + 2 }, () => Array(n + 2).fill(0));\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 2; j <= n + 1; j++) {\n            for (let k = i + 1; k < j; k++) {\n                f[i][j] = Math.max(f[i][j], f[i][k] + f[k][j] + arr[i] * arr[k] * arr[j]);\n            }\n        }\n    }\n    return f[0][n + 1];\n}\n}",
        "initialCode": "class Solution {\n    maxCoins(nums: number[]): number {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.",
    "relatedProblems": [
      "target-sum",
      "distinct-subsequences",
      "longest-common-subsequence"
    ]
  },
  "regular-expression-matching": {
    "id": "regular-expression-matching",
    "slug": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "difficulty": "Hard",
    "category": "2-D Dynamic Programming",
    "problemStatement": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).",
    "videoUrl": "",
    "pattern": "Dynamic Programming",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(m\u00d7n)",
    "spaceComplexity": "O(m\u00d7n)",
    "oneliner": "Use a 2D DP table to track matching substrings.",
    "intuition": [
      "Break the problem into smaller subproblems of matching prefixes.",
      "Handle '*' by considering 0 matches or extending previous matches."
    ],
    "visualizationType": "array",
    "initialState": [
      [
        "",
        "a",
        "*",
        "b"
      ],
      [
        "",
        true,
        true,
        false
      ],
      [
        "a",
        false,
        true,
        false
      ],
      [
        "a",
        false,
        true,
        false
      ],
      [
        "b",
        false,
        false,
        true
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Regular Expression Matching",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = ,a,*,b",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = ,true,true,false",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = a,false,true,false",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = a,false,true,false",
        "transientMessage": "Iteration 4",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = b,false,false,true",
        "transientMessage": "Iteration 5",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            "",
            "a",
            "*",
            "b"
          ],
          [
            "",
            true,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "a",
            false,
            true,
            false
          ],
          [
            "b",
            false,
            false,
            true
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def isMatch(self, s, p):\n        \"\"\"\n        Intuition:\n        - Break the problem into smaller subproblems of matching prefixes.\n        - Handle '*' by considering 0 matches or extending previous matches.\n        \"\"\"\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n        dp[0][0] = True\n\n        for j in range(2, n + 1):  # Iterate through the range.\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):  # Iterate through the range.\n            for j in range(1, n + 1):  # Iterate through the range.\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n\n        return dp[m][n]",
    "keyInsight": "Use DP to build up solutions for matching prefixes of string and pattern.",
    "testCases": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false"
      },
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true"
      },
      {
        "input": "s = \"ab\", p = \".*\"",
        "output": "true"
      }
    ],
    "walkthrough": [
      "Define state: dp[i] represents optimal solution up to index i",
      "Establish base case(s)",
      "Iterate through problem space",
      "Apply recurrence relation at each step",
      "Return final state as answer"
    ],
    "hints": [
      "\ud83e\udde0 Think about what state you need to track",
      "\ud83d\udca1 Consider the recurrence relation",
      "\ud83d\udd0d Can you optimize space complexity?"
    ],
    "approach": "Dynamic Programming: Use a 2D DP table to track matching substrings.",
    "videoId": "HAA8mgxlov8",
    "mentalModel": "Like solving a puzzle. Break it down into pieces and assemble the logic.",
    "initialCode": "class Solution:\n    def isMatch(self, s, p):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n) recursion stack",
        "intuition": [
          "Use recursion to explore all possibilities.",
          "Without memoization, this leads to exponential time."
        ],
        "code": "def isMatch_brute(nums):\n    def helper(i, state):\n        if i == len(nums):\n            return 0  # base case\n        # Try including or excluding nums[i]\n        include = helper(i + 1, new_state)\n        exclude = helper(i + 1, state)\n        return max(include, exclude)\n    return helper(0, initial_state)"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(m\u00d7n)",
        "spaceComplexity": "O(m\u00d7n)",
        "intuition": [
          "Break the problem into smaller subproblems of matching prefixes.",
          "Handle '*' by considering 0 matches or extending previous matches."
        ],
        "code": "def isMatch(s, p):\n    \"\"\"\n    Intuition:\n    - Break the problem into smaller subproblems of matching prefixes.\n    - Handle '*' by considering 0 matches or extending previous matches.\n    \"\"\"\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]  # Initialize DP table to store results.\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):  # Iterate through the range.\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):  # Iterate through the range.\n        for j in range(1, n + 1):  # Iterate through the range.\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n            else:\n                dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n    \n    return dp[m][n]"
      }
    ],
    "examples": [
      {
        "input": "nums = [1, 2, 3]",
        "output": "[result]",
        "explanation": "Build solution from smaller subproblems."
      },
      {
        "input": "nums = [1]",
        "output": "[base case]",
        "explanation": "Base case with single element."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "0 <= values[i] <= 10^4"
    ],
    "commonMistakes": [
      "Wrong base case initialization",
      "Incorrect recurrence relation",
      "Not considering all subproblem dependencies"
    ],
    "interviewTip": "Start with brute force, add memoization, then optimize to tabulation.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    isMatch(s, p) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nclass Solution {\n    /**\n     * @param {any} s, p\n     * @return {any}\n     */\n    isMatch(s, p) {\n        const m = s.length;\n        const n = p.length;\n        const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n        const dfs = (i, j) => {\n            if (j >= n) {\n                return i === m;\n            }\n            if (f[i][j]) {\n                return f[i][j] === 1;\n            }\n            let res = -1;\n            if (j + 1 < n && p[j + 1] === '*') {\n                if (dfs(i, j + 2) || (i < m && (s[i] === p[j] || p[j] === '.') && dfs(i + 1, j))) {\n                    res = 1;\n                }\n            } else if (i < m && (s[i] === p[j] || p[j] === '.') && dfs(i + 1, j + 1)) {\n                res = 1;\n        }\n        f[i][j] = res;\n        return res === 1;\n    };\n    return dfs(0, 0);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean isMatch(String s, String p) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    private Boolean[][] f;\n    private String s;\n    private String p;\n    private int m;\n    private int n;\n\n    public boolean isMatch(String s, String p) {\n        m = s.length();\n        n = p.length();\n        f = new Boolean[m + 1][n + 1];\n        this.s = s;\n        this.p = p;\n        return dfs(0, 0);\n    }\n\n    private boolean dfs(int i, int j) {\n        if (j >= n) {\n            return i == m;\n        }\n        if (f[i][j] != null) {\n            return f[i][j];\n        }\n        boolean res = false;\n        if (j + 1 < n && p.charAt(j + 1) == '*') {\n            res = dfs(i, j + 2)\n                || (i < m && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') && dfs(i + 1, j));\n        } else {\n            res = i < m && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') && dfs(i + 1, j + 1);\n        }\n        return f[i][j] = res;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool isMatch(string s, string p) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        int f[m + 1][n + 1];\n        memset(f, 0, sizeof f);\n        function<bool(int, int)> dfs = [&](int i, int j) -> bool {\n            if (j >= n) {\n                return i == m;\n            }\n            if (f[i][j]) {\n                return f[i][j] == 1;\n            }\n            int res = -1;\n            if (j + 1 < n && p[j + 1] == '*') {\n                if (dfs(i, j + 2) or (i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j))) {\n                    res = 1;\n                }\n            } else if (i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j + 1)) {\n                res = 1;\n            }\n            f[i][j] = res;\n            return res == 1;\n        };\n        return dfs(0, 0);\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isMatch(s string, p string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isMatch(s string, p string) bool {\n\tm, n := len(s), len(p)\n\tf := make([][]int, m+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\tvar dfs func(i, j int) bool\n\tdfs = func(i, j int) bool {\n\t\tif j >= n {\n\t\t\treturn i == m\n\t\t}\n\t\tif f[i][j] != 0 {\n\t\t\treturn f[i][j] == 1\n\t\t}\n\t\tres := -1\n\t\tif j+1 < n && p[j+1] == '*' {\n\t\t\tif dfs(i, j+2) || (i < m && (s[i] == p[j] || p[j] == '.') && dfs(i+1, j)) {\n\t\t\t\tres = 1\n\t\t\t}\n\t\t} else if i < m && (s[i] == p[j] || p[j] == '.') && dfs(i+1, j+1) {\n\t\t\tres = 1\n\t\t}\n\t\tf[i][j] = res\n\t\treturn res == 1\n\t}\n\treturn dfs(0, 0)\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn is_match(s: String, p: String) -> bool {\n        let (m, n) = (s.len(), p.len());\n        let mut f = vec![vec![0; n + 1]; m + 1];\n\n        fn dfs(\n            s: &Vec<char>,\n            p: &Vec<char>,\n            f: &mut Vec<Vec<i32>>,\n            i: usize,\n            j: usize,\n            m: usize,\n            n: usize,\n        ) -> bool {\n            if j >= n {\n                return i == m;\n            }\n            if f[i][j] != 0 {\n                return f[i][j] == 1;\n            }\n            let mut res = -1;\n            if j + 1 < n && p[j + 1] == '*' {\n                if dfs(s, p, f, i, j + 2, m, n)\n                    || (i < m && (s[i] == p[j] || p[j] == '.') && dfs(s, p, f, i + 1, j, m, n))\n                {\n                    res = 1;\n                }\n            } else if i < m && (s[i] == p[j] || p[j] == '.') && dfs(s, p, f, i + 1, j + 1, m, n) {\n                res = 1;\n            }\n            f[i][j] = res;\n            res == 1\n        }\n\n        dfs(\n            &s.chars().collect(),\n            &p.chars().collect(),\n            &mut f,\n            0,\n            0,\n            m,\n            n,\n        )\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def isMatch(self, s, p):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    isMatch(s: any, p: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    isMatch(s: any, p: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).",
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-with-cooldown",
      "longest-common-subsequence",
      "maximum-product-subarray"
    ],
    "suggestedNextQuestion": {
      "slug": "distinct-subsequences",
      "title": "Distinct Subsequences",
      "difficulty": "Hard",
      "pattern": "Dynamic Programming"
    }
  },
  "hand-of-straights": {
    "id": "hand-of-straights",
    "slug": "hand-of-straights",
    "title": "Hand of Straights",
    "difficulty": "Medium",
    "category": "Greedy",
    "problemStatement": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
    "videoUrl": "",
    "pattern": "Greedy with HashMap",
    "patternEmoji": "\ud83d\udcca\u27a1\ufe0f",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "oneliner": "Use a frequency map and always start with the smallest available card.",
    "intuition": [
      "We need consecutive sequences, so sorting helps process cards in order",
      "Greedy approach: always form a group starting with the smallest remaining card"
    ],
    "visualizationType": "array",
    "initialState": [
      1,
      2,
      3,
      6,
      2,
      3,
      4,
      7,
      8
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Hand of Straights",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 1",
        "transientMessage": "Iteration 1",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 2",
        "transientMessage": "Iteration 2",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 3",
        "transientMessage": "Iteration 3",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = 6",
        "transientMessage": "Iteration 4",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = 2",
        "transientMessage": "Iteration 5",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = 3",
        "transientMessage": "Iteration 6",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          1,
          2,
          3,
          6,
          2,
          3,
          4,
          7,
          8
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    from collections import Counter\n    \n    def isNStraightHand(self, hand, groupSize):\n        \"\"\"\n        Intuition:\n        - We need consecutive sequences, so sorting helps process cards in order\n        - Greedy approach: always form a group starting with the smallest remaining card\n        \"\"\"\n        if len(hand) % groupSize != 0:\n            return False  # Condition not met.\n        \n        count = Counter(hand)\n        sorted_keys = sorted(count.keys())\n        \n        for key in sorted_keys:  # Iterate over elements.\n            if count[key] > 0:\n                start_count = count[key]\n                for i in range(groupSize):  # Iterate through the range.\n                    if count[key + i] < start_count:\n                        return False  # Condition not met.\n                    count[key + i] -= start_count\n        \n        return True  # Condition satisfied.",
    "keyInsight": "Process cards in sorted order and greedily form groups starting with the smallest available card.",
    "testCases": [
      {
        "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
        "output": "true"
      },
      {
        "input": "hand = [1,2,3,4,5], groupSize = 4",
        "output": "false"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Greedy with HashMap: Use a frequency map and always start with the smallest available card.",
    "examples": [
      {
        "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
        "output": "true",
        "explanation": "Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]"
      },
      {
        "input": "hand = [1,2,3,4,5], groupSize = 4",
        "output": "false",
        "explanation": "Alice's hand cannot be rearranged into groups of 4."
      }
    ],
    "constraints": [
      "1 <= hand.length <= 10^4",
      "0 <= hand[i] <= 10^9",
      "1 <= groupSize <= hand.length"
    ],
    "videoId": "amnrMCVd2YI",
    "suggestedNextQuestion": {
      "slug": "integer-to-roman",
      "title": "Integer to Roman",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def isNStraightHand(hand, groupSize):\n    if len(hand) % groupSize: return False\n    count = {}\n    for n in hand: count[n] = count.get(n, 0) + 1\n    minH = list(count.keys())\n    import heapq\n    heapq.heapify(minH)\n    \n    while minH:\n        first = minH[0]\n        for i in range(first, first + groupSize):\n            if i not in count: return False\n            count[i] -= 1\n            if count[i] == 0:\n                if i != minH[0]: return False\n                heapq.heappop(minH)\n    return True"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "We need consecutive sequences, so sorting helps process cards in order",
          "Greedy approach: always form a group starting with the smallest remaining card"
        ],
        "code": "from collections import Counter\n\ndef isNStraightHand(hand, groupSize):\n    \"\"\"\n    Intuition:\n    - We need consecutive sequences, so sorting helps process cards in order\n    - Greedy approach: always form a group starting with the smallest remaining card\n    \"\"\"\n    if len(hand) % groupSize != 0:\n        return False  # Condition not met.\n    \n    count = Counter(hand)\n    sorted_keys = sorted(count.keys())\n    \n    for key in sorted_keys:  # Iterate over elements.\n        if count[key] > 0:\n            start_count = count[key]\n            for i in range(groupSize):  # Iterate through the range.\n                if count[key + i] < start_count:\n                    return False  # Condition not met.\n                count[key + i] -= start_count\n    \n    return True  # Condition satisfied."
      }
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    solve(hand, groupSize) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    solve(hand, groupSize) {}\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean solve(int[] hand, int groupSize) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean solve(int[] hand, int groupSize) {\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool solve(vector<int>& hand, int groupSize) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool solve(vector<int>& hand, int groupSize) {\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) isNStraightHand(hand []int, groupSize int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) isNStraightHand(hand []int, groupSize int) bool {\n\tif len(hand)%groupSize != 0 {\n\t\treturn false\n\t}\n\tsort.Ints(hand)\n\tcnt := map[int]int{}\n\tfor _, x := range hand {\n\t\tcnt[x]++\n\t}\n\tfor _, x := range hand {\n\t\tif cnt[x] > 0 {\n\t\t\tfor y := x; y < x+groupSize; y++ {\n\t\t\t\tif cnt[y] == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tcnt[y]--\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn is_n_straight_hand(hand: i32, groupSize: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\nuse std::collections::BTreeMap;\nuse std::collections::VecDeque;\nuse std::iter::FromIterator;\n\nimpl Solution {\n    fn is_n_straight_hand(hand: Vec<i32>, w: i32) -> bool {\n        let mut btm: BTreeMap<i32, usize> = BTreeMap::new();\n        for card in hand {\n            *btm.entry(card).or_default() += 1;\n        }\n        let w = w as usize;\n        let mut queue: VecDeque<(i32, usize)> = VecDeque::from_iter(btm);\n        while !queue.is_empty() {\n            let first = queue.pop_front().unwrap();\n            let mut stack: Vec<(i32, usize)> = vec![];\n            for i in 1..w {\n                if let Some(front) = queue.pop_front() {\n                    if front.0 != first.0 + i as i32 || front.1 < first.1 {\n                        return false;\n                    } else {\n                        let left = front.1 - first.1;\n                        if left > 0 {\n                            stack.push((front.0, left));\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            }\n            while let Some(last) = stack.pop() {\n                queue.push_front(last);\n            }\n        }\n        true\n    }\n}\n\n#[test]\nfn test() {\n    let hand = vec![1, 2, 3, 6, 2, 3, 4, 7, 8];\n    let w = 3;\n    let res = true;\n    assert_eq!(Solution::is_n_straight_hand(hand, w), res);\n    let hand = vec![1, 2, 3, 4, 5];\n    let w = 4;\n    let res = false;\n    assert_eq!(Solution::is_n_straight_hand(hand, w), res);\n    let hand = vec![5, 1];\n    let w = 2;\n    let res = false;\n    assert_eq!(Solution::is_n_straight_hand(hand, w), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def solve(self):\n        # Your code here\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    solve(hand: number[], groupSize: number): boolean {\n        return false;\n    }\n}",
        "initialCode": "class Solution {\n    solve(hand: number[], groupSize: number): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
    "relatedProblems": [
      "partition-equal-subset-sum",
      "flatten-binary-tree-to-linked-list",
      "factorial-trailing-zeroes"
    ]
  },
  "merge-triplets-to-form-target-triplet": {
    "id": "merge-triplets-to-form-target-triplet",
    "slug": "merge-triplets-to-form-target-triplet",
    "title": "Merge Triplets to Form Target Triplet",
    "difficulty": "Medium",
    "category": "Greedy",
    "problemStatement": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\nTo obtain target, you may apply the following operation on triplets any number of times (possibly zero):\nReturn true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",
    "videoUrl": "",
    "pattern": "Greedy",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Only consider triplets that don't exceed target values and greedily build up to target.",
    "intuition": [
      "We can only increase values through max operations, so any triplet with a component exceeding the target is useless.",
      "Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component."
    ],
    "visualizationType": "array",
    "initialState": [
      [
        2,
        5,
        3
      ],
      [
        1,
        8,
        4
      ],
      [
        1,
        7,
        5
      ]
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Merge Triplets to Form Target Triplet",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = 2,5,3",
        "transientMessage": "Iteration 1",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = 1,8,4",
        "transientMessage": "Iteration 2",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = 1,7,5",
        "transientMessage": "Iteration 3",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Compute result phase 8",
        "transientMessage": "Building solution",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [
          2,
          0
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          [
            2,
            5,
            3
          ],
          [
            1,
            8,
            4
          ],
          [
            1,
            7,
            5
          ]
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def mergeTriplets(self, triplets, target):\n        \"\"\"\n        Intuition:\n        - We can only increase values through max operations, so any triplet with a component exceeding the target is useless.\n        - Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component.\n        \"\"\"\n        target_a, target_b, target_c = target\n        found_a, found_b, found_c = False, False, False\n\n        for a, b, c in triplets:  # Iterate over elements.\n            if a > target_a or b > target_b or c > target_c:\n                continue\n            if a == target_a:\n                found_a = True\n            if b == target_b:\n                found_b = True\n            if c == target_c:\n                found_c = True\n\n        return found_a and found_b and found_c",
    "keyInsight": "We can only increase components via max operations, so we must find valid triplets that contribute each target component without overshooting.",
    "testCases": [
      {
        "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
        "output": "true"
      },
      {
        "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
        "output": "false"
      },
      {
        "input": "triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]",
        "output": "true"
      }
    ],
    "walkthrough": [
      "Goal: find triplets that can combine to form target",
      "Filter out triplets where any element exceeds target",
      "For remaining triplets, check which target positions they satisfy",
      "Track if we've found triplets matching each target element",
      "Return True if all three target elements are achievable"
    ],
    "hints": [
      "\ud83e\udde0 Can local optimal lead to global optimal?",
      "\ud83d\udca1 Sort by relevant property first",
      "\ud83d\udd0d Prove greedy works before implementing"
    ],
    "approach": "Greedy: Only consider triplets that don't exceed target values and greedily build up to target.",
    "videoId": "kShkQLQZ9K4",
    "suggestedNextQuestion": {
      "slug": "minimum-number-of-arrows-to-burst-balloons",
      "title": "Minimum Number of Arrows to Burst Balloons",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def mergeTriplets(self, triplets, target):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def mergeTriplets(triplets, target):\n    good = set()\n    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue\n        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)\n    return len(good) == 3"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "We can only increase values through max operations, so any triplet with a component exceeding the target is useless.",
          "Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component."
        ],
        "code": "def mergeTriplets(triplets, target):\n    \"\"\"\n    Intuition:\n    - We can only increase values through max operations, so any triplet with a component exceeding the target is useless.\n    - Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component.\n    \"\"\"\n    target_a, target_b, target_c = target\n    found_a, found_b, found_c = False, False, False\n    \n    for a, b, c in triplets:  # Iterate over elements.\n        if a > target_a or b > target_b or c > target_c:\n            continue\n        if a == target_a:\n            found_a = True\n        if b == target_b:\n            found_b = True\n        if c == target_c:\n            found_c = True\n    \n    return found_a and found_b and found_c"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    mergeTriplets(triplets, target) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} triplets, target\n     * @return {any}\n     */\n    mergeTriplets(triplets, target) {\n        let canFormX = false;\n        let canFormY = false;\n        let canFormZ = false;\n\n        for (const [a, b, c] of triplets) {\n          if (a <= target[0] && b <= target[1] && c <= target[2]) {\n            if (a === target[0]) canFormX = true;\n            if (b === target[1]) canFormY = true;\n            if (c === target[2]) canFormZ = true;\n          }\n      }\n\n    return canFormX && canFormY && canFormZ;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\n        // Your code here\n        return false;\n    }\n}",
        "code": "class Solution {\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\n        int x = target[0], y = target[1], z = target[2];\n        int d = 0, e = 0, f = 0;\n        for (var t : triplets) {\n            int a = t[0], b = t[1], c = t[2];\n            if (a <= x && b <= y && c <= z) {\n                d = Math.max(d, a);\n                e = Math.max(e, b);\n                f = Math.max(f, c);\n            }\n        }\n        return d == x && e == y && f == z;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {\n        int x = target[0], y = target[1], z = target[2];\n        int d = 0, e = 0, f = 0;\n        for (auto& t : triplets) {\n            int a = t[0], b = t[1], c = t[2];\n            if (a <= x && b <= y && c <= z) {\n                d = max(d, a);\n                e = max(e, b);\n                f = max(f, c);\n            }\n        }\n        return d == x && e == y && f == z;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) mergeTriplets(triplets [][]int, target []int) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) mergeTriplets(triplets [][]int, target []int) bool {\n\tx, y, z := target[0], target[1], target[2]\n\td, e, f := 0, 0, 0\n\tfor _, t := range triplets {\n\t\ta, b, c := t[0], t[1], t[2]\n\t\tif a <= x && b <= y && c <= z {\n\t\t\td = max(d, a)\n\t\t\te = max(e, b)\n\t\t\tf = max(f, c)\n\t\t}\n\t}\n\treturn d == x && e == y && f == z\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn merge_triplets(triplets: Vec<Vec<i32>>, target: Vec<i32>) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn merge_triplets(triplets: Vec<Vec<i32>>, target: Vec<i32>) -> bool {\n        let [x, y, z]: [i32; 3] = target.try_into().unwrap();\n        let (mut d, mut e, mut f) = (0, 0, 0);\n\n        for triplet in triplets {\n            if let [a, b, c] = triplet[..] {\n                if a <= x && b <= y && c <= z {\n                    d = d.max(a);\n                    e = e.max(b);\n                    f = f.max(c);\n                }\n            }\n        }\n\n        [d, e, f] == [x, y, z]\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def mergeTriplets(self, triplets, target):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    mergeTriplets(triplets: number[][], target: number[]): boolean  {\n    const [x, y, z] = target;\n    let [d, e, f] = [0, 0, 0];\n    for (const [a, b, c] of triplets) {\n        if (a <= x && b <= y && c <= z) {\n            d = Math.max(d, a);\n            e = Math.max(e, b);\n            f = Math.max(f, c);\n        }\n    }\n    return d === x && e === y && f === z;\n}\n}",
        "initialCode": "class Solution {\n    mergeTriplets(triplets: number[][], target: number[]): boolean {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\nTo obtain target, you may apply the following operation on triplets any number of times (possibly zero):\nReturn true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",
    "relatedProblems": [
      "best-time-to-buy-and-sell-stock-ii",
      "jump-game",
      "integer-to-roman"
    ]
  },
  "partition-labels": {
    "id": "partition-labels",
    "slug": "partition-labels",
    "title": "Partition Labels",
    "difficulty": "Medium",
    "category": "Greedy",
    "problemStatement": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.",
    "videoUrl": "",
    "pattern": "Greedy with Last Occurrence Tracking",
    "patternEmoji": "\ud83c\udfaf",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track last occurrences and extend partitions greedily.",
    "intuition": [
      "Each character must appear in only one partition",
      "We need to know the furthest position each character appears"
    ],
    "visualizationType": "array",
    "initialState": [
      "a",
      "b",
      "a",
      "b",
      "c",
      "b",
      "b",
      "d",
      "d"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Partition Labels",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = a",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = b",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = a",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = b",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Process arr[4] = c",
        "transientMessage": "Iteration 5",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 4
          }
        ],
        "indices": [
          4
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Process arr[5] = b",
        "transientMessage": "Iteration 6",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 5
          }
        ],
        "indices": [
          5
        ],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 11,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "a",
          "b",
          "a",
          "b",
          "c",
          "b",
          "b",
          "d",
          "d"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def partitionLabels(self, s):\n        \"\"\"\n        Intuition:\n        - Each character must appear in only one partition\n        - We need to know the furthest position each character appears\n        \"\"\"\n        last = {char: i for i, char in enumerate(s)}\n        result = []\n        start = 0\n        end = 0\n\n        for i, char in enumerate(s):  # Iterate over elements.\n            end = max(end, last[char])  # Take the maximum value.\n            if i == end:\n                result.append(end - start + 1)  # Add to end.\n                start = end + 1\n\n        return result  # Return the final result.",
    "keyInsight": "For each partition, we must include all occurrences of every character in it.",
    "testCases": [
      {
        "input": "s = \"ababcbacadefegdehijhklij\"",
        "output": "[9,7,8]"
      },
      {
        "input": "s = \"eccbbbbdec\"",
        "output": "[10]"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Greedy with Last Occurrence Tracking: Track last occurrences and extend partitions greedily.",
    "videoId": "B7m8UmZE-vw",
    "suggestedNextQuestion": {
      "slug": "task-scheduler",
      "title": "Task Scheduler",
      "difficulty": "Medium",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def partitionLabels(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def partitionLabels(s):\n    lastIndex = { c:i for i, c in enumerate(s) }\n    j, anchor = 0, 0\n    res = []\n    for i, c in enumerate(s):\n        j = max(j, lastIndex[c])\n        if i == j:\n            res.append(i - anchor + 1)\n            anchor = i + 1\n    return res"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "Each character must appear in only one partition",
          "We need to know the furthest position each character appears"
        ],
        "code": "def partitionLabels(s):\n    \"\"\"\n    Intuition:\n    - Each character must appear in only one partition\n    - We need to know the furthest position each character appears\n    \"\"\"\n    last = {char: i for i, char in enumerate(s)}\n    result = []\n    start = 0\n    end = 0\n    \n    for i, char in enumerate(s):  # Iterate over elements.\n        end = max(end, last[char])  # Take the maximum value.\n        if i == end:\n            result.append(end - start + 1)  # Add to end.\n            start = end + 1\n    \n    return result  # Return the final result."
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    partitionLabels(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "/**\n * @param {string} s\n * @return {number[]}\n */\nclass Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    partitionLabels(s) {\n        const last = new Array(26).fill(0);\n        const idx = c => c.charCodeAt() - 'a'.charCodeAt();\n        const n = s.length;\n        for (let i = 0; i < n; ++i) {\n            last[idx(s[i])] = i;\n        }\n        const ans = [];\n        for (let i = 0, j = 0, mx = 0; i < n; ++i) {\n            mx = Math.max(mx, last[idx(s[i])]);\n            if (mx === i) {\n                ans.push(i - j + 1);\n                j = i + 1;\n            }\n    }\n    return ans;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public List<Integer> partitionLabels(String s) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}",
        "code": "class Solution {\n    public List<Integer> partitionLabels(String s) {\n        int[] last = new int[26];\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            last[s.charAt(i) - 'a'] = i;\n        }\n        List<Integer> ans = new ArrayList<>();\n        int mx = 0, j = 0;\n        for (int i = 0; i < n; ++i) {\n            mx = Math.max(mx, last[s.charAt(i) - 'a']);\n            if (mx == i) {\n                ans.add(i - j + 1);\n                j = i + 1;\n            }\n        }\n        return ans;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    vector<int> partitionLabels(string s) {\n        // Your code here\n        return {};\n    }\n}",
        "code": "class Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        int last[26] = {0};\n        int n = s.size();\n        for (int i = 0; i < n; ++i) {\n            last[s[i] - 'a'] = i;\n        }\n        vector<int> ans;\n        int mx = 0, j = 0;\n        for (int i = 0; i < n; ++i) {\n            mx = max(mx, last[s[i] - 'a']);\n            if (mx == i) {\n                ans.push_back(i - j + 1);\n                j = i + 1;\n            }\n        }\n        return ans;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) partitionLabels(s string) (ans []int) {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) partitionLabels(s string) (ans []int) {\n\tlast := [26]int{}\n\tfor i, c := range s {\n\t\tlast[c-'a'] = i\n\t}\n\tvar mx, j int\n\tfor i, c := range s {\n\t\tmx = max(mx, last[c-'a'])\n\t\tif mx == i {\n\t\t\tans = append(ans, i-j+1)\n\t\t\tj = i + 1\n\t\t}\n\t}\n\treturn\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn partition_labels(s: String) -> Vec<i32> {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn partition_labels(s: String) -> Vec<i32> {\n        let n = s.len();\n        let bytes = s.as_bytes();\n        let mut last = [0; 26];\n        for i in 0..n {\n            last[(bytes[i] - b'a') as usize] = i;\n        }\n        let mut ans = vec![];\n        let mut j = 0;\n        let mut mx = 0;\n        for i in 0..n {\n            mx = mx.max(last[(bytes[i] - b'a') as usize]);\n            if mx == i {\n                ans.push((i - j + 1) as i32);\n                j = i + 1;\n            }\n        }\n        ans\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def partitionLabels(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    partitionLabels(s: string): number[]  {\n    const last: number[] = Array(26).fill(0);\n    const idx = (c: string) => c.charCodeAt(0) - 'a'.charCodeAt(0);\n    const n = s.length;\n    for (let i = 0; i < n; ++i) {\n        last[idx(s[i])] = i;\n    }\n    const ans: number[] = [];\n    for (let i = 0, j = 0, mx = 0; i < n; ++i) {\n        mx = Math.max(mx, last[idx(s[i])]);\n        if (mx === i) {\n            ans.push(i - j + 1);\n            j = i + 1;\n        }\n    }\n    return ans;\n}\n}",
        "initialCode": "class Solution {\n    partitionLabels(s: string): number[] {\n        // Your code here\n        return [];\n    }\n}"
      }
    },
    "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.",
    "relatedProblems": [
      "binary-tree-level-order-traversal",
      "binary-tree-right-side-view",
      "simplify-path"
    ]
  },
  "valid-parenthesis-string": {
    "id": "valid-parenthesis-string",
    "slug": "valid-parenthesis-string",
    "title": "Valid Parenthesis String",
    "difficulty": "Medium",
    "category": "Greedy",
    "problemStatement": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:",
    "videoUrl": "",
    "pattern": "Greedy with Range Tracking",
    "patternEmoji": "\ud83d\udcca",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Track possible open parenthesis counts with min/max bounds.",
    "intuition": [
      "We can't know what '*' will be, so track all possible open counts",
      "Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid."
    ],
    "visualizationType": "array",
    "initialState": [
      "(",
      "*",
      ")",
      "("
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Valid Parenthesis String",
        "transientMessage": "Starting algorithm",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Initialize variables",
        "transientMessage": "Set up pointers and counters",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Process arr[0] = (",
        "transientMessage": "Iteration 1",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [
          {
            "label": "i",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Process arr[1] = *",
        "transientMessage": "Iteration 2",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          1
        ],
        "color": "success"
      },
      {
        "step": 5,
        "visual": "Process arr[2] = )",
        "transientMessage": "Iteration 3",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [
          {
            "label": "i",
            "index": 2
          }
        ],
        "indices": [
          2
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Process arr[3] = (",
        "transientMessage": "Iteration 4",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [
          {
            "label": "i",
            "index": 3
          }
        ],
        "indices": [
          3
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Update state",
        "transientMessage": "Applying changes",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 8,
        "visual": "Finalize result",
        "transientMessage": "Computing final answer",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 9,
        "visual": "Algorithm complete",
        "transientMessage": "Result ready!",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "Finalize and return",
        "transientMessage": "Algorithm complete!",
        "arrayState": [
          "(",
          "*",
          ")",
          "("
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def checkValidString(self, s):\n        \"\"\"\n        Intuition:\n        - We can't know what '*' will be, so track all possible open counts\n        - Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid.\n        \"\"\"\n        min_open = max_open = 0\n        for char in s:  # Iterate over elements.\n            if char == '(':\n                min_open += 1\n                max_open += 1\n            elif char == ')':\n                min_open = max(min_open - 1, 0)  # Take the maximum value.\n                max_open -= 1\n            else:  # char == '*'\n                min_open = max(min_open - 1, 0)  # Take the maximum value.\n                max_open += 1\n            if max_open < 0:\n                return False  # Condition not met.\n        return min_open == 0",
    "keyInsight": "We track the range of possible open parenthesis counts instead of exact values.",
    "testCases": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"(*)\"",
        "output": "true"
      },
      {
        "input": "s = \"(*))\"",
        "output": "true"
      }
    ],
    "walkthrough": [
      "Understand the problem constraints",
      "Identify the optimal approach",
      "Implement the solution step by step",
      "Handle edge cases",
      "Return the result"
    ],
    "hints": [
      "\ud83e\udde0 Analyze the problem constraints",
      "\ud83d\udca1 Consider the most efficient approach",
      "\ud83d\udd0d Handle edge cases carefully"
    ],
    "approach": "Greedy with Range Tracking: Track possible open parenthesis counts with min/max bounds.",
    "videoId": "QhPdNS143Qg",
    "suggestedNextQuestion": {
      "slug": "candy",
      "title": "Candy",
      "difficulty": "Hard",
      "pattern": "Greedy"
    },
    "mentalModel": "Like a cashier making change. Always pick the biggest coin that fits, hoping it leads to the fewest coins total.",
    "initialCode": "class Solution:\n    def checkValidString(self, s):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or worse",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Explore all possibilities without optimization.",
          "Use nested loops or recursion."
        ],
        "code": "def checkValidString(s):\n    # Greedy with range\n    low, high = 0, 0\n    for c in s:\n        low += 1 if c == '(' else -1\n        high += 1 if c != ')' else -1\n        if high < 0: return False\n        low = max(low, 0)\n    return low == 0"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "We can't know what '*' will be, so track all possible open counts",
          "Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid."
        ],
        "code": "def checkValidString(s):\n    \"\"\"\n    Intuition:\n    - We can't know what '*' will be, so track all possible open counts\n    - Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid.\n    \"\"\"\n    min_open = max_open = 0\n    for char in s:  # Iterate over elements.\n        if char == '(':\n            min_open += 1\n            max_open += 1\n        elif char == ')':\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open -= 1\n        else:  # char == '*'\n            min_open = max(min_open - 1, 0)  # Take the maximum value.\n            max_open += 1\n        if max_open < 0:\n            return False  # Condition not met.\n    return min_open == 0"
      }
    ],
    "examples": [
      {
        "input": "Example input",
        "output": "Expected output",
        "explanation": "Basic case."
      },
      {
        "input": "Edge case input",
        "output": "Edge output",
        "explanation": "Handles edge cases."
      }
    ],
    "constraints": [
      "1 <= n <= 10^4",
      "Valid input guaranteed"
    ],
    "commonMistakes": [
      "Not handling edge cases (empty input, single element)",
      "Integer overflow for large inputs",
      "Time limit exceeded due to inefficient approach"
    ],
    "interviewTip": "Discuss time/space complexity. Handle edge cases explicitly.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    checkValidString(s) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s\n     * @return {any}\n     */\n    checkValidString(s) {\n        let result = 0;\n        let offset = 0;\n\n        for (const character of s) {\n          result += character === '(' ? 1 : -1;\n          offset += character !== ')' ? 1 : -1;\n          if (offset < 0) return false;\n          result = Math.max(0, result);\n      }\n\n    return !result;\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean checkValidString(String s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean checkValidString(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = s.charAt(i) == '*';\n        }\n        for (int i = n - 2; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                char a = s.charAt(i), b = s.charAt(j);\n                dp[i][j] = (a == '(' || a == '*') && (b == '*' || b == ')')\n                    && (i + 1 == j || dp[i + 1][j - 1]);\n                for (int k = i; k < j && !dp[i][j]; ++k) {\n                    dp[i][j] = dp[i][k] && dp[k + 1][j];\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool checkValidString(string s) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool checkValidString(string s) {\n        int n = s.size();\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = s[i] == '*';\n        }\n        for (int i = n - 2; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                char a = s[i], b = s[j];\n                dp[i][j] = (a == '(' || a == '*') && (b == '*' || b == ')') && (i + 1 == j || dp[i + 1][j - 1]);\n                for (int k = i; k < j && !dp[i][j]; ++k) {\n                    dp[i][j] = dp[i][k] && dp[k + 1][j];\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) checkValidString(s string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) checkValidString(s string) bool {\n\tn := len(s)\n\tdp := make([][]bool, n)\n\tfor i := range dp {\n\t\tdp[i] = make([]bool, n)\n\t\tdp[i][i] = s[i] == '*'\n\t}\n\tfor i := n - 2; i >= 0; i-- {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\ta, b := s[i], s[j]\n\t\t\tdp[i][j] = (a == '(' || a == '*') && (b == '*' || b == ')') && (i+1 == j || dp[i+1][j-1])\n\t\t\tfor k := i; k < j && !dp[i][j]; k++ {\n\t\t\t\tdp[i][j] = dp[i][k] && dp[k+1][j]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[0][n-1]\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn check_valid_string(s: i32) -> i32 {\n        // Your code here\n        0\n    }\n}",
        "code": "struct Solution;\n\nimpl Solution {\n    fn check_valid_string(s: String) -> bool {\n        let mut lo = 0;\n        let mut hi = 0;\n        for c in s.chars() {\n            match c {\n                '(' => {\n                    lo += 1;\n                    hi += 1;\n                }\n                ')' => {\n                    lo = 0.max(lo - 1);\n                    hi -= 1;\n                }\n                _ => {\n                    lo = 0.max(lo - 1);\n                    hi += 1;\n                }\n            }\n            if hi < 0 {\n                return false;\n            }\n        }\n        lo == 0\n    }\n}\n\n#[test]\nfn test() {\n    let s = \"()\".to_string();\n    let res = true;\n    assert_eq!(Solution::check_valid_string(s), res);\n    let s = \"(*)\".to_string();\n    let res = true;\n    assert_eq!(Solution::check_valid_string(s), res);\n    let s = \"(*))\".to_string();\n    let res = true;\n    assert_eq!(Solution::check_valid_string(s), res);\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def checkValidString(self, s):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    checkValidString(s: any): any  {\n    // Your code here\n};\n}",
        "initialCode": "class Solution {\n    checkValidString(s: any): any {\n        // Your code here\n        return;\n    }\n}"
      }
    },
    "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:",
    "relatedProblems": [
      "maximum-sum-circular-subarray",
      "integer-replacement",
      "snakes-and-ladders"
    ]
  },
  "permutation-in-string": {
    "id": "permutation-in-string",
    "slug": "permutation-in-string",
    "title": "Permutation in String",
    "difficulty": "Medium",
    "category": "Sliding Window",
    "problemStatement": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.",
    "videoUrl": "",
    "pattern": "Sliding Window",
    "patternEmoji": "\ud83e\ude9f",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "oneliner": "Use sliding window with character frequency matching.",
    "intuition": [
      "A permutation means same characters with same frequencies",
      "Use a window of s1's length and slide it through s2"
    ],
    "visualizationType": "array",
    "initialState": [
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g"
    ],
    "animationSteps": [
      {
        "step": 1,
        "visual": "Problem: Permutation in String",
        "transientMessage": "Backtracking approach",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 2,
        "visual": "Start with empty path",
        "transientMessage": "Path: []",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [],
        "indices": [],
        "color": "accent"
      },
      {
        "step": 3,
        "visual": "Try first choice",
        "transientMessage": "Add a to path",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 0
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 4,
        "visual": "Recurse deeper",
        "transientMessage": "Path: [a]",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [
          {
            "label": "i",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 5,
        "visual": "Try second choice",
        "transientMessage": "Add b to path",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 1
          }
        ],
        "indices": [
          0,
          1
        ],
        "color": "accent"
      },
      {
        "step": 6,
        "visual": "Found valid solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [],
        "indices": [
          0,
          1,
          2
        ],
        "color": "success"
      },
      {
        "step": 7,
        "visual": "Backtrack",
        "transientMessage": "Remove last choice",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [
          {
            "label": "back",
            "index": 1
          }
        ],
        "indices": [
          0
        ],
        "color": "accent"
      },
      {
        "step": 8,
        "visual": "Try alternative",
        "transientMessage": "Try c instead",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [
          {
            "label": "try",
            "index": 2
          }
        ],
        "indices": [
          0,
          2
        ],
        "color": "accent"
      },
      {
        "step": 9,
        "visual": "Found another solution!",
        "transientMessage": "Save to results",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [],
        "indices": [
          0,
          2
        ],
        "color": "success"
      },
      {
        "step": 10,
        "visual": "All solutions found",
        "transientMessage": "Complete!",
        "arrayState": [
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g"
        ],
        "pointers": [],
        "indices": [],
        "color": "success"
      }
    ],
    "code": "class Solution:\n    def checkInclusion(self, s1, s2):\n        \"\"\"\n        Intuition:\n        - A permutation means same characters with same frequencies\n        - Use a window of s1's length and slide it through s2\n        \"\"\"\n        if len(s1) > len(s2):\n            return False  # Condition not met.\n\n        s1_count = [0] * 26\n        window_count = [0] * 26\n\n        # Count characters in s1\n        for char in s1:  # Iterate over elements.\n            s1_count[ord(char) - ord('a')] += 1\n\n        # Initialize window\n        for i in range(len(s1)):  # Iterate through the range.\n            window_count[ord(s2[i]) - ord('a')] += 1\n\n        if s1_count == window_count:\n            return True  # Condition satisfied.\n\n        # Slide window\n        for i in range(len(s1), len(s2)):  # Iterate through the range.\n            # Add new character\n            window_count[ord(s2[i]) - ord('a')] += 1\n            # Remove old character\n            window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n\n            if s1_count == window_count:\n                return True  # Condition satisfied.\n\n        return False  # Condition not met.",
    "keyInsight": "Permutations have identical character counts - compare frequency arrays.",
    "testCases": [
      {
        "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
        "output": "true"
      },
      {
        "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
        "output": "false"
      }
    ],
    "walkthrough": [
      "Initialize window boundaries (left, right)",
      "Expand window by moving right pointer",
      "Update window state with new element",
      "Shrink window when condition violated",
      "Track optimal result throughout"
    ],
    "hints": [
      "\ud83e\udde0 What defines a valid window?",
      "\ud83d\udca1 When should you expand vs shrink?",
      "\ud83d\udd0d Track window state efficiently"
    ],
    "approach": "Sliding Window: Use sliding window with character frequency matching.",
    "videoId": "UbyhOgBN834",
    "suggestedNextQuestion": {
      "slug": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "pattern": "Sliding Window"
    },
    "mentalModel": "Imagine a caterpillar crawling along a branch. It extends its head (right pointer) to eat leaves (add elements), and pulls its tail (left pointer) to digest (remove elements).",
    "initialCode": "class Solution:\n    def checkInclusion(self, s1, s2):\n        pass\n",
    "approaches": [
      {
        "name": "bruteforce",
        "label": "Brute Force",
        "timeComplexity": "O(n\u00b2) or O(n\u00b3)",
        "spaceComplexity": "O(n)",
        "intuition": [
          "Generate all possible substrings/subarrays.",
          "Check each one for the required condition."
        ],
        "code": "def checkInclusion_brute(s):\n    # Try all substrings\n    n = len(s)\n    result = 0\n    for i in range(n):\n        for j in range(i, n):\n            # Check substring s[i:j+1]\n            pass\n    return result"
      },
      {
        "name": "optimal",
        "label": "Optimal",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "intuition": [
          "A permutation means same characters with same frequencies",
          "Use a window of s1's length and slide it through s2"
        ],
        "code": "def checkInclusion(s1, s2):\n    \"\"\"\n    Intuition:\n    - A permutation means same characters with same frequencies\n    - Use a window of s1's length and slide it through s2\n    \"\"\"\n    if len(s1) > len(s2):\n        return False  # Condition not met.\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:  # Iterate over elements.\n        s1_count[ord(char) - ord('a')] += 1\n    \n    # Initialize window\n    for i in range(len(s1)):  # Iterate through the range.\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == window_count:\n        return True  # Condition satisfied.\n    \n    # Slide window\n    for i in range(len(s1), len(s2)):  # Iterate through the range.\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        # Remove old character\n        window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == window_count:\n            return True  # Condition satisfied.\n    \n    return False  # Condition not met."
      }
    ],
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "Sliding window expands until duplicate, then shrinks."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "All same characters."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s consists of printable ASCII characters"
    ],
    "commonMistakes": [
      "Not updating the window properly when shrinking",
      "Forgetting to reset window state",
      "Edge case: window larger than input"
    ],
    "interviewTip": "Explain window expansion/contraction. Handle 'exactly k' vs 'at most k'.",
    "implementations": {
      "javascript": {
        "initialCode": "class Solution {\n    checkInclusion(s1, s2) {\n        // Your code here\n        return;\n    }\n}",
        "code": "class Solution {\n    /**\n     * @param {any} s1, s2\n     * @return {any}\n     */\n    checkInclusion(s1, s2) {\n        const getCharCode = c => c.charCodeAt() - 'a'.charCodeAt();\n        const isMatch = (a1, a2) => a1.every((n, i) => a2[i] === n);\n\n        if (s1.length > s2.length) {\n          return false;\n        }\n\n        const map1 = new Array(26).fill(0);\n        const map2 = new Array(26).fill(0);\n        for (let i = 0; i < s1.length; i++) {\n          map1[getCharCode(s1[i])]++;\n          map2[getCharCode(s2[i])]++;\n        }\n\n        for (let i = 0; i < s2.length - s1.length; i++) {\n          if (isMatch(map1, map2)) return true;\n          map2[getCharCode(s2[i + s1.length])]++;\n          map2[getCharCode(s2[i])]--;\n      }\n\n    return isMatch(map1, map2);\n    }\n}"
      },
      "java": {
        "initialCode": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        int need = 0;\n        int[] cnt = new int[26];\n        for (char c : s1.toCharArray()) {\n            if (++cnt[c - 'a'] == 1) {\n                ++need;\n            }\n        }\n        int m = s1.length(), n = s2.length();\n        for (int i = 0; i < n; ++i) {\n            int c = s2.charAt(i) - 'a';\n            if (--cnt[c] == 0) {\n                --need;\n            }\n            if (i >= m) {\n                c = s2.charAt(i - m) - 'a';\n                if (++cnt[c] == 1) {\n                    ++need;\n                }\n            }\n            if (need == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
      },
      "cpp": {
        "initialCode": "class Solution {\n    bool checkInclusion(string s1, string s2) {\n        // Your code here\n        return \"\";\n    }\n}",
        "code": "class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        int need = 0;\n        int cnt[26]{};\n        for (char c : s1) {\n            if (++cnt[c - 'a'] == 1) {\n                ++need;\n            }\n        }\n        int m = s1.size(), n = s2.size();\n        for (int i = 0; i < n; ++i) {\n            int c = s2[i] - 'a';\n            if (--cnt[c] == 0) {\n                --need;\n            }\n            if (i >= m) {\n                c = s2[i - m] - 'a';\n                if (++cnt[c] == 1) {\n                    ++need;\n                }\n            }\n            if (need == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n};"
      },
      "go": {
        "initialCode": "type Solution struct {}\n\nfunc (s *Solution) checkInclusion(s1 string, s2 string) bool {\n    // Your code here\n    return\n}",
        "code": "type Solution struct {}\n\nfunc (s *Solution) checkInclusion(s1 string, s2 string) bool {\n\tneed := 0\n\tcnt := [26]int{}\n\n\tfor _, c := range s1 {\n\t\tif cnt[c-'a']++; cnt[c-'a'] == 1 {\n\t\t\tneed++\n\t\t}\n\t}\n\n\tm, n := len(s1), len(s2)\n\tfor i := 0; i < n; i++ {\n\t\tc := s2[i] - 'a'\n\t\tif cnt[c]--; cnt[c] == 0 {\n\t\t\tneed--\n\t\t}\n\t\tif i >= m {\n\t\t\tc = s2[i-m] - 'a'\n\t\t\tif cnt[c]++; cnt[c] == 1 {\n\t\t\t\tneed++\n\t\t\t}\n\t\t}\n\t\tif need == 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}"
      },
      "rust": {
        "initialCode": "impl Solution {\n    pub fn check_inclusion(s1: String, s2: String) -> bool {\n        // Your code here\n        Default::default()\n    }\n}",
        "code": "impl Solution {\n    pub fn check_inclusion(s1: String, s2: String) -> bool {\n        let mut need = 0;\n        let mut cnt = vec![0; 26];\n\n        for c in s1.chars() {\n            let index = (c as u8 - b'a') as usize;\n            if cnt[index] == 0 {\n                need += 1;\n            }\n            cnt[index] += 1;\n        }\n\n        let m = s1.len();\n        let n = s2.len();\n        let s2_bytes = s2.as_bytes();\n\n        for i in 0..n {\n            let c = (s2_bytes[i] - b'a') as usize;\n            cnt[c] -= 1;\n            if cnt[c] == 0 {\n                need -= 1;\n            }\n\n            if i >= m {\n                let c = (s2_bytes[i - m] - b'a') as usize;\n                cnt[c] += 1;\n                if cnt[c] == 1 {\n                    need += 1;\n                }\n            }\n\n            if need == 0 {\n                return true;\n            }\n        }\n\n        false\n    }\n}"
      },
      "python": {
        "initialCode": "class Solution:\n    def checkInclusion(self, s1, s2):\n        pass\n"
      },
      "typescript": {
        "code": "class Solution {\n    checkInclusion(s1: string, s2: string): boolean  {\n    let need = 0;\n    const cnt: number[] = Array(26).fill(0);\n    const a = 'a'.charCodeAt(0);\n    for (const c of s1) {\n        if (++cnt[c.charCodeAt(0) - a] === 1) {\n            need++;\n        }\n    }\n\n    const [m, n] = [s1.length, s2.length];\n    for (let i = 0; i < n; i++) {\n        let c = s2.charCodeAt(i) - a;\n        if (--cnt[c] === 0) {\n            need--;\n        }\n        if (i >= m) {\n            c = s2.charCodeAt(i - m) - a;\n            if (++cnt[c] === 1) {\n                need++;\n            }\n        }\n        if (need === 0) {\n            return true;\n        }\n    }\n    return false;\n}\n}",
        "initialCode": "class Solution {\n    checkInclusion(s1: string, s2: string): boolean {\n        // Your code here\n        return \"\";\n    }\n}"
      }
    },
    "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.",
    "relatedProblems": [
      "minimum-size-subarray-sum",
      "longest-repeating-character-replacement"
    ]
  }
}