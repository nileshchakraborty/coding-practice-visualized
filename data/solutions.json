{
    "solutions": {
        "triangle": {
            "title": "Triangle",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcc9",
            "timeComplexity": "O(n^2)",
            "spaceComplexity": "O(n)",
            "oneliner": "Compute min path sum from bottom to top to avoid greedy traps!",
            "intuition": [
                "\ud83d\udd3a Greedy doesn't work! Local min \u2260 Global min",
                "\ud83e\udde0 Subproblem: Min path from cell (i, j) to bottom",
                "\ud83d\udca1 dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])"
            ],
            "testCases": [
                {
                    "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11"
                },
                {
                    "input": "triangle = [[-10]]",
                    "output": "-10"
                }
            ],
            "code": "def minimumTotal(triangle):\n    dp = triangle[-1][:]\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(i + 1):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n    return dp[0]",
            "keyInsight": "Bottom-up DP simplifies boundary conditions and reuses space.",
            "description": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.",
            "examples": [
                {
                    "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11",
                    "explanation": "Path 2 -> 3 -> 5 -> 1 = 11."
                },
                {
                    "input": "triangle = [[-10]]",
                    "output": "-10",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= triangle.length <= 200",
                "triangle[0].length == 1",
                "triangle[i].length == triangle[i - 1].length + 1",
                "-10^4 <= triangle[i][j] <= 10^4"
            ],
            "hints": [
                "Use DP from bottom to top.",
                "dp[i] = triangle[row][i] + min(dp[i], dp[i+1]).",
                "Space optimization: reuse same array."
            ],
            "relatedProblems": [
                "minimum-path-sum",
                "dungeon-game"
            ],
            "videoId": "OM1MTokvxs4",
            "problemStatement": "Given a triangle array, return the minimum path sum from top to bottom.\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "best-time-to-buy-and-sell-stock": {
            "title": "Best Time to Buy and Sell Stock",
            "pattern": "Track Minimum",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track the minimum price seen so far, maximize profit at each step!",
            "intuition": [
                "\ud83c\udfaf Buy LOW, Sell HIGH",
                "\ud83e\udde0 Keep track of the cheapest day to buy",
                "\ud83d\udca1 At each day, calculate: what if I sold today?"
            ],
            "testCases": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "5"
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize Trackers",
                    "visual": "min_price = \u221e\nmax_profit = 0",
                    "explanation": "Start with infinity as min (first price will always be lower)"
                },
                {
                    "step": 2,
                    "title": "Walk Through Prices",
                    "visual": "prices: [7, 1, 5, 3, 6, 4]\n         \u2191\n       Day 1: price = 7",
                    "explanation": "Visit each day's price"
                },
                {
                    "step": 3,
                    "title": "Update Minimum",
                    "visual": "Day 1: min = min(\u221e, 7) = 7\nDay 2: min = min(7, 1) = 1 \u2b50 NEW LOW!",
                    "explanation": "Always track the best buying opportunity"
                },
                {
                    "step": 4,
                    "title": "Calculate Profit",
                    "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 \ud83d\udcb0\n        max_profit = 5",
                    "explanation": "At each step: profit = today - min_so_far"
                }
            ],
            "code": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit",
            "keyInsight": "One pass solution - no need to compare every pair!",
            "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
            "examples": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "5",
                    "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0",
                    "explanation": "No profitable transaction possible."
                }
            ],
            "constraints": [
                "1 <= prices.length <= 10^5",
                "0 <= prices[i] <= 10^4"
            ],
            "hints": [
                "Track the minimum price seen so far.",
                "At each day, calculate potential profit if you sold today.",
                "Keep track of the maximum profit seen."
            ],
            "relatedProblems": [
                "best-time-to-buy-and-sell-stock-ii",
                "best-time-to-buy-and-sell-stock-iii",
                "maximum-subarray"
            ],
            "videoId": "1pkOgXD63yU",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Initialize Trackers",
                    "visual": "min_price = \u221e\nmax_profit = 0",
                    "explanation": "Start with infinity as min (first price will always be lower)"
                },
                {
                    "step": 2,
                    "title": "Walk Through Prices",
                    "visual": "prices: [7, 1, 5, 3, 6, 4]\n         \u2191\n       Day 1: price = 7",
                    "explanation": "Visit each day's price"
                },
                {
                    "step": 3,
                    "title": "Update Minimum",
                    "visual": "Day 1: min = min(\u221e, 7) = 7\nDay 2: min = min(7, 1) = 1 \u2b50 NEW LOW!",
                    "explanation": "Always track the best buying opportunity"
                },
                {
                    "step": 4,
                    "title": "Calculate Profit",
                    "visual": "Day 5: price = 6\n        profit = 6 - 1 = 5 \ud83d\udcb0\n        max_profit = 5",
                    "explanation": "At each step: profit = today - min_so_far"
                }
            ],
            "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "valid-palindrome": {
            "title": "Valid Palindrome",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers from both ends, skip non-alphanumeric!",
            "intuition": [
                "\ud83c\udfaf Palindrome reads same forwards & backwards",
                "\ud83e\udde0 Compare characters from outside \u2192 inside",
                "\ud83d\udca1 Skip spaces and punctuation!"
            ],
            "testCases": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "true"
                },
                {
                    "input": "s = \"race a car\"",
                    "output": "false"
                },
                {
                    "input": "s = \" \"",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up Pointers",
                    "visual": "\"A man, a plan, a canal: Panama\"\n \u2191                              \u2191\nleft                          right",
                    "explanation": "Start from both ends of the string"
                },
                {
                    "step": 2,
                    "title": "Skip Non-Letters",
                    "visual": "\"...canal: Panama\"\n         \u2191      \u2191\n     skip ':'  'a'",
                    "explanation": "Move pointer if not alphanumeric"
                },
                {
                    "step": 3,
                    "title": "Compare (Case-Insensitive)",
                    "visual": "'A' == 'a' \u2705 (lowercase both)\n'M' == 'm' \u2705\n'N' == 'n' \u2705",
                    "explanation": "Convert to lowercase and compare"
                },
                {
                    "step": 4,
                    "title": "Move Inward",
                    "visual": "left \u2192 \u2190     \u2192 \u2190 right\n      Meet in middle = VALID!",
                    "explanation": "Continue until pointers cross"
                }
            ],
            "code": "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True",
            "keyInsight": "Two pointers = no extra space needed for reversed string!",
            "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.",
            "examples": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "true",
                    "explanation": "After filtering: 'amanaplanacanalpanama' is a palindrome."
                },
                {
                    "input": "s = \"race a car\"",
                    "output": "false",
                    "explanation": "After filtering: 'raceacar' is not a palindrome."
                }
            ],
            "constraints": [
                "1 <= s.length <= 2 * 10^5",
                "s consists only of printable ASCII characters."
            ],
            "hints": [
                "Use two pointers from both ends.",
                "Skip non-alphanumeric characters.",
                "Compare characters (case-insensitive)."
            ],
            "relatedProblems": [
                "valid-palindrome-ii",
                "palindrome-linked-list",
                "longest-palindromic-substring"
            ],
            "videoId": "jJXJ16kPFWg",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Set Up Pointers",
                    "visual": "\"A man, a plan, a canal: Panama\"\n \u2191                              \u2191\nleft                          right",
                    "explanation": "Start from both ends of the string"
                },
                {
                    "step": 2,
                    "title": "Skip Non-Letters",
                    "visual": "\"...canal: Panama\"\n         \u2191      \u2191\n     skip ':'  'a'",
                    "explanation": "Move pointer if not alphanumeric"
                },
                {
                    "step": 3,
                    "title": "Compare (Case-Insensitive)",
                    "visual": "'A' == 'a' \u2705 (lowercase both)\n'M' == 'm' \u2705\n'N' == 'n' \u2705",
                    "explanation": "Convert to lowercase and compare"
                },
                {
                    "step": 4,
                    "title": "Move Inward",
                    "visual": "left \u2192 \u2190     \u2192 \u2190 right\n      Meet in middle = VALID!",
                    "explanation": "Continue until pointers cross"
                }
            ],
            "problemStatement": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "merge-sorted-array": {
            "title": "Merge Sorted Array",
            "pattern": "Three Pointers (Reverse)",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(m + n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Fill from the END to avoid overwriting!",
            "intuition": [
                "\ud83c\udfaf Can't start from front - would overwrite nums1!",
                "\ud83e\udde0 Start from back - empty space is there for us!",
                "\ud83d\udca1 Three pointers: end of nums1, end of nums2, write position"
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                    "output": "[1,2,2,3,5,6]"
                },
                {
                    "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                    "output": "[1]"
                },
                {
                    "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
                    "output": "[1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Up 3 Pointers",
                    "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            \u2191     \u2191              \u2191\n           p1    write           p2",
                    "explanation": "p1 at last real element, p2 at end of nums2, write at end"
                },
                {
                    "step": 2,
                    "title": "Compare & Place Larger",
                    "visual": "3 vs 6 \u2192 6 wins!\n[1,2,3,0,0,6] \u2190 place 6",
                    "explanation": "Bigger goes to write position"
                },
                {
                    "step": 3,
                    "title": "Move Pointers",
                    "visual": "[1,2,3,0,0,6]\n            \u2191 \u2191\n           p1 write\n           \u2190 moved left",
                    "explanation": "Decrement write and the pointer that was used"
                },
                {
                    "step": 4,
                    "title": "Continue Until Done",
                    "visual": "Result: [1,2,2,3,5,6] \u2705",
                    "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
                }
            ],
            "code": "def merge(nums1, m, nums2, n):\n    p1, p2 = m - 1, n - 1\n    write = m + n - 1\n    \n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[write] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[write] = nums2[p2]\n            p2 -= 1\n        write -= 1\n    return nums1",
            "keyInsight": "Reverse iteration = in-place without overwriting!",
            "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.",
            "examples": [
                {
                    "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                    "output": "[1,2,2,3,5,6]",
                    "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]."
                },
                {
                    "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
                    "output": "[1]",
                    "explanation": "No elements to merge from nums2."
                }
            ],
            "constraints": [
                "nums1.length == m + n",
                "nums2.length == n",
                "0 <= m, n <= 200",
                "1 <= m + n <= 200",
                "-10^9 <= nums1[i], nums2[j] <= 10^9"
            ],
            "hints": [
                "Start from the end of both arrays and work backwards.",
                "Compare elements from the end and place the larger one at the back of nums1.",
                "This avoids overwriting elements we haven't processed yet."
            ],
            "relatedProblems": [
                "merge-two-sorted-lists",
                "sort-an-array",
                "squares-of-a-sorted-array"
            ],
            "videoId": "P1Ic85RarKY",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Set Up 3 Pointers",
                    "visual": "nums1: [1,2,3,0,0,0]  nums2: [2,5,6]\n            \u2191     \u2191              \u2191\n           p1    write           p2",
                    "explanation": "p1 at last real element, p2 at end of nums2, write at end"
                },
                {
                    "step": 2,
                    "title": "Compare & Place Larger",
                    "visual": "3 vs 6 \u2192 6 wins!\n[1,2,3,0,0,6] \u2190 place 6",
                    "explanation": "Bigger goes to write position"
                },
                {
                    "step": 3,
                    "title": "Move Pointers",
                    "visual": "[1,2,3,0,0,6]\n            \u2191 \u2191\n           p1 write\n           \u2190 moved left",
                    "explanation": "Decrement write and the pointer that was used"
                },
                {
                    "step": 4,
                    "title": "Continue Until Done",
                    "visual": "Result: [1,2,2,3,5,6] \u2705",
                    "explanation": "If nums2 remaining, copy them. nums1 remaining? Already in place!"
                }
            ],
            "problemStatement": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you come up with an algorithm that runs in O(m + n) time?",
            "difficulty": "Easy"
        },
        "valid-parentheses": {
            "title": "Valid Parentheses",
            "pattern": "Stack",
            "patternEmoji": "(\ufe0f)\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push open brackets; pop and match close brackets.",
            "intuition": [
                "\ud83c\udfaf Last Opened must be First Closed (LIFO).",
                "\ud83e\udde0 Stack tracks open brackets.",
                "\ud83d\udca1 Mismatch or empty stack on close? Invalid."
            ],
            "testCases": [
                {
                    "input": "s = \"()\"",
                    "output": "true"
                },
                {
                    "input": "s = \"()[]{}\"",
                    "output": "true"
                },
                {
                    "input": "s = \"(]\"",
                    "output": "false"
                },
                {
                    "input": "s = \"([])\"",
                    "output": "true"
                },
                {
                    "input": "s = \"([)]\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Open",
                    "visual": "Push '(', '[', '{'.",
                    "explanation": "Await closing."
                },
                {
                    "step": 2,
                    "title": "Close",
                    "visual": "Pop top. Matches current? () [] {}",
                    "explanation": "Verify pairing."
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Stack empty? Valid.",
                    "explanation": "No unclosed brackets left."
                }
            ],
            "code": "def isValid(s):\n    stack = []\n    closeToOpen = {')': '(', ']': '[', '}': '{'}\n    for c in s:\n        if c in closeToOpen:\n            if stack and stack[-1] == closeToOpen[c]:\n                stack.pop()\n            else:\n                return False\n        else:\n            stack.append(c)\n    return not stack",
            "keyInsight": "Map only the closing brackets allows clean logic: \"Is it a closer? Check stack. Else, it must be an opener.\"",
            "visualizationType": "string",
            "initialState": "()[]{}",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Open",
                    "visual": "Push '(', '[', '{'.",
                    "explanation": "Await closing."
                },
                {
                    "step": 2,
                    "title": "Close",
                    "visual": "Pop top. Matches current? () [] {}",
                    "explanation": "Verify pairing."
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Stack empty? Valid.",
                    "explanation": "No unclosed brackets left."
                }
            ],
            "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
                {
                    "input": "s = \"()\"",
                    "output": "true",
                    "explanation": "Simple pair of matching parentheses."
                },
                {
                    "input": "s = \"()[]{}\"",
                    "output": "true",
                    "explanation": "Multiple types of matching brackets."
                },
                {
                    "input": "s = \"(]\"",
                    "output": "false",
                    "explanation": "Mismatched bracket types."
                }
            ],
            "constraints": [
                "1 <= s.length <= 10^4",
                "s consists of parentheses only '()[]{}'."
            ],
            "hints": [
                "Use a stack to track opening brackets.",
                "When you see a closing bracket, check if it matches the top of the stack.",
                "At the end, the stack should be empty."
            ],
            "relatedProblems": [
                "generate-parentheses",
                "longest-valid-parentheses",
                "remove-invalid-parentheses"
            ],
            "videoId": "WTzjTskDFMg",
            "problemStatement": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
            "difficulty": "Easy"
        },
        "maximum-subarray": {
            "title": "Maximum Subarray",
            "pattern": "Kadane's Algorithm",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Extend current sum OR start fresh - pick the better option!",
            "intuition": [
                "\ud83c\udfaf At each position: should I continue or restart?",
                "\ud83e\udde0 If current_sum < 0, better to start fresh!",
                "\ud83d\udca1 Track both current sum and overall maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6"
                },
                {
                    "input": "nums = [1]",
                    "output": "1"
                },
                {
                    "input": "nums = [5,4,-1,7,8]",
                    "output": "23"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
                    "explanation": "Start with first element as both"
                },
                {
                    "step": 2,
                    "title": "The Key Decision",
                    "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         \u2191\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 \u2190 WINNER!",
                    "explanation": "current_sum = max(num, current_sum + num)"
                },
                {
                    "step": 3,
                    "title": "Update Maximum",
                    "visual": "current: 1 \u2192 -2 \u2192 4 \u2192 3 \u2192 5 \u2192 6 \u2192 1 \u2192 5\n                   \u2191           \u2191\n                 reset       max=6!",
                    "explanation": "max_sum = max(max_sum, current_sum)"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "[4,-1,2,1] = 6 \u2705\n \u2191 max subarray",
                    "explanation": "Return max_sum"
                }
            ],
            "code": "def maxSubArray(nums):\n    current_sum = nums[0]\n    max_sum = nums[0]\n    \n    for num in nums[1:]:\n        # Either extend current subarray or start new\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum",
            "keyInsight": "The magic: negative prefix sum is never worth keeping!",
            "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
            "examples": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6",
                    "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
                },
                {
                    "input": "nums = [1]",
                    "output": "1",
                    "explanation": "Single element is the maximum."
                },
                {
                    "input": "nums = [5,4,-1,7,8]",
                    "output": "23",
                    "explanation": "The entire array has the largest sum."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4"
            ],
            "hints": [
                "Use Kadane's algorithm.",
                "At each position, decide: extend current subarray or start fresh.",
                "current_sum = max(nums[i], current_sum + nums[i])"
            ],
            "relatedProblems": [
                "maximum-product-subarray",
                "best-time-to-buy-and-sell-stock",
                "maximum-sum-circular-subarray"
            ],
            "videoId": "5WZl3MMT0Eg",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "current_sum = nums[0]\nmax_sum = nums[0]",
                    "explanation": "Start with first element as both"
                },
                {
                    "step": 2,
                    "title": "The Key Decision",
                    "visual": "[-2,1,-3,4,-1,2,1,-5,4]\n         \u2191\ncurrent = -2 + 1 = -1\n   OR\nstart fresh = 1 \u2190 WINNER!",
                    "explanation": "current_sum = max(num, current_sum + num)"
                },
                {
                    "step": 3,
                    "title": "Update Maximum",
                    "visual": "current: 1 \u2192 -2 \u2192 4 \u2192 3 \u2192 5 \u2192 6 \u2192 1 \u2192 5\n                   \u2191           \u2191\n                 reset       max=6!",
                    "explanation": "max_sum = max(max_sum, current_sum)"
                },
                {
                    "step": 4,
                    "title": "Result",
                    "visual": "[4,-1,2,1] = 6 \u2705\n \u2191 max subarray",
                    "explanation": "Return max_sum"
                }
            ],
            "problemStatement": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
            "difficulty": "Medium"
        },
        "climbing-stairs": {
            "title": "Climbing Stairs",
            "pattern": "DP (Fibonacci)",
            "patternEmoji": "\ud83e\uddb7",
            "timeComplexity": "O(N)",
            "spaceComplexity": "O(1)",
            "oneliner": "ways(i) = ways(i-1) + ways(i-2). It's just Fibonacci.",
            "intuition": [
                "\ud83c\udfaf To reach Step N, I must have come from N-1 or N-2.",
                "\ud83e\udde0 Count(N) = Count(N-1) + Count(N-2).",
                "\ud83d\udca1 Use two variables to store previous results."
            ],
            "testCases": [
                {
                    "input": "n = 2",
                    "output": "2"
                },
                {
                    "input": "n = 3",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "one, two = 1, 1",
                    "explanation": "Base cases."
                },
                {
                    "step": 2,
                    "title": "Loop",
                    "visual": "temp=one. one=one+two. two=temp.",
                    "explanation": "Shift."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "return one.",
                    "explanation": "Result."
                }
            ],
            "code": "def climbStairs(n):\n    one, two = 1, 1\n    for i in range(n - 1):\n        temp = one\n        one = one + two\n        two = temp\n    return one",
            "keyInsight": "Notice the subproblem structure overlap. Memorization or Iterative DP solves it efficiently.",
            "visualizationType": "array",
            "initialState": [
                1,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "one, two = 1, 1",
                    "explanation": "Base cases."
                },
                {
                    "step": 2,
                    "title": "Loop",
                    "visual": "temp=one. one=one+two. two=temp.",
                    "explanation": "Shift."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "return one.",
                    "explanation": "Result."
                }
            ],
            "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
            "examples": [
                {
                    "input": "n = 2",
                    "output": "2",
                    "explanation": "Two ways: (1+1) or (2)."
                },
                {
                    "input": "n = 3",
                    "output": "3",
                    "explanation": "Three ways: (1+1+1), (1+2), (2+1)."
                }
            ],
            "constraints": [
                "1 <= n <= 45"
            ],
            "hints": [
                "This is a classic dynamic programming problem.",
                "The number of ways to reach step n = ways to reach (n-1) + ways to reach (n-2).",
                "This is essentially the Fibonacci sequence!"
            ],
            "relatedProblems": [
                "min-cost-climbing-stairs",
                "house-robber",
                "fibonacci-number"
            ],
            "videoId": "Y0lT9Fck7qI",
            "problemStatement": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "linked-list-cycle": {
            "title": "Linked List Cycle",
            "pattern": "Fast & Slow Pointers",
            "patternEmoji": "\ud83d\udc07\ud83d\udc22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Slow moves 1 step, Fast moves 2. If they collide, there is a cycle.",
            "intuition": [
                "\ud83c\udfaf Floyd's Tortoise and Hare.",
                "\ud83e\udde0 If cycle exists, Fast will eventually lap Slow.",
                "\ud83d\udca1 If Fast reaches null, no cycle."
            ],
            "testCases": [
                {
                    "input": "head = [3,2,0,-4], pos = 1",
                    "output": "true"
                },
                {
                    "input": "head = [1,2], pos = 0",
                    "output": "true"
                },
                {
                    "input": "head = [1], pos = -1",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Run",
                    "visual": "Slow=Head, Fast=Head. Loop.",
                    "explanation": "Start race."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Slow == Fast? Return True.",
                    "explanation": "Collision!"
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Fast is None? Return False.",
                    "explanation": "Reached end."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
            "keyInsight": "Fast pointer MUST check `fast.next` before jumping two steps to avoid AttributeError.",
            "visualizationType": "linked-list",
            "initialState": [
                3,
                2,
                0,
                -4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Run",
                    "visual": "Slow=Head, Fast=Head. Loop.",
                    "explanation": "Start race."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Slow == Fast? Return True.",
                    "explanation": "Collision!"
                },
                {
                    "step": 3,
                    "title": "End",
                    "visual": "Fast is None? Return False.",
                    "explanation": "Reached end."
                }
            ],
            "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.",
            "examples": [
                {
                    "input": "head = [3,2,0,-4], pos = 1",
                    "output": "true",
                    "explanation": "There is a cycle where the tail connects to node at index 1."
                },
                {
                    "input": "head = [1,2], pos = 0",
                    "output": "true",
                    "explanation": "Tail connects to node at index 0."
                },
                {
                    "input": "head = [1], pos = -1",
                    "output": "false",
                    "explanation": "No cycle in the list."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 10^4]",
                "-10^5 <= Node.val <= 10^5",
                "pos is -1 or a valid index."
            ],
            "hints": [
                "Use Floyd's Cycle Detection (Tortoise and Hare).",
                "Have a slow pointer move by 1 and fast pointer move by 2.",
                "If they meet, there's a cycle."
            ],
            "relatedProblems": [
                "linked-list-cycle-ii",
                "happy-number",
                "find-the-duplicate-number"
            ],
            "videoId": "gBTe7lFR3vc",
            "problemStatement": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you solve it using O(1) (i.e. constant) memory?",
            "difficulty": "Easy"
        },
        "binary-search": {
            "title": "Binary Search",
            "pattern": "Divide & Conquer",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Half the search space each time by checking the middle!",
            "intuition": [
                "\ud83c\udfaf Array is SORTED - exploit this!",
                "\ud83e\udde0 Check middle: too big? go left. Too small? go right.",
                "\ud83d\udca1 Halving = log\u2082(n) steps maximum"
            ],
            "testCases": [
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 9",
                    "output": "4"
                },
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 2",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Set Boundaries",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n \u2191                    \u2191\nleft                right",
                    "explanation": "Start with full array range"
                },
                {
                    "step": 2,
                    "title": "Find Middle",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n          \u2191\n         mid (index 3, value 7)",
                    "explanation": "mid = (left + right) // 2"
                },
                {
                    "step": 3,
                    "title": "Compare & Narrow",
                    "visual": "target = 11\n7 < 11 \u2192 search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             \u2191       \u2191\n           left    right",
                    "explanation": "Eliminate half the options!"
                },
                {
                    "step": 4,
                    "title": "Repeat Until Found",
                    "visual": "mid = 11 \u2705 FOUND!\nOR left > right = Not found",
                    "explanation": "Continue halving until match or exhausted"
                }
            ],
            "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1   # search right\n        else:\n            right = mid - 1  # search left\n    \n    return -1",
            "keyInsight": "Each step eliminates HALF - that's why it's O(log n)!",
            "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.",
            "examples": [
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 9",
                    "output": "4",
                    "explanation": "9 exists in nums and its index is 4."
                },
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 2",
                    "output": "-1",
                    "explanation": "2 does not exist in nums."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "-10^4 < nums[i], target < 10^4",
                "All the integers in nums are unique.",
                "nums is sorted in ascending order."
            ],
            "hints": [
                "Use two pointers: left and right.",
                "Calculate mid = (left + right) // 2.",
                "Compare nums[mid] with target and narrow the search range."
            ],
            "relatedProblems": [
                "search-insert-position",
                "search-in-rotated-sorted-array",
                "find-first-and-last-position-of-element-in-sorted-array"
            ],
            "videoId": "s4DPM8ct1pI",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Set Boundaries",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n \u2191                    \u2191\nleft                right",
                    "explanation": "Start with full array range"
                },
                {
                    "step": 2,
                    "title": "Find Middle",
                    "visual": "[1, 3, 5, 7, 9, 11, 13]\n          \u2191\n         mid (index 3, value 7)",
                    "explanation": "mid = (left + right) // 2"
                },
                {
                    "step": 3,
                    "title": "Compare & Narrow",
                    "visual": "target = 11\n7 < 11 \u2192 search RIGHT half\n[_, _, _, _, 9, 11, 13]\n             \u2191       \u2191\n           left    right",
                    "explanation": "Eliminate half the options!"
                },
                {
                    "step": 4,
                    "title": "Repeat Until Found",
                    "visual": "mid = 11 \u2705 FOUND!\nOR left > right = Not found",
                    "explanation": "Continue halving until match or exhausted"
                }
            ],
            "problemStatement": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "number-of-islands": {
            "title": "Number of Islands",
            "pattern": "Matrix DFS / BFS",
            "patternEmoji": "\ud83c\udfdd\ufe0f",
            "timeComplexity": "O(M*N)",
            "spaceComplexity": "O(M*N)",
            "oneliner": "Iterate grid. If '1', increment count and run DFS/BFS to sink (mark '0') the entire island.",
            "intuition": [
                "\ud83c\udfaf '1' is land. Connected '1's form one island.",
                "\ud83e\udde0 When we find an island, destroy it so we don't count it again.",
                "\ud83d\udca1 Flood fill."
            ],
            "testCases": [
                {
                    "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
                    "output": "1"
                },
                {
                    "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Find '1' at (r, c). Count++.",
                    "explanation": "Discovery."
                },
                {
                    "step": 2,
                    "title": "Sink",
                    "visual": "DFS(r, c). Turn '1' to '0'. Recurse 4 dirs.",
                    "explanation": "Erase."
                },
                {
                    "step": 3,
                    "title": "Repeat",
                    "visual": "Continue scan till end.",
                    "explanation": "Completion."
                }
            ],
            "code": "def numIslands(grid):\n    if not grid: return 0\n    rows, cols = len(grid), len(grid[0])\n    visit = set()\n    islands = 0\n    \n    def bfs(r, c):\n        q = []\n        q.append((r, c))\n        visit.add((r,c))\n        while q:\n            row, col = q.pop(0)\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                r, c = row + dr, col + dc\n                if (r in range(rows) and c in range(cols) and\n                    grid[r][c] == \"1\" and (r, c) not in visit):\n                    q.append((r, c))\n                    visit.add((r, c))\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == \"1\" and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1\n    return islands",
            "keyInsight": "You can modify the grid in-place (change '1' to '0') to save O(MN) space for the visited set.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "1",
                    "1",
                    "0"
                ],
                [
                    "1",
                    "1",
                    "0"
                ],
                [
                    "0",
                    "0",
                    "1"
                ]
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Find '1' at (r, c). Count++.",
                    "explanation": "Discovery."
                },
                {
                    "step": 2,
                    "title": "Sink",
                    "visual": "DFS(r, c). Turn '1' to '0'. Recurse 4 dirs.",
                    "explanation": "Erase."
                },
                {
                    "step": 3,
                    "title": "Repeat",
                    "visual": "Continue scan till end.",
                    "explanation": "Completion."
                }
            ],
            "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                {
                    "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                    "output": "1",
                    "explanation": "One connected land mass."
                },
                {
                    "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                    "output": "3",
                    "explanation": "Three separate islands."
                }
            ],
            "constraints": [
                "m == grid.length",
                "n == grid[i].length",
                "1 <= m, n <= 300",
                "grid[i][j] is '0' or '1'."
            ],
            "hints": [
                "Use DFS or BFS to explore connected land.",
                "When you find a '1', increment count and mark all connected land as visited.",
                "Continue scanning the grid."
            ],
            "relatedProblems": [
                "surrounded-regions",
                "max-area-of-island",
                "number-of-enclaves"
            ],
            "videoId": "pV2kpPD66nE",
            "problemStatement": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "reverse-linked-list": {
            "title": "Reverse Linked List",
            "pattern": "Iterative Pointer Swap",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Change each node's pointer to point backwards!",
            "intuition": [
                "\ud83c\udfaf Each node.next should point to previous node",
                "\ud83e\udde0 Need to save 'next' before changing pointer",
                "\ud83d\udca1 Use 3 pointers: prev, current, next"
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]"
                },
                {
                    "input": "head = [1,2]",
                    "output": "[2,1]"
                },
                {
                    "input": "head = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "None \u2190 1 \u2192 2 \u2192 3 \u2192 None\n \u2191    \u2191\nprev  curr",
                    "explanation": "prev starts at None (new tail)"
                },
                {
                    "step": 2,
                    "title": "Save Next",
                    "visual": "1 \u2192 2 \u2192 3\n    \u2191\n   next_node (save before we lose it!)",
                    "explanation": "Must save before changing pointer"
                },
                {
                    "step": 3,
                    "title": "Reverse Pointer",
                    "visual": "None \u2190 1   2 \u2192 3\n \u2191    \u2191   \u2191\nprev curr next",
                    "explanation": "curr.next = prev"
                },
                {
                    "step": 4,
                    "title": "Move Forward",
                    "visual": "None \u2190 1 \u2190 2 \u2190 3\n               \u2191\n              prev (new head!)",
                    "explanation": "Shift all pointers right, repeat"
                }
            ],
            "code": "def reverseList(head):\n    prev = None\n    curr = head\n    \n    while curr:\n        next_node = curr.next  # save next\n        curr.next = prev       # reverse pointer\n        prev = curr            # move prev forward\n        curr = next_node       # move curr forward\n    \n    return prev  # prev is new head",
            "keyInsight": "Three-pointer technique is fundamental for linked list operations!",
            "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]",
                    "explanation": "The list is reversed."
                },
                {
                    "input": "head = [1,2]",
                    "output": "[2,1]",
                    "explanation": "Two-element list reversed."
                },
                {
                    "input": "head = []",
                    "output": "[]",
                    "explanation": "Empty list remains empty."
                }
            ],
            "constraints": [
                "The number of nodes in the list is the range [0, 5000].",
                "-5000 <= Node.val <= 5000"
            ],
            "hints": [
                "Use three pointers: prev, curr, next.",
                "At each step, reverse curr's pointer to prev.",
                "Move all pointers one step forward."
            ],
            "relatedProblems": [
                "reverse-linked-list-ii",
                "palindrome-linked-list",
                "reverse-nodes-in-k-group"
            ],
            "videoId": "G0_I-ZF0S38",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Initialize",
                    "visual": "None \u2190 1 \u2192 2 \u2192 3 \u2192 None\n \u2191    \u2191\nprev  curr",
                    "explanation": "prev starts at None (new tail)"
                },
                {
                    "step": 2,
                    "title": "Save Next",
                    "visual": "1 \u2192 2 \u2192 3\n    \u2191\n   next_node (save before we lose it!)",
                    "explanation": "Must save before changing pointer"
                },
                {
                    "step": 3,
                    "title": "Reverse Pointer",
                    "visual": "None \u2190 1   2 \u2192 3\n \u2191    \u2191   \u2191\nprev curr next",
                    "explanation": "curr.next = prev"
                },
                {
                    "step": 4,
                    "title": "Move Forward",
                    "visual": "None \u2190 1 \u2190 2 \u2190 3\n               \u2191\n              prev (new head!)",
                    "explanation": "Shift all pointers right, repeat"
                }
            ],
            "problemStatement": "Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",
            "difficulty": "Easy"
        },
        "contains-duplicate": {
            "title": "Contains Duplicate",
            "pattern": "Hash Set",
            "patternEmoji": "\ud83d\udc6f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Add to set; if exists, return True.",
            "intuition": [
                "\ud83c\udfaf Any number appearing twice?",
                "\ud83e\udde0 Set stores unique elements.",
                "\ud83d\udca1 Check membership before adding."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "true"
                },
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "false"
                },
                {
                    "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Iterate numbers.",
                    "explanation": "Standard pass."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "In set? True.",
                    "explanation": "Collision."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "Add to set.",
                    "explanation": "Track seen."
                }
            ],
            "code": "def containsDuplicate(nums):\n    seen = set()\n    for n in nums:\n        if n in seen: return True\n        seen.add(n)\n    return False",
            "keyInsight": "HashSet provides immediate collision detection.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Iterate numbers.",
                    "explanation": "Standard pass."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "In set? True.",
                    "explanation": "Collision."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "Add to set.",
                    "explanation": "Track seen."
                }
            ],
            "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "true",
                    "explanation": "1 appears twice."
                },
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "false",
                    "explanation": "All elements are distinct."
                },
                {
                    "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                    "output": "true",
                    "explanation": "Multiple duplicates exist."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Use a hash set to track seen numbers.",
                "If you see a number already in the set, return true.",
                "Alternatively, sort the array and check adjacent elements."
            ],
            "relatedProblems": [
                "contains-duplicate-ii",
                "contains-duplicate-iii",
                "find-the-duplicate-number"
            ],
            "videoId": "3OamzN90kPg",
            "problemStatement": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "invert-binary-tree": {
            "title": "Invert Binary Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Swap left and right children, then recurse.",
            "intuition": [
                "\ud83c\udfaf Mirror image.",
                "\ud83e\udde0 For every node, left becomes right.",
                "\ud83d\udca1 Post-order or Pre-order traversal works fine."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]"
                },
                {
                    "input": "root = [2,1,3]",
                    "output": "[2,3,1]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Swap",
                    "visual": "root.left, root.right = root.right, root.left.",
                    "explanation": "Action."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "invert(left), invert(right).",
                    "explanation": "Propagate."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "If null, return null.",
                    "explanation": "Stop."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef invertTree(root):\n    if not root: return None\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root",
            "keyInsight": "Max Howell famously got rejected by Google for not solving this on a whiteboard.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3,
                6,
                9
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Swap",
                    "visual": "root.left, root.right = root.right, root.left.",
                    "explanation": "Action."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "invert(left), invert(right).",
                    "explanation": "Propagate."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "If null, return null.",
                    "explanation": "Stop."
                }
            ],
            "description": "Given the root of a binary tree, invert the tree, and return its root.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]",
                    "explanation": "Mirror the tree."
                },
                {
                    "input": "root = [2,1,3]",
                    "output": "[2,3,1]",
                    "explanation": "Swap children."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 100].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Recursively swap left and right children.",
                "Base case: null node returns null.",
                "DFS or BFS both work."
            ],
            "relatedProblems": [
                "same-tree",
                "symmetric-tree"
            ],
            "videoId": "OnSn2XEQ4MY",
            "problemStatement": "Given the root of a binary tree, invert the tree, and return its root.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "coin-change": {
            "title": "Coin Change",
            "pattern": "1D DP",
            "patternEmoji": "\ud83e\ude99",
            "timeComplexity": "O(amount * n)",
            "spaceComplexity": "O(amount)",
            "oneliner": "dp[i] = min(dp[i], dp[i-coin] + 1) for each coin.",
            "intuition": [
                "\ud83c\udfaf Min coins to make amount.",
                "\ud83e\udde0 dp[i] = min coins for amount i.",
                "\ud83d\udca1 For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
            ],
            "testCases": [
                {
                    "input": "coins = [1,2,5], amount = 11",
                    "output": "3"
                },
                {
                    "input": "coins = [2], amount = 3",
                    "output": "-1"
                },
                {
                    "input": "coins = [1], amount = 0",
                    "output": "0"
                }
            ],
            "code": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1",
            "keyInsight": "Bottom-up DP iterating coins first or amount first.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initializing dp array with size amount + 1 (4 in this case)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "value": 0,
                    "color": "success",
                    "transientMessage": "Setting dp[0] to 0 because no coins are needed to make the amount 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Processing coin with value 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "value": 1,
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Updating dp[1] to min(dp[1], dp[0] + 1) = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "value": 2,
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Updating dp[2] to min(dp[2], dp[1] + 1) = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Processing coin with value 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "value": 1,
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Updating dp[2] to min(dp[2], dp[0] + 1) = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "value": 2,
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Updating dp[3] to min(dp[3], dp[1] + 1) = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "coin"
                        }
                    ],
                    "transientMessage": "Processing coin with value 5"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "value": -1,
                    "color": "error",
                    "transientMessage": "Amount 3 cannot be formed with the given coins, returning -1"
                }
            ],
            "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
            "examples": [
                {
                    "input": "coins = [1,2,5], amount = 11",
                    "output": "3",
                    "explanation": "11 = 5 + 5 + 1"
                },
                {
                    "input": "coins = [2], amount = 3",
                    "output": "-1",
                    "explanation": "Cannot make 3 with only 2s."
                },
                {
                    "input": "coins = [1], amount = 0",
                    "output": "0",
                    "explanation": "No coins needed for amount 0."
                }
            ],
            "constraints": [
                "1 <= coins.length <= 12",
                "1 <= coins[i] <= 2^31 - 1",
                "0 <= amount <= 10^4"
            ],
            "hints": [
                "Use dynamic programming.",
                "dp[i] = minimum coins needed to make amount i.",
                "For each coin, dp[i] = min(dp[i], dp[i-coin] + 1)."
            ],
            "relatedProblems": [
                "coin-change-ii",
                "minimum-cost-for-tickets",
                "perfect-squares"
            ],
            "videoId": "H9bfqozjoqs",
            "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "two-sum": {
            "title": "Two Sum",
            "pattern": "Hash Map",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Store seen numbers; check if (target - current) exists in map.",
            "intuition": [
                "\ud83c\udfaf We need: nums[j] = target - nums[i].",
                "\ud83e\udde0 While iterating, store {val: index} of what we've seen.",
                "\ud83d\udca1 Look back: do we have the complement?"
            ],
            "testCases": [
                {
                    "input": "nums = [2,7,11,15], target = 9",
                    "output": "[0,1]"
                },
                {
                    "input": "nums = [3,2,4], target = 6",
                    "output": "[1,2]"
                },
                {
                    "input": "nums = [3,3], target = 6",
                    "output": "[0,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Visit 2. Need 7. Map: {2:0}.",
                    "explanation": "Remember 2."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Visit 7. Need 2. 2 is in Map!",
                    "explanation": "Pair found."
                },
                {
                    "step": 3,
                    "title": "Found",
                    "visual": "Return [Map[2], CurrentIndex].",
                    "explanation": "Indices found."
                }
            ],
            "code": "def twoSum(nums, target):\n    prevMap = {}\n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prevMap:\n            return [prevMap[diff], i]\n        prevMap[n] = i\n    return []",
            "keyInsight": "One pass is sufficient because the pair is commutative; we find it when we reach the *second* number.",
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Visit 2. Need 7. Map: {2:0}.",
                    "explanation": "Remember 2."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Visit 7. Need 2. 2 is in Map!",
                    "explanation": "Pair found."
                },
                {
                    "step": 3,
                    "title": "Found",
                    "visual": "Return [Map[2], CurrentIndex].",
                    "explanation": "Indices found."
                }
            ],
            "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [2,7,11,15], target = 9",
                    "output": "[0,1]",
                    "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
                },
                {
                    "input": "nums = [3,2,4], target = 6",
                    "output": "[1,2]",
                    "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
                },
                {
                    "input": "nums = [3,3], target = 6",
                    "output": "[0,1]",
                    "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
                }
            ],
            "constraints": [
                "2 <= nums.length <= 10^4",
                "-10^9 <= nums[i] <= 10^9",
                "-10^9 <= target <= 10^9",
                "Only one valid answer exists."
            ],
            "hints": [
                "A really brute force way would be to search for all possible pairs of numbers but that would be too slow.",
                "Try using a hash map to store the complement of each number.",
                "Can you do it in one pass through the array?"
            ],
            "relatedProblems": [
                "three-sum",
                "two-sum-ii---input-array-is-sorted",
                "two-sum-iv---input-is-a-bst"
            ],
            "videoId": "KLlXCFG5TnA",
            "problemStatement": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "remove-element": {
            "title": "Remove Element",
            "pattern": "Two Pointers",
            "patternEmoji": "\u270c\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use a read pointer and a write pointer to filter in-place.",
            "intuition": [
                "\ud83c\udfaf We need to remove all instances of val in-place",
                "\ud83e\udde0 Maintain a 'k' pointer that tracks the position of valid elements",
                "\ud83d\udca1 If current element != val, put it at k and increment k"
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,2,3], val = 3",
                    "output": "2, nums = [2,2,_,_]"
                },
                {
                    "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                    "output": "5, nums = [0,1,4,0,3,_,_,_]"
                }
            ],
            "code": "def removeElement(nums, val):\n    k = 0\n    for i in range(len(nums)):\n        if nums[i] != val:\n            nums[k] = nums[i]\n            k += 1\n    return k",
            "keyInsight": "Overwrite values we don't want with the ones we keep!",
            "description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.",
            "examples": [
                {
                    "input": "nums = [3,2,2,3], val = 3",
                    "output": "2, nums = [2,2,_,_]",
                    "explanation": "Your function should return k = 2, with the first two elements of nums being 2."
                },
                {
                    "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
                    "output": "5, nums = [0,1,4,0,3,_,_,_]",
                    "explanation": "Your function should return k = 5."
                }
            ],
            "constraints": [
                "0 <= nums.length <= 100",
                "0 <= nums[i] <= 50",
                "0 <= val <= 100"
            ],
            "hints": [
                "Use two pointers - one for iteration, one for placing valid elements.",
                "Overwrite elements equal to val with elements from the end.",
                "The order doesn't matter, so we can swap freely."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array",
                "move-zeroes",
                "remove-linked-list-elements"
            ],
            "videoId": "Pcd1ii9P9ZI",
            "problemStatement": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "majority-element": {
            "title": "Majority Element",
            "pattern": "Boyer-Moore Voting",
            "patternEmoji": "\ud83d\uddf3\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Cancel out different elements; the majority always survives!",
            "intuition": [
                "\ud83c\udfaf Majority element appears > n/2 times",
                "\ud83e\udde0 Think of it as a war: mixed pair die, majority wins",
                "\ud83d\udca1 Count +, Count -. If count 0, pick new candidate."
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3"
                },
                {
                    "input": "nums = [2,2,1,1,1,2,2]",
                    "output": "2"
                }
            ],
            "code": "def majorityElement(nums):\n    count = 0\n    candidate = None\n    \n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (1 if num == candidate else -1)\n        \n    return candidate",
            "keyInsight": "If >50% of people vote Red, even if everyone else pairs up against them, Red wins!",
            "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.",
            "examples": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3",
                    "explanation": "3 appears 2 times out of 3."
                },
                {
                    "input": "nums = [2,2,1,1,1,2,2]",
                    "output": "2",
                    "explanation": "2 appears 4 times out of 7."
                }
            ],
            "constraints": [
                "n == nums.length",
                "1 <= n <= 5 * 10^4",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Use Boyer-Moore Voting Algorithm.",
                "Maintain a candidate and count.",
                "If count is 0, pick new candidate. If same, increment, else decrement."
            ],
            "relatedProblems": [
                "majority-element-ii",
                "check-if-a-number-is-majority-element-in-a-sorted-array"
            ],
            "videoId": "7pnhv842keE",
            "problemStatement": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u230an / 2\u230b times. You may assume that the majority element always exists in the array.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "ransom-note": {
            "title": "Ransom Note",
            "pattern": "Hash Map / Counter",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(m+n)",
            "spaceComplexity": "O(1) (26 chars)",
            "oneliner": "Count letters in magazine; ensure every letter in note is available.",
            "intuition": [
                "\ud83c\udfaf Can we construct 'note' from 'magazine' letters?",
                "\ud83e\udde0 Count frequency of each char in magazine.",
                "\ud83d\udca1 For each char in note, subtract count. If count < 0, False."
            ],
            "testCases": [
                {
                    "input": "ransomNote = \"a\", magazine = \"b\"",
                    "output": "false"
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"ab\"",
                    "output": "false"
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"aab\"",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count Magazine",
                    "visual": "Map: {a:2, b:1}",
                    "explanation": "Available resources."
                },
                {
                    "step": 2,
                    "title": "Check Note",
                    "visual": "Need 'a'? Map['a']--. Remaining: 1.",
                    "explanation": "Consume resource."
                },
                {
                    "step": 3,
                    "title": "Verify",
                    "visual": "If Map[char] < 0, impossible.",
                    "explanation": "Not enough letters."
                }
            ],
            "code": "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    counts = Counter(magazine)\n    for c in ransomNote:\n        counts[c] -= 1\n        if counts[c] < 0: return False\n    return True",
            "keyInsight": "Using an array of size 26 is slightly faster than a hashmap, but Counter is cleaner.",
            "visualizationType": "string",
            "initialState": "ransomNote='aa', magazine='aab'",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Count Magazine",
                    "visual": "Map: {a:2, b:1}",
                    "explanation": "Available resources."
                },
                {
                    "step": 2,
                    "title": "Check Note",
                    "visual": "Need 'a'? Map['a']--. Remaining: 1.",
                    "explanation": "Consume resource."
                },
                {
                    "step": 3,
                    "title": "Verify",
                    "visual": "If Map[char] < 0, impossible.",
                    "explanation": "Not enough letters."
                }
            ],
            "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote.",
            "examples": [
                {
                    "input": "ransomNote = \"a\", magazine = \"b\"",
                    "output": "false",
                    "explanation": "'a' is not in magazine."
                },
                {
                    "input": "ransomNote = \"aa\", magazine = \"aab\"",
                    "output": "true",
                    "explanation": "Both 'a's can be found in magazine."
                }
            ],
            "constraints": [
                "1 <= ransomNote.length, magazine.length <= 10^5",
                "ransomNote and magazine consist of lowercase English letters."
            ],
            "hints": [
                "Count character frequencies in magazine.",
                "Check if ransomNote's frequencies are all <= magazine's.",
                "Use a hash map or array of size 26."
            ],
            "relatedProblems": [
                "stickers-to-spell-word",
                "first-unique-character-in-a-string"
            ],
            "videoId": "OKmDwbsROuc",
            "problemStatement": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "valid-anagram": {
            "title": "Valid Anagram",
            "pattern": "Hash Map / Sorting",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Check if character counts are identical.",
            "intuition": [
                "\ud83c\udfaf Anagram = same letters, rearranged.",
                "\ud83e\udde0 Sorting works (O(nlogn)), but counting is faster (O(n)).",
                "\ud83d\udca1 Count S, subtract T. All zero? True."
            ],
            "testCases": [
                {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "output": "true"
                },
                {
                    "input": "s = \"rat\", t = \"car\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count S",
                    "visual": "{a:3, n:1, g:1, r:1, m:1}",
                    "explanation": "Tally up."
                },
                {
                    "step": 2,
                    "title": "Subtract T",
                    "visual": "Decrement counts for 'nagaram'.",
                    "explanation": "Cancel out."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "All zero? Match.",
                    "explanation": "Any non-zero means mismatch."
                }
            ],
            "code": "def isAnagram(s, t):\n    if len(s) != len(t): return False\n    # return sorted(s) == sorted(t)\n    from collections import Counter\n    return Counter(s) == Counter(t)",
            "keyInsight": "Length check first is a cheap optimization.",
            "visualizationType": "string",
            "initialState": "anagram vs nagaram",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Count S",
                    "visual": "{a:3, n:1, g:1, r:1, m:1}",
                    "explanation": "Tally up."
                },
                {
                    "step": 2,
                    "title": "Subtract T",
                    "visual": "Decrement counts for 'nagaram'.",
                    "explanation": "Cancel out."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "All zero? Match.",
                    "explanation": "Any non-zero means mismatch."
                }
            ],
            "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "output": "true",
                    "explanation": "Both have same letter counts."
                },
                {
                    "input": "s = \"rat\", t = \"car\"",
                    "output": "false",
                    "explanation": "Different letter counts."
                }
            ],
            "constraints": [
                "1 <= s.length, t.length <= 5 * 10^4",
                "s and t consist of lowercase English letters."
            ],
            "hints": [
                "If lengths differ, return false immediately.",
                "Count character frequencies and compare.",
                "Or sort both strings and compare."
            ],
            "relatedProblems": [
                "group-anagrams",
                "find-all-anagrams-in-a-string",
                "find-resultant-array-after-removing-anagrams"
            ],
            "videoId": "9UtInBqnCgA",
            "problemStatement": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nExample 1:\nExample 2:\nConstraints:\nFollow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",
            "difficulty": "Easy"
        },
        "happy-number": {
            "title": "Happy Number",
            "pattern": "Floyd's Cycle Finding",
            "patternEmoji": "\ud83d\ude00",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Detect cycle in sum-of-squares chain. 1 is happy root; other cycles are sad.",
            "intuition": [
                "\ud83c\udfaf Process: replace n with sum of squares of digits.",
                "\ud83e\udde0 It either reaches 1 (Happy) or stuck in a loop (Sad).",
                "\ud83d\udca1 Use Slow/Fast pointers or a Set to detect loop."
            ],
            "testCases": [
                {
                    "input": "n = 19",
                    "output": "true"
                },
                {
                    "input": "n = 2",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Simulate",
                    "visual": "19 -> 1^2+9^2=82 -> 68 -> 100 -> 1.",
                    "explanation": "Converged to 1."
                },
                {
                    "step": 2,
                    "title": "Cycle",
                    "visual": "2 -> 4 -> 16... -> 4 (Loop!).",
                    "explanation": "Detected visited number."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "If 1: True. If Cycle: False.",
                    "explanation": "Decision."
                }
            ],
            "code": "def isHappy(n):\n    visit = set()\n    while n not in visit:\n        visit.add(n)\n        n = sum(int(d)**2 for d in str(n))\n        if n == 1: return True\n    return False",
            "keyInsight": "The cycle doesn't grow infinitely; digits reduce numbers drastically (999 -> 243). Loop is guaranteed small.",
            "visualizationType": "string",
            "initialState": "19",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Simulate",
                    "visual": "19 -> 1^2+9^2=82 -> 68 -> 100 -> 1.",
                    "explanation": "Converged to 1."
                },
                {
                    "step": 2,
                    "title": "Cycle",
                    "visual": "2 -> 4 -> 16... -> 4 (Loop!).",
                    "explanation": "Detected visited number."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "If 1: True. If Cycle: False.",
                    "explanation": "Decision."
                }
            ],
            "description": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.",
            "examples": [
                {
                    "input": "n = 19",
                    "output": "true",
                    "explanation": "1\u00b2 + 9\u00b2 = 82 \u2192 8\u00b2 + 2\u00b2 = 68 \u2192 ... \u2192 1"
                },
                {
                    "input": "n = 2",
                    "output": "false",
                    "explanation": "2 \u2192 4 \u2192 16 \u2192 37 \u2192 58 \u2192 89 \u2192 145 \u2192 42 \u2192 20 \u2192 4 (cycle)"
                }
            ],
            "constraints": [
                "1 <= n <= 2^31 - 1"
            ],
            "hints": [
                "Use Floyd's cycle detection (fast and slow).",
                "Or use a hash set to detect cycles.",
                "If you see a number twice, it's not happy."
            ],
            "relatedProblems": [
                "linked-list-cycle",
                "add-digits",
                "ugly-number"
            ],
            "videoId": "ljz85bxOYJ0",
            "problemStatement": "Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nReturn true if n is a happy number, and false if not.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "middle-of-the-linked-list": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers, one moving twice as fast as the other, to find the middle.",
            "intuition": [
                "The faster pointer will reach the end when the slower one is at the middle.",
                "Move slow and fast pointers; fast moves two steps while slow moves one."
            ],
            "visualizationType": "linkedlist",
            "initialState": [
                "A",
                "B",
                "C",
                "D",
                "E"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "slow"
                        },
                        {
                            "index": 1,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 1: slow = A, fast = B"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "slow"
                        },
                        {
                            "index": 3,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 2: slow = B, fast = D"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "slow"
                        },
                        {
                            "index": 4,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Step 3: slow = C, fast = None. Middle found!"
                }
            ],
            "code": "def middleNode(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow",
            "keyInsight": "The fast pointer will reach the end when the slow one is at the middle.",
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[3,4,5]"
                },
                {
                    "input": "head = [1,2,3,4,5,6]",
                    "output": "[4,5,6]"
                }
            ],
            "description": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[3,4,5]",
                    "explanation": "The middle node is 3."
                },
                {
                    "input": "head = [1,2,3,4,5,6]",
                    "output": "[4,5,6]",
                    "explanation": "There are two middles, return the second one."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 100].",
                "1 <= Node.val <= 100"
            ],
            "hints": [
                "Use slow and fast pointers.",
                "Slow moves 1 step, fast moves 2 steps.",
                "When fast reaches end, slow is at middle."
            ],
            "relatedProblems": [
                "delete-the-middle-node-of-a-linked-list",
                "linked-list-cycle",
                "reorder-list"
            ],
            "videoId": "A2_ldqM4QcY",
            "problemStatement": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\nExample 1:\nExample 2:\nConstraints:",
            "title": "Middle of the Linked List",
            "difficulty": "Easy"
        },
        "time-needed-to-buy-tickets": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers to simulate buying tickets in a queue.",
            "intuition": [
                "Track the time taken for each person to buy their ticket using two pointers.",
                "Adjust pointers based on the number of tickets needed and available."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Front"
                        }
                    ],
                    "transientMessage": "First person buys a ticket (1/2), time = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Middle"
                        }
                    ],
                    "transientMessage": "Second person buys a ticket (1/3), time = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "Back"
                        }
                    ],
                    "transientMessage": "Third person buys a ticket (1/2), time = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Front"
                        }
                    ],
                    "transientMessage": "First person buys a ticket (2/2), time = 4"
                }
            ],
            "code": "def time_needed_to_buy(tickets, k):\n    time = 0\n    n = len(tickets)\n    while tickets[k] > 0:\n        for i in range(n):\n            if tickets[i] == 0:\n                continue\n            tickets[i] -= 1\n            time += 1\n            if tickets[k] == 0:\n                return time",
            "keyInsight": "Simulate the queue by decrementing ticket counts and incrementing time.",
            "testCases": [
                {
                    "input": "tickets = [2,3,2], k = 2",
                    "output": "6"
                },
                {
                    "input": "tickets = [5,1,1,1], k = 0",
                    "output": "8"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Time Needed to Buy Tickets",
            "description": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line to buy more tickets. Return the time taken for the person at position k to finish buying all their tickets.",
            "examples": [
                {
                    "input": "tickets = [2,3,2], k = 2",
                    "output": "6",
                    "explanation": "Person 2 finishes after 6 seconds."
                },
                {
                    "input": "tickets = [5,1,1,1], k = 0",
                    "output": "8",
                    "explanation": "Person 0 needs 5 tickets, takes 8 seconds total."
                }
            ],
            "constraints": [
                "n == tickets.length",
                "1 <= n <= 100",
                "1 <= tickets[i] <= 100",
                "0 <= k < n"
            ],
            "hints": [
                "For people before k: min(tickets[i], tickets[k]).",
                "For people at k: tickets[k].",
                "For people after k: min(tickets[i], tickets[k] - 1)."
            ],
            "relatedProblems": [
                "number-of-students-unable-to-eat-lunch"
            ],
            "videoId": "6Sk5xZCr94o",
            "problemStatement": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\nYou are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\nEach person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\nReturn the time taken for the person initially at position k (0-indexed) to finish buying tickets.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "minimum-absolute-difference": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort the array and use two pointers to find the minimum absolute difference.",
            "intuition": [
                "Sorting helps in easily finding the closest pairs by comparing adjacent elements.",
                "Two pointers starting from consecutive positions can efficiently track the smallest difference."
            ],
            "visualizationType": "array",
            "initialState": [
                4,
                2,
                1,
                3
            ],
            "animationSteps": [
                {
                    "type": "sort",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "transientMessage": "Sorting the array: [1, 2, 3, 4]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Difference = 1"
                }
            ],
            "code": "def minimumAbsDifference(nums):\n    nums.sort()\n    min_diff = float('inf')\n    result = []\n    for i in range(1, len(nums)):\n        diff = nums[i] - nums[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = [[nums[i-1], nums[i]]]\n        elif diff == min_diff:\n            result.append([nums[i-1], nums[i]])\n    return result",
            "keyInsight": "Sorting the array allows us to only check adjacent elements for the minimum difference.",
            "testCases": [
                {
                    "input": "arr = [4,2,1,3]",
                    "output": "[[1,2],[2,3],[3,4]]"
                },
                {
                    "input": "arr = [1,3,6,10,15]",
                    "output": "[[1,3]]"
                },
                {
                    "input": "arr = [3,8,-10,23,19,-4,-14,27]",
                    "output": "[[-14,-10],[19,23],[23,27]]"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Minimum Absolute Difference",
            "description": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order (with respect to pairs), each pair [a, b] follows a < b.",
            "examples": [
                {
                    "input": "arr = [4,2,1,3]",
                    "output": "[[1,2],[2,3],[3,4]]",
                    "explanation": "Min diff is 1, all adjacent pairs after sorting."
                },
                {
                    "input": "arr = [1,3,6,10,15]",
                    "output": "[[1,3]]",
                    "explanation": "Min diff is 2."
                }
            ],
            "constraints": [
                "2 <= arr.length <= 10^5",
                "-10^6 <= arr[i] <= 10^6"
            ],
            "hints": [
                "Sort the array first.",
                "Minimum difference must be between adjacent elements.",
                "Find min diff, then collect all pairs with that diff."
            ],
            "relatedProblems": [
                "minimum-absolute-difference-in-bst",
                "k-diff-pairs-in-an-array"
            ],
            "videoId": "mH1aEjOEjcQ",
            "problemStatement": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.\nReturn a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "missing-number": {
            "pattern": "Math",
            "patternEmoji": "\u2716\ufe0f\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Calculate the expected sum and subtract the actual sum.",
            "intuition": [
                "Use the formula for the sum of the first n natural numbers.",
                "Subtract the actual sum from this expected sum to find the missing number."
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                0,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "transientMessage": "Sum of given numbers = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "transientMessage": "Expected sum for n=3 = 6"
                }
            ],
            "code": "def missingNumber(nums):\n    n = len(nums)\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum",
            "keyInsight": "The sum of numbers from 0 to n is a known formula: n(n+1)/2.",
            "testCases": [
                {
                    "input": "nums = [3,0,1]",
                    "output": "2"
                },
                {
                    "input": "nums = [0,1]",
                    "output": "2"
                },
                {
                    "input": "nums = [9,6,4,2,3,5,7,0,1]",
                    "output": "8"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Missing Number",
            "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
            "examples": [
                {
                    "input": "nums = [3,0,1]",
                    "output": "2",
                    "explanation": "n = 3, range is [0,3], 2 is missing."
                },
                {
                    "input": "nums = [0,1]",
                    "output": "2",
                    "explanation": "n = 2, range is [0,2], 2 is missing."
                }
            ],
            "constraints": [
                "n == nums.length",
                "1 <= n <= 10^4",
                "0 <= nums[i] <= n",
                "All numbers in nums are unique."
            ],
            "hints": [
                "Use XOR: XOR all numbers 0 to n, then XOR with array.",
                "Or use sum formula: n*(n+1)/2 - sum(nums).",
                "Both approaches are O(n) time, O(1) space."
            ],
            "relatedProblems": [
                "single-number",
                "find-the-duplicate-number",
                "first-missing-positive"
            ],
            "videoId": "WnPLSRLSANE",
            "problemStatement": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
            "difficulty": "Easy"
        },
        "minimum-time-visiting-all-points": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers to traverse points and calculate min time.",
            "intuition": [
                "Calculate the time to move from one point to another using Manhattan distance.",
                "Traverse through all points sequentially."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    3,
                    4
                ],
                [
                    -1,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Start"
                        }
                    ],
                    "transientMessage": "At (1, 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Current"
                        },
                        {
                            "index": 1,
                            "label": "Next"
                        }
                    ],
                    "transientMessage": "Move to (3, 4) in 5 units."
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Current"
                        },
                        {
                            "index": 2,
                            "label": "Next"
                        }
                    ],
                    "transientMessage": "Move to (-1, 0) in 5 units."
                }
            ],
            "code": "def minTimeToVisitAllPoints(points):\n    total_time = 0\n    for i in range(len(points) - 1):\n        current_point = points[i]\n        next_point = points[i + 1]\n        time_to_next = max(abs(next_point[0] - current_point[0]), abs(next_point[1] - current_point[1]))\n        total_time += time_to_next\n    return total_time",
            "keyInsight": "Manhattan distance gives the minimum time to move between two points.",
            "testCases": [
                {
                    "input": "points = [[1,1],[3,4],[-1,0]]",
                    "output": "7"
                },
                {
                    "input": "points = [[3,2],[-2,2]]",
                    "output": "5"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Minimum Time Visiting All Points",
            "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move diagonally 1 unit in 1 second, or move horizontally or vertically 1 unit in 1 second.",
            "examples": [
                {
                    "input": "points = [[1,1],[3,4],[-1,0]]",
                    "output": "7",
                    "explanation": "(1,1) to (3,4) = 3 steps, (3,4) to (-1,0) = 4 steps."
                },
                {
                    "input": "points = [[3,2],[-2,2]]",
                    "output": "5",
                    "explanation": "5 horizontal steps."
                }
            ],
            "constraints": [
                "points.length == n",
                "1 <= n <= 100",
                "-1000 <= points[i][0], points[i][1] <= 1000"
            ],
            "hints": [
                "For two points, time = max(|dx|, |dy|).",
                "Chebyshev distance works here.",
                "Sum distances between consecutive points."
            ],
            "relatedProblems": [
                "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
            ],
            "videoId": "QJz-0VmNpuE",
            "problemStatement": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\nYou can move according to these rules:\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "fizz-buzz": {
            "pattern": "Iterative",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Iterate through numbers 1 to n, appending 'Fizz', 'Buzz', or 'FizzBuzz' based on divisibility.",
            "intuition": [
                "Check each number for divisibility by 3 and 5.",
                "Use modulo operation to determine if a number is divisible."
            ],
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "type": "append",
                    "value": "1",
                    "transientMessage": "1 is not divisible by 3 or 5, append '1'"
                },
                {
                    "type": "append",
                    "value": "Fizz",
                    "transientMessage": "2 is not divisible by 3 or 5, append '2'"
                },
                {
                    "type": "append",
                    "value": "Buzz",
                    "transientMessage": "3 is divisible by 3, append 'Buzz'"
                },
                {
                    "type": "append",
                    "value": "4",
                    "transientMessage": "4 is not divisible by 3 or 5, append '4'"
                },
                {
                    "type": "append",
                    "value": "FizzBuzz",
                    "transientMessage": "15 is divisible by both 3 and 5, append 'FizzBuzz'"
                }
            ],
            "code": "def fizzBuzz(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 15 == 0:\n            result.append('FizzBuzz')\n        elif i % 3 == 0:\n            result.append('Fizz')\n        elif i % 5 == 0:\n            result.append('Buzz')\n        else:\n            result.append(str(i))\n    return result",
            "keyInsight": "Modulo operation helps in checking divisibility efficiently.",
            "testCases": [
                {
                    "input": "n = 3",
                    "output": "[\"1\",\"2\",\"Fizz\"]"
                },
                {
                    "input": "n = 5",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                },
                {
                    "input": "n = 15",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Fizz Buzz",
            "description": "Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5, answer[i] == \"Fizz\" if i is divisible by 3, answer[i] == \"Buzz\" if i is divisible by 5, answer[i] == i (as a string) if none of the above conditions are true.",
            "examples": [
                {
                    "input": "n = 3",
                    "output": "[\"1\",\"2\",\"Fizz\"]",
                    "explanation": "1 and 2 are neither, 3 is divisible by 3."
                },
                {
                    "input": "n = 5",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
                    "explanation": "5 is divisible by 5."
                }
            ],
            "constraints": [
                "1 <= n <= 10^4"
            ],
            "hints": [
                "Check divisibility by 15 first (3 AND 5).",
                "Then check 3, then 5, then default to number.",
                "Use string concatenation for cleaner code."
            ],
            "relatedProblems": [
                "fizz-buzz-multithreaded"
            ],
            "videoId": "AfxHGNRtFac",
            "problemStatement": "Given an integer n, return a string array answer (1-indexed) where:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "count-and-say": {
            "pattern": "Iterative with String Manipulation",
            "patternEmoji": "\ud83d\udd04\ud83d\udcac",
            "timeComplexity": "O(n * m)",
            "spaceComplexity": "O(m)",
            "oneliner": "Iteratively build each sequence by counting and saying the previous one.",
            "intuition": [
                "Start with the initial '1' and iteratively generate the next sequence by describing the current one.",
                "Use a loop to count consecutive digits and form the new string accordingly."
            ],
            "visualizationType": "string",
            "initialState": "1",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "First iteration: '1' -> '1 one'"
                },
                {
                    "type": "update",
                    "newString": "11",
                    "color": "success",
                    "transientMessage": "Second iteration: '1 one' -> '2 ones'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "transientMessage": "Third iteration: '2 ones' -> '1 two, 1 one'"
                }
            ],
            "code": "def countAndSay(n):\n    if n == 1:\n        return '1'\n    current = '1'\n    for _ in range(1, n):\n        next_seq = ''\n        i = 0\n        while i < len(current):\n            count = 1\n            while i + 1 < len(current) and current[i] == current[i + 1]:\n                i += 1\n                count += 1\n            next_seq += str(count) + current[i]\n            i += 1\n        current = next_seq\n    return current",
            "keyInsight": "Each number is generated by reading off the digits of the previous number.",
            "testCases": [
                {
                    "input": "n = 1",
                    "output": "\"1\""
                },
                {
                    "input": "n = 4",
                    "output": "\"1211\""
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Count and Say",
            "description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: countAndSay(1) = \"1\", countAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1). To determine how you \"say\" a digit string, group it into runs of consecutive identical digits. Then for each group, say the number of digits, then the digit.",
            "examples": [
                {
                    "input": "n = 1",
                    "output": "\"1\"",
                    "explanation": "Base case."
                },
                {
                    "input": "n = 4",
                    "output": "\"1211\"",
                    "explanation": "1 -> 11 -> 21 -> 1211"
                }
            ],
            "constraints": [
                "1 <= n <= 30"
            ],
            "hints": [
                "Build iteratively from 1 to n.",
                "For each string, group consecutive digits.",
                "Build next string: count + digit for each group."
            ],
            "relatedProblems": [
                "encode-and-decode-strings",
                "string-compression"
            ],
            "videoId": "a1v3GIaJNoM",
            "problemStatement": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"3322251\" we replace \"33\" with \"23\", replace \"222\" with \"32\", replace \"5\" with \"15\" and replace \"1\" with \"11\". Thus the compressed string becomes \"23321511\".\nGiven a positive integer n, return the nth element of the count-and-say sequence.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "two-sum-iv---input-is-a-bst": {
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Use in-order traversal to collect elements, then apply two-pointer technique.",
            "intuition": [
                "Perform an in-order traversal of the BST to get a sorted list of numbers.",
                "Use two pointers starting from ends of this sorted list to find the pair that sums up to the target."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 17. Too big!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 13. Match!"
                }
            ],
            "code": "def twoSumBST(root, target):\n    def inorder(node):\n        if not node: return []\n        return inorder(node.left) + [node.val] + inorder(node.right)\n    nums = inorder(root)\n    left, right = 0, len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
            "keyInsight": "The BST in-order traversal provides a sorted array, enabling the two-pointer technique.",
            "testCases": [
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 9",
                    "output": "true"
                },
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 28",
                    "output": "false"
                }
            ],
            "generated": true,
            "validationPassed": false,
            "title": "Two Sum IV - Input is a BST",
            "description": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
            "examples": [
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 9",
                    "output": "true",
                    "explanation": "5 + 4 = 9."
                },
                {
                    "input": "root = [5,3,6,2,4,null,7], k = 28",
                    "output": "false",
                    "explanation": "No pair sums to 28."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 10^4].",
                "-10^4 <= Node.val <= 10^4",
                "root is guaranteed to be a valid BST.",
                "-10^5 <= k <= 10^5"
            ],
            "hints": [
                "Use in-order traversal to get sorted array, then two pointers.",
                "Or use a hash set while traversing.",
                "For each node, check if k - node.val exists."
            ],
            "relatedProblems": [
                "two-sum",
                "two-sum-ii---input-array-is-sorted",
                "two-sum-iii---data-structure-design"
            ],
            "videoId": "cxoOxinXYiE",
            "problemStatement": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "isomorphic-strings": {
            "title": "Isomorphic Strings",
            "pattern": "Hash Map (Bi-directional)",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Map s[i]->t[i] AND t[i]->s[i]; detect conflicts.",
            "intuition": [
                "\ud83c\udfaf 'egg' -> 'add'. e->a, g->d.",
                "\ud83e\udde0 Must be consistent (1-to-1 mapping).",
                "\ud83d\udca1 If 'e' maps to 'a', 'a' must map back to 'e' ONLY."
            ],
            "testCases": [
                {
                    "input": "s = \"egg\", t = \"add\"",
                    "output": "true"
                },
                {
                    "input": "s = \"foo\", t = \"bar\"",
                    "output": "false"
                },
                {
                    "input": "s = \"paper\", t = \"title\"",
                    "output": "true"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Iterate",
                    "visual": "Pair (s[i], t[i]).",
                    "explanation": "Check character mapping."
                },
                {
                    "step": 2,
                    "title": "Check S->T",
                    "visual": "MapS[s[i]] exists? Must equal t[i].",
                    "explanation": "Forward consistency."
                },
                {
                    "step": 3,
                    "title": "Check T->S",
                    "visual": "MapT[t[i]] exists? Must equal s[i].",
                    "explanation": "Backward consistency (No two chars map to same target)."
                }
            ],
            "code": "def isIsomorphic(s, t):\n    mapST, mapTS = {}, {}\n    for c1, c2 in zip(s, t):\n        if (c1 in mapST and mapST[c1] != c2) or \\\n           (c2 in mapTS and mapTS[c2] != c1):\n            return False\n        mapST[c1] = c2\n        mapTS[c2] = c1\n    return True",
            "keyInsight": "Using two maps prevents 'many-to-one' mapping errors (like 'ab' -> 'cc').",
            "visualizationType": "string",
            "initialState": "egg -> add",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Iterate",
                    "visual": "Pair (s[i], t[i]).",
                    "explanation": "Check character mapping."
                },
                {
                    "step": 2,
                    "title": "Check S->T",
                    "visual": "MapS[s[i]] exists? Must equal t[i].",
                    "explanation": "Forward consistency."
                },
                {
                    "step": 3,
                    "title": "Check T->S",
                    "visual": "MapT[t[i]] exists? Must equal s[i].",
                    "explanation": "Backward consistency (No two chars map to same target)."
                }
            ],
            "description": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
            "examples": [
                {
                    "input": "s = \"egg\", t = \"add\"",
                    "output": "true",
                    "explanation": "e->a, g->d"
                },
                {
                    "input": "s = \"foo\", t = \"bar\"",
                    "output": "false",
                    "explanation": "o cannot map to both a and r."
                }
            ],
            "constraints": [
                "1 <= s.length <= 5 * 10^4",
                "t.length == s.length",
                "s and t consist of any valid ascii character."
            ],
            "hints": [
                "Use two hash maps for bidirectional mapping.",
                "Map s[i] to t[i] and t[i] to s[i].",
                "If any mapping conflicts, return false."
            ],
            "relatedProblems": [
                "word-pattern",
                "word-pattern-ii"
            ],
            "videoId": "7yF-U1hLEqQ",
            "problemStatement": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "word-pattern": {
            "title": "Word Pattern",
            "pattern": "Hash Map (Bi-directional)",
            "patternEmoji": "\ud83e\udde9",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Same as Isomorphic Strings, but mapping Char -> Word.",
            "intuition": [
                "\ud83c\udfaf Pattern 'abba' and words 'dog cat cat dog'.",
                "\ud83e\udde0 a -> dog, b -> cat.",
                "\ud83d\udca1 Split string by space, then check 1-to-1 mapping."
            ],
            "testCases": [
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
                    "output": "true"
                },
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
                    "output": "false"
                },
                {
                    "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['dog', 'cat', 'cat', 'dog']",
                    "explanation": "Get tokens."
                },
                {
                    "step": 2,
                    "title": "Length Check",
                    "visual": "If len(pattern) != len(words): False.",
                    "explanation": "Must match length."
                },
                {
                    "step": 3,
                    "title": "Bi-Map",
                    "visual": "Map P->W and W->P. Check conflicts.",
                    "explanation": "Ensure consistency."
                }
            ],
            "code": "def wordPattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words): return False\n    c_to_w, w_to_c = {}, {}\n    for c, w in zip(pattern, words):\n        if c in c_to_w and c_to_w[c] != w: return False\n        if w in w_to_c and w_to_c[w] != c: return False\n        c_to_w[c] = w\n        w_to_c[w] = c\n    return True",
            "keyInsight": "Don't forget to check if lengths differ first!",
            "visualizationType": "string",
            "initialState": "abba -> dog cat cat dog",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['dog', 'cat', 'cat', 'dog']",
                    "explanation": "Get tokens."
                },
                {
                    "step": 2,
                    "title": "Length Check",
                    "visual": "If len(pattern) != len(words): False.",
                    "explanation": "Must match length."
                },
                {
                    "step": 3,
                    "title": "Bi-Map",
                    "visual": "Map P->W and W->P. Check conflicts.",
                    "explanation": "Ensure consistency."
                }
            ],
            "description": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.",
            "examples": [
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
                    "output": "true",
                    "explanation": "a->dog, b->cat"
                },
                {
                    "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
                    "output": "false",
                    "explanation": "a cannot map to both dog and fish."
                }
            ],
            "constraints": [
                "1 <= pattern.length <= 300",
                "pattern contains only lowercase letters.",
                "1 <= s.length <= 3000",
                "s contains lowercase letters and spaces."
            ],
            "hints": [
                "Split s by spaces to get words array.",
                "Use two maps: pattern[i] -> word and word -> pattern[i].",
                "Check for conflicts in both directions."
            ],
            "relatedProblems": [
                "isomorphic-strings",
                "word-pattern-ii"
            ],
            "videoId": "W_akoecmCbM",
            "problemStatement": "Given a pattern and a string s, find if s follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Specifically:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "group-anagrams": {
            "title": "Group Anagrams",
            "pattern": "Hash Map",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(NK)",
            "spaceComplexity": "O(NK)",
            "oneliner": "Map sorted string (or char-count tuple) to list of strings.",
            "intuition": [
                "\ud83c\udfaf All anagrams have the same 'signature'.",
                "\ud83e\udde0 Signature = sorted string ('eat' -> 'aet').",
                "\ud83d\udca1 Store {signature: [list of words]}."
            ],
            "testCases": [
                {
                    "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                    "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
                },
                {
                    "input": "strs = [\"\"]",
                    "output": "[[\"\"]]"
                },
                {
                    "input": "strs = [\"a\"]",
                    "output": "[[\"a\"]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Hash Key",
                    "visual": "\"eat\" -> (1,0,0...1...1) OR \"aet\"",
                    "explanation": "Generate canonical key."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "Map[key].append(word).",
                    "explanation": "Group them."
                },
                {
                    "step": 3,
                    "title": "Collect",
                    "visual": "Return Map.values()",
                    "explanation": "List of lists."
                }
            ],
            "code": "def groupAnagrams(strs):\n    from collections import defaultdict\n    res = defaultdict(list)\n    for s in strs:\n        # Using tuple(sorted(s)) as key\n        # Or char count tuple for O(N) instead of O(N log K)\n        count = [0] * 26\n        for c in s:\n            count[ord(c) - ord('a')] += 1\n        res[tuple(count)].append(s)\n    return list(res.values())",
            "keyInsight": "Using a count-tuple `(2, 1, 0...)` as a dictionary key is efficient and avoids sorting overhead.",
            "visualizationType": "string",
            "initialState": "eat, tea, tan, ate, nat, bat",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Hash Key",
                    "visual": "\"eat\" -> (1,0,0...1...1) OR \"aet\"",
                    "explanation": "Generate canonical key."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "Map[key].append(word).",
                    "explanation": "Group them."
                },
                {
                    "step": 3,
                    "title": "Collect",
                    "visual": "Return Map.values()",
                    "explanation": "List of lists."
                }
            ],
            "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                {
                    "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                    "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                    "explanation": "Grouped by sorted characters."
                },
                {
                    "input": "strs = [\"\"]",
                    "output": "[[\"\"]]",
                    "explanation": "Empty string is its own group."
                }
            ],
            "constraints": [
                "1 <= strs.length <= 10^4",
                "0 <= strs[i].length <= 100",
                "strs[i] consists of lowercase English letters."
            ],
            "hints": [
                "Sort each word and use as key.",
                "Or use character count tuple as key.",
                "Group words with same key together."
            ],
            "relatedProblems": [
                "valid-anagram",
                "find-all-anagrams-in-a-string",
                "group-shifted-strings"
            ],
            "videoId": "vzdNOK2oB2E",
            "problemStatement": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "contains-duplicate-ii": {
            "title": "Contains Duplicate II",
            "pattern": "Sliding Window / Hash Map",
            "patternEmoji": "\u26a0\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(k)",
            "oneliner": "Maintain a window of size k using a set; duplicate in window triggers True.",
            "intuition": [
                "\ud83c\udfaf Duplicate must be within distance k (abs(i-j) <= k).",
                "\ud83e\udde0 Keep latest k elements in a set.",
                "\ud83d\udca1 If current num is in set -> found it!"
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1], k = 3",
                    "output": "true"
                },
                {
                    "input": "nums = [1,0,1,1], k = 1",
                    "output": "true"
                },
                {
                    "input": "nums = [1,2,3,1,2,3], k = 2",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Expand",
                    "visual": "Add nums[i] to window set.",
                    "explanation": "Track recent."
                },
                {
                    "step": 2,
                    "title": "Shrink",
                    "visual": "If window size > k, remove nums[i-k].",
                    "explanation": "Maintain invariant."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "nums[i] already in set? True.",
                    "explanation": "Collision detected."
                }
            ],
            "code": "def containsNearbyDuplicate(nums, k):\n    window = set()\n    l = 0\n    for r in range(len(nums)):\n        if r - l > k:\n            window.remove(nums[l])\n            l += 1\n        if nums[r] in window:\n            return True\n        window.add(nums[r])\n    return False",
            "keyInsight": "Removing the element falling out of the window makes lookups O(1).",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Expand",
                    "visual": "Add nums[i] to window set.",
                    "explanation": "Track recent."
                },
                {
                    "step": 2,
                    "title": "Shrink",
                    "visual": "If window size > k, remove nums[i-k].",
                    "explanation": "Maintain invariant."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "nums[i] already in set? True.",
                    "explanation": "Collision detected."
                }
            ],
            "description": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1], k = 3",
                    "output": "true",
                    "explanation": "nums[0] == nums[3] and 3-0 = 3 <= 3."
                },
                {
                    "input": "nums = [1,2,3,1,2,3], k = 2",
                    "output": "false",
                    "explanation": "Duplicate 1s are 3 apart, not <= 2."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9",
                "0 <= k <= 10^5"
            ],
            "hints": [
                "Use sliding window with hash set of size k.",
                "Or use hash map storing last seen index.",
                "Check if current index - last index <= k."
            ],
            "relatedProblems": [
                "contains-duplicate",
                "contains-duplicate-iii"
            ],
            "videoId": "ypn0aZ0nrL4",
            "problemStatement": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "longest-consecutive-sequence": {
            "title": "Longest Consecutive Sequence",
            "pattern": "Hash Set",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Only start counting if (num-1) is NOT in set. This ensures we only count from sequence starts.",
            "intuition": [
                "\ud83c\udfaf We want 1, 2, 3, 4 given unsorted inputs.",
                "\ud83e\udde0 Hash Set gives O(1) lookup.",
                "\ud83d\udca1 Key: Don't count '2' if '1' exists. Only start counting at '1'. Avoids O(n^2)."
            ],
            "testCases": [
                {
                    "input": "nums = [100,4,200,1,3,2]",
                    "output": "4"
                },
                {
                    "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                    "output": "9"
                },
                {
                    "input": "nums = [1,0,1,2]",
                    "output": "3"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Setify",
                    "visual": "{100, 4, 200, 1, 3, 2}",
                    "explanation": "Remove dupes, fast access."
                },
                {
                    "step": 2,
                    "title": "Check Start",
                    "visual": "Is 100-1 in set? No. Start chain. 100... len 1.\nIs 4-1 (3) in set? Yes. Skip.",
                    "explanation": "Ensure single traversal."
                },
                {
                    "step": 3,
                    "title": "Expand",
                    "visual": "At 1: 1 in, 2 in, 3 in, 4 in. Stop. Len 4.",
                    "explanation": "Count sequence."
                }
            ],
            "code": "def longestConsecutive(nums):\n    numSet = set(nums)\n    longest = 0\n    for n in numSet:\n        if (n - 1) not in numSet:\n            length = 0\n            while (n + length) in numSet:\n                length += 1\n            longest = max(length, longest)\n    return longest",
            "keyInsight": "Checking `if (n-1) not in set` ensures each sequence is only processed ONCE, making it linear.",
            "visualizationType": "array",
            "initialState": [
                100,
                4,
                200,
                1,
                3,
                2
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Setify",
                    "visual": "{100, 4, 200, 1, 3, 2}",
                    "explanation": "Remove dupes, fast access."
                },
                {
                    "step": 2,
                    "title": "Check Start",
                    "visual": "Is 100-1 in set? No. Start chain. 100... len 1.\nIs 4-1 (3) in set? Yes. Skip.",
                    "explanation": "Ensure single traversal."
                },
                {
                    "step": 3,
                    "title": "Expand",
                    "visual": "At 1: 1 in, 2 in, 3 in, 4 in. Stop. Len 4.",
                    "explanation": "Count sequence."
                }
            ],
            "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.",
            "examples": [
                {
                    "input": "nums = [100,4,200,1,3,2]",
                    "output": "4",
                    "explanation": "Longest consecutive is [1,2,3,4]."
                },
                {
                    "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                    "output": "9",
                    "explanation": "0 to 8 is 9 consecutive."
                }
            ],
            "constraints": [
                "0 <= nums.length <= 10^5",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "hints": [
                "Put all numbers in a set.",
                "For each number, check if it's the start of a sequence (n-1 not in set).",
                "If so, count consecutive numbers."
            ],
            "relatedProblems": [
                "binary-tree-longest-consecutive-sequence",
                "find-three-consecutive-integers-that-sum-to-a-given-number"
            ],
            "videoId": "P6RZZMu_maU",
            "problemStatement": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "insert-delete-getrandom-o1": {
            "title": "Insert Delete GetRandom O(1)",
            "pattern": "Hash Map + Dynamic Array",
            "patternEmoji": "\ud83c\udfb2",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Map stores {val: index}. To delete, swap val with last element, then pop.",
            "intuition": [
                "\ud83c\udfaf List allows O(1) random access (choice).",
                "\ud83e\udde0 Hashmap allows O(1) lookup/delete logic.",
                "\ud83d\udca1 Problem: Deleting from middle of list is O(n). Solution: Swap with end, then pop!"
            ],
            "testCases": [
                {
                    "input": "ops = [\"RandomizedSet\",\"insert\",\"remove\",\"getRandom\"]; args = [[],[1],[2],[]]",
                    "output": "[null,true,false,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Insert",
                    "visual": "Append to list. Map[val] = len-1.",
                    "explanation": "Easy O(1)."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Val at index `i`. Swap list[i] with list[end]. Update map for swapped item. Pop list.",
                    "explanation": "O(1) removal."
                },
                {
                    "step": 3,
                    "title": "Random",
                    "visual": "random.choice(list)",
                    "explanation": "Uniform distribution."
                }
            ],
            "code": "import random\nclass RandomizedSet:\n    def __init__(self):\n        self.valMap = {}\n        self.valList = []\n    def insert(self, val):\n        if val in self.valMap: return False\n        self.valMap[val] = len(self.valList)\n        self.valList.append(val)\n        return True\n    def remove(self, val):\n        if val not in self.valMap: return False\n        idx = self.valMap[val]\n        lastVal = self.valList[-1]\n        self.valList[idx] = lastVal\n        self.valMap[lastVal] = idx\n        self.valList.pop()\n        del self.valMap[val]\n        return True\n    def getRandom(self):\n        return random.choice(self.valList)",
            "keyInsight": "The 'Swap and Pop' technique is crucial for O(1) deletions in arrays.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Insert",
                    "visual": "Append to list. Map[val] = len-1.",
                    "explanation": "Easy O(1)."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Val at index `i`. Swap list[i] with list[end]. Update map for swapped item. Pop list.",
                    "explanation": "O(1) removal."
                },
                {
                    "step": 3,
                    "title": "Random",
                    "visual": "random.choice(list)",
                    "explanation": "Uniform distribution."
                }
            ],
            "description": "Implement the RandomizedSet class: RandomizedSet() Initializes the object. bool insert(int val) Inserts an item val if not present. Returns true if not present, false otherwise. bool remove(int val) Removes an item val if present. Returns true if present, false otherwise. int getRandom() Returns a random element from the current set. Each element must have the same probability of being returned.",
            "examples": [
                {
                    "input": "[[\"RandomizedSet\"],[\"insert\"],[\"remove\"],[\"insert\"],[\"getRandom\"],[\"remove\"],[\"insert\"],[\"getRandom\"]], [[],[1],[2],[2],[],[1],[2],[]]",
                    "output": "[null,true,false,true,2,true,false,2]",
                    "explanation": "Operations performed in sequence."
                }
            ],
            "constraints": [
                "-2^31 <= val <= 2^31 - 1",
                "At most 2 * 10^5 calls will be made to insert, remove, and getRandom.",
                "There will be at least one element in the data structure when getRandom is called."
            ],
            "hints": [
                "Use array + hash map.",
                "Hash map stores val -> index.",
                "On remove, swap with last element for O(1)."
            ],
            "relatedProblems": [
                "insert-delete-getrandom-o1-duplicates-allowed"
            ],
            "videoId": "j4KwhBziOpg",
            "problemStatement": "Implement the RandomizedSet class:\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\nExample 1:\nConstraints:",
            "difficulty": "Medium"
        },
        "how-many-numbers-are-smaller-than-the-current-number": {
            "title": "How Many Numbers Are Smaller Than the Current Number",
            "pattern": "Bucket Sort / Counting",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1) (range limited)",
            "oneliner": "Count occurrences, prefix sum to find cumulative count smaller.",
            "intuition": [
                "\ud83c\udfaf If 5 numbers are <= 7, and 2 numbers are == 7, then 3 are < 7.",
                "\ud83e\udde0 Frequency array tracks counts.",
                "\ud83d\udca1 Prefix sums give 'count of numbers <= i'."
            ],
            "testCases": [
                {
                    "input": "nums = [8,1,2,2,3]",
                    "output": "[4,0,1,1,3]"
                },
                {
                    "input": "nums = [6,5,4,8]",
                    "output": "[2,1,0,3]"
                },
                {
                    "input": "nums = [7,7,7,7]",
                    "output": "[0,0,0,0]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Freq array of size 101.",
                    "explanation": "Constraints say nums[i] <= 100."
                },
                {
                    "step": 2,
                    "title": "Prefix Sum",
                    "visual": "freq[i] += freq[i-1].",
                    "explanation": "Cumulative count."
                },
                {
                    "step": 3,
                    "title": "Map",
                    "visual": "Res[i] = freq[nums[i]-1].",
                    "explanation": "Get numbers strictly smaller."
                }
            ],
            "code": "def smallerNumbersThanCurrent(nums):\n    count = [0] * 102\n    for n in nums: count[n+1] += 1\n    for i in range(1, 102): count[i] += count[i-1]\n    return [count[n] for n in nums]",
            "keyInsight": "Using the input constraints (0-100) allows faster-than-sorting O(n) solution using counting sort ideas.",
            "visualizationType": "array",
            "initialState": [
                8,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Freq array of size 101.",
                    "explanation": "Constraints say nums[i] <= 100."
                },
                {
                    "step": 2,
                    "title": "Prefix Sum",
                    "visual": "freq[i] += freq[i-1].",
                    "explanation": "Cumulative count."
                },
                {
                    "step": 3,
                    "title": "Map",
                    "visual": "Res[i] = freq[nums[i]-1].",
                    "explanation": "Get numbers strictly smaller."
                }
            ],
            "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].",
            "examples": [
                {
                    "input": "nums = [8,1,2,2,3]",
                    "output": "[4,0,1,1,3]",
                    "explanation": "For 8, there are 4 smaller numbers."
                },
                {
                    "input": "nums = [6,5,4,8]",
                    "output": "[2,1,0,3]",
                    "explanation": "Count smaller numbers for each."
                }
            ],
            "constraints": [
                "2 <= nums.length <= 500",
                "0 <= nums[i] <= 100"
            ],
            "hints": [
                "Use counting sort since values <= 100.",
                "Build prefix sum of counts.",
                "Answer for nums[i] is prefix[nums[i]]."
            ],
            "relatedProblems": [
                "count-of-smaller-numbers-after-self",
                "reverse-pairs"
            ],
            "videoId": "x2K_4xNxCME",
            "problemStatement": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].\nReturn the answer in an array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "simplify-path": {
            "title": "Simplify Path",
            "pattern": "Stack",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Split by '/'. Stack keeps directories. '..' pops, '.' ignores.",
            "intuition": [
                "\ud83c\udfaf Canonical path logic.",
                "\ud83e\udde0 '..' means go up (pop).",
                "\ud83d\udca1 '.' or empty means stay (ignore)."
            ],
            "testCases": [
                {
                    "input": "path = \"/home/\"",
                    "output": "\"/home\""
                },
                {
                    "input": "path = \"/home//foo/\"",
                    "output": "\"/home/foo\""
                },
                {
                    "input": "path = \"/home/user/Documents/../Pictures\"",
                    "output": "\"/home/user/Pictures\""
                },
                {
                    "input": "path = \"/../\"",
                    "output": "\"/\""
                },
                {
                    "input": "path = \"/.../a/../b/c/../d/./\"",
                    "output": "\"/.../b/d\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['a', '.', 'b', '..', '..', 'c']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Process",
                    "visual": "'a': push. '.': skip. 'b': push. '..': pop(b). '..': pop(a). 'c': push.",
                    "explanation": "Stack operations."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'/' + join(stack)",
                    "explanation": "Rebuild."
                }
            ],
            "code": "def simplifyPath(path):\n    stack = []\n    for portion in path.split('/'):\n        if portion == '..':\n            if stack: stack.pop()\n        elif portion == '.' or not portion:\n            continue\n        else:\n            stack.append(portion)\n    return '/' + '/'.join(stack)",
            "keyInsight": "Splitting by slash handles multiple slashes `//` automatically (producing empty strings to ignore).",
            "visualizationType": "string",
            "initialState": "/a/./b/../../c/",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['a', '.', 'b', '..', '..', 'c']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Process",
                    "visual": "'a': push. '.': skip. 'b': push. '..': pop(b). '..': pop(a). 'c': push.",
                    "explanation": "Stack operations."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'/' + join(stack)",
                    "explanation": "Rebuild."
                }
            ],
            "description": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.",
            "examples": [
                {
                    "input": "path = \"/home/\"",
                    "output": "\"/home\"",
                    "explanation": "Remove trailing slash."
                },
                {
                    "input": "path = \"/../\"",
                    "output": "\"/\"",
                    "explanation": "Cannot go above root."
                },
                {
                    "input": "path = \"/home//foo/\"",
                    "output": "\"/home/foo\"",
                    "explanation": "Multiple slashes treated as one."
                }
            ],
            "constraints": [
                "1 <= path.length <= 3000",
                "path consists of English letters, digits, period '.', slash '/' or '_'."
            ],
            "hints": [
                "Split by '/' and use a stack.",
                "Ignore empty strings and '.'. Pop for '..'.",
                "Join stack with '/' at the end."
            ],
            "relatedProblems": [
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "qYlHrAKJfyA",
            "problemStatement": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Your task is to transform this absolute path into its simplified canonical path.\nThe rules of a Unix-style file system are as follows:\nThe simplified canonical path should follow these rules:\nReturn the simplified canonical path.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nExample 5:\nConstraints:",
            "difficulty": "Medium"
        },
        "min-stack": {
            "title": "Min Stack",
            "pattern": "Stack (Two Stacks)",
            "patternEmoji": "\u2b07\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Maintain a second stack tracking the minimum value at each depth.",
            "intuition": [
                "\ud83c\udfaf Get Min in O(1).",
                "\ud83e\udde0 Normal stack holds values.",
                "\ud83d\udca1 MinStack holds min_so_far. Push? min(val, top). Pop? Pop both."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]; args = [[],[-2],[0],[-3],[],[],[],[]]",
                    "output": "[null,null,null,null,-3,null,0,-2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Main: [-2]. MinStack: [-2].",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "Push Smaller",
                    "visual": "Main: [-2, -3]. MinStack: [-2, -3].",
                    "explanation": "New min found."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Pop both. Min reverts to -2.",
                    "explanation": "Sync."
                }
            ],
            "code": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()\n    def top(self): return self.stack[-1]\n    def getMin(self): return self.minStack[-1]",
            "keyInsight": "The minimum history needs to be stacked because when we pop the minimum, we need to know what the *previous* minimum was.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Main: [-2]. MinStack: [-2].",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "Push Smaller",
                    "visual": "Main: [-2, -3]. MinStack: [-2, -3].",
                    "explanation": "New min found."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Pop both. Min reverts to -2.",
                    "explanation": "Sync."
                }
            ],
            "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
            "examples": [
                {
                    "input": "[[\"MinStack\"],[\"push\"],[\"push\"],[\"push\"],[\"getMin\"],[\"pop\"],[\"top\"],[\"getMin\"]], [[],[-2],[0],[-3],[],[],[],[]]",
                    "output": "[null,null,null,null,-3,null,0,-2]",
                    "explanation": "Min tracking works correctly."
                }
            ],
            "constraints": [
                "-2^31 <= val <= 2^31 - 1",
                "Methods pop, top and getMin will always be called on non-empty stacks.",
                "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
            ],
            "hints": [
                "Use two stacks: one for values, one for minimums.",
                "Or store pairs (value, current_min) in single stack.",
                "Update min on each push."
            ],
            "relatedProblems": [
                "max-stack",
                "implement-stack-using-queues"
            ],
            "videoId": "qkLl7nAwDPo",
            "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nYou must implement a solution with O(1) time complexity for each function.\nExample 1:\nConstraints:",
            "difficulty": "Medium"
        },
        "evaluate-reverse-polish-notation": {
            "title": "Evaluate Reverse Polish Notation",
            "pattern": "Stack",
            "patternEmoji": "\u2797\u2796",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push numbers. Operator? Pop two, apply, push result.",
            "intuition": [
                "\ud83c\udfaf Postfix notation (3 4 +) eliminates parenthesis ambiguity.",
                "\ud83e\udde0 Stack holds operands waiting for an operator.",
                "\ud83d\udca1 Saw '+'? Pop 4, Pop 3. Do 3+4=7. Push 7."
            ],
            "testCases": [
                {
                    "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9"
                },
                {
                    "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
                    "output": "6"
                },
                {
                    "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
                    "output": "22"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Stack: [2, 1]",
                    "explanation": "Operands."
                },
                {
                    "step": 2,
                    "title": "Op +",
                    "visual": "Pop 1, 2. Add -> 3. Stack: [3].",
                    "explanation": "Execute."
                },
                {
                    "step": 3,
                    "title": "Continue",
                    "visual": "Push 3. Op *. 3 * 3 = 9.",
                    "explanation": "Chain."
                }
            ],
            "code": "def evalRPN(tokens):\n    stack = []\n    for t in tokens:\n        if t not in \"+-*/\":\n            stack.append(int(t))\n        else:\n            b, a = stack.pop(), stack.pop()\n            if t == \"+\": stack.append(a + b)\n            elif t == \"-\": stack.append(a - b)\n            elif t == \"*\": stack.append(a * b)\n            else: stack.append(int(a / b))\n    return stack[0]",
            "keyInsight": "Careful with division: 'int(a / b)' truncates toward zero in Python, unlike '//' which floors.",
            "visualizationType": "array",
            "initialState": [
                "2",
                "1",
                "+",
                "3",
                "*"
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Push",
                    "visual": "Stack: [2, 1]",
                    "explanation": "Operands."
                },
                {
                    "step": 2,
                    "title": "Op +",
                    "visual": "Pop 1, 2. Add -> 3. Stack: [3].",
                    "explanation": "Execute."
                },
                {
                    "step": 3,
                    "title": "Continue",
                    "visual": "Push 3. Op *. 3 * 3 = 9.",
                    "explanation": "Chain."
                }
            ],
            "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression.",
            "examples": [
                {
                    "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9",
                    "explanation": "((2 + 1) * 3) = 9"
                },
                {
                    "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
                    "output": "6",
                    "explanation": "(4 + (13 / 5)) = 6"
                }
            ],
            "constraints": [
                "1 <= tokens.length <= 10^4",
                "tokens[i] is an operator or an integer in range [-200, 200]."
            ],
            "hints": [
                "Use a stack.",
                "Push operands. On operator, pop two operands, compute, push result.",
                "Note: division truncates toward zero."
            ],
            "relatedProblems": [
                "basic-calculator",
                "basic-calculator-ii",
                "expression-add-operators"
            ],
            "videoId": "iu0082c4HDE",
            "problemStatement": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "basic-calculator": {
            "title": "Basic Calculator",
            "pattern": "Stack (Signs)",
            "patternEmoji": "\ud83d\udc22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Track result and sign. Parenthesis? Push current result & sign, reset.",
            "intuition": [
                "\ud83c\udfaf Linear scan with recursion simulated by stack.",
                "\ud83e\udde0 '(': Stash current state. Start fresh sub-problem.",
                "\ud83d\udca1 ')': Finish sub-problem, multiply by stashed sign, add stashed result."
            ],
            "testCases": [
                {
                    "input": "s = \"1 + 1\"",
                    "output": "2"
                },
                {
                    "input": "s = \" 2-1 + 2 \"",
                    "output": "3"
                },
                {
                    "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
                    "output": "23"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Update 'res' with num*sign.",
                    "explanation": "Accumulate."
                },
                {
                    "step": 2,
                    "title": "Open (",
                    "visual": "Push res, sign. Res=0, Sign=1.",
                    "explanation": "Context switch."
                },
                {
                    "step": 3,
                    "title": "Close )",
                    "visual": "Res = Res * pop_sign + pop_res.",
                    "explanation": "Resolve scope."
                }
            ],
            "code": "def calculate(s):\n    res, num, sign, stack = 0, 0, 1, []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c in '+-':\n            res += sign * num\n            num = 0\n            sign = 1 if c == '+' else -1\n        elif c == '(': \n            stack.append(res)\n            stack.append(sign)\n            sign = 1\n            res = 0\n        elif c == ')':\n            res += sign * num\n            res *= stack.pop()\n            res += stack.pop()\n            num = 0\n    return res + num * sign",
            "keyInsight": "Only one 'sign' variable is needed to handle +/-, applying it lazily when a number ends.",
            "visualizationType": "string",
            "initialState": "(1+(4+5+2)-3)+(6+8)",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Update 'res' with num*sign.",
                    "explanation": "Accumulate."
                },
                {
                    "step": 2,
                    "title": "Open (",
                    "visual": "Push res, sign. Res=0, Sign=1.",
                    "explanation": "Context switch."
                },
                {
                    "step": 3,
                    "title": "Close )",
                    "visual": "Res = Res * pop_sign + pop_res.",
                    "explanation": "Resolve scope."
                }
            ],
            "description": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions.",
            "examples": [
                {
                    "input": "s = \"1 + 1\"",
                    "output": "2",
                    "explanation": "1 + 1 = 2"
                },
                {
                    "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
                    "output": "23",
                    "explanation": "Evaluate nested parentheses."
                }
            ],
            "constraints": [
                "1 <= s.length <= 3 * 10^5",
                "s consists of digits, '+', '-', '(', ')', and ' '.",
                "s represents a valid expression.",
                "'+' is not used as unary operation."
            ],
            "hints": [
                "Use stack to handle nested parentheses.",
                "Track current result and sign.",
                "On '(', push current state. On ')', pop and apply."
            ],
            "relatedProblems": [
                "basic-calculator-ii",
                "basic-calculator-iii",
                "evaluate-reverse-polish-notation"
            ],
            "videoId": "081AqOuasw0",
            "problemStatement": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Hard"
        },
        "implement-stack-using-queues": {
            "title": "Implement Stack using Queues",
            "pattern": "Queue Rotation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "Push O(n), Pop O(1)",
            "spaceComplexity": "O(n)",
            "oneliner": "Push to queue, then rotate (pop & push back) all previous elements to keep new element at front.",
            "intuition": [
                "\ud83c\udfaf Queue is FIFO. Stack is LIFO.",
                "\ud83e\udde0 To make Queue look LIFO, the 'newest' item must be at the head.",
                "\ud83d\udca1 After appending X, rotate all other N items behind X."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MyStack\",\"push\",\"push\",\"pop\",\"top\",\"empty\"]; args = [[],[1],[2],[],[],[]]",
                    "output": "[null,null,null,2,1,false]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Push X",
                    "visual": "Q appends X. Q: [1, 2, X].",
                    "explanation": "Wrong order."
                },
                {
                    "step": 2,
                    "title": "Rotate",
                    "visual": "Pop 1, Push 1. Pop 2, Push 2. Q: [X, 1, 2].",
                    "explanation": "X is now front."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Q.popleft() returns X.",
                    "explanation": "LIFO behavior achieved."
                }
            ],
            "code": "from collections import deque\nclass MyStack:\n    def __init__(self):\n        self.q = deque()\n    def push(self, x):\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.popleft())\n    def pop(self): return self.q.popleft()\n    def top(self): return self.q[0]\n    def empty(self): return not self.q",
            "keyInsight": "Single queue is sufficient if we rotate it!",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Push X",
                    "visual": "Q appends X. Q: [1, 2, X].",
                    "explanation": "Wrong order."
                },
                {
                    "step": 2,
                    "title": "Rotate",
                    "visual": "Pop 1, Push 1. Pop 2, Push 2. Q: [X, 1, 2].",
                    "explanation": "X is now front."
                },
                {
                    "step": 3,
                    "title": "Pop",
                    "visual": "Q.popleft() returns X.",
                    "explanation": "LIFO behavior achieved."
                }
            ],
            "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).",
            "examples": [
                {
                    "input": "[[\"MyStack\"],[\"push\"],[\"push\"],[\"top\"],[\"pop\"],[\"empty\"]], [[],[1],[2],[],[],[]]",
                    "output": "[null,null,null,2,2,false]",
                    "explanation": "Stack operations using queues."
                }
            ],
            "constraints": [
                "1 <= x <= 9",
                "At most 100 calls will be made to push, pop, top, and empty.",
                "All calls to pop and top are valid."
            ],
            "hints": [
                "On push, add to queue then rotate n-1 times.",
                "This puts new element at front.",
                "Pop and top become O(1)."
            ],
            "relatedProblems": [
                "implement-queue-using-stacks",
                "min-stack"
            ],
            "videoId": "rW4vm0-DLYc",
            "problemStatement": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\nNotes:\nExample 1:\nConstraints:\nFollow-up: Can you implement the stack using only one queue?",
            "difficulty": "Easy"
        },
        "add-two-numbers": {
            "title": "Add Two Numbers",
            "pattern": "Linked List Math",
            "patternEmoji": "\ud83d\udcda",
            "timeComplexity": "O(max(m, n))",
            "spaceComplexity": "O(max(m, n))",
            "oneliner": "Traverse both lists, add digits + carry, create new node.",
            "intuition": [
                "\ud83c\udfaf Just like elementary math: add right-to-left.",
                "\ud83e\udde0 Lists are already reversed (digits at head).",
                "\ud83d\udca1 Don't forget the final carry if it exists!"
            ],
            "testCases": [
                {
                    "input": "l1 = [2,4,3], l2 = [5,6,4]",
                    "output": "[7,0,8]"
                },
                {
                    "input": "l1 = [0], l2 = [0]",
                    "output": "[0]"
                },
                {
                    "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
                    "output": "[8,9,9,9,0,0,0,1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Dummy node. Carry = 0.",
                    "explanation": "Base setup."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum // 10.",
                    "explanation": "Standard addition."
                },
                {
                    "step": 3,
                    "title": "Next",
                    "visual": "Move l1, l2 pointers if not null.",
                    "explanation": "Iterate."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef addTwoNumbers(l1, l2):\n    dummy = ListNode()\n    cur = dummy\n    carry = 0\n    while l1 or l2 or carry:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        val = v1 + v2 + carry\n        carry = val // 10\n        val = val % 10\n        cur.next = ListNode(val)\n        cur = cur.next\n        if l1: l1 = l1.next\n        if l2: l2 = l2.next\n    return dummy.next",
            "keyInsight": "Using 'v1 = l1.val if l1 else 0' cleans up the code significantly, removing null checks inside the addition.",
            "visualizationType": "linked-list",
            "initialState": [
                2,
                4,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Dummy node. Carry = 0.",
                    "explanation": "Base setup."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "Sum = v1 + v2 + carry. New val = Sum % 10. Carry = Sum // 10.",
                    "explanation": "Standard addition."
                },
                {
                    "step": 3,
                    "title": "Next",
                    "visual": "Move l1, l2 pointers if not null.",
                    "explanation": "Iterate."
                }
            ],
            "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
            "examples": [
                {
                    "input": "l1 = [2,4,3], l2 = [5,6,4]",
                    "output": "[7,0,8]",
                    "explanation": "342 + 465 = 807"
                },
                {
                    "input": "l1 = [9,9,9,9], l2 = [9,9,9]",
                    "output": "[8,9,9,0,1]",
                    "explanation": "9999 + 999 = 10998"
                }
            ],
            "constraints": [
                "The number of nodes in each list is in range [1, 100].",
                "0 <= Node.val <= 9",
                "The lists represent numbers without leading zeros (except 0 itself)."
            ],
            "hints": [
                "Iterate both lists simultaneously.",
                "Track carry for sums >= 10.",
                "Don't forget the final carry!"
            ],
            "relatedProblems": [
                "multiply-strings",
                "add-binary",
                "add-two-numbers-ii"
            ],
            "videoId": "wgFPrzTjm7s",
            "problemStatement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "merge-two-sorted-lists": {
            "title": "Merge Two Sorted Lists",
            "pattern": "Linked List / Two Pointers",
            "patternEmoji": "\ud83d\udd00",
            "timeComplexity": "O(m+n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use a dummy head; stitch nodes from l1 or l2 whichever is smaller.",
            "intuition": [
                "\ud83c\udfaf Zipper merge.",
                "\ud83e\udde0 Compare heads. Attach smaller to 'tail'.",
                "\ud83d\udca1 Advance the chosen one."
            ],
            "testCases": [
                {
                    "input": "list1 = [1,2,4], list2 = [1,3,4]",
                    "output": "[1,1,2,3,4,4]"
                },
                {
                    "input": "list1 = [], list2 = []",
                    "output": "[]"
                },
                {
                    "input": "list1 = [], list2 = [0]",
                    "output": "[0]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Dummy",
                    "visual": "Tail -> Dummy.",
                    "explanation": "Simplifies edge cases."
                },
                {
                    "step": 2,
                    "title": "Stitch",
                    "visual": "l1.val < l2.val? Tail.next = l1. l1 = l1.next.",
                    "explanation": "Pick smallest."
                },
                {
                    "step": 3,
                    "title": "Cleanup",
                    "visual": "Tail.next = l1 or l2 (whichever remains).",
                    "explanation": "Attach rest."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef mergeTwoLists(list1, list2):\n    dummy = ListNode()\n    tail = dummy\n    while list1 and list2:\n        if list1.val < list2.val:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    if list1:\n        tail.next = list1\n    elif list2:\n        tail.next = list2\n    return dummy.next",
            "keyInsight": "We don't create new nodes; we just re-link existing ones.",
            "visualizationType": "linked-list",
            "initialState": [
                1,
                2,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Dummy",
                    "visual": "Tail -> Dummy.",
                    "explanation": "Simplifies edge cases."
                },
                {
                    "step": 2,
                    "title": "Stitch",
                    "visual": "l1.val < l2.val? Tail.next = l1. l1 = l1.next.",
                    "explanation": "Pick smallest."
                },
                {
                    "step": 3,
                    "title": "Cleanup",
                    "visual": "Tail.next = l1 or l2 (whichever remains).",
                    "explanation": "Attach rest."
                }
            ],
            "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
            "examples": [
                {
                    "input": "list1 = [1,2,4], list2 = [1,3,4]",
                    "output": "[1,1,2,3,4,4]",
                    "explanation": "Merged in sorted order."
                },
                {
                    "input": "list1 = [], list2 = []",
                    "output": "[]",
                    "explanation": "Both empty."
                },
                {
                    "input": "list1 = [], list2 = [0]",
                    "output": "[0]",
                    "explanation": "One empty, one with element."
                }
            ],
            "constraints": [
                "The number of nodes in both lists is in range [0, 50].",
                "-100 <= Node.val <= 100",
                "Both lists are sorted in non-decreasing order."
            ],
            "hints": [
                "Use a dummy node to simplify the code.",
                "Compare heads of both lists, take the smaller one.",
                "Move the pointer forward on the list you took from."
            ],
            "relatedProblems": [
                "merge-sorted-array",
                "merge-k-sorted-lists",
                "sort-list"
            ],
            "videoId": "XIdigk956u0",
            "problemStatement": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "copy-list-with-random-pointer": {
            "title": "Copy List with Random Pointer",
            "pattern": "Hash Map / Interweaving",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n) (or O(1) interweave)",
            "oneliner": "Two passes: 1. Create copy nodes mapped in dict. 2. Link next/random using dict.",
            "intuition": [
                "\ud83c\udfaf Deep copy means new nodes.",
                "\ud83e\udde0 Random pointers might point to nodes not visited yet.",
                "\ud83d\udca1 Map {OldNode -> NewNode} solves strict reference issues."
            ],
            "testCases": [
                {
                    "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]"
                },
                {
                    "input": "head = [[1,1],[2,1]]",
                    "output": "[[1,1],[2,1]]"
                },
                {
                    "input": "head = [[3,null],[3,0],[3,null]]",
                    "output": "[[3,null],[3,0],[3,null]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Iterate. Map[old] = Node(old.val).",
                    "explanation": "Create clones."
                },
                {
                    "step": 2,
                    "title": "Link",
                    "visual": "Iterate. copy.next = map[old.next]. copy.random = map[old.random].",
                    "explanation": "Wire up."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return map[head].",
                    "explanation": "Done."
                }
            ],
            "code": "class Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head: return None\n    oldToCopy = {None: None}\n    cur = head\n    while cur:\n        copy = Node(cur.val)\n        oldToCopy[cur] = copy\n        cur = cur.next\n    cur = head\n    while cur:\n        copy = oldToCopy[cur]\n        copy.next = oldToCopy[cur.next]\n        copy.random = oldToCopy[cur.random]\n        cur = cur.next\n    return oldToCopy[head]",
            "keyInsight": "The hashmap approach is simplest. The O(1) space 'interweaving' approach is clever but much harder to implement correctly in an interview.",
            "visualizationType": "linked-list",
            "initialState": [
                [
                    7,
                    null
                ],
                [
                    13,
                    0
                ],
                [
                    11,
                    4
                ],
                [
                    10,
                    2
                ],
                [
                    1,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Iterate. Map[old] = Node(old.val).",
                    "explanation": "Create clones."
                },
                {
                    "step": 2,
                    "title": "Link",
                    "visual": "Iterate. copy.next = map[old.next]. copy.random = map[old.random].",
                    "explanation": "Wire up."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return map[head].",
                    "explanation": "Done."
                }
            ],
            "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list.",
            "examples": [
                {
                    "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
                    "explanation": "Deep copy with same structure."
                }
            ],
            "constraints": [
                "0 <= n <= 1000",
                "-10^4 <= Node.val <= 10^4",
                "Node.random is null or points to a node in the list."
            ],
            "hints": [
                "Use hash map: old node -> new node.",
                "First pass: create all new nodes.",
                "Second pass: connect next and random pointers."
            ],
            "relatedProblems": [
                "clone-graph",
                "clone-binary-tree-with-random-pointer"
            ],
            "videoId": "5Y2EiZST97Y",
            "problemStatement": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nYour code will only be given the head of the original linked list.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "reverse-linked-list-ii": {
            "title": "Reverse Linked List II",
            "pattern": "Linked List Manipulation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reach 'left'; reverse 'right-left' times; reconnect.",
            "intuition": [
                "\ud83c\udfaf Use a Dummy to handle edge case (left=1).",
                "\ud83e\udde0 'prev' sits before reversing starts.",
                "\ud83d\udca1 Reverse the sub-segment standard way. Fix connections."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5], left = 2, right = 4",
                    "output": "[1,4,3,2,5]"
                },
                {
                    "input": "head = [5], left = 1, right = 1",
                    "output": "[5]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Reach",
                    "visual": "Move prev to left-1.",
                    "explanation": "Positioning."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "For i in range(r-l): temp=curr.next; curr.next=temp.next; temp.next=prev.next; prev.next=temp.",
                    "explanation": "Bubble swap."
                },
                {
                    "step": 3,
                    "title": "Done",
                    "visual": "Return dummy.next.",
                    "explanation": "Head might change."
                }
            ],
            "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\ndef reverseBetween(head, left, right):\n    dummy = ListNode(0, head)\n    leftPrev, cur = dummy, head\n    for i in range(left - 1):\n        leftPrev, cur = cur, cur.next\n    prev = None\n    for i in range(right - left + 1):\n        tmp = cur.next\n        cur.next = prev\n        prev, cur = cur, tmp\n    # Connect\n    leftPrev.next.next = cur\n    leftPrev.next = prev\n    return dummy.next",
            "keyInsight": "It's easier to fully reverse the sublist using standard Prev/Curr/Next logic, then stitch the ends `leftPrev` and `cur` back.",
            "visualizationType": "linked-list",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Reach",
                    "visual": "Move prev to left-1.",
                    "explanation": "Positioning."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "For i in range(r-l): temp=curr.next; curr.next=temp.next; temp.next=prev.next; prev.next=temp.",
                    "explanation": "Bubble swap."
                },
                {
                    "step": 3,
                    "title": "Done",
                    "visual": "Return dummy.next.",
                    "explanation": "Head might change."
                }
            ],
            "description": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5], left = 2, right = 4",
                    "output": "[1,4,3,2,5]",
                    "explanation": "Nodes 2-4 are reversed."
                },
                {
                    "input": "head = [5], left = 1, right = 1",
                    "output": "[5]",
                    "explanation": "Single node, nothing to reverse."
                }
            ],
            "constraints": [
                "The number of nodes is n.",
                "1 <= n <= 500",
                "-500 <= Node.val <= 500",
                "1 <= left <= right <= n"
            ],
            "hints": [
                "Use dummy node for clean edge cases.",
                "Find the node before 'left' position.",
                "Reverse nodes from left to right using standard technique."
            ],
            "relatedProblems": [
                "reverse-linked-list",
                "reverse-nodes-in-k-group"
            ],
            "videoId": "RF_M9tX4Eag",
            "problemStatement": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "maximum-depth-of-binary-tree": {
            "title": "Maximum Depth of Binary Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "1 + max(dfs(left), dfs(right))",
            "intuition": [
                "\ud83c\udfaf Base case: Null node has depth 0.",
                "\ud83e\udde0 Recursive step: I am 1 deeper than my deepest child.",
                "\ud83d\udca1 Return 1 + max(L, R)."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "3"
                },
                {
                    "input": "root = [1,null,2]",
                    "output": "2"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Base",
                    "visual": "If zero? Ret 0.",
                    "explanation": "Leaf check."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "L = depth(left), R = depth(right).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Combine",
                    "visual": "Ret 1 + max(L, R).",
                    "explanation": "Count me."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef maxDepth(root):\n    if not root: return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))",
            "keyInsight": "Simplest recursion pattern. BFS also works for level counting.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Base",
                    "visual": "If zero? Ret 0.",
                    "explanation": "Leaf check."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "L = depth(left), R = depth(right).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Combine",
                    "visual": "Ret 1 + max(L, R).",
                    "explanation": "Count me."
                }
            ],
            "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "3",
                    "explanation": "Root -> 20 -> 15 or 7 is 3 levels."
                },
                {
                    "input": "root = [1,null,2]",
                    "output": "2",
                    "explanation": "Root -> 2 is 2 levels."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 10^4].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Use recursion: depth = 1 + max(left, right).",
                "Or use BFS level order traversal.",
                "Count levels as you traverse."
            ],
            "relatedProblems": [
                "minimum-depth-of-binary-tree",
                "balanced-binary-tree",
                "maximum-depth-of-n-ary-tree"
            ],
            "videoId": "hTM3phVI6YQ",
            "problemStatement": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "same-tree": {
            "title": "Same Tree",
            "pattern": "DFS (Recursion)",
            "patternEmoji": "\ud83d\udc6f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Check if p==q, then recurse: same(p.left, q.left) && same(p.right, q.right).",
            "intuition": [
                "\ud83c\udfaf Are they structural clones with same values?",
                "\ud83e\udde0 Both Null? True. One Null? False. Vals differ? False.",
                "\ud83d\udca1 Else, check children recursively."
            ],
            "testCases": [
                {
                    "input": "p = [1,2,3], q = [1,2,3]",
                    "output": "true"
                },
                {
                    "input": "p = [1,2], q = [1,null,2]",
                    "output": "false"
                },
                {
                    "input": "p = [1,2,1], q = [1,1,2]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Null Check",
                    "visual": "Both None -> True. One None -> False.",
                    "explanation": "Structure."
                },
                {
                    "step": 2,
                    "title": "Val Check",
                    "visual": "p.val != q.val -> False.",
                    "explanation": "Data."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "return same(L,L) and same(R,R).",
                    "explanation": "Deep check."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSameTree(p, q):\n    if not p and not q: return True\n    if not p or not q or p.val != q.val: return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
            "keyInsight": "Checking 'not p and not q' handles the leaf success case naturally.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Null Check",
                    "visual": "Both None -> True. One None -> False.",
                    "explanation": "Structure."
                },
                {
                    "step": 2,
                    "title": "Val Check",
                    "visual": "p.val != q.val -> False.",
                    "explanation": "Data."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "return same(L,L) and same(R,R).",
                    "explanation": "Deep check."
                }
            ],
            "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
            "examples": [
                {
                    "input": "p = [1,2,3], q = [1,2,3]",
                    "output": "true",
                    "explanation": "Both trees have same structure and values."
                },
                {
                    "input": "p = [1,2], q = [1,null,2]",
                    "output": "false",
                    "explanation": "Different structure."
                }
            ],
            "constraints": [
                "The number of nodes in both trees is in range [0, 100].",
                "-10^4 <= Node.val <= 10^4"
            ],
            "hints": [
                "If both null, return true. If one null, return false.",
                "If values differ, return false.",
                "Recursively check left and right subtrees."
            ],
            "relatedProblems": [
                "symmetric-tree",
                "subtree-of-another-tree"
            ],
            "videoId": "vRbbcKXCkOw",
            "problemStatement": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "symmetric-tree": {
            "title": "Symmetric Tree",
            "pattern": "DFS (Helpers)",
            "patternEmoji": "\ud83e\ude9e",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Compare root.left and root.right as mirror images (outer vs outer, inner vs inner).",
            "intuition": [
                "\ud83c\udfaf A tree is symmetric if Left Subtree is MIRROR of Right Subtree.",
                "\ud83e\udde0 isMirror(t1, t2): val match? t1.left==t2.right? t1.right==t2.left?",
                "\ud83d\udca1 Key is crossing the comparison."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,2,3,4,4,3]",
                    "output": "true"
                },
                {
                    "input": "root = [1,2,2,null,3,null,3]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Helper",
                    "visual": "check(L, R)",
                    "explanation": "Start split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "L.val == R.val?",
                    "explanation": "Values."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "check(L.left, R.right) AND check(L.right, R.left).",
                    "explanation": "Mirror logic."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef isSymmetric(root):\n    if not root: return True\n    def dfs(left, right):\n        if not left and not right: return True\n        if not left or not right: return False\n        return (left.val == right.val and \n                dfs(left.left, right.right) and \n                dfs(left.right, right.left))\n    return dfs(root.left, root.right)",
            "keyInsight": "You need a helper function because the 'root' only has specific logic, while the recursive step compares TWO nodes.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                2,
                3,
                4,
                4,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Helper",
                    "visual": "check(L, R)",
                    "explanation": "Start split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "L.val == R.val?",
                    "explanation": "Values."
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "check(L.left, R.right) AND check(L.right, R.left).",
                    "explanation": "Mirror logic."
                }
            ],
            "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
            "examples": [
                {
                    "input": "root = [1,2,2,3,4,4,3]",
                    "output": "true",
                    "explanation": "Left and right subtrees are mirrors."
                },
                {
                    "input": "root = [1,2,2,null,3,null,3]",
                    "output": "false",
                    "explanation": "Not symmetric."
                }
            ],
            "constraints": [
                "The number of nodes is in range [1, 1000].",
                "-100 <= Node.val <= 100"
            ],
            "hints": [
                "Compare left subtree with right subtree.",
                "Left's left should equal Right's right.",
                "Left's right should equal Right's left."
            ],
            "relatedProblems": [
                "same-tree",
                "flip-equivalent-binary-trees"
            ],
            "videoId": "Mao9uzxwvmc",
            "problemStatement": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "binary-tree-level-order-traversal": {
            "title": "Binary Tree Level Order Traversal",
            "pattern": "BFS (Queue)",
            "patternEmoji": "\ud83d\udcc2",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a deque; process current level sizet times; append children.",
            "intuition": [
                "\ud83c\udfaf Breadth-first.",
                "\ud83e\udde0 Queue valid nodes.",
                "\ud83d\udca1 Snapshot queue length 'L' to know boundary of current level."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[9,20],[15,7]]"
                },
                {
                    "input": "root = [1]",
                    "output": "[[1]]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Q = [root]",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Level Loop",
                    "visual": "For _ in range(len(Q)): Pop, Add data, Push children.",
                    "explanation": "Batch process."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "Append level list to results.",
                    "explanation": "Structure."
                }
            ],
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef levelOrder(root):\n    import collections\n    res = []\n    q = collections.deque()\n    q.append(root)\n    while q:\n        qLen = len(q)\n        level = []\n        for i in range(qLen):\n            node = q.popleft()\n            if node:\n                level.append(node.val)\n                q.append(node.left)\n                q.append(node.right)\n        if level:\n            res.append(level)\n    return res",
            "keyInsight": "Checking `if node:` inside the loop is cleaner than checking children individually before appending.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "Q = [root]",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Level Loop",
                    "visual": "For _ in range(len(Q)): Pop, Add data, Push children.",
                    "explanation": "Batch process."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "Append level list to results.",
                    "explanation": "Structure."
                }
            ],
            "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[9,20],[15,7]]",
                    "explanation": "Level by level from top to bottom."
                },
                {
                    "input": "root = [1]",
                    "output": "[[1]]",
                    "explanation": "Single node."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 2000].",
                "-1000 <= Node.val <= 1000"
            ],
            "hints": [
                "Use BFS with a queue.",
                "Track level size to separate levels.",
                "Add all nodes at current level, then move to next."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal-ii",
                "binary-tree-zigzag-level-order-traversal",
                "average-of-levels-in-binary-tree"
            ],
            "videoId": "6ZnyEApgFYg",
            "problemStatement": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "clone-graph": {
            "title": "Clone Graph",
            "pattern": "Graph (Hashtable + DFS)",
            "patternEmoji": "\ud83d\udd78",
            "timeComplexity": "O(N + E)",
            "spaceComplexity": "O(N)",
            "oneliner": "Use a hashmap {old_node: new_node} to avoid cycles and duplicates during DFS copy.",
            "intuition": [
                "\ud83c\udfaf Deep copy means creating new instances for every node.",
                "\ud83e\udde0 Graph has cycles; if we visit a node already in map, return the mapped copy.",
                "\ud83d\udca1 Map acts as 'visited' set AND reference storage."
            ],
            "testCases": [
                {
                    "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                    "output": "[[2,4],[1,3],[2,4],[1,3]]"
                },
                {
                    "input": "adjList = [[]]",
                    "output": "[[]]"
                },
                {
                    "input": "adjList = []",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Init map = {}. DFS(node).",
                    "explanation": "Start traversal."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "If node in map? Return map[node].",
                    "explanation": "Cycle handled."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "copy = Node(node.val). map[node] = copy.",
                    "explanation": "Create node."
                },
                {
                    "step": 4,
                    "title": "Neighbors",
                    "visual": "For nei in neighbors: copy.neighbors.append(dfs(nei)).",
                    "explanation": "Recurse."
                }
            ],
            "code": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node: return None\n    oldToNew = {}\n    \n    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]\n        \n        copy = Node(node.val)\n        oldToNew[node] = copy\n        \n        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))\n        return copy\n        \n    return dfs(node)",
            "keyInsight": "The hashmap is essential. Without it, you'd get stuck in an infinite loop due to cycles.",
            "visualizationType": "graph",
            "initialState": [
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ],
                [
                    2,
                    4
                ],
                [
                    1,
                    3
                ]
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "Init map = {}. DFS(node).",
                    "explanation": "Start traversal."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "If node in map? Return map[node].",
                    "explanation": "Cycle handled."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "copy = Node(node.val). map[node] = copy.",
                    "explanation": "Create node."
                },
                {
                    "step": 4,
                    "title": "Neighbors",
                    "visual": "For nei in neighbors: copy.neighbors.append(dfs(nei)).",
                    "explanation": "Recurse."
                }
            ],
            "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.",
            "examples": [
                {
                    "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                    "output": "[[2,4],[1,3],[2,4],[1,3]]",
                    "explanation": "Deep copy of the graph."
                }
            ],
            "constraints": [
                "The number of nodes is in range [0, 100].",
                "1 <= Node.val <= 100",
                "Node.val is unique for each node.",
                "There are no repeated edges and no self-loops."
            ],
            "hints": [
                "Use hash map: old node -> cloned node.",
                "Use BFS or DFS to traverse.",
                "Clone node first, then clone neighbors."
            ],
            "relatedProblems": [
                "copy-list-with-random-pointer",
                "clone-n-ary-tree",
                "clone-binary-tree-with-random-pointer"
            ],
            "videoId": "mQeF6bN8hMk",
            "problemStatement": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nTest case format:\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "course-schedule": {
            "title": "Course Schedule",
            "pattern": "Topological Sort (DFS/BFS)",
            "patternEmoji": "\ud83d\udcc3",
            "timeComplexity": "O(N + E)",
            "spaceComplexity": "O(N + E)",
            "oneliner": "Detect cycle in a directed graph. DFS with 'visiting' state or Kahn's Algo (indegrees).",
            "intuition": [
                "\ud83c\udfaf Prereqs are edges. A valid schedule -> No cycles.",
                "\ud83e\udde0 DFS: 0=unvisited, 1=visiting, 2=visited.",
                "\ud83d\udca1 If we meet '1' (visiting), cycle detected."
            ],
            "testCases": [
                {
                    "input": "numCourses = 2, prerequisites = [[1,0]]",
                    "output": "true"
                },
                {
                    "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Build",
                    "visual": "Adj List: {0: [1]}.",
                    "explanation": "Graph rep."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Visit 0. State[0]=Visiting. Visit children.",
                    "explanation": "Traverse."
                },
                {
                    "step": 3,
                    "title": "Cycle?",
                    "visual": "Back edge to Visiting? Cycle! Finish: State[0]=Visited.",
                    "explanation": "Detection."
                }
            ],
            "code": "def canFinish(numCourses, prerequisites):\n    preMap = { i: [] for i in range(numCourses) }\n    for crs, pre in prerequisites:\n        preMap[crs].append(pre)\n        \n    visitSet = set() # Visiting\n    \n    def dfs(crs):\n        if crs in visitSet:\n            return False\n        if preMap[crs] == []: # No prereqs or already verified\n            return True\n            \n        visitSet.add(crs)\n        for pre in preMap[crs]:\n            if not dfs(pre): return False\n        visitSet.remove(crs)\n        preMap[crs] = [] # Optimization: marked as verified\n        return True\n        \n    for crs in range(numCourses):\n        if not dfs(crs): return False\n    return True",
            "keyInsight": "Clearing `preMap[crs] = []` acts as marking it 'Visited' (safe), optimizing so we don't re-check safe nodes.",
            "visualizationType": "graph",
            "initialState": {
                "numCourses": 2,
                "prerequisites": [
                    [
                        1,
                        0
                    ]
                ]
            },
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Build",
                    "visual": "Adj List: {0: [1]}.",
                    "explanation": "Graph rep."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Visit 0. State[0]=Visiting. Visit children.",
                    "explanation": "Traverse."
                },
                {
                    "step": 3,
                    "title": "Cycle?",
                    "visual": "Back edge to Visiting? Cycle! Finish: State[0]=Visited.",
                    "explanation": "Detection."
                }
            ],
            "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
            "examples": [
                {
                    "input": "numCourses = 2, prerequisites = [[1,0]]",
                    "output": "true",
                    "explanation": "Take 0 first, then 1."
                },
                {
                    "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                    "output": "false",
                    "explanation": "Cycle exists, impossible."
                }
            ],
            "constraints": [
                "1 <= numCourses <= 2000",
                "0 <= prerequisites.length <= 5000",
                "prerequisites[i].length == 2",
                "0 <= ai, bi < numCourses"
            ],
            "hints": [
                "This is cycle detection in a directed graph.",
                "Use topological sort (Kahn's algorithm or DFS).",
                "If cycle exists, cannot complete all courses."
            ],
            "relatedProblems": [
                "course-schedule-ii",
                "course-schedule-iv",
                "minimum-height-trees"
            ],
            "videoId": "EgI5nU9etnU",
            "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn true if you can finish all courses. Otherwise, return false.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "permutations": {
            "title": "Permutations",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(N!)",
            "spaceComplexity": "O(N)",
            "oneliner": "Iterate choices, remove choice (visiting), recurse, add choice back (unvisiting).",
            "intuition": [
                "\ud83c\udfaf Ordering matters.",
                "\ud83e\udde0 Decision tree: 1st slot has N choices, 2nd has N-1...",
                "\ud83d\udca1 Base case: len(path) == len(nums)."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
                },
                {
                    "input": "nums = [0,1]",
                    "output": "[[0,1],[1,0]]"
                },
                {
                    "input": "nums = [1]",
                    "output": "[[1]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Choose",
                    "visual": "Pick 1. Remaining: [2,3].",
                    "explanation": "Branch."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "dfs(path + [1]).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Pop 1. Try 2.",
                    "explanation": "Undo."
                }
            ],
            "code": "def permute(nums):\n    res = []\n    \n    if (len(nums) == 1):\n        return [nums[:]]\n        \n    for i in range(len(nums)):\n        n = nums.pop(0)\n        perms = permute(nums)\n        \n        for p in perms:\n            p.append(n)\n        res.extend(perms)\n        nums.append(n)\n    return res",
            "keyInsight": "The iterative swapping or popping/appending creates the variations without explicit visited sets.",
            "visualizationType": "tree-decision",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Choose",
                    "visual": "Pick 1. Remaining: [2,3].",
                    "explanation": "Branch."
                },
                {
                    "step": 2,
                    "title": "Recurse",
                    "visual": "dfs(path + [1]).",
                    "explanation": "Explore."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Pop 1. Try 2.",
                    "explanation": "Undo."
                }
            ],
            "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                    "explanation": "All 6 permutations."
                },
                {
                    "input": "nums = [1]",
                    "output": "[[1]]",
                    "explanation": "Only one permutation."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 6",
                "-10 <= nums[i] <= 10",
                "All integers in nums are unique."
            ],
            "hints": [
                "Use backtracking.",
                "At each position, try all remaining numbers.",
                "Swap elements to avoid using extra space."
            ],
            "relatedProblems": [
                "permutations-ii",
                "next-permutation",
                "combinations"
            ],
            "videoId": "s7AvT7cGdSo",
            "problemStatement": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "combination-sum": {
            "title": "Combination Sum",
            "pattern": "Backtracking (Decision Tree)",
            "patternEmoji": "\ud83c\udf81",
            "timeComplexity": "O(2^Target)",
            "spaceComplexity": "O(Target)",
            "oneliner": "At each step: Option 1 (Include nums[i], stay at i), Option 2 (Exclude nums[i], move to i+1).",
            "intuition": [
                "\ud83c\udfaf Unlimited use of same number -> stay at index `i`.",
                "\ud83e\udde0 Sum > Target? Stop. Sum == Target? Record.",
                "\ud83d\udca1 Avoid duplicates by only moving forward index."
            ],
            "testCases": [
                {
                    "input": "candidates = [2,3,6,7], target = 7",
                    "output": "[[2,2,3],[7]]"
                },
                {
                    "input": "candidates = [2,3,5], target = 8",
                    "output": "[[2,2,2,2],[2,3,3],[3,5]]"
                },
                {
                    "input": "candidates = [2], target = 1",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Include",
                    "visual": "Add 2. New sum. Recurse(i).",
                    "explanation": "Reuse."
                },
                {
                    "step": 2,
                    "title": "Exclude",
                    "visual": "Pop 2. Recurse(i+1).",
                    "explanation": "Skip."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "Sum > Target? Return.",
                    "explanation": "Prune."
                }
            ],
            "code": "def combinationSum(candidates, target):\n    res = []\n    \n    def dfs(i, cur, total):\n        if total == target:\n            res.append(cur.copy())\n            return\n        if i >= len(candidates) or total > target:\n            return\n            \n        # Decision 1: Include candidate[i] -> stay at i\n        cur.append(candidates[i])\n        dfs(i, cur, total + candidates[i])\n        \n        # Decision 2: Exclude candidate[i] -> move to i+1\n        cur.pop()\n        dfs(i + 1, cur, total)\n        \n    dfs(0, [], 0)\n    return res",
            "keyInsight": "Splitting the decision into 'include current' OR 'never use current again' avoids duplicate combinations perfectly.",
            "visualizationType": "tree-decision",
            "initialState": {
                "candidates": [
                    2,
                    3,
                    6,
                    7
                ],
                "target": 7
            },
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Include",
                    "visual": "Add 2. New sum. Recurse(i).",
                    "explanation": "Reuse."
                },
                {
                    "step": 2,
                    "title": "Exclude",
                    "visual": "Pop 2. Recurse(i+1).",
                    "explanation": "Skip."
                },
                {
                    "step": 3,
                    "title": "Base",
                    "visual": "Sum > Target? Return.",
                    "explanation": "Prune."
                }
            ],
            "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times.",
            "examples": [
                {
                    "input": "candidates = [2,3,6,7], target = 7",
                    "output": "[[2,2,3],[7]]",
                    "explanation": "2+2+3=7 and 7=7."
                },
                {
                    "input": "candidates = [2,3,5], target = 8",
                    "output": "[[2,2,2,2],[2,3,3],[3,5]]",
                    "explanation": "Three valid combinations."
                }
            ],
            "constraints": [
                "1 <= candidates.length <= 30",
                "2 <= candidates[i] <= 40",
                "All elements in candidates are distinct.",
                "1 <= target <= 40"
            ],
            "hints": [
                "Use backtracking.",
                "Allow reusing same element (start index doesn't advance).",
                "Prune when sum exceeds target."
            ],
            "relatedProblems": [
                "combination-sum-ii",
                "combination-sum-iii",
                "subsets"
            ],
            "videoId": "GBKI9VSKdGg",
            "problemStatement": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "word-search": {
            "title": "Word Search",
            "pattern": "Backtracking (Matrix)",
            "patternEmoji": "\ud83d\udd0e",
            "timeComplexity": "O(N * M * 4^L)",
            "spaceComplexity": "O(L)",
            "oneliner": "DFS on grid: match char? Mark visited -> Recurse neighbors -> Unmark.",
            "intuition": [
                "\ud83c\udfaf Snake through the grid.",
                "\ud83e\udde0 Cannot reuse cell in same path (need path_visited set).",
                "\ud83d\udca1 Prune immediately if char mismatch."
            ],
            "testCases": [
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                    "output": "true"
                },
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
                    "output": "true"
                },
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find Start",
                    "visual": "Scan for word[0]. Start DFS.",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Match? Path.add. Recurse 4 dirs.",
                    "explanation": "Pathfinding."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Return. Path.remove.",
                    "explanation": "Cleanup."
                }
            ],
            "code": "def exist(board, word):\n    ROWS, COLS = len(board), len(board[0])\n    path = set()\n    \n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n        if (r < 0 or c < 0 or \n            r >= ROWS or c >= COLS or \n            word[i] != board[r][c] or \n            (r,c) in path):\n            return False\n            \n        path.add((r, c))\n        res = (dfs(r + 1, c, i + 1) or\n               dfs(r - 1, c, i + 1) or\n               dfs(r, c + 1, i + 1) or\n               dfs(r, c - 1, i + 1))\n        path.remove((r, c))\n        return res\n        \n    for r in range(ROWS):\n        for c in range(COLS):\n            if dfs(r, c, 0): return True\n    return False",
            "keyInsight": "Using a set for the current path is cleaner than modifying the board, though board modification (e.g. replacing with '#') saves space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "A",
                    "B",
                    "C",
                    "E"
                ],
                [
                    "S",
                    "F",
                    "C",
                    "S"
                ],
                [
                    "A",
                    "D",
                    "E",
                    "E"
                ]
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Find Start",
                    "visual": "Scan for word[0]. Start DFS.",
                    "explanation": "Init."
                },
                {
                    "step": 2,
                    "title": "DFS",
                    "visual": "Match? Path.add. Recurse 4 dirs.",
                    "explanation": "Pathfinding."
                },
                {
                    "step": 3,
                    "title": "Backtrack",
                    "visual": "Return. Path.remove.",
                    "explanation": "Cleanup."
                }
            ],
            "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
            "examples": [
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                    "output": "true",
                    "explanation": "Path exists."
                },
                {
                    "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                    "output": "false",
                    "explanation": "Cannot reuse cells."
                }
            ],
            "constraints": [
                "m == board.length",
                "n = board[i].length",
                "1 <= m, n <= 6",
                "1 <= word.length <= 15",
                "board and word only contain uppercase and lowercase English letters."
            ],
            "hints": [
                "Use backtracking with DFS.",
                "Mark visited cells temporarily.",
                "Restore after backtracking."
            ],
            "relatedProblems": [
                "word-search-ii"
            ],
            "videoId": "pfiQ_PS1g8E",
            "problemStatement": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you use search pruning to make your solution faster with a larger board?",
            "difficulty": "Medium"
        },
        "kth-largest-element-in-an-array": {
            "title": "Kth Largest Element in an Array",
            "pattern": "Heap / QuickSelect",
            "patternEmoji": "\ud83e\udd47",
            "timeComplexity": "O(N) avg",
            "spaceComplexity": "O(1) / O(K)",
            "oneliner": "QuickSelect for O(N) OR Min-Heap of size K (keep K largest seen).",
            "intuition": [
                "\ud83c\udfaf We want the Kth item if sorted descending.",
                "\ud83e\udde0 Sorting is O(NlogN). Can we do better?",
                "\ud83d\udca1 QuickSelect partitions array like QuickSort but only recurses into one half."
            ],
            "testCases": [
                {
                    "input": "nums = [3,2,1,5,6,4], k = 2",
                    "output": "5"
                },
                {
                    "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Pivot",
                    "visual": "Pick pivot, partition < pivot, > pivot.",
                    "explanation": "Split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Is pivot index == len-k? Return pivot.",
                    "explanation": "Target?"
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "If idx < target, go right. Else left.",
                    "explanation": "Search."
                }
            ],
            "code": "def findKthLargest(nums, k):\n    k = len(nums) - k\n    \n    def quickSelect(l, r):\n        pivot, p = nums[r], l\n        for i in range(l, r):\n            if nums[i] <= pivot:\n                nums[p], nums[i] = nums[i], nums[p]\n                p += 1\n        nums[p], nums[r] = nums[r], nums[p]\n        \n        if p > k: return quickSelect(l, p - 1)\n        elif p < k: return quickSelect(p + 1, r)\n        else: return nums[p]\n        \n    return quickSelect(0, len(nums) - 1)",
            "keyInsight": "Running QuickSelect is theoretically O(N) average, superior to Heap's O(N log K) if K is large, although Python's `heapq.nlargest` is very optimized.",
            "visualizationType": "array",
            "initialState": [
                3,
                2,
                1,
                5,
                6,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Pivot",
                    "visual": "Pick pivot, partition < pivot, > pivot.",
                    "explanation": "Split."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "Is pivot index == len-k? Return pivot.",
                    "explanation": "Target?"
                },
                {
                    "step": 3,
                    "title": "Recurse",
                    "visual": "If idx < target, go right. Else left.",
                    "explanation": "Search."
                }
            ],
            "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?",
            "examples": [
                {
                    "input": "nums = [3,2,1,5,6,4], k = 2",
                    "output": "5",
                    "explanation": "Sorted: [1,2,3,4,5,6], 2nd largest is 5."
                },
                {
                    "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
                    "output": "4",
                    "explanation": "4th largest is 4."
                }
            ],
            "constraints": [
                "1 <= k <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4"
            ],
            "hints": [
                "Use a min-heap of size k.",
                "Or use Quickselect for O(n) average.",
                "Heap gives O(n log k)."
            ],
            "relatedProblems": [
                "top-k-frequent-elements",
                "find-k-pairs-with-smallest-sums",
                "kth-smallest-element-in-a-sorted-matrix"
            ],
            "videoId": "XEmy13g1Qxc",
            "problemStatement": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "top-k-frequent-elements": {
            "title": "Top K Frequent Elements",
            "pattern": "Bucket Sort / Heap",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(N)",
            "spaceComplexity": "O(N)",
            "oneliner": "Count freqs. Use Bucket Sort (freq is index, list of numbers is val) to get results in O(N).",
            "intuition": [
                "\ud83c\udfaf Map {num -> count}.",
                "\ud83e\udde0 Max freq is N. Create array where index is freq.",
                "\ud83d\udca1 Iterate bucket from N down to 1 to find most frequent."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,1,2,2,3], k = 2",
                    "output": "[1,2]"
                },
                {
                    "input": "nums = [1], k = 1",
                    "output": "[1]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Hashmap counts.",
                    "explanation": "Freqs."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "bucket[count].append(num).",
                    "explanation": "Group."
                },
                {
                    "step": 3,
                    "title": "Gather",
                    "visual": "Flatten buckets in reverse.",
                    "explanation": "Result."
                }
            ],
            "code": "def topKFrequent(nums, k):\n    count = {}\n    freq = [[] for i in range(len(nums) + 1)]\n    \n    for n in nums:\n        count[n] = 1 + count.get(n, 0)\n    for n, c in count.items():\n        freq[c].append(n)\n        \n    res = []\n    for i in range(len(freq) - 1, 0, -1):\n        for n in freq[i]:\n            res.append(n)\n            if len(res) == k:\n                return res",
            "keyInsight": "Bucket Sort is essentially O(N) here because frequencies are bounded by array size.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Count",
                    "visual": "Hashmap counts.",
                    "explanation": "Freqs."
                },
                {
                    "step": 2,
                    "title": "Bucket",
                    "visual": "bucket[count].append(num).",
                    "explanation": "Group."
                },
                {
                    "step": 3,
                    "title": "Gather",
                    "visual": "Flatten buckets in reverse.",
                    "explanation": "Result."
                }
            ],
            "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
            "examples": [
                {
                    "input": "nums = [1,1,1,2,2,3], k = 2",
                    "output": "[1,2]",
                    "explanation": "1 appears 3 times, 2 appears 2 times."
                },
                {
                    "input": "nums = [1], k = 1",
                    "output": "[1]",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-10^4 <= nums[i] <= 10^4",
                "k is in range [1, the number of unique elements].",
                "It is guaranteed that the answer is unique."
            ],
            "hints": [
                "Count frequencies with a hash map.",
                "Use a min-heap of size k.",
                "Or use bucket sort for O(n)."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "sort-characters-by-frequency",
                "top-k-frequent-words"
            ],
            "videoId": "YPTqKIgVk-k",
            "problemStatement": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.",
            "difficulty": "Medium"
        },
        "remove-duplicates-from-sorted-array": {
            "title": "Remove Duplicates from Sorted Array",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use slow/fast pointers. Slow marks 'write position', fast scans ahead.",
            "intuition": [
                "\ud83c\udfaf We need to remove duplicates IN-PLACE and return new length.",
                "\ud83e\udde0 Use 'slow' pointer for write position, 'fast' to scan.",
                "\ud83d\udca1 When nums[fast] != nums[slow], copy nums[fast] to nums[slow+1]."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,2]",
                    "output": "2, nums = [1,2,_]"
                },
                {
                    "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                    "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=0, fast=1",
                    "explanation": "Start pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow]? Move slow, copy.",
                    "explanation": "Unique found."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return slow + 1",
                    "explanation": "Length of unique elements."
                }
            ],
            "code": "def removeDuplicates(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1",
            "keyInsight": "The slow pointer always points to the last unique element.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                2
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=0, fast=1",
                    "explanation": "Start pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow]? Move slow, copy.",
                    "explanation": "Unique found."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Return slow + 1",
                    "explanation": "Length of unique elements."
                }
            ],
            "description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.",
            "examples": [
                {
                    "input": "nums = [1,1,2]",
                    "output": "2, nums = [1,2,_]",
                    "explanation": "Return k=2, first 2 elements are unique."
                },
                {
                    "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                    "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
                    "explanation": "5 unique elements."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-100 <= nums[i] <= 100",
                "nums is sorted in non-decreasing order."
            ],
            "hints": [
                "Use two pointers - slow for unique position, fast for scanning.",
                "If nums[fast] != nums[slow], copy to slow+1.",
                "Return slow + 1 as count."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array-ii",
                "remove-element",
                "move-zeroes"
            ],
            "videoId": "DEJAZBq0FDA",
            "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "remove-duplicates-from-sorted-array-ii": {
            "title": "Remove Duplicates from Sorted Array II",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Allow at most 2 duplicates. Compare with nums[slow-1] instead of nums[slow].",
            "intuition": [
                "\ud83c\udfaf Each unique element can appear at most twice.",
                "\ud83e\udde0 Compare nums[fast] with nums[slow-1] (not slow).",
                "\ud83d\udca1 If different, copy and advance slow."
            ],
            "testCases": [
                {
                    "input": "nums = [1,1,1,2,2,3]",
                    "output": "5, nums = [1,1,2,2,3,_]"
                },
                {
                    "input": "nums = [0,0,1,1,1,1,2,3,3]",
                    "output": "7, nums = [0,0,1,1,2,3,3,_,_]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=2, fast=2",
                    "explanation": "First 2 are always kept."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow-2]?",
                    "explanation": "Check 2 back."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "nums[slow] = nums[fast]; slow++",
                    "explanation": "Keep element."
                }
            ],
            "code": "def removeDuplicates(nums):\n    if len(nums) <= 2: return len(nums)\n    slow = 2\n    for fast in range(2, len(nums)):\n        if nums[fast] != nums[slow - 2]:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow",
            "keyInsight": "The key insight is comparing with slow-2, not slow-1.",
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                1,
                2,
                2,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "slow=2, fast=2",
                    "explanation": "First 2 are always kept."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "nums[fast] != nums[slow-2]?",
                    "explanation": "Check 2 back."
                },
                {
                    "step": 3,
                    "title": "Copy",
                    "visual": "nums[slow] = nums[fast]; slow++",
                    "explanation": "Keep element."
                }
            ],
            "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.",
            "examples": [
                {
                    "input": "nums = [1,1,1,2,2,3]",
                    "output": "5, nums = [1,1,2,2,3,_]",
                    "explanation": "Keep at most 2 of each."
                },
                {
                    "input": "nums = [0,0,1,1,1,1,2,3,3]",
                    "output": "7, nums = [0,0,1,1,2,3,3,_,_]",
                    "explanation": "7 elements after removing extras."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-10^4 <= nums[i] <= 10^4",
                "nums is sorted in non-decreasing order."
            ],
            "hints": [
                "Use two pointers with a count variable.",
                "Allow at most 2 of each element.",
                "Compare with element 2 positions back."
            ],
            "relatedProblems": [
                "remove-duplicates-from-sorted-array",
                "remove-duplicates-from-sorted-list-ii"
            ],
            "videoId": "ycAq8iqh0TI",
            "problemStatement": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nIf all assertions pass, then your solution will be accepted.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "rotate-array": {
            "title": "Rotate Array",
            "pattern": "Reverse Trick",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse entire array, then reverse first k, then reverse rest.",
            "intuition": [
                "\ud83c\udfaf Rotate array right by k steps.",
                "\ud83e\udde0 Reverse trick: reverse all, reverse [0:k], reverse [k:].",
                "\ud83d\udca1 Handles k > len(nums) with k %= len."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,4,5,6,7], k = 3",
                    "output": "[5,6,7,1,2,3,4]"
                },
                {
                    "input": "nums = [-1,-100,3,99], k = 2",
                    "output": "[3,99,-1,-100]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Normalize",
                    "visual": "k = k % n",
                    "explanation": "Handle overflow."
                },
                {
                    "step": 2,
                    "title": "Reverse All",
                    "visual": "[7,6,5,4,3,2,1]",
                    "explanation": "Flip entire array."
                },
                {
                    "step": 3,
                    "title": "Reverse Parts",
                    "visual": "[5,6,7] + [1,2,3,4]",
                    "explanation": "Flip both halves."
                }
            ],
            "code": "def rotate(nums, k):\n    n = len(nums)\n    k %= n\n    def reverse(l, r):\n        while l < r:\n            nums[l], nums[r] = nums[r], nums[l]\n            l, r = l + 1, r - 1\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums",
            "keyInsight": "Three reverses is more elegant than slicing or cyclic replacement.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Normalize",
                    "visual": "k = k % n",
                    "explanation": "Handle overflow."
                },
                {
                    "step": 2,
                    "title": "Reverse All",
                    "visual": "[7,6,5,4,3,2,1]",
                    "explanation": "Flip entire array."
                },
                {
                    "step": 3,
                    "title": "Reverse Parts",
                    "visual": "[5,6,7] + [1,2,3,4]",
                    "explanation": "Flip both halves."
                }
            ],
            "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
            "examples": [
                {
                    "input": "nums = [1,2,3,4,5,6,7], k = 3",
                    "output": "[5,6,7,1,2,3,4]",
                    "explanation": "Rotate right 3 times."
                },
                {
                    "input": "nums = [-1,-100,3,99], k = 2",
                    "output": "[3,99,-1,-100]",
                    "explanation": "Rotate right 2 times."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5",
                "-2^31 <= nums[i] <= 2^31 - 1",
                "0 <= k <= 10^5"
            ],
            "hints": [
                "Use the reverse technique.",
                "Reverse the entire array.",
                "Reverse first k elements, then reverse remaining elements."
            ],
            "relatedProblems": [
                "rotate-list",
                "reverse-words-in-a-string",
                "rotate-image"
            ],
            "videoId": "BHr381Guz3Y",
            "problemStatement": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
            "difficulty": "Medium"
        },
        "best-time-to-buy-and-sell-stock-ii": {
            "title": "Best Time to Buy and Sell Stock II",
            "pattern": "Greedy",
            "patternEmoji": "\ud83d\udcb0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Buy before every rise, sell after every rise. Collect all profits.",
            "intuition": [
                "\ud83c\udfaf Unlimited transactions allowed.",
                "\ud83e\udde0 Collect profit for every upward movement.",
                "\ud83d\udca1 If prices[i] > prices[i-1], add the difference."
            ],
            "testCases": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "7"
                },
                {
                    "input": "prices = [1,2,3,4,5]",
                    "output": "4"
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Check pairs",
                    "explanation": "Compare consecutive."
                },
                {
                    "step": 2,
                    "title": "Profit",
                    "visual": "If up, add diff",
                    "explanation": "Greedy gain."
                },
                {
                    "step": 3,
                    "title": "Sum",
                    "visual": "Total = 7",
                    "explanation": "All upward moves."
                }
            ],
            "code": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit",
            "keyInsight": "Every upward slope contributes to profit. Just sum them all.",
            "visualizationType": "array",
            "initialState": [
                7,
                1,
                5,
                3,
                6,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Scan",
                    "visual": "Check pairs",
                    "explanation": "Compare consecutive."
                },
                {
                    "step": 2,
                    "title": "Profit",
                    "visual": "If up, add diff",
                    "explanation": "Greedy gain."
                },
                {
                    "step": 3,
                    "title": "Sum",
                    "visual": "Total = 7",
                    "explanation": "All upward moves."
                }
            ],
            "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.",
            "examples": [
                {
                    "input": "prices = [7,1,5,3,6,4]",
                    "output": "7",
                    "explanation": "Buy at 1, sell at 5, profit 4. Buy at 3, sell at 6, profit 3. Total 7."
                },
                {
                    "input": "prices = [1,2,3,4,5]",
                    "output": "4",
                    "explanation": "Buy at 1, sell at 5, or sum all increases."
                }
            ],
            "constraints": [
                "1 <= prices.length <= 3 * 10^4",
                "0 <= prices[i] <= 10^4"
            ],
            "hints": [
                "Capture every upward price movement.",
                "Sum of (prices[i] - prices[i-1]) for all increases.",
                "Greedy approach works here."
            ],
            "relatedProblems": [
                "best-time-to-buy-and-sell-stock",
                "best-time-to-buy-and-sell-stock-iii",
                "best-time-to-buy-and-sell-stock-with-cooldown"
            ],
            "videoId": "3SJ3pUkPQMc",
            "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "jump-game": {
            "title": "Jump Game",
            "pattern": "Greedy",
            "patternEmoji": "\ud83e\udd98",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track the farthest reachable index. If i > maxReach, return False.",
            "intuition": [
                "\ud83c\udfaf Can you reach the last index?",
                "\ud83e\udde0 At each step, update max reachable: max(reach, i + nums[i]).",
                "\ud83d\udca1 If current index exceeds reach, we're stuck."
            ],
            "testCases": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "true"
                },
                {
                    "input": "nums = [3,2,1,0,4]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "reach = 0",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Update",
                    "visual": "reach = max(reach, i + nums[i])",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "reach >= n-1?",
                    "explanation": "Can reach end."
                }
            ],
            "code": "def canJump(nums):\n    reach = 0\n    for i in range(len(nums)):\n        if i > reach:\n            return False\n        reach = max(reach, i + nums[i])\n    return True",
            "keyInsight": "Greedy approach: always track the maximum reachable position.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                1,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "reach = 0",
                    "explanation": "Start."
                },
                {
                    "step": 2,
                    "title": "Update",
                    "visual": "reach = max(reach, i + nums[i])",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "reach >= n-1?",
                    "explanation": "Can reach end."
                }
            ],
            "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
            "examples": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "true",
                    "explanation": "Jump 1 step from 0 to 1, then 3 steps to last."
                },
                {
                    "input": "nums = [3,2,1,0,4]",
                    "output": "false",
                    "explanation": "Always stuck at index 3."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "0 <= nums[i] <= 10^5"
            ],
            "hints": [
                "Track the farthest reachable index.",
                "If current index > farthest, return false.",
                "If farthest >= last index, return true."
            ],
            "relatedProblems": [
                "jump-game-ii",
                "jump-game-iii",
                "jump-game-iv"
            ],
            "videoId": "Yan0cv2cLy8",
            "problemStatement": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "jump-game-ii": {
            "title": "Jump Game II",
            "pattern": "Greedy BFS",
            "patternEmoji": "\ud83e\udd98\ud83e\udd98",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "BFS-style: track current level end and farthest reachable.",
            "intuition": [
                "\ud83c\udfaf Minimum jumps to reach end.",
                "\ud83e\udde0 Think of it as BFS levels. Each 'jump' is a level.",
                "\ud83d\udca1 When we pass current level end, increment jumps."
            ],
            "testCases": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "2"
                },
                {
                    "input": "nums = [2,3,0,1,4]",
                    "output": "2"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "jumps=0, end=0, far=0",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "far = max(far, i+nums[i])",
                    "explanation": "Track farthest."
                },
                {
                    "step": 3,
                    "title": "Level",
                    "visual": "i == end? jumps++, end=far",
                    "explanation": "Next jump."
                }
            ],
            "code": "def jump(nums):\n    jumps = 0\n    end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == end:\n            jumps += 1\n            end = farthest\n    return jumps",
            "keyInsight": "Think of it as BFS where each 'level' represents one jump.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                1,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "jumps=0, end=0, far=0",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "far = max(far, i+nums[i])",
                    "explanation": "Track farthest."
                },
                {
                    "step": 3,
                    "title": "Level",
                    "visual": "i == end? jumps++, end=far",
                    "explanation": "Next jump."
                }
            ],
            "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. Return the minimum number of jumps to reach nums[n - 1].",
            "examples": [
                {
                    "input": "nums = [2,3,1,1,4]",
                    "output": "2",
                    "explanation": "Jump 1 to index 1, then 3 to last index."
                },
                {
                    "input": "nums = [2,3,0,1,4]",
                    "output": "2",
                    "explanation": "Same minimum jumps."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4",
                "0 <= nums[i] <= 1000",
                "It's guaranteed you can reach nums[n - 1]."
            ],
            "hints": [
                "Use BFS-like approach with levels.",
                "Track current jump's end and farthest reachable.",
                "Increment jumps when reaching current end."
            ],
            "relatedProblems": [
                "jump-game",
                "jump-game-iii",
                "minimum-jumps-to-reach-home"
            ],
            "videoId": "dJ7sWiOoK7g",
            "problemStatement": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "h-index": {
            "title": "H-Index",
            "pattern": "Counting Sort / Binary Search",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Count papers at each citation level. Scan from high to low.",
            "intuition": [
                "\ud83c\udfaf H-index: h papers with at least h citations.",
                "\ud83e\udde0 Use counting sort bucket. papers[i] = count of papers with i citations.",
                "\ud83d\udca1 Accumulate from high to find h where count >= h."
            ],
            "testCases": [
                {
                    "input": "citations = [3,0,6,1,5]",
                    "output": "3"
                },
                {
                    "input": "citations = [1,3,1]",
                    "output": "1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Bucket",
                    "visual": "Count citations",
                    "explanation": "Counting sort."
                },
                {
                    "step": 2,
                    "title": "Accumulate",
                    "visual": "From n down to 0",
                    "explanation": "Sum papers."
                },
                {
                    "step": 3,
                    "title": "Find h",
                    "visual": "total >= h",
                    "explanation": "First valid."
                }
            ],
            "code": "def hIndex(citations):\n    n = len(citations)\n    papers = [0] * (n + 1)\n    for c in citations:\n        papers[min(n, c)] += 1\n    total = 0\n    for h in range(n, -1, -1):\n        total += papers[h]\n        if total >= h:\n            return h\n    return 0",
            "keyInsight": "Counting sort avoids O(n log n) sort. Cap citations at n.",
            "visualizationType": "array",
            "initialState": [
                3,
                0,
                6,
                1,
                5
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Bucket",
                    "visual": "Count citations",
                    "explanation": "Counting sort."
                },
                {
                    "step": 2,
                    "title": "Accumulate",
                    "visual": "From n down to 0",
                    "explanation": "Sum papers."
                },
                {
                    "step": 3,
                    "title": "Find h",
                    "visual": "total >= h",
                    "explanation": "First valid."
                }
            ],
            "description": "Count papers at each citation level. Scan from high to low.\n\nH-index: h papers with at least h citations.\nUse counting sort bucket. papers[i] = count of papers with i citations.",
            "examples": [
                {
                    "input": "citations = [3,0,6,1,5]",
                    "output": "3"
                },
                {
                    "input": "citations = [1,3,1]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "H-index: h papers with at least h citations.",
                "Use counting sort bucket. papers[i] = count of papers with i citations.",
                "Accumulate from high to find h where count >= h."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "CjKJDloMnwM",
            "problemStatement": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "product-of-array-except-self": {
            "title": "Product of Array Except Self",
            "pattern": "Prefix/Suffix Products",
            "patternEmoji": "\u2716\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two passes: left products, then right products multiplied in.",
            "intuition": [
                "\ud83c\udfaf res[i] = product of all except nums[i].",
                "\ud83e\udde0 res[i] = (product of left) * (product of right).",
                "\ud83d\udca1 First pass: left products. Second pass: multiply right products."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "[24,12,8,6]"
                },
                {
                    "input": "nums = [-1,1,0,-3,3]",
                    "output": "[0,0,9,0,0]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Left",
                    "visual": "res = [1, 1, 2, 6]",
                    "explanation": "Prefix products."
                },
                {
                    "step": 2,
                    "title": "Right",
                    "visual": "Multiply suffix",
                    "explanation": "Right to left."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "[24,12,8,6]",
                    "explanation": "Combined."
                }
            ],
            "code": "def productExceptSelf(nums):\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n    return res",
            "keyInsight": "Use output array for left products, then multiply right products in-place.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Left",
                    "visual": "res = [1, 1, 2, 6]",
                    "explanation": "Prefix products."
                },
                {
                    "step": 2,
                    "title": "Right",
                    "visual": "Multiply suffix",
                    "explanation": "Right to left."
                },
                {
                    "step": 3,
                    "title": "Result",
                    "visual": "[24,12,8,6]",
                    "explanation": "Combined."
                }
            ],
            "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
            "examples": [
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "[24,12,8,6]",
                    "explanation": "answer[0] = 2*3*4 = 24, answer[1] = 1*3*4 = 12, etc."
                },
                {
                    "input": "nums = [-1,1,0,-3,3]",
                    "output": "[0,0,9,0,0]",
                    "explanation": "Products accounting for the zero."
                }
            ],
            "constraints": [
                "2 <= nums.length <= 10^5",
                "-30 <= nums[i] <= 30",
                "Product of any prefix or suffix fits in 32-bit integer."
            ],
            "hints": [
                "Calculate prefix products from left.",
                "Calculate suffix products from right.",
                "answer[i] = prefix[i-1] * suffix[i+1]."
            ],
            "relatedProblems": [
                "trapping-rain-water",
                "maximum-product-subarray",
                "paint-house-ii"
            ],
            "videoId": "bNvIQI2wAjk",
            "problemStatement": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)",
            "difficulty": "Medium"
        },
        "gas-station": {
            "title": "Gas Station",
            "pattern": "Greedy",
            "patternEmoji": "\u26fd",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If total gas >= total cost, solution exists. Start from where deficit resets.",
            "intuition": [
                "\ud83c\udfaf Find the starting gas station to complete the circuit.",
                "\ud83e\udde0 Track total and current tank. Reset start when current < 0.",
                "\ud83d\udca1 If total >= 0, answer is the last reset point."
            ],
            "testCases": [
                {
                    "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                    "output": "3"
                },
                {
                    "input": "gas = [2,3,4], cost = [3,4,3]",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Track",
                    "visual": "total, tank, start",
                    "explanation": "Initialize."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "tank += gas[i] - cost[i]",
                    "explanation": "Net gain."
                },
                {
                    "step": 3,
                    "title": "Reset",
                    "visual": "tank<0? start=i+1, tank=0",
                    "explanation": "New start."
                }
            ],
            "code": "def canCompleteCircuit(gas, cost):\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1",
            "keyInsight": "If you can't reach station i+1 from some start, try starting from i+1.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Track",
                    "visual": "total, tank, start",
                    "explanation": "Initialize."
                },
                {
                    "step": 2,
                    "title": "Add",
                    "visual": "tank += gas[i] - cost[i]",
                    "explanation": "Net gain."
                },
                {
                    "step": 3,
                    "title": "Reset",
                    "visual": "tank<0? start=i+1, tank=0",
                    "explanation": "New start."
                }
            ],
            "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.",
            "examples": [
                {
                    "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                    "output": "3",
                    "explanation": "Start at station 3, you can complete the circuit."
                },
                {
                    "input": "gas = [2,3,4], cost = [3,4,3]",
                    "output": "-1",
                    "explanation": "Not possible to complete."
                }
            ],
            "constraints": [
                "n == gas.length == cost.length",
                "1 <= n <= 10^5",
                "0 <= gas[i], cost[i] <= 10^4"
            ],
            "hints": [
                "If total gas < total cost, impossible.",
                "If we run out at station j, start can't be 0 to j.",
                "Greedy: reset start when tank goes negative."
            ],
            "relatedProblems": [
                "minimum-cost-to-make-at-least-one-valid-path-in-a-grid"
            ],
            "videoId": "lJwbPZGo05A",
            "problemStatement": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "candy": {
            "title": "Candy",
            "pattern": "Two Pass Greedy",
            "patternEmoji": "\ud83c\udf6c",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.",
            "intuition": [
                "\ud83c\udfaf Each child gets at least 1 candy. Higher rating = more than neighbors.",
                "\ud83e\udde0 Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
                "\ud83d\udca1 Right-to-left: same logic, take max."
            ],
            "testCases": [
                {
                    "input": "ratings = [1,0,2]",
                    "output": "5"
                },
                {
                    "input": "ratings = [1,2,2]",
                    "output": "4"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "candy = [1,1,1...]",
                    "explanation": "Everyone gets 1."
                },
                {
                    "step": 2,
                    "title": "Left",
                    "visual": "Increasing? +1",
                    "explanation": "Left rule."
                },
                {
                    "step": 3,
                    "title": "Right",
                    "visual": "Decreasing? max",
                    "explanation": "Right rule."
                }
            ],
            "code": "def candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n    return sum(candies)",
            "keyInsight": "Two passes handle left and right neighbors independently, then combine.",
            "visualizationType": "array",
            "initialState": [
                1,
                0,
                2
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "candy = [1,1,1...]",
                    "explanation": "Everyone gets 1."
                },
                {
                    "step": 2,
                    "title": "Left",
                    "visual": "Increasing? +1",
                    "explanation": "Left rule."
                },
                {
                    "step": 3,
                    "title": "Right",
                    "visual": "Decreasing? max",
                    "explanation": "Right rule."
                }
            ],
            "description": "Left pass: satisfy left neighbor rule. Right pass: satisfy right rule.\n\nEach child gets at least 1 candy. Higher rating = more than neighbors.\nLeft-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
            "examples": [
                {
                    "input": "ratings = [1,0,2]",
                    "output": "5"
                },
                {
                    "input": "ratings = [1,2,2]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Each child gets at least 1 candy. Higher rating = more than neighbors.",
                "Left-to-right: if ratings[i] > ratings[i-1], candy[i] = candy[i-1]+1.",
                "Right-to-left: same logic, take max."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "QzPWc0yI-C0",
            "problemStatement": "There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\nYou are giving candies to these children subjected to the following requirements:\nReturn the minimum number of candies you need to have to distribute the candies to the children.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "trapping-rain-water": {
            "title": "Trapping Rain Water",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udca7",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two pointers from ends. Water at i = min(leftMax, rightMax) - height[i].",
            "intuition": [
                "\ud83c\udfaf How much water can be trapped?",
                "\ud83e\udde0 Water at each position = min(maxLeft, maxRight) - height.",
                "\ud83d\udca1 Two pointers: move the smaller side inward."
            ],
            "testCases": [
                {
                    "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": "6"
                },
                {
                    "input": "height = [4,2,0,3,2,5]",
                    "output": "9"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, maxL=maxR=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "Move smaller side",
                    "explanation": "Bottleneck."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "water += max - height[i]",
                    "explanation": "Accumulate."
                }
            ],
            "code": "def trap(height):\n    if not height: return 0\n    l, r = 0, len(height) - 1\n    leftMax, rightMax = height[l], height[r]\n    water = 0\n    while l < r:\n        if leftMax < rightMax:\n            l += 1\n            leftMax = max(leftMax, height[l])\n            water += leftMax - height[l]\n        else:\n            r -= 1\n            rightMax = max(rightMax, height[r])\n            water += rightMax - height[r]\n    return water",
            "keyInsight": "The smaller of leftMax/rightMax determines water level at current position.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                0,
                2,
                1,
                0,
                1,
                3,
                2,
                1,
                2,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, maxL=maxR=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "Move smaller side",
                    "explanation": "Bottleneck."
                },
                {
                    "step": 3,
                    "title": "Add",
                    "visual": "water += max - height[i]",
                    "explanation": "Accumulate."
                }
            ],
            "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
            "examples": [
                {
                    "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": "6",
                    "explanation": "Water fills between bars."
                },
                {
                    "input": "height = [4,2,0,3,2,5]",
                    "output": "9",
                    "explanation": "Water fills between 4,5 and intermediate bars."
                }
            ],
            "constraints": [
                "n == height.length",
                "1 <= n <= 2 * 10^4",
                "0 <= height[i] <= 10^5"
            ],
            "hints": [
                "Water at position i = min(maxLeft, maxRight) - height[i].",
                "Use two pointers from both ends.",
                "Or precompute maxLeft and maxRight arrays."
            ],
            "relatedProblems": [
                "container-with-most-water",
                "product-of-array-except-self",
                "trapping-rain-water-ii"
            ],
            "videoId": "ZI2z5pq0TqA",
            "problemStatement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "roman-to-integer": {
            "title": "Roman to Integer",
            "pattern": "Hash Map",
            "patternEmoji": "\ud83c\udfdb\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If current < next, subtract; else add.",
            "intuition": [
                "\ud83c\udfaf Convert Roman numeral to integer.",
                "\ud83e\udde0 Map each symbol to value.",
                "\ud83d\udca1 If s[i] < s[i+1], subtract s[i]; else add."
            ],
            "testCases": [
                {
                    "input": "s = \"III\"",
                    "output": "3"
                },
                {
                    "input": "s = \"LVIII\"",
                    "output": "58"
                },
                {
                    "input": "s = \"MCMXCIV\"",
                    "output": "1994"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "I=1, V=5, X=10...",
                    "explanation": "Values."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Compare curr and next",
                    "explanation": "Direction."
                },
                {
                    "step": 3,
                    "title": "Add/Sub",
                    "visual": "Accumulate result",
                    "explanation": "Total."
                }
            ],
            "code": "def romanToInt(s):\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    for i in range(len(s)):\n        if i + 1 < len(s) and roman[s[i]] < roman[s[i + 1]]:\n            total -= roman[s[i]]\n        else:\n            total += roman[s[i]]\n    return total",
            "keyInsight": "Subtraction happens when a smaller value precedes a larger one.",
            "visualizationType": "string",
            "initialState": "MCMXCIV",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Map",
                    "visual": "I=1, V=5, X=10...",
                    "explanation": "Values."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Compare curr and next",
                    "explanation": "Direction."
                },
                {
                    "step": 3,
                    "title": "Add/Sub",
                    "visual": "Accumulate result",
                    "explanation": "Total."
                }
            ],
            "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.",
            "examples": [
                {
                    "input": "s = \"III\"",
                    "output": "3",
                    "explanation": "III = 1 + 1 + 1 = 3."
                },
                {
                    "input": "s = \"LVIII\"",
                    "output": "58",
                    "explanation": "L = 50, V= 5, III = 3."
                },
                {
                    "input": "s = \"MCMXCIV\"",
                    "output": "1994",
                    "explanation": "M = 1000, CM = 900, XC = 90, IV = 4."
                }
            ],
            "constraints": [
                "1 <= s.length <= 15",
                "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').",
                "It is guaranteed that s is a valid roman numeral."
            ],
            "hints": [
                "Create a mapping of symbols to values.",
                "If current < next, subtract current.",
                "Otherwise add current."
            ],
            "relatedProblems": [
                "integer-to-roman"
            ],
            "videoId": "3jdxYj3DD98",
            "problemStatement": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nGiven a roman numeral, convert it to an integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "integer-to-roman": {
            "title": "Integer to Roman",
            "pattern": "Greedy",
            "patternEmoji": "\ud83c\udfdb\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(1)",
            "oneliner": "Greedily subtract largest possible value and append symbol.",
            "intuition": [
                "\ud83c\udfaf Convert integer to Roman numeral.",
                "\ud83e\udde0 Use a list of (value, symbol) pairs in descending order.",
                "\ud83d\udca1 Repeatedly subtract and append until num is 0."
            ],
            "testCases": [
                {
                    "input": "num = 3749",
                    "output": "\"MMMDCCXLIX\""
                },
                {
                    "input": "num = 58",
                    "output": "\"LVIII\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "List",
                    "visual": "(1000,M), (900,CM)...",
                    "explanation": "All values."
                },
                {
                    "step": 2,
                    "title": "Greed",
                    "visual": "While num >= val: append",
                    "explanation": "Subtract."
                },
                {
                    "step": 3,
                    "title": "Build",
                    "visual": "Concatenate symbols",
                    "explanation": "Result."
                }
            ],
            "code": "def intToRoman(num):\n    val_sym = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),\n               (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'),\n               (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]\n    res = []\n    for val, sym in val_sym:\n        while num >= val:\n            res.append(sym)\n            num -= val\n    return ''.join(res)",
            "keyInsight": "Include subtraction pairs (CM, CD, XC, etc.) in the lookup table.",
            "visualizationType": "string",
            "initialState": "3749",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "List",
                    "visual": "(1000,M), (900,CM)...",
                    "explanation": "All values."
                },
                {
                    "step": 2,
                    "title": "Greed",
                    "visual": "While num >= val: append",
                    "explanation": "Subtract."
                },
                {
                    "step": 3,
                    "title": "Build",
                    "visual": "Concatenate symbols",
                    "explanation": "Result."
                }
            ],
            "description": "Greedily subtract largest possible value and append symbol.\n\nConvert integer to Roman numeral.\nUse a list of (value, symbol) pairs in descending order.",
            "examples": [
                {
                    "input": "num = 3749",
                    "output": "\"MMMDCCXLIX\""
                },
                {
                    "input": "num = 58",
                    "output": "\"LVIII\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert integer to Roman numeral.",
                "Use a list of (value, symbol) pairs in descending order.",
                "Repeatedly subtract and append until num is 0."
            ],
            "relatedProblems": [
                "jump-game",
                "gas-station",
                "best-time-to-buy-and-sell-stock-ii"
            ],
            "videoId": "ohBNdSJyLh8",
            "problemStatement": "Seven different symbols represent Roman numerals with the following values:\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\nGiven an integer, convert it to a Roman numeral.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "length-of-last-word": {
            "title": "Length of Last Word",
            "pattern": "String Traversal",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Strip trailing spaces, find last space, return len - last_space - 1.",
            "intuition": [
                "\ud83c\udfaf Find length of last word.",
                "\ud83e\udde0 Iterate from end, skip trailing spaces, count letters.",
                "\ud83d\udca1 Or just use split()[-1]."
            ],
            "testCases": [
                {
                    "input": "s = \"Hello World\"",
                    "output": "5"
                },
                {
                    "input": "s = \"   fly me   to   the moon  \"",
                    "output": "4"
                },
                {
                    "input": "s = \"luffy is still joyboy\"",
                    "output": "6"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Trim",
                    "visual": "Skip trailing spaces",
                    "explanation": "Find word."
                },
                {
                    "step": 2,
                    "title": "Count",
                    "visual": "Count until space",
                    "explanation": "Length."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Length = 5",
                    "explanation": "Done."
                }
            ],
            "code": "def lengthOfLastWord(s):\n    return len(s.strip().split()[-1])",
            "keyInsight": "Python's split() handles multiple spaces elegantly.",
            "visualizationType": "string",
            "initialState": "Hello World",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Trim",
                    "visual": "Skip trailing spaces",
                    "explanation": "Find word."
                },
                {
                    "step": 2,
                    "title": "Count",
                    "visual": "Count until space",
                    "explanation": "Length."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Length = 5",
                    "explanation": "Done."
                }
            ],
            "description": "Strip trailing spaces, find last space, return len - last_space - 1.\n\nFind length of last word.\nIterate from end, skip trailing spaces, count letters.",
            "examples": [
                {
                    "input": "s = \"Hello World\"",
                    "output": "5"
                },
                {
                    "input": "s = \"   fly me   to   the moon  \"",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find length of last word.",
                "Iterate from end, skip trailing spaces, count letters.",
                "Or just use split()[-1]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "KT9rltZTybQ",
            "problemStatement": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "longest-common-prefix": {
            "title": "Longest Common Prefix",
            "pattern": "Horizontal Scan",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(S)",
            "spaceComplexity": "O(1)",
            "oneliner": "Compare characters at same position across all strings.",
            "intuition": [
                "\ud83c\udfaf Find the longest common prefix among all strings.",
                "\ud83e\udde0 Iterate character by character.",
                "\ud83d\udca1 Stop when any string differs or ends."
            ],
            "testCases": [
                {
                    "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                    "output": "\"fl\""
                },
                {
                    "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                    "output": "\"\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Zip",
                    "visual": "Compare columns",
                    "explanation": "Char by char."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "All same?",
                    "explanation": "Continue."
                },
                {
                    "step": 3,
                    "title": "Stop",
                    "visual": "Mismatch found",
                    "explanation": "Return prefix."
                }
            ],
            "code": "def longestCommonPrefix(strs):\n    if not strs: return ''\n    for i in range(len(strs[0])):\n        char = strs[0][i]\n        for s in strs[1:]:\n            if i >= len(s) or s[i] != char:\n                return strs[0][:i]\n    return strs[0]",
            "keyInsight": "Vertical scanning is more efficient than horizontal pairwise comparison.",
            "visualizationType": "array",
            "initialState": [
                "flower",
                "flow",
                "flight"
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Zip",
                    "visual": "Compare columns",
                    "explanation": "Char by char."
                },
                {
                    "step": 2,
                    "title": "Check",
                    "visual": "All same?",
                    "explanation": "Continue."
                },
                {
                    "step": 3,
                    "title": "Stop",
                    "visual": "Mismatch found",
                    "explanation": "Return prefix."
                }
            ],
            "description": "Compare characters at same position across all strings.\n\nFind the longest common prefix among all strings.\nIterate character by character.",
            "examples": [
                {
                    "input": "strs = [\"flower\",\"flow\",\"flight\"]",
                    "output": "\"fl\""
                },
                {
                    "input": "strs = [\"dog\",\"racecar\",\"car\"]",
                    "output": "\"\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find the longest common prefix among all strings.",
                "Iterate character by character.",
                "Stop when any string differs or ends."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "0sWShKIJoo4",
            "problemStatement": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "reverse-words-in-a-string": {
            "title": "Reverse Words in a String",
            "pattern": "Two Pointers / Split",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Split by spaces, reverse, join with single space.",
            "intuition": [
                "\ud83c\udfaf Reverse the order of words in a string.",
                "\ud83e\udde0 Split removes extra spaces, reverse list, join.",
                "\ud83d\udca1 Handle leading/trailing/multiple spaces."
            ],
            "testCases": [
                {
                    "input": "s = \"the sky is blue\"",
                    "output": "\"blue is sky the\""
                },
                {
                    "input": "s = \"  hello world  \"",
                    "output": "\"world hello\""
                },
                {
                    "input": "s = \"a good   example\"",
                    "output": "\"example good a\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['the', 'sky', 'is', 'blue']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "['blue', 'is', 'sky', 'the']",
                    "explanation": "Flip order."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'blue is sky the'",
                    "explanation": "Combine."
                }
            ],
            "code": "def reverseWords(s):\n    return ' '.join(s.split()[::-1])",
            "keyInsight": "Python's split() without args handles multiple spaces elegantly.",
            "visualizationType": "string",
            "initialState": "the sky is blue",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Split",
                    "visual": "['the', 'sky', 'is', 'blue']",
                    "explanation": "Tokenize."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "['blue', 'is', 'sky', 'the']",
                    "explanation": "Flip order."
                },
                {
                    "step": 3,
                    "title": "Join",
                    "visual": "'blue is sky the'",
                    "explanation": "Combine."
                }
            ],
            "description": "Split by spaces, reverse, join with single space.\n\nReverse the order of words in a string.\nSplit removes extra spaces, reverse list, join.",
            "examples": [
                {
                    "input": "s = \"the sky is blue\"",
                    "output": "\"blue is sky the\""
                },
                {
                    "input": "s = \"  hello world  \"",
                    "output": "\"world hello\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse the order of words in a string.",
                "Split removes extra spaces, reverse list, join.",
                "Handle leading/trailing/multiple spaces."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "vhnRAaJybpA",
            "problemStatement": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?",
            "difficulty": "Medium"
        },
        "zigzag-conversion": {
            "title": "Zigzag Conversion",
            "pattern": "Simulation",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use row index and direction flag. Toggle direction at bounds.",
            "intuition": [
                "\ud83c\udfaf Write string in zigzag pattern, read row by row.",
                "\ud83e\udde0 Track current row, direction (up/down).",
                "\ud83d\udca1 Flip direction at row 0 and row numRows-1."
            ],
            "testCases": [
                {
                    "input": "s = \"PAYPALISHIRING\", numRows = 3",
                    "output": "\"PAHNAPLSIIGYIR\""
                },
                {
                    "input": "s = \"PAYPALISHIRING\", numRows = 4",
                    "output": "\"PINALSIGYAHRPI\""
                },
                {
                    "input": "s = \"A\", numRows = 1",
                    "output": "\"A\""
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "rows = [''] * numRows",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Traverse",
                    "visual": "Add char to row[i]",
                    "explanation": "Fill."
                },
                {
                    "step": 3,
                    "title": "Direction",
                    "visual": "Bounce at edges",
                    "explanation": "Zigzag."
                }
            ],
            "code": "def convert(s, numRows):\n    if numRows == 1 or numRows >= len(s): return s\n    rows = [''] * numRows\n    idx, step = 0, 1\n    for c in s:\n        rows[idx] += c\n        if idx == 0: step = 1\n        elif idx == numRows - 1: step = -1\n        idx += step\n    return ''.join(rows)",
            "keyInsight": "The pattern is: go down until bottom, then go up until top, repeat.",
            "visualizationType": "string",
            "initialState": "PAYPALISHIRING",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "rows = [''] * numRows",
                    "explanation": "Setup."
                },
                {
                    "step": 2,
                    "title": "Traverse",
                    "visual": "Add char to row[i]",
                    "explanation": "Fill."
                },
                {
                    "step": 3,
                    "title": "Direction",
                    "visual": "Bounce at edges",
                    "explanation": "Zigzag."
                }
            ],
            "description": "Use row index and direction flag. Toggle direction at bounds.\n\nWrite string in zigzag pattern, read row by row.\nTrack current row, direction (up/down).",
            "examples": [
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 3",
                    "output": "\"PAHNAPLSIIGYIR\""
                },
                {
                    "input": "s = \"PAYPALISHIRING\"; numRows = 4",
                    "output": "\"PINALSIGYAHRPI\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Write string in zigzag pattern, read row by row.",
                "Track current row, direction (up/down).",
                "Flip direction at row 0 and row numRows-1."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Q2Tw6gcVEwc",
            "problemStatement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "find-the-index-of-the-first-occurrence-in-a-string": {
            "title": "Find the Index of the First Occurrence in a String",
            "pattern": "KMP / Simple Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(n*m)",
            "spaceComplexity": "O(1)",
            "oneliner": "Slide needle over haystack, check for match.",
            "intuition": [
                "\ud83c\udfaf Find first occurrence of needle in haystack.",
                "\ud83e\udde0 Simple: check each starting position.",
                "\ud83d\udca1 Or use Python's built-in find()."
            ],
            "testCases": [
                {
                    "input": "haystack = \"sadbutsad\", needle = \"sad\"",
                    "output": "0"
                },
                {
                    "input": "haystack = \"leetcode\", needle = \"leeto\"",
                    "output": "-1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Slide",
                    "visual": "Check each position",
                    "explanation": "Linear scan."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "Compare substring",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Index or -1",
                    "explanation": "Result."
                }
            ],
            "code": "def strStr(haystack, needle):\n    return haystack.find(needle)",
            "keyInsight": "Python's find() is optimized. For interviews, show manual sliding window.",
            "visualizationType": "string",
            "initialState": "sadbutsad",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Slide",
                    "visual": "Check each position",
                    "explanation": "Linear scan."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "Compare substring",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Index or -1",
                    "explanation": "Result."
                }
            ],
            "description": "Slide needle over haystack, check for match.\n\nFind first occurrence of needle in haystack.\nSimple: check each starting position.",
            "examples": [
                {
                    "input": "haystack = \"sadbutsad\"; needle = \"sad\"",
                    "output": "0"
                },
                {
                    "input": "haystack = \"leetcode\"; needle = \"leeto\"",
                    "output": "-1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find first occurrence of needle in haystack.",
                "Simple: check each starting position.",
                "Or use Python's built-in find()."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "JoF0Z7nVSrA",
            "problemStatement": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "text-justification": {
            "title": "Text Justification",
            "pattern": "Greedy + Simulation",
            "patternEmoji": "\ud83d\udcdd",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Greedily pack words, distribute spaces evenly. Left-justify last line.",
            "intuition": [
                "\ud83c\udfaf Fully justify text to maxWidth.",
                "\ud83e\udde0 Pack as many words as fit, distribute extra spaces.",
                "\ud83d\udca1 Last line: left-justified."
            ],
            "testCases": [
                {
                    "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
                    "output": "[\n\u00a0 \u00a0\"This \u00a0 \u00a0is \u00a0 \u00a0an\",\n\u00a0 \u00a0\"example \u00a0of text\",\n\u00a0 \u00a0\"justification. \u00a0\"\n]"
                },
                {
                    "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
                    "output": "[\n\u00a0 \"What \u00a0 must \u00a0 be\",\n\u00a0 \"acknowledgment \u00a0\",\n\u00a0 \"shall be \u00a0 \u00a0 \u00a0 \u00a0\"\n]"
                },
                {
                    "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
                    "output": "[\n\u00a0 \"Science \u00a0is \u00a0what we\",\n  \"understand \u00a0 \u00a0 \u00a0well\",\n\u00a0 \"enough to explain to\",\n\u00a0 \"a \u00a0computer. \u00a0Art is\",\n\u00a0 \"everything \u00a0else \u00a0we\",\n\u00a0 \"do \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\"\n]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Pack",
                    "visual": "Greedy word fit",
                    "explanation": "Fill line."
                },
                {
                    "step": 2,
                    "title": "Space",
                    "visual": "Distribute evenly",
                    "explanation": "Justify."
                },
                {
                    "step": 3,
                    "title": "Last",
                    "visual": "Left align",
                    "explanation": "Special case."
                }
            ],
            "code": "def fullJustify(words, maxWidth):\n    res, line, width = [], [], 0\n    for w in words:\n        if width + len(w) + len(line) > maxWidth:\n            for i in range(maxWidth - width):\n                line[i % (len(line) - 1 or 1)] += ' '\n            res.append(''.join(line))\n            line, width = [], 0\n        line.append(w)\n        width += len(w)\n    return res + [' '.join(line).ljust(maxWidth)]",
            "keyInsight": "Distribute extra spaces using modulo for even distribution.",
            "visualizationType": "array",
            "initialState": [
                "This",
                "is",
                "an",
                "example"
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Pack",
                    "visual": "Greedy word fit",
                    "explanation": "Fill line."
                },
                {
                    "step": 2,
                    "title": "Space",
                    "visual": "Distribute evenly",
                    "explanation": "Justify."
                },
                {
                    "step": 3,
                    "title": "Last",
                    "visual": "Left align",
                    "explanation": "Special case."
                }
            ],
            "description": "Greedily pack words, distribute spaces evenly. Left-justify last line.\n\nFully justify text to maxWidth.\nPack as many words as fit, distribute extra spaces.",
            "examples": [
                {
                    "input": "words = [\"This\", \"is\", \"an\", \"example\"]; maxWidth = 16",
                    "output": "[\"This    is    an\", \"example         \"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Fully justify text to maxWidth.",
                "Pack as many words as fit, distribute extra spaces.",
                "Last line: left-justified."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TzMl5gId3s0",
            "problemStatement": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\nNote:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Hard"
        },
        "find-all-numbers-disappeared-in-an-array": {
            "title": "Find All Numbers Disappeared in an Array",
            "pattern": "Index Marking",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Mark visited indices negative. Return indices still positive.",
            "intuition": [
                "\ud83c\udfaf Find numbers 1..n missing from array.",
                "\ud83e\udde0 Use indices as markers: negate nums[nums[i]-1].",
                "\ud83d\udca1 Positive indices indicate missing numbers."
            ],
            "testCases": [
                {
                    "input": "nums = [4,3,2,7,8,2,3,1]",
                    "output": "[5,6]"
                },
                {
                    "input": "nums = [1,1]",
                    "output": "[2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Mark",
                    "visual": "Negate at index",
                    "explanation": "Seen."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Find positives",
                    "explanation": "Missing."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "[5, 6]",
                    "explanation": "Result."
                }
            ],
            "code": "def findDisappearedNumbers(nums):\n    for n in nums:\n        idx = abs(n) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i, n in enumerate(nums) if n > 0]",
            "keyInsight": "Using array indices as a hash set avoids extra space.",
            "visualizationType": "array",
            "initialState": [
                4,
                3,
                2,
                7,
                8,
                2,
                3,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Mark",
                    "visual": "Negate at index",
                    "explanation": "Seen."
                },
                {
                    "step": 2,
                    "title": "Scan",
                    "visual": "Find positives",
                    "explanation": "Missing."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "[5, 6]",
                    "explanation": "Result."
                }
            ],
            "description": "Mark visited indices negative. Return indices still positive.\n\nFind numbers 1..n missing from array.\nUse indices as markers: negate nums[nums[i]-1].",
            "examples": [
                {
                    "input": "nums = [4,3,2,7,8,2,3,1]",
                    "output": "[5,6]"
                },
                {
                    "input": "nums = [1,1]",
                    "output": "[2]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find numbers 1..n missing from array.",
                "Use indices as markers: negate nums[nums[i]-1].",
                "Positive indices indicate missing numbers."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "8i-f24YFWC4",
            "problemStatement": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\nExample 1:\nExample 2:\nConstraints:\nFollow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.",
            "difficulty": "Easy"
        },
        "is-subsequence": {
            "title": "Is Subsequence",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use pointer for s, advance when char matches in t.",
            "intuition": [
                "\ud83c\udfaf Is s a subsequence of t?",
                "\ud83e\udde0 Two pointers: advance s pointer on match.",
                "\ud83d\udca1 If s pointer reaches end, it's a subsequence."
            ],
            "testCases": [
                {
                    "input": "s = \"abc\", t = \"ahbgdc\"",
                    "output": "true"
                },
                {
                    "input": "s = \"axc\", t = \"ahbgdc\"",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "i=0, j=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "s[i]==t[j]? i++",
                    "explanation": "Advance."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "i == len(s)?",
                    "explanation": "Result."
                }
            ],
            "code": "def isSubsequence(s, t):\n    i = 0\n    for c in t:\n        if i < len(s) and c == s[i]:\n            i += 1\n    return i == len(s)",
            "keyInsight": "Characters must appear in order but not necessarily contiguous.",
            "visualizationType": "string",
            "initialState": "abc",
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "i=0, j=0",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Match",
                    "visual": "s[i]==t[j]? i++",
                    "explanation": "Advance."
                },
                {
                    "step": 3,
                    "title": "Check",
                    "visual": "i == len(s)?",
                    "explanation": "Result."
                }
            ],
            "description": "Use pointer for s, advance when char matches in t.\n\nIs s a subsequence of t?\nTwo pointers: advance s pointer on match.",
            "examples": [
                {
                    "input": "s = \"abc\"; t = \"ahbgdc\"",
                    "output": "true"
                },
                {
                    "input": "s = \"axc\"; t = \"ahbgdc\"",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Is s a subsequence of t?",
                "Two pointers: advance s pointer on match.",
                "If s pointer reaches end, it's a subsequence."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "99RVfqklbCE",
            "problemStatement": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "two-sum-ii---input-array-is-sorted": {
            "title": "Two Sum II - Input Array Is Sorted",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Left and right pointers. Move left up if sum too small, right down if too big.",
            "intuition": [
                "\ud83c\udfaf Find two numbers that add up to target (1-indexed).",
                "\ud83e\udde0 Since sorted, use two pointers from ends.",
                "\ud83d\udca1 Adjust pointers based on sum vs target."
            ],
            "testCases": [
                {
                    "input": "numbers = [2,7,11,15], target = 9",
                    "output": "[1,2]"
                },
                {
                    "input": "numbers = [2,3,4], target = 6",
                    "output": "[1,3]"
                },
                {
                    "input": "numbers = [-1,0], target = -1",
                    "output": "[1,2]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Endpoints."
                },
                {
                    "step": 2,
                    "title": "Sum",
                    "visual": "Compare to target",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Adjust",
                    "visual": "Move pointers",
                    "explanation": "Narrow."
                }
            ],
            "code": "def twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l + 1, r + 1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1\n    return []",
            "keyInsight": "Sorted array + two sum = classic two pointer pattern.",
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Endpoints."
                },
                {
                    "step": 2,
                    "title": "Sum",
                    "visual": "Compare to target",
                    "explanation": "Check."
                },
                {
                    "step": 3,
                    "title": "Adjust",
                    "visual": "Move pointers",
                    "explanation": "Narrow."
                }
            ],
            "description": "Left and right pointers. Move left up if sum too small, right down if too big.\n\nFind two numbers that add up to target (1-indexed).\nSince sorted, use two pointers from ends.",
            "examples": [
                {
                    "input": "numbers = [2,7,11,15]; target = 9",
                    "output": "[1,2]"
                },
                {
                    "input": "numbers = [2,3,4]; target = 6",
                    "output": "[1,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find two numbers that add up to target (1-indexed).",
                "Since sorted, use two pointers from ends.",
                "Adjust pointers based on sum vs target."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "cQ1Oz4ckceM",
            "problemStatement": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "container-with-most-water": {
            "title": "Container With Most Water",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udca7",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two pointers from ends. Move the shorter one inward.",
            "intuition": [
                "\ud83c\udfaf Maximize water container area.",
                "\ud83e\udde0 Area = min(height[l], height[r]) * (r - l).",
                "\ud83d\udca1 Moving shorter line could find taller one."
            ],
            "testCases": [
                {
                    "input": "height = [1,8,6,2,5,4,8,3,7]",
                    "output": "49"
                },
                {
                    "input": "height = [1,1]",
                    "output": "1"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Max width."
                },
                {
                    "step": 2,
                    "title": "Area",
                    "visual": "min * width",
                    "explanation": "Calculate."
                },
                {
                    "step": 3,
                    "title": "Move",
                    "visual": "Shorter side",
                    "explanation": "Optimize."
                }
            ],
            "code": "def maxArea(height):\n    l, r = 0, len(height) - 1\n    maxA = 0\n    while l < r:\n        area = min(height[l], height[r]) * (r - l)\n        maxA = max(maxA, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return maxA",
            "keyInsight": "Moving the taller line can never increase area (width decreases, height capped).",
            "visualizationType": "array",
            "initialState": [
                1,
                8,
                6,
                2,
                5,
                4,
                8,
                3,
                7
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1",
                    "explanation": "Max width."
                },
                {
                    "step": 2,
                    "title": "Area",
                    "visual": "min * width",
                    "explanation": "Calculate."
                },
                {
                    "step": 3,
                    "title": "Move",
                    "visual": "Shorter side",
                    "explanation": "Optimize."
                }
            ],
            "description": "Two pointers from ends. Move the shorter one inward.\n\nMaximize water container area.\nArea = min(height[l], height[r]) * (r - l).",
            "examples": [
                {
                    "input": "height = [1,8,6,2,5,4,8,3,7]",
                    "output": "49"
                },
                {
                    "input": "height = [1,1]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maximize water container area.",
                "Area = min(height[l], height[r]) * (r - l).",
                "Moving shorter line could find taller one."
            ],
            "relatedProblems": [
                "two-sum",
                "3sum"
            ],
            "videoId": "UuiTKBwPgAo",
            "problemStatement": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "3sum": {
            "title": "3Sum",
            "pattern": "Two Pointers + Sort",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort, fix one element, two-pointer for remaining two.",
            "intuition": [
                "\ud83c\udfaf Find all triplets summing to 0.",
                "\ud83e\udde0 Sort array. For each i, use two pointers on [i+1, n-1].",
                "\ud83d\udca1 Skip duplicates to avoid duplicate triplets."
            ],
            "testCases": [
                {
                    "input": "nums = [-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                },
                {
                    "input": "nums = [0,1,1]",
                    "output": "[]"
                },
                {
                    "input": "nums = [0,0,0]",
                    "output": "[[0,0,0]]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Sort",
                    "visual": "[-4,-1,-1,0,1,2]",
                    "explanation": "Order matters."
                },
                {
                    "step": 2,
                    "title": "Fix",
                    "visual": "i = 0",
                    "explanation": "First element."
                },
                {
                    "step": 3,
                    "title": "Two Ptr",
                    "visual": "l, r narrow",
                    "explanation": "Find complement."
                }
            ],
            "code": "def threeSum(nums):\n    nums.sort()\n    res = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]: l += 1\n                while l < r and nums[r] == nums[r - 1]: r -= 1\n                l, r = l + 1, r - 1\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res",
            "keyInsight": "Sorting enables two-pointer approach and duplicate skipping.",
            "visualizationType": "array",
            "initialState": [
                -1,
                0,
                1,
                2,
                -1,
                -4
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Sort",
                    "visual": "[-4,-1,-1,0,1,2]",
                    "explanation": "Order matters."
                },
                {
                    "step": 2,
                    "title": "Fix",
                    "visual": "i = 0",
                    "explanation": "First element."
                },
                {
                    "step": 3,
                    "title": "Two Ptr",
                    "visual": "l, r narrow",
                    "explanation": "Find complement."
                }
            ],
            "description": "Sort, fix one element, two-pointer for remaining two.\n\nFind all triplets summing to 0.\nSort array. For each i, use two pointers on [i+1, n-1].",
            "examples": [
                {
                    "input": "nums = [-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                },
                {
                    "input": "nums = [0,1,1]",
                    "output": "[]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find all triplets summing to 0.",
                "Sort array. For each i, use two pointers on [i+1, n-1].",
                "Skip duplicates to avoid duplicate triplets."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jzZsG8n2R9A",
            "problemStatement": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "squares-of-a-sorted-array": {
            "title": "Squares of a Sorted Array",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udcd0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Compare absolute values at ends, place larger square at end of result.",
            "intuition": [
                "\ud83c\udfaf Square each element, return sorted array.",
                "\ud83e\udde0 Largest squares at ends (negative or positive).",
                "\ud83d\udca1 Two pointers from ends, fill result from back."
            ],
            "testCases": [
                {
                    "input": "nums = [-4,-1,0,3,10]",
                    "output": "[0,1,9,16,100]"
                },
                {
                    "input": "nums = [-7,-3,2,3,11]",
                    "output": "[4,9,9,49,121]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, pos=n-1",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "|nums[l]| vs |nums[r]|",
                    "explanation": "Larger abs."
                },
                {
                    "step": 3,
                    "title": "Fill",
                    "visual": "res[pos] = square",
                    "explanation": "From back."
                }
            ],
            "code": "def sortedSquares(nums):\n    n = len(nums)\n    res = [0] * n\n    l, r = 0, n - 1\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            res[pos] = nums[l] ** 2\n            l += 1\n        else:\n            res[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return res",
            "keyInsight": "The largest absolute value is always at one of the ends.",
            "visualizationType": "array",
            "initialState": [
                -4,
                -1,
                0,
                3,
                10
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Init",
                    "visual": "l=0, r=n-1, pos=n-1",
                    "explanation": "Pointers."
                },
                {
                    "step": 2,
                    "title": "Compare",
                    "visual": "|nums[l]| vs |nums[r]|",
                    "explanation": "Larger abs."
                },
                {
                    "step": 3,
                    "title": "Fill",
                    "visual": "res[pos] = square",
                    "explanation": "From back."
                }
            ],
            "description": "Compare absolute values at ends, place larger square at end of result.\n\nSquare each element, return sorted array.\nLargest squares at ends (negative or positive).",
            "examples": [
                {
                    "input": "nums = [-4,-1,0,3,10]",
                    "output": "[0,1,9,16,100]"
                },
                {
                    "input": "nums = [-7,-3,2,3,11]",
                    "output": "[4,9,9,49,121]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Square each element, return sorted array.",
                "Largest squares at ends (negative or positive).",
                "Two pointers from ends, fill result from back."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "FPCZsG_AkUg",
            "problemStatement": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "longest-mountain-in-array": {
            "title": "Longest Mountain in Array",
            "pattern": "Two Pointers / Expand",
            "patternEmoji": "\ud83c\udfd4\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).",
            "intuition": [
                "\ud83c\udfaf Find longest mountain subarray (up then down).",
                "\ud83e\udde0 At each peak, extend left and right.",
                "\ud83d\udca1 Mountain needs at least 3 elements."
            ],
            "testCases": [
                {
                    "input": "arr = [2,1,4,7,3,2,5]",
                    "output": "5"
                },
                {
                    "input": "arr = [2,2,2]",
                    "output": "0"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find Peak",
                    "visual": "arr[i-1] < arr[i] > arr[i+1]",
                    "explanation": "Locate."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "Left and right",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Length",
                    "visual": "right - left + 1",
                    "explanation": "Calculate."
                }
            ],
            "code": "def longestMountain(arr):\n    n = len(arr)\n    res = 0\n    i = 1\n    while i < n - 1:\n        if arr[i - 1] < arr[i] > arr[i + 1]:\n            l = i - 1\n            while l > 0 and arr[l - 1] < arr[l]: l -= 1\n            r = i + 1\n            while r < n - 1 and arr[r] > arr[r + 1]: r += 1\n            res = max(res, r - l + 1)\n            i = r\n        else:\n            i += 1\n    return res",
            "keyInsight": "After finding a mountain, skip to the end of the downhill.",
            "visualizationType": "array",
            "initialState": [
                2,
                1,
                4,
                7,
                3,
                2,
                5
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Find Peak",
                    "visual": "arr[i-1] < arr[i] > arr[i+1]",
                    "explanation": "Locate."
                },
                {
                    "step": 2,
                    "title": "Expand",
                    "visual": "Left and right",
                    "explanation": "Extend."
                },
                {
                    "step": 3,
                    "title": "Length",
                    "visual": "right - left + 1",
                    "explanation": "Calculate."
                }
            ],
            "description": "Find peak, expand left (strictly decreasing), expand right (strictly decreasing).\n\nFind longest mountain subarray (up then down).\nAt each peak, extend left and right.",
            "examples": [
                {
                    "input": "arr = [2,1,4,7,3,2,5]",
                    "output": "5"
                },
                {
                    "input": "arr = [2,2,2]",
                    "output": "0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find longest mountain subarray (up then down).",
                "At each peak, extend left and right.",
                "Mountain needs at least 3 elements."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "VtM-0OYcRtE",
            "problemStatement": "You may recall that an array arr is a mountain array if and only if:\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
            "difficulty": "Medium"
        },
        "delete-node-in-a-bst": {
            "title": "Delete Node in a BST",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(h)",
            "oneliner": "Find node, replace with successor (leftmost in right subtree).",
            "intuition": [
                "\ud83c\udfaf Delete node with given key from BST.",
                "\ud83e\udde0 Three cases: leaf, one child, two children.",
                "\ud83d\udca1 Two children: replace with inorder successor."
            ],
            "testCases": [
                {
                    "input": "root = [5,3,6,2,4,null,7], key = 3",
                    "output": "[5,4,6,2,null,null,7]"
                },
                {
                    "input": "root = [5,3,6,2,4,null,7], key = 0",
                    "output": "[5,3,6,2,4,null,7]"
                },
                {
                    "input": "root = [], key = 0",
                    "output": "[]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Find",
                    "visual": "BST search",
                    "explanation": "Locate node."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Handle cases",
                    "explanation": "Remove."
                },
                {
                    "step": 3,
                    "title": "Replace",
                    "visual": "Successor",
                    "explanation": "Maintain BST."
                }
            ],
            "code": "def deleteNode(root, key):\n    if not root: return None\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if not root.left: return root.right\n        if not root.right: return root.left\n        # Find successor\n        succ = root.right\n        while succ.left: succ = succ.left\n        root.val = succ.val\n        root.right = deleteNode(root.right, succ.val)\n    return root",
            "keyInsight": "The successor is the leftmost node in the right subtree.",
            "visualizationType": "tree",
            "initialState": [
                5,
                3,
                6,
                2,
                4,
                null,
                7
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Find",
                    "visual": "BST search",
                    "explanation": "Locate node."
                },
                {
                    "step": 2,
                    "title": "Delete",
                    "visual": "Handle cases",
                    "explanation": "Remove."
                },
                {
                    "step": 3,
                    "title": "Replace",
                    "visual": "Successor",
                    "explanation": "Maintain BST."
                }
            ],
            "description": "Find node, replace with successor (leftmost in right subtree).\n\nDelete node with given key from BST.\nThree cases: leaf, one child, two children.",
            "examples": [
                {
                    "input": "root = [5,3,6,2,4,null,7]; key = 3",
                    "output": "[5,4,6,2,null,null,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Delete node with given key from BST.",
                "Three cases: leaf, one child, two children.",
                "Two children: replace with inorder successor."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "LFzAoJJt92M",
            "problemStatement": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it with time complexity O(height of tree)?",
            "difficulty": "Medium"
        },
        "insert-into-a-binary-search-tree": {
            "title": "Insert into a Binary Search Tree",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(h)",
            "oneliner": "Navigate BST, insert at null position.",
            "intuition": [
                "\ud83c\udfaf Insert value into BST maintaining property.",
                "\ud83e\udde0 Go left if val < root, right otherwise.",
                "\ud83d\udca1 Insert at the first null spot found."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3], val = 5",
                    "output": "[4,2,7,1,3,5]"
                },
                {
                    "input": "root = [40,20,60,10,30,50,70], val = 25",
                    "output": "[40,20,60,10,30,50,70,null,null,25]"
                },
                {
                    "input": "root = [4,2,7,1,3,null,null,null,null,null,null], val = 5",
                    "output": "[4,2,7,1,3,5]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Navigate",
                    "visual": "Compare values",
                    "explanation": "BST property."
                },
                {
                    "step": 2,
                    "title": "Insert",
                    "visual": "At null",
                    "explanation": "Add node."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Root",
                    "explanation": "Done."
                }
            ],
            "code": "def insertIntoBST(root, val):\n    if not root: return TreeNode(val)\n    if val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root",
            "keyInsight": "Always insert as a leaf node at the correct position.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Navigate",
                    "visual": "Compare values",
                    "explanation": "BST property."
                },
                {
                    "step": 2,
                    "title": "Insert",
                    "visual": "At null",
                    "explanation": "Add node."
                },
                {
                    "step": 3,
                    "title": "Return",
                    "visual": "Root",
                    "explanation": "Done."
                }
            ],
            "description": "Navigate BST, insert at null position.\n\nInsert value into BST maintaining property.\nGo left if val < root, right otherwise.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3]; val = 5",
                    "output": "[4,2,7,1,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Insert value into BST maintaining property.",
                "Go left if val < root, right otherwise.",
                "Insert at the first null spot found."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Cpg_BFTU5UQ",
            "problemStatement": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "palindrome-linked-list": {
            "title": "Palindrome Linked List",
            "pattern": "Fast/Slow + Reverse",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find middle, reverse second half, compare.",
            "intuition": [
                "\ud83c\udfaf Check if linked list is a palindrome.",
                "\ud83e\udde0 Fast/slow to find middle, reverse second half.",
                "\ud83d\udca1 Compare first and second halves."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,2,1]",
                    "output": "true"
                },
                {
                    "input": "head = [1,2]",
                    "output": "false"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Middle",
                    "visual": "Slow at center",
                    "explanation": "Fast/slow."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "Flip second half",
                    "explanation": "In-place."
                },
                {
                    "step": 3,
                    "title": "Compare",
                    "visual": "Match values",
                    "explanation": "Check."
                }
            ],
            "code": "def isPalindrome(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow, fast = slow.next, fast.next.next\n    # Reverse second half\n    prev = None\n    while slow:\n        slow.next, prev, slow = prev, slow, slow.next\n    # Compare\n    while prev:\n        if head.val != prev.val:\n            return False\n        head, prev = head.next, prev.next\n    return True",
            "keyInsight": "O(1) space by reversing half in-place rather than using a stack.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                2,
                1
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Middle",
                    "visual": "Slow at center",
                    "explanation": "Fast/slow."
                },
                {
                    "step": 2,
                    "title": "Reverse",
                    "visual": "Flip second half",
                    "explanation": "In-place."
                },
                {
                    "step": 3,
                    "title": "Compare",
                    "visual": "Match values",
                    "explanation": "Check."
                }
            ],
            "description": "Find middle, reverse second half, compare.\n\nCheck if linked list is a palindrome.\nFast/slow to find middle, reverse second half.",
            "examples": [
                {
                    "input": "head = [1,2,2,1]",
                    "output": "true"
                },
                {
                    "input": "head = [1,2]",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Check if linked list is a palindrome.",
                "Fast/slow to find middle, reverse second half.",
                "Compare first and second halves."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yOzXms1J6Nk",
            "problemStatement": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "gfg---reverse-first-k-elements-of-a-queue": {
            "title": "GFG - Reverse first K elements of a Queue",
            "pattern": "Stack + Queue",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use stack to reverse first k, then cycle remaining elements.",
            "intuition": [
                "\ud83c\udfaf Reverse first k elements of a queue.",
                "\ud83e\udde0 Pop k to stack, push back, cycle n-k elements.",
                "\ud83d\udca1 Stack reverses order naturally."
            ],
            "testCases": [
                {
                    "input": "k = 3, queue = [10, 20, 30, 40, 50]",
                    "output": "[30, 20, 10, 40, 50]"
                },
                {
                    "input": "k = 4, queue = [10, 20, 30, 40, 50]",
                    "output": "[40, 30, 20, 10, 50]"
                }
            ],
            "steps": [
                {
                    "step": 1,
                    "title": "Stack",
                    "visual": "Push k elements",
                    "explanation": "Reverse."
                },
                {
                    "step": 2,
                    "title": "Push",
                    "visual": "Pop stack to queue",
                    "explanation": "Reversed."
                },
                {
                    "step": 3,
                    "title": "Cycle",
                    "visual": "Move n-k to back",
                    "explanation": "Reorder."
                }
            ],
            "code": "from collections import deque\n\ndef reverseFirstK(queue, k):\n    queue = deque(queue)\n    if not queue or k <= 0 or k > len(queue):\n        return list(queue)\n    stack = []\n    for _ in range(k):\n        stack.append(queue.popleft())\n    while stack:\n        queue.append(stack.pop())\n    for _ in range(len(queue) - k):\n        queue.append(queue.popleft())\n    return list(queue)",
            "keyInsight": "Use a stack to reverse order, then cycle the remaining elements.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [
                {
                    "step": 1,
                    "title": "Stack",
                    "visual": "Push k elements",
                    "explanation": "Reverse."
                },
                {
                    "step": 2,
                    "title": "Push",
                    "visual": "Pop stack to queue",
                    "explanation": "Reversed."
                },
                {
                    "step": 3,
                    "title": "Cycle",
                    "visual": "Move n-k to back",
                    "explanation": "Reorder."
                }
            ],
            "description": "Use stack to reverse first k, then cycle remaining elements.\n\nReverse first k elements of a queue.\nPop k to stack, push back, cycle n-k elements.",
            "examples": [
                {
                    "input": "queue = [1,2,3,4,5]; k = 3",
                    "output": "[3,2,1,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse first k elements of a queue.",
                "Pop k to stack, push back, cycle n-k elements.",
                "Stack reverses order naturally."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "8vuPi0rPWOk",
            "problemStatement": "Given an integer K and a queue of integers, we need to reverse the order of the first K elements of the queue, leaving the other elements in the same relative order."
        },
        "minimum-size-subarray-sum": {
            "title": "Minimum Size Subarray Sum",
            "pattern": "Sliding Window",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Expand right until sum >= target, shrink left while valid.",
            "intuition": [
                "\ud83c\udfaf Find minimal length subarray with sum >= target.",
                "\ud83e\udde0 Sliding window: expand right, shrink left when valid.",
                "\ud83d\udca1 Track minimum length when sum >= target."
            ],
            "testCases": [
                {
                    "input": "target = 7, nums = [2,3,1,2,4,3]",
                    "output": "2"
                },
                {
                    "input": "target = 4, nums = [1,4,4]",
                    "output": "1"
                },
                {
                    "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
                    "output": "0"
                }
            ],
            "code": "def minSubArrayLen(target, nums):\n    left = 0\n    total = 0\n    minLen = float('inf')\n    for right in range(len(nums)):\n        total += nums[right]\n        while total >= target:\n            minLen = min(minLen, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return minLen if minLen != float('inf') else 0",
            "keyInsight": "Shrink window while maintaining validity to find minimum.",
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                1,
                2,
                4,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initialize pointers and total sum"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Add nums[1] to total"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Total >= target, check window size"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move left pointer to reduce total"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Add nums[3] to total"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Total >= target, check window size"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Add nums[5] to total"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Minimum window size found"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Total >= target, check window size"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "No more elements to process"
                }
            ],
            "description": "Expand right until sum >= target, shrink left while valid.\n\nFind minimal length subarray with sum >= target.\nSliding window: expand right, shrink left when valid.",
            "examples": [
                {
                    "input": "target = 7; nums = [2,3,1,2,4,3]",
                    "output": "2"
                },
                {
                    "input": "target = 4; nums = [1,4,4]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimal length subarray with sum >= target.",
                "Sliding window: expand right, shrink left when valid.",
                "Track minimum length when sum >= target."
            ],
            "relatedProblems": [
                "longest-substring-without-repeating-characters",
                "minimum-window-substring"
            ],
            "videoId": "aYqYMIqZx5s",
            "problemStatement": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "longest-substring-without-repeating-characters": {
            "title": "Longest Substring Without Repeating Characters",
            "pattern": "Sliding Window + Hash Set",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(min(n,m))",
            "oneliner": "Expand right, shrink left when duplicate found.",
            "intuition": [
                "\ud83c\udfaf Find longest substring with all unique characters.",
                "\ud83e\udde0 Use set to track current window characters.",
                "\ud83d\udca1 Remove from left when duplicate encountered."
            ],
            "testCases": [
                {
                    "input": "s = \"abcabcbb\"",
                    "output": "3"
                },
                {
                    "input": "s = \"bbbbb\"",
                    "output": "1"
                },
                {
                    "input": "s = \"pwwkew\"",
                    "output": "3"
                }
            ],
            "code": "def lengthOfLongestSubstring(s):\n    seen = set()\n    left = 0\n    maxLen = 0\n    for right in range(len(s)):\n        while s[right] in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(s[right])\n        maxLen = max(maxLen, right - left + 1)\n    return maxLen",
            "keyInsight": "Use a hash set/map to detect duplicates in O(1).",
            "visualizationType": "string",
            "initialState": "abcabcbb",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initialize 'seen' set and pointers 'left' and 'right' at 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 1, add 'b' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 2, add 'c' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 3, 'a' is in 'seen', remove 'b' and move 'left' to 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 3, add 'a' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 4, 'b' is in 'seen', remove 'c' and move 'left' to 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 4, add 'b' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 5, 'c' is in 'seen', remove 'a' and move 'left' to 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 5, add 'c' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "left"
                        },
                        {
                            "index": 6,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Move 'right' to index 6, add 'b' to 'seen'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6
                    ],
                    "color": "success",
                    "transientMessage": "Final result: Length of the longest substring without repeating characters is 3"
                }
            ],
            "description": "Given a string s, find the length of the longest substring without repeating characters.",
            "examples": [
                {
                    "input": "s = \"abcabcbb\"",
                    "output": "3",
                    "explanation": "The answer is 'abc', with length 3."
                },
                {
                    "input": "s = \"bbbbb\"",
                    "output": "1",
                    "explanation": "The answer is 'b', with length 1."
                },
                {
                    "input": "s = \"pwwkew\"",
                    "output": "3",
                    "explanation": "The answer is 'wke', with length 3."
                }
            ],
            "constraints": [
                "0 <= s.length <= 5 * 10^4",
                "s consists of English letters, digits, symbols and spaces."
            ],
            "hints": [
                "Use the sliding window technique.",
                "Maintain a set of characters in current window.",
                "When you see a duplicate, shrink window from left."
            ],
            "relatedProblems": [
                "longest-repeating-character-replacement",
                "minimum-window-substring",
                "substring-with-concatenation-of-all-words"
            ],
            "videoId": "wiGpQwVHdE0",
            "problemStatement": "Given a string s, find the length of the longest substring without duplicate characters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "substring-with-concatenation-of-all-words": {
            "title": "Substring with Concatenation of All Words",
            "pattern": "Sliding Window + Hash Map",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n*m)",
            "spaceComplexity": "O(m)",
            "oneliner": "Sliding window of size wordLen*numWords, check if all words match.",
            "intuition": [
                "\ud83c\udfaf Find all starting indices of concatenated substrings.",
                "\ud83e\udde0 All words have same length, total window = len*count.",
                "\ud83d\udca1 Slide window, compare word frequency maps."
            ],
            "testCases": [
                {
                    "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
                    "output": "[0,9]"
                },
                {
                    "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
                    "output": "[]"
                },
                {
                    "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
                    "output": "[6,9,12]"
                }
            ],
            "code": "from collections import Counter\n\ndef findSubstring(s, words):\n    if not s or not words: return []\n    wordLen = len(words[0])\n    numWords = len(words)\n    totalLen = wordLen * numWords\n    wordCount = Counter(words)\n    res = []\n    for i in range(len(s) - totalLen + 1):\n        seen = Counter()\n        for j in range(numWords):\n            word = s[i + j * wordLen : i + (j + 1) * wordLen]\n            if word not in wordCount:\n                break\n            seen[word] += 1\n            if seen[word] > wordCount[word]:\n                break\n        else:\n            res.append(i)\n    return res",
            "keyInsight": "Fixed word length simplifies the sliding window logic.",
            "visualizationType": "string",
            "initialState": "barfoothefoobarman",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 5,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Checking the first substring 'barfoo'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 6,
                            "label": "i"
                        },
                        {
                            "index": 11,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Checking the next substring 'thefoo'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        12,
                        17
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 12,
                            "label": "i"
                        },
                        {
                            "index": 17,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Checking the next substring 'barman'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 5,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "'barfoo' matches the word count"
                },
                {
                    "type": "highlight",
                    "indices": [
                        12,
                        17
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 12,
                            "label": "i"
                        },
                        {
                            "index": 17,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "'barman' matches the word count"
                }
            ],
            "description": "Sliding window of size wordLen*numWords, check if all words match.\n\nFind all starting indices of concatenated substrings.\nAll words have same length, total window = len*count.",
            "examples": [
                {
                    "input": "s = \"barfoothefoobarman\"; words = [\"foo\",\"bar\"]",
                    "output": "[0,9]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find all starting indices of concatenated substrings.",
                "All words have same length, total window = len*count.",
                "Slide window, compare word frequency maps."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cYbN9p1uPQY",
            "problemStatement": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Hard"
        },
        "minimum-window-substring": {
            "title": "Minimum Window Substring",
            "pattern": "Sliding Window + Hash Map",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(m)",
            "oneliner": "Expand right to include all t chars, shrink left to minimize.",
            "intuition": [
                "\ud83c\udfaf Find minimum window in s containing all chars of t.",
                "\ud83e\udde0 Count required chars, expand right until all satisfied.",
                "\ud83d\udca1 Shrink left while still valid, track minimum."
            ],
            "testCases": [
                {
                    "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
                    "output": "\"BANC\""
                },
                {
                    "input": "s = \"a\", t = \"a\"",
                    "output": "\"a\""
                },
                {
                    "input": "s = \"a\", t = \"aa\"",
                    "output": "\"\""
                }
            ],
            "code": "from collections import Counter\n\ndef minWindow(s, t):\n    if not t or not s: return ''\n    need = Counter(t)\n    have = {}\n    required = len(need)\n    formed = 0\n    left = 0\n    res = (float('inf'), 0, 0)\n    for right, c in enumerate(s):\n        have[c] = have.get(c, 0) + 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while formed == required:\n            if right - left + 1 < res[0]:\n                res = (right - left + 1, left, right + 1)\n            have[s[left]] -= 1\n            if s[left] in need and have[s[left]] < need[s[left]]:\n                formed -= 1\n            left += 1\n    return '' if res[0] == float('inf') else s[res[1]:res[2]]",
            "keyInsight": "Track 'formed' count to know when all required chars are satisfied.",
            "visualizationType": "string",
            "initialState": "ADOBECODEBANC",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initializing pointers and counters"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'A' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'D' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'O' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'B' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'E' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Processing character 'C' at right pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Minimum window found: 'BANC'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 6,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Shrinking window by moving left pointer"
                },
                {
                    "type": "highlight",
                    "indices": [
                        7,
                        8,
                        9,
                        10,
                        11
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 7,
                            "label": "left"
                        },
                        {
                            "index": 11,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Final minimum window: 'BANC'"
                }
            ],
            "description": "Expand right to include all t chars, shrink left to minimize.\n\nFind minimum window in s containing all chars of t.\nCount required chars, expand right until all satisfied.",
            "examples": [
                {
                    "input": "s = \"ADOBECODEBANC\"; t = \"ABC\"",
                    "output": "\"BANC\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimum window in s containing all chars of t.",
                "Count required chars, expand right until all satisfied.",
                "Shrink left while still valid, track minimum."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jSto0O4AJbM",
            "problemStatement": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\nThe testcases will be generated such that the answer is unique.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you find an algorithm that runs in O(m + n) time?",
            "difficulty": "Hard"
        },
        "valid-sudoku": {
            "title": "Valid Sudoku",
            "pattern": "Hash Set per Row/Col/Box",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(81)",
            "spaceComplexity": "O(81)",
            "oneliner": "Check each row, column, and 3x3 box for duplicates.",
            "intuition": [
                "\ud83c\udfaf Validate a partially filled Sudoku board.",
                "\ud83e\udde0 Use sets for each row, column, and 3x3 box.",
                "\ud83d\udca1 Box index = (row//3, col//3)."
            ],
            "testCases": [
                {
                    "input": "board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "true"
                },
                {
                    "input": "board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "false"
                }
            ],
            "code": "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.': continue\n            box_idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True",
            "keyInsight": "The box index formula (r//3)*3 + (c//3) maps to 0-8.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "5",
                    "3",
                    ".",
                    ".",
                    "7",
                    ".",
                    ".",
                    ".",
                    "."
                ]
            ],
            "animationSteps": [],
            "description": "Check each row, column, and 3x3 box for duplicates.\n\nValidate a partially filled Sudoku board.\nUse sets for each row, column, and 3x3 box.",
            "examples": [
                {
                    "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Validate a partially filled Sudoku board.",
                "Use sets for each row, column, and 3x3 box.",
                "Box index = (row//3, col//3)."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TjFXEUCMqI8",
            "problemStatement": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nNote:\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "spiral-matrix": {
            "title": "Spiral Matrix",
            "pattern": "Layer by Layer",
            "patternEmoji": "\ud83c\udf00",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Process layer by layer: right, down, left, up, shrink bounds.",
            "intuition": [
                "\ud83c\udfaf Return matrix elements in spiral order.",
                "\ud83e\udde0 Maintain top/bottom/left/right boundaries.",
                "\ud83d\udca1 Traverse each direction, shrink boundary, repeat."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                },
                {
                    "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                    "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
                }
            ],
            "code": "def spiralOrder(matrix):\n    if not matrix: return []\n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1): res.append(matrix[top][c])\n        top += 1\n        for r in range(top, bottom + 1): res.append(matrix[r][right])\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1): res.append(matrix[bottom][c])\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1): res.append(matrix[r][left])\n            left += 1\n    return res",
            "keyInsight": "After going right and down, check bounds before going left and up.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    7,
                    8,
                    9
                ]
            ],
            "animationSteps": [],
            "description": "Process layer by layer: right, down, left, up, shrink bounds.\n\nReturn matrix elements in spiral order.\nMaintain top/bottom/left/right boundaries.",
            "examples": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return matrix elements in spiral order.",
                "Maintain top/bottom/left/right boundaries.",
                "Traverse each direction, shrink boundary, repeat."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "BJnMZNwUk1M",
            "problemStatement": "Given an m x n matrix, return all elements of the matrix in spiral order.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "rotate-image": {
            "title": "Rotate Image",
            "pattern": "Transpose + Reverse",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Transpose matrix, then reverse each row.",
            "intuition": [
                "\ud83c\udfaf Rotate matrix 90\u00b0 clockwise in-place.",
                "\ud83e\udde0 Transpose: swap matrix[i][j] with matrix[j][i].",
                "\ud83d\udca1 Reverse each row."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[7,4,1],[8,5,2],[9,6,3]]"
                },
                {
                    "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                    "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
                }
            ],
            "code": "def rotate(matrix):\n    n = len(matrix)\n    # Transpose\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse rows\n    for row in matrix:\n        row.reverse()\n    return matrix",
            "keyInsight": "Transpose + reverse = 90\u00b0 clockwise rotation.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    2,
                    3
                ],
                [
                    4,
                    5,
                    6
                ],
                [
                    7,
                    8,
                    9
                ]
            ],
            "animationSteps": [],
            "description": "Transpose matrix, then reverse each row.\n\nRotate matrix 90\u00b0 clockwise in-place.\nTranspose: swap matrix[i][j] with matrix[j][i].",
            "examples": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[7,4,1],[8,5,2],[9,6,3]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Rotate matrix 90\u00b0 clockwise in-place.",
                "Transpose: swap matrix[i][j] with matrix[j][i].",
                "Reverse each row."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fMSJSS7eO1w",
            "problemStatement": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "set-matrix-zeroes": {
            "title": "Set Matrix Zeroes",
            "pattern": "First Row/Col as Markers",
            "patternEmoji": "0\ufe0f\u20e3",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use first row/col as markers. Track if they need zeroing separately.",
            "intuition": [
                "\ud83c\udfaf If cell is 0, set entire row and column to 0.",
                "\ud83e\udde0 Use first row/col to mark which rows/cols to zero.",
                "\ud83d\udca1 Handle first row/col separately."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[1,0,1],[0,0,0],[1,0,1]]"
                },
                {
                    "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                    "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
                }
            ],
            "code": "def setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    firstRow = firstCol = False\n    for r in range(m):\n        for c in range(n):\n            if matrix[r][c] == 0:\n                if r == 0: firstRow = True\n                if c == 0: firstCol = True\n                matrix[r][0] = matrix[0][c] = 0\n    for r in range(1, m):\n        for c in range(1, n):\n            if matrix[r][0] == 0 or matrix[0][c] == 0:\n                matrix[r][c] = 0\n    if firstRow:\n        for c in range(n): matrix[0][c] = 0\n    if firstCol:\n        for r in range(m): matrix[r][0] = 0\n    return matrix",
            "keyInsight": "First row/col store markers; use separate flags for their own zeroing.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1,
                    1
                ],
                [
                    1,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "Use first row/col as markers. Track if they need zeroing separately.\n\nIf cell is 0, set entire row and column to 0.\nUse first row/col to mark which rows/cols to zero.",
            "examples": [
                {
                    "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[1,0,1],[0,0,0],[1,0,1]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "If cell is 0, set entire row and column to 0.",
                "Use first row/col to mark which rows/cols to zero.",
                "Handle first row/col separately."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "T41rL0L3Pnw",
            "problemStatement": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
            "difficulty": "Medium"
        },
        "game-of-life": {
            "title": "Game of Life",
            "pattern": "State Encoding",
            "patternEmoji": "\ud83c\udfae",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.",
            "intuition": [
                "\ud83c\udfaf Apply Conway's Game of Life rules.",
                "\ud83e\udde0 Use extra states to encode old->new: 2=was live, 3=was dead now live.",
                "\ud83d\udca1 Second pass: decode to 0/1."
            ],
            "testCases": [
                {
                    "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
                },
                {
                    "input": "board = [[1,1],[1,0]]",
                    "output": "[[1,1],[1,1]]"
                }
            ],
            "code": "def gameOfLife(board):\n    m, n = len(board), len(board[0])\n    def countLive(r, c):\n        live = 0\n        for dr in [-1, 0, 1]:\n            for dc in [-1, 0, 1]:\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] in [1, 2]:\n                    live += 1\n        return live\n    for r in range(m):\n        for c in range(n):\n            live = countLive(r, c)\n            if board[r][c] == 1:\n                if live < 2 or live > 3: board[r][c] = 2  # dies\n            else:\n                if live == 3: board[r][c] = 3  # becomes live\n    for r in range(m):\n        for c in range(n):\n            board[r][c] = 1 if board[r][c] == 1 or board[r][c] == 3 else 0\n    return board",
            "keyInsight": "Encode transitions to update in-place without auxiliary space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    0,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    1
                ],
                [
                    1,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [],
            "description": "Encode transitions: 2 = live->dead, 3 = dead->live. Then decode.\n\nApply Conway's Game of Life rules.\nUse extra states to encode old->new: 2=was live, 3=was dead now live.",
            "examples": [
                {
                    "input": "board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Apply Conway's Game of Life rules.",
                "Use extra states to encode old->new: 2=was live, 3=was dead now live.",
                "Second pass: decode to 0/1."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fei4bJQdBUQ",
            "problemStatement": "According to Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nThe next state of the board is determined by applying the above rules simultaneously to every cell in the current state of the m x n grid board. In this process, births and deaths occur simultaneously.\nGiven the current state of the board, update the board to reflect its next state.\nNote that you do not need to return anything.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
            "difficulty": "Medium"
        },
        "summary-ranges": {
            "title": "Summary Ranges",
            "pattern": "Linear Scan",
            "patternEmoji": "\ud83d\udccb",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track start, extend while consecutive, format range.",
            "intuition": [
                "\ud83c\udfaf Return smallest sorted list of ranges covering all numbers.",
                "\ud83e\udde0 Start a range, extend while nums[i]+1 == nums[i+1].",
                "\ud83d\udca1 Format as 'a->b' or just 'a' if single."
            ],
            "testCases": [
                {
                    "input": "nums = [0,1,2,4,5,7]",
                    "output": "[\"0->2\",\"4->5\",\"7\"]"
                },
                {
                    "input": "nums = [0,2,3,4,6,8,9]",
                    "output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
                }
            ],
            "code": "def summaryRanges(nums):\n    if not nums: return []\n    res = []\n    start = nums[0]\n    for i in range(1, len(nums) + 1):\n        if i == len(nums) or nums[i] != nums[i - 1] + 1:\n            if start == nums[i - 1]:\n                res.append(str(start))\n            else:\n                res.append(f'{start}->{nums[i - 1]}')\n            if i < len(nums):\n                start = nums[i]\n    return res",
            "keyInsight": "Use index i-1 for end of range when gap detected.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                2,
                4,
                5,
                7
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        }
                    ],
                    "transientMessage": "Initialization: start = nums[0] = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Checking if nums[1] == nums[0] + 1 (1 == 0 + 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Checking if nums[2] == nums[1] + 1 (2 == 1 + 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 3,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Checking if nums[3] == nums[2] + 1 (4 != 2 + 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 2,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Appending range '0->2' to result"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "nums[i]"
                        }
                    ],
                    "transientMessage": "Updating start to nums[3] = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 4,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Checking if nums[4] == nums[3] + 1 (5 == 4 + 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 5,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Checking if nums[5] == nums[4] + 1 (7 != 5 + 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 4,
                            "label": "nums[i-1]"
                        }
                    ],
                    "transientMessage": "Appending range '4->5' to result"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 5,
                            "label": "nums[i]"
                        }
                    ],
                    "transientMessage": "Updating start to nums[5] = 7"
                }
            ],
            "description": "Track start, extend while consecutive, format range.\n\nReturn smallest sorted list of ranges covering all numbers.\nStart a range, extend while nums[i]+1 == nums[i+1].",
            "examples": [
                {
                    "input": "nums = [0,1,2,4,5,7]",
                    "output": "[\"0->2\",\"4->5\",\"7\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return smallest sorted list of ranges covering all numbers.",
                "Start a range, extend while nums[i]+1 == nums[i+1].",
                "Format as 'a->b' or just 'a' if single."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ZoLasC3JuNg",
            "problemStatement": "You are given a sorted unique integer array nums.\nA range [a,b] is the set of all integers from a to b (inclusive).\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\nEach range [a,b] in the list should be output as:\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "merge-intervals": {
            "title": "Merge Intervals",
            "pattern": "Sort + Merge",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort by start, merge overlaps into result.",
            "intuition": [
                "\ud83c\udfaf Merge all overlapping intervals.",
                "\ud83e\udde0 Sort by start. If current overlaps last, extend end.",
                "\ud83d\udca1 Otherwise, add as new interval."
            ],
            "testCases": [
                {
                    "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                    "output": "[[1,6],[8,10],[15,18]]"
                },
                {
                    "input": "intervals = [[1,4],[4,5]]",
                    "output": "[[1,5]]"
                }
            ],
            "code": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = []\n    for interval in intervals:\n        if res and res[-1][1] >= interval[0]:\n            res[-1][1] = max(res[-1][1], interval[1])\n        else:\n            res.append(interval)\n    return res",
            "keyInsight": "After sorting, overlapping intervals are adjacent.",
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    2,
                    6
                ],
                [
                    8,
                    10
                ],
                [
                    15,
                    18
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Sorting intervals by starting time"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "current"
                        },
                        {
                            "index": 1,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "Checking if intervals[0] overlaps with intervals[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "current"
                        },
                        {
                            "index": 1,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "Merging intervals[0] and intervals[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "current"
                        },
                        {
                            "index": 3,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "Checking if merged interval overlaps with intervals[2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "current"
                        },
                        {
                            "index": 3,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "No overlap, adding intervals[2] to result"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "current"
                        },
                        {
                            "index": 4,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "Checking if intervals[3] overlaps with intervals[4]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "current"
                        },
                        {
                            "index": 4,
                            "label": "next"
                        }
                    ],
                    "transientMessage": "No overlap, adding intervals[3] to result"
                }
            ],
            "description": "Sort by start, merge overlaps into result.\n\nMerge all overlapping intervals.\nSort by start. If current overlaps last, extend end.",
            "examples": [
                {
                    "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                    "output": "[[1,6],[8,10],[15,18]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Merge all overlapping intervals.",
                "Sort by start. If current overlaps last, extend end.",
                "Otherwise, add as new interval."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "44H3cEC2fFM",
            "problemStatement": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "insert-interval": {
            "title": "Insert Interval",
            "pattern": "Merge on Insert",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Add all before, merge overlaps, add all after.",
            "intuition": [
                "\ud83c\udfaf Insert and merge new interval into sorted list.",
                "\ud83e\udde0 Three phases: before, during overlap, after.",
                "\ud83d\udca1 Merge during overlap by extending bounds."
            ],
            "testCases": [
                {
                    "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
                    "output": "[[1,5],[6,9]]"
                },
                {
                    "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
                    "output": "[[1,2],[3,10],[12,16]]"
                }
            ],
            "code": "def insert(intervals, newInterval):\n    res = []\n    for i, intv in enumerate(intervals):\n        if newInterval[1] < intv[0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intv[1]:\n            res.append(intv)\n        else:\n            newInterval = [min(newInterval[0], intv[0]), max(newInterval[1], intv[1])]\n    res.append(newInterval)\n    return res",
            "keyInsight": "Keep merging into newInterval until no more overlap.",
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    6,
                    9
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "Comparing newInterval with the first interval [1, 3]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "newInterval[1] (3) is not less than intv[0] (1), so proceed to next check"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "newInterval[0] (1) is not greater than intv[1] (3), so merge intervals"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "Updating newInterval to [min(1, 1), max(3, 3)] = [1, 3]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "Comparing updated newInterval with the second interval [6, 9]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "newInterval[1] (3) is less than intv[0] (6), so insert newInterval and append remaining intervals"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "intv"
                        }
                    ],
                    "transientMessage": "Final result is [[1, 3], [6, 9]]"
                }
            ],
            "description": "Add all before, merge overlaps, add all after.\n\nInsert and merge new interval into sorted list.\nThree phases: before, during overlap, after.",
            "examples": [
                {
                    "input": "intervals = [[1,3],[6,9]]; newInterval = [2,5]",
                    "output": "[[1,5],[6,9]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Insert and merge new interval into sorted list.",
                "Three phases: before, during overlap, after.",
                "Merge during overlap by extending bounds."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "A8NUOmlwOlM",
            "problemStatement": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nNote that you don't need to modify intervals in-place. You can make a new array and return it.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "minimum-number-of-arrows-to-burst-balloons": {
            "title": "Minimum Number of Arrows to Burst Balloons",
            "pattern": "Greedy Interval",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort by end. Shoot at end of first, skip all overlapping.",
            "intuition": [
                "\ud83c\udfaf Minimum arrows to burst all balloons.",
                "\ud83e\udde0 Sort by end point. Each arrow at end pops all touching.",
                "\ud83d\udca1 Greedy: shoot as late as possible within current set."
            ],
            "testCases": [
                {
                    "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
                    "output": "2"
                },
                {
                    "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
                    "output": "4"
                },
                {
                    "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
                    "output": "2"
                }
            ],
            "code": "def findMinArrowPoints(points):\n    if not points: return 0\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    end = points[0][1]\n    for start, e in points[1:]:\n        if start > end:\n            arrows += 1\n            end = e\n    return arrows",
            "keyInsight": "Sorting by end allows greedy selection of arrow positions.",
            "visualizationType": "array",
            "initialState": [
                [
                    10,
                    16
                ],
                [
                    2,
                    8
                ],
                [
                    1,
                    6
                ],
                [
                    7,
                    12
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Sorting balloons by end position"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "First balloon (1, 6) is the first to be burst"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Balloon (10, 16) does not overlap with (1, 6), adding an arrow"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Balloon (7, 12) overlaps with previous, no new arrow needed"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Balloon (10, 16) does not overlap with previous, adding an arrow"
                }
            ],
            "description": "Sort by end. Shoot at end of first, skip all overlapping.\n\nMinimum arrows to burst all balloons.\nSort by end point. Each arrow at end pops all touching.",
            "examples": [
                {
                    "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Minimum arrows to burst all balloons.",
                "Sort by end point. Each arrow at end pops all touching.",
                "Greedy: shoot as late as possible within current set."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "lPmkKnxBFs0",
            "problemStatement": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "reverse-nodes-in-k-group": {
            "title": "Reverse Nodes in k-Group",
            "pattern": "Iterative Reversal",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse k nodes at a time, connect reversed groups.",
            "intuition": [
                "\ud83c\udfaf Reverse every k nodes, leave remainder as-is.",
                "\ud83e\udde0 Find kth node, reverse that segment, connect.",
                "\ud83d\udca1 Use dummy head for cleaner edge case handling."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5], k = 2",
                    "output": "[2,1,4,3,5]"
                },
                {
                    "input": "head = [1,2,3,4,5], k = 3",
                    "output": "[3,2,1,4,5]"
                }
            ],
            "code": "def reverseKGroup(head, k):\n    dummy = ListNode(0, head)\n    prevGroup = dummy\n    while True:\n        kth = prevGroup\n        for _ in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        nextGroup = kth.next\n        prev, curr = kth.next, prevGroup.next\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        tmp = prevGroup.next\n        prevGroup.next = kth\n        prevGroup = tmp\n    return dummy.next",
            "keyInsight": "Track prevGroup to connect reversed segments.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Reverse k nodes at a time, connect reversed groups.\n\nReverse every k nodes, leave remainder as-is.\nFind kth node, reverse that segment, connect.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[2,1,4,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse every k nodes, leave remainder as-is.",
                "Find kth node, reverse that segment, connect.",
                "Use dummy head for cleaner edge case handling."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "1UOPsfP85V4",
            "problemStatement": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\nExample 1:\nExample 2:\nConstraints:\nFollow-up: Can you solve the problem in O(1) extra memory space?",
            "difficulty": "Hard"
        },
        "remove-nth-node-from-end-of-list": {
            "title": "Remove Nth Node From End of List",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc46\ud83d\udc46",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Advance fast by n, then move both until fast reaches end.",
            "intuition": [
                "\ud83c\udfaf Remove nth node from end in one pass.",
                "\ud83e\udde0 Fast pointer leads by n. When fast ends, slow is at target.",
                "\ud83d\udca1 Use dummy to handle removing head."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5], n = 2",
                    "output": "[1,2,3,5]"
                },
                {
                    "input": "head = [1], n = 1",
                    "output": "[]"
                },
                {
                    "input": "head = [1,2], n = 1",
                    "output": "[1]"
                }
            ],
            "code": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n    for _ in range(n + 1):\n        fast = fast.next\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    slow.next = slow.next.next\n    return dummy.next",
            "keyInsight": "Dummy node simplifies removing the head case.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Advance fast by n, then move both until fast reaches end.\n\nRemove nth node from end in one pass.\nFast pointer leads by n. When fast ends, slow is at target.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; n = 2",
                    "output": "[1,2,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove nth node from end in one pass.",
                "Fast pointer leads by n. When fast ends, slow is at target.",
                "Use dummy to handle removing head."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "XVuQxVej6y8",
            "problemStatement": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you do this in one pass?",
            "difficulty": "Medium"
        },
        "remove-duplicates-from-sorted-list-ii": {
            "title": "Remove Duplicates from Sorted List II",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Skip all nodes with duplicate values, keep only unique.",
            "intuition": [
                "\ud83c\udfaf Remove all duplicated nodes (not just extra copies).",
                "\ud83e\udde0 If cur.val == cur.next.val, skip all with that value.",
                "\ud83d\udca1 Dummy head handles removing head."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,3,4,4,5]",
                    "output": "[1,2,5]"
                },
                {
                    "input": "head = [1,1,1,2,3]",
                    "output": "[2,3]"
                }
            ],
            "code": "def deleteDuplicates(head):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next",
            "keyInsight": "Skip entire duplicate sequences, not just individual copies.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                3,
                4,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Skip all nodes with duplicate values, keep only unique.\n\nRemove all duplicated nodes (not just extra copies).\nIf cur.val == cur.next.val, skip all with that value.",
            "examples": [
                {
                    "input": "head = [1,2,3,3,4,4,5]",
                    "output": "[1,2,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove all duplicated nodes (not just extra copies).",
                "If cur.val == cur.next.val, skip all with that value.",
                "Dummy head handles removing head."
            ],
            "relatedProblems": [
                "two-sum",
                "container-with-most-water",
                "3sum"
            ],
            "videoId": "aBNILPZdQNc",
            "problemStatement": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "rotate-list": {
            "title": "Rotate List",
            "pattern": "Cycle + Break",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Make cycle, find new tail at (len - k % len - 1), break.",
            "intuition": [
                "\ud83c\udfaf Rotate list right by k places.",
                "\ud83e\udde0 Connect tail to head, find new tail, break there.",
                "\ud83d\udca1 k % len handles k > len."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,3,4,5], k = 2",
                    "output": "[4,5,1,2,3]"
                },
                {
                    "input": "head = [0,1,2], k = 4",
                    "output": "[2,0,1]"
                }
            ],
            "code": "def rotateRight(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    k %= length\n    if k == 0:\n        return head\n    tail.next = head  # Make cycle\n    steps = length - k\n    newTail = head\n    for _ in range(steps - 1):\n        newTail = newTail.next\n    newHead = newTail.next\n    newTail.next = None\n    return newHead",
            "keyInsight": "Creating a cycle simplifies finding the new head/tail.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "Make cycle, find new tail at (len - k % len - 1), break.\n\nRotate list right by k places.\nConnect tail to head, find new tail, break there.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]; k = 2",
                    "output": "[4,5,1,2,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Rotate list right by k places.",
                "Connect tail to head, find new tail, break there.",
                "k % len handles k > len."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "UcGtPs2LE_c",
            "problemStatement": "Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "partition-list": {
            "title": "Partition List",
            "pattern": "Two Dummy Lists",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Build two lists: less than x, greater or equal. Concatenate.",
            "intuition": [
                "\ud83c\udfaf Partition around x, preserving relative order.",
                "\ud83e\udde0 Two dummy heads for less and greater-or-equal lists.",
                "\ud83d\udca1 Connect them at the end."
            ],
            "testCases": [
                {
                    "input": "head = [1,4,3,2,5,2], x = 3",
                    "output": "[1,2,2,4,3,5]"
                },
                {
                    "input": "head = [2,1], x = 2",
                    "output": "[1,2]"
                }
            ],
            "code": "def partition(head, x):\n    before = beforeHead = ListNode(0)\n    after = afterHead = ListNode(0)\n    while head:\n        if head.val < x:\n            before.next = head\n            before = before.next\n        else:\n            after.next = head\n            after = after.next\n        head = head.next\n    after.next = None\n    before.next = afterHead.next\n    return beforeHead.next",
            "keyInsight": "Two lists avoid in-place reordering complexity.",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                4,
                3,
                2,
                5,
                2
            ],
            "animationSteps": [],
            "description": "Build two lists: less than x, greater or equal. Concatenate.\n\nPartition around x, preserving relative order.\nTwo dummy heads for less and greater-or-equal lists.",
            "examples": [
                {
                    "input": "head = [1,4,3,2,5,2]; x = 3",
                    "output": "[1,2,2,4,3,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Partition around x, preserving relative order.",
                "Two dummy heads for less and greater-or-equal lists.",
                "Connect them at the end."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "KT1iUciJr4g",
            "problemStatement": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "sort-list": {
            "title": "Sort List",
            "pattern": "Merge Sort",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Find middle, split, recursively sort, merge.",
            "intuition": [
                "\ud83c\udfaf Sort linked list in O(n log n) time.",
                "\ud83e\udde0 Merge sort: split at middle, recurse, merge.",
                "\ud83d\udca1 Fast/slow to find middle."
            ],
            "testCases": [
                {
                    "input": "head = [4,2,1,3]",
                    "output": "[1,2,3,4]"
                },
                {
                    "input": "head = [-1,5,3,4,0]",
                    "output": "[-1,0,3,4,5]"
                },
                {
                    "input": "head = []",
                    "output": "[]"
                }
            ],
            "code": "def sortList(head):\n    if not head or not head.next:\n        return head\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow, fast = slow.next, fast.next.next\n    mid = slow.next\n    slow.next = None\n    left = sortList(head)\n    right = sortList(mid)\n    return merge(left, right)\n\ndef merge(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next, l1 = l1, l1.next\n        else:\n            tail.next, l2 = l2, l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next",
            "keyInsight": "Merge sort is ideal for linked lists due to O(1) merge.",
            "visualizationType": "linkedlist",
            "initialState": [
                4,
                2,
                1,
                3
            ],
            "animationSteps": [],
            "description": "Find middle, split, recursively sort, merge.\n\nSort linked list in O(n log n) time.\nMerge sort: split at middle, recurse, merge.",
            "examples": [
                {
                    "input": "head = [4,2,1,3]",
                    "output": "[1,2,3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sort linked list in O(n log n) time.",
                "Merge sort: split at middle, recurse, merge.",
                "Fast/slow to find middle."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "TGveA1oFhrc",
            "problemStatement": "Given the head of a linked list, return the list after sorting it in ascending order.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)?",
            "difficulty": "Medium"
        },
        "construct-binary-tree-from-preorder-and-inorder-traversal": {
            "title": "Construct Binary Tree from Preorder and Inorder Traversal",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Preorder first is root. Find it in inorder to split left/right.",
            "intuition": [
                "\ud83c\udfaf Build tree from preorder and inorder.",
                "\ud83e\udde0 Preorder[0] = root. Find in inorder to know left/right sizes.",
                "\ud83d\udca1 Use hashmap for O(1) index lookup."
            ],
            "testCases": [
                {
                    "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
                    "output": "[3,9,20,null,null,15,7]"
                },
                {
                    "input": "preorder = [-1], inorder = [-1]",
                    "output": "[-1]"
                }
            ],
            "code": "def buildTree(preorder, inorder):\n    if not preorder:\n        return None\n    idx_map = {v: i for i, v in enumerate(inorder)}\n    def build(preL, preR, inL, inR):\n        if preL > preR:\n            return None\n        root = TreeNode(preorder[preL])\n        mid = idx_map[preorder[preL]]\n        leftSize = mid - inL\n        root.left = build(preL + 1, preL + leftSize, inL, mid - 1)\n        root.right = build(preL + leftSize + 1, preR, mid + 1, inR)\n        return root\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
            "keyInsight": "Preorder gives root, inorder gives subtree boundaries.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Preorder first is root. Find it in inorder to split left/right.\n\nBuild tree from preorder and inorder.\nPreorder[0] = root. Find in inorder to know left/right sizes.",
            "examples": [
                {
                    "input": "preorder = [3,9,20,15,7]; inorder = [9,3,15,20,7]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build tree from preorder and inorder.",
                "Preorder[0] = root. Find in inorder to know left/right sizes.",
                "Use hashmap for O(1) index lookup."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ihj4IQGZ2zc",
            "problemStatement": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "construct-binary-tree-from-inorder-and-postorder-traversal": {
            "title": "Construct Binary Tree from Inorder and Postorder Traversal",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Postorder last is root. Build right subtree first (reverse postorder).",
            "intuition": [
                "\ud83c\udfaf Build tree from inorder and postorder.",
                "\ud83e\udde0 Postorder[-1] = root. Process right subtree first.",
                "\ud83d\udca1 Use hashmap for inorder index lookup."
            ],
            "testCases": [
                {
                    "input": "inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]",
                    "output": "[3,9,20,null,null,15,7]"
                },
                {
                    "input": "inorder = [-1], postorder = [-1]",
                    "output": "[-1]"
                }
            ],
            "code": "def buildTree(inorder, postorder):\n    idx_map = {v: i for i, v in enumerate(inorder)}\n    self_idx = [len(postorder) - 1]\n    def build(inL, inR):\n        if inL > inR:\n            return None\n        root = TreeNode(postorder[self_idx[0]])\n        mid = idx_map[postorder[self_idx[0]]]\n        self_idx[0] -= 1\n        root.right = build(mid + 1, inR)\n        root.left = build(inL, mid - 1)\n        return root\n    return build(0, len(inorder) - 1)",
            "keyInsight": "Build right subtree first since postorder is left-right-root.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "Postorder last is root. Build right subtree first (reverse postorder).\n\nBuild tree from inorder and postorder.\nPostorder[-1] = root. Process right subtree first.",
            "examples": [
                {
                    "input": "inorder = [9,3,15,20,7]; postorder = [9,15,7,20,3]",
                    "output": "[3,9,20,null,null,15,7]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build tree from inorder and postorder.",
                "Postorder[-1] = root. Process right subtree first.",
                "Use hashmap for inorder index lookup."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "vm-2tbxcCPo",
            "problemStatement": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "flatten-binary-tree-to-linked-list": {
            "title": "Flatten Binary Tree to Linked List",
            "pattern": "Preorder + Pointer Manipulation",
            "patternEmoji": "\ud83d\udccb",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Find rightmost of left subtree, connect to right, move left to right.",
            "intuition": [
                "\ud83c\udfaf Flatten tree to right-skewed linked list (preorder).",
                "\ud83e\udde0 For each node: find rightmost of left, connect to right.",
                "\ud83d\udca1 Then move left subtree to right, nullify left."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,5,3,4,null,6]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                },
                {
                    "input": "root = [0]",
                    "output": "[0]"
                }
            ],
            "code": "def flatten(root):\n    curr = root\n    while curr:\n        if curr.left:\n            prev = curr.left\n            while prev.right:\n                prev = prev.right\n            prev.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n        curr = curr.right\n    return root",
            "keyInsight": "Morris-like traversal without recursion or stack.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                5,
                3,
                4,
                null,
                6
            ],
            "animationSteps": [],
            "description": "Find rightmost of left subtree, connect to right, move left to right.\n\nFlatten tree to right-skewed linked list (preorder).\nFor each node: find rightmost of left, connect to right.",
            "examples": [
                {
                    "input": "root = [1,2,5,3,4,null,6]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Flatten tree to right-skewed linked list (preorder).",
                "For each node: find rightmost of left, connect to right.",
                "Then move left subtree to right, nullify left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "rKnD7rLT0lI",
            "problemStatement": "Given the root of a binary tree, flatten the tree into a \"linked list\":\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "path-sum": {
            "title": "Path Sum",
            "pattern": "DFS",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS, subtract node value, check leaf with remaining 0.",
            "intuition": [
                "\ud83c\udfaf Does any root-to-leaf path sum to target?",
                "\ud83e\udde0 DFS: subtract current value, recurse.",
                "\ud83d\udca1 At leaf, check if remaining == 0."
            ],
            "testCases": [
                {
                    "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
                    "output": "true"
                },
                {
                    "input": "root = [1,2,3], targetSum = 5",
                    "output": "false"
                },
                {
                    "input": "root = [], targetSum = 0",
                    "output": "false"
                }
            ],
            "code": "def hasPathSum(root, targetSum):\n    if not root:\n        return False\n    if not root.left and not root.right:\n        return targetSum == root.val\n    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)",
            "keyInsight": "Check leaf condition: no left AND no right child.",
            "visualizationType": "tree",
            "initialState": [
                5,
                4,
                8,
                11,
                null,
                13,
                4,
                7,
                2,
                null,
                null,
                null,
                1
            ],
            "animationSteps": [],
            "description": "DFS, subtract node value, check leaf with remaining 0.\n\nDoes any root-to-leaf path sum to target?\nDFS: subtract current value, recurse.",
            "examples": [
                {
                    "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1]; targetSum = 22",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Does any root-to-leaf path sum to target?",
                "DFS: subtract current value, recurse.",
                "At leaf, check if remaining == 0."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "LSKQyOz_P8I",
            "problemStatement": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "sum-root-to-leaf-numbers": {
            "title": "Sum Root to Leaf Numbers",
            "pattern": "DFS",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS carrying current number. At leaf, add to sum.",
            "intuition": [
                "\ud83c\udfaf Sum all root-to-leaf numbers.",
                "\ud83e\udde0 Pass current number * 10 + node.val down.",
                "\ud83d\udca1 At leaf, return current number."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3]",
                    "output": "25"
                },
                {
                    "input": "root = [4,9,0,5,1]",
                    "output": "1026"
                }
            ],
            "code": "def sumNumbers(root):\n    def dfs(node, curr):\n        if not node:\n            return 0\n        curr = curr * 10 + node.val\n        if not node.left and not node.right:\n            return curr\n        return dfs(node.left, curr) + dfs(node.right, curr)\n    return dfs(root, 0)",
            "keyInsight": "Build number digit by digit as you traverse.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [],
            "description": "DFS carrying current number. At leaf, add to sum.\n\nSum all root-to-leaf numbers.\nPass current number * 10 + node.val down.",
            "examples": [
                {
                    "input": "root = [1,2,3]",
                    "output": "25"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sum all root-to-leaf numbers.",
                "Pass current number * 10 + node.val down.",
                "At leaf, return current number."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "Jk16lZGFWxE",
            "problemStatement": "You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "binary-tree-maximum-path-sum": {
            "title": "Binary Tree Maximum Path Sum",
            "pattern": "DFS + Global Max",
            "patternEmoji": "\ud83c\udfc6",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "For each node, compute max path through it. Update global max.",
            "intuition": [
                "\ud83c\udfaf Find max path sum (any path in tree).",
                "\ud83e\udde0 At each node: max = node + left + right. Return node + max(left, right).",
                "\ud83d\udca1 Use global variable to track overall max."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3]",
                    "output": "6"
                },
                {
                    "input": "root = [-10,9,20,null,null,15,7]",
                    "output": "42"
                }
            ],
            "code": "def maxPathSum(root):\n    maxSum = [float('-inf')]\n    def dfs(node):\n        if not node:\n            return 0\n        left = max(0, dfs(node.left))\n        right = max(0, dfs(node.right))\n        maxSum[0] = max(maxSum[0], node.val + left + right)\n        return node.val + max(left, right)\n    dfs(root)\n    return maxSum[0]",
            "keyInsight": "Return single branch max, but compute cross-node max internally.",
            "visualizationType": "tree",
            "initialState": [
                -10,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "For each node, compute max path through it. Update global max.\n\nFind max path sum (any path in tree).\nAt each node: max = node + left + right. Return node + max(left, right).",
            "examples": [
                {
                    "input": "root = [-10,9,20,null,null,15,7]",
                    "output": "42"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find max path sum (any path in tree).",
                "At each node: max = node + left + right. Return node + max(left, right).",
                "Use global variable to track overall max."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Hr5cWUld4vU",
            "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node's values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "count-complete-tree-nodes": {
            "title": "Count Complete Tree Nodes",
            "pattern": "Binary Search on Tree",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log\u00b2 n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Compare left/right depths. If equal, left is perfect. Otherwise right is.",
            "intuition": [
                "\ud83c\udfaf Count nodes in complete binary tree efficiently.",
                "\ud83e\udde0 If left depth == right depth, left is perfect (2^d - 1 nodes).",
                "\ud83d\udca1 Recurse on the other side."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5,6]",
                    "output": "6"
                },
                {
                    "input": "root = []",
                    "output": "0"
                },
                {
                    "input": "root = [1]",
                    "output": "1"
                }
            ],
            "code": "def countNodes(root):\n    if not root:\n        return 0\n    leftD = rightD = 0\n    l, r = root, root\n    while l:\n        leftD += 1\n        l = l.left\n    while r:\n        rightD += 1\n        r = r.right\n    if leftD == rightD:\n        return (1 << leftD) - 1\n    return 1 + countNodes(root.left) + countNodes(root.right)",
            "keyInsight": "Complete tree allows O(log\u00b2 n) instead of O(n).",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                6
            ],
            "animationSteps": [],
            "description": "Compare left/right depths. If equal, left is perfect. Otherwise right is.\n\nCount nodes in complete binary tree efficiently.\nIf left depth == right depth, left is perfect (2^d - 1 nodes).",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5,6]",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count nodes in complete binary tree efficiently.",
                "If left depth == right depth, left is perfect (2^d - 1 nodes).",
                "Recurse on the other side."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "u-yWemKGWO0",
            "problemStatement": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less than O(n) time complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "binary-tree-right-side-view": {
            "title": "Binary Tree Right Side View",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udc41\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level, take last node of each level.",
            "intuition": [
                "\ud83c\udfaf Return rightmost node at each level.",
                "\ud83e\udde0 BFS: at each level, record last node.",
                "\ud83d\udca1 Or DFS with level tracking, process right first."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,null,5,null,4]",
                    "output": "[1,3,4]"
                },
                {
                    "input": "root = [1,2,3,4,null,null,null,5]",
                    "output": "[1,3,4,5]"
                },
                {
                    "input": "root = [1,null,3]",
                    "output": "[1,3]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ],
            "code": "from collections import deque\n\ndef rightSideView(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    while q:\n        size = len(q)\n        for i in range(size):\n            node = q.popleft()\n            if i == size - 1:\n                res.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n    return res",
            "keyInsight": "Take the last node at each level during BFS.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                null,
                5,
                null,
                4
            ],
            "animationSteps": [],
            "description": "BFS level by level, take last node of each level.\n\nReturn rightmost node at each level.\nBFS: at each level, record last node.",
            "examples": [
                {
                    "input": "root = [1,2,3,null,5,null,4]",
                    "output": "[1,3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return rightmost node at each level.",
                "BFS: at each level, record last node.",
                "Or DFS with level tracking, process right first."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "d4zLyf32e3I",
            "problemStatement": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample 1:\nExample 2:\nExample 3:\nExample 4:\nConstraints:",
            "difficulty": "Medium"
        },
        "average-of-levels-in-binary-tree": {
            "title": "Average of Levels in Binary Tree",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level, compute average per level.",
            "intuition": [
                "\ud83c\udfaf Return average value at each level.",
                "\ud83e\udde0 BFS: sum nodes at each level, divide by count.",
                "\ud83d\udca1 Process level by level with queue."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[3.00000,14.50000,11.00000]"
                },
                {
                    "input": "root = [3,9,20,15,7]",
                    "output": "[3.00000,14.50000,11.00000]"
                }
            ],
            "code": "from collections import deque\n\ndef averageOfLevels(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    while q:\n        size = len(q)\n        total = 0\n        for _ in range(size):\n            node = q.popleft()\n            total += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        res.append(total / size)\n    return res",
            "keyInsight": "Sum all nodes at each level and divide by count.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS level by level, compute average per level.\n\nReturn average value at each level.\nBFS: sum nodes at each level, divide by count.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[3.0,14.5,11.0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return average value at each level.",
                "BFS: sum nodes at each level, divide by count.",
                "Process level by level with queue."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "i3_fDqR_dYs",
            "problemStatement": "Example 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "binary-tree-zigzag-level-order-traversal": {
            "title": "Binary Tree Zigzag Level Order Traversal",
            "pattern": "BFS + Direction Flag",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS, alternate direction each level (reverse odd levels).",
            "intuition": [
                "\ud83c\udfaf Level order but alternating left-right direction.",
                "\ud83e\udde0 BFS with direction flag. Reverse level if needed.",
                "\ud83d\udca1 Or use deque to add from different ends."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[20,9],[15,7]]"
                },
                {
                    "input": "root = [1]",
                    "output": "[[1]]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ],
            "code": "from collections import deque\n\ndef zigzagLevelOrder(root):\n    if not root:\n        return []\n    res = []\n    q = deque([root])\n    leftToRight = True\n    while q:\n        size = len(q)\n        level = deque()\n        for _ in range(size):\n            node = q.popleft()\n            if leftToRight:\n                level.append(node.val)\n            else:\n                level.appendleft(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        res.append(list(level))\n        leftToRight = not leftToRight\n    return res",
            "keyInsight": "Use deque's appendleft for reverse direction.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS, alternate direction each level (reverse odd levels).\n\nLevel order but alternating left-right direction.\nBFS with direction flag. Reverse level if needed.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[20,9],[15,7]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Level order but alternating left-right direction.",
                "BFS with direction flag. Reverse level if needed.",
                "Or use deque to add from different ends."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "igbboQbiwqw",
            "problemStatement": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "minimum-absolute-difference-in-bst": {
            "title": "Minimum Absolute Difference in BST",
            "pattern": "Inorder Traversal",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Inorder gives sorted order. Track prev, compare adjacent.",
            "intuition": [
                "\ud83c\udfaf Find min diff between any two nodes.",
                "\ud83e\udde0 Inorder traversal gives sorted values.",
                "\ud83d\udca1 Min diff is between adjacent sorted values."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,6,1,3]",
                    "output": "1"
                },
                {
                    "input": "root = [1,0,48,null,null,12,49]",
                    "output": "1"
                }
            ],
            "code": "def getMinimumDifference(root):\n    prev = [None]\n    minDiff = [float('inf')]\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        if prev[0] is not None:\n            minDiff[0] = min(minDiff[0], node.val - prev[0])\n        prev[0] = node.val\n        inorder(node.right)\n    inorder(root)\n    return minDiff[0]",
            "keyInsight": "Inorder on BST is sorted, so min diff is between adjacent.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                6,
                1,
                3
            ],
            "animationSteps": [],
            "description": "Inorder gives sorted order. Track prev, compare adjacent.\n\nFind min diff between any two nodes.\nInorder traversal gives sorted values.",
            "examples": [
                {
                    "input": "root = [4,2,6,1,3]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find min diff between any two nodes.",
                "Inorder traversal gives sorted values.",
                "Min diff is between adjacent sorted values."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "9LxvhVvBnCI",
            "problemStatement": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/",
            "difficulty": "Easy"
        },
        "kth-smallest-element-in-a-bst": {
            "title": "Kth Smallest Element in a BST",
            "pattern": "Inorder Traversal",
            "patternEmoji": "\ud83c\udfc6",
            "timeComplexity": "O(h + k)",
            "spaceComplexity": "O(h)",
            "oneliner": "Inorder traversal, return kth element.",
            "intuition": [
                "\ud83c\udfaf Find kth smallest element in BST.",
                "\ud83e\udde0 Inorder = sorted order. Count until k.",
                "\ud83d\udca1 Use iterative inorder with stack."
            ],
            "testCases": [
                {
                    "input": "root = [3,1,4,null,2], k = 1",
                    "output": "1"
                },
                {
                    "input": "root = [5,3,6,2,4,null,null,1], k = 3",
                    "output": "3"
                }
            ],
            "code": "def kthSmallest(root, k):\n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            return root.val\n        root = root.right",
            "keyInsight": "Iterative inorder avoids full traversal for small k.",
            "visualizationType": "tree",
            "initialState": [
                3,
                1,
                4,
                null,
                2
            ],
            "animationSteps": [],
            "description": "Inorder traversal, return kth element.\n\nFind kth smallest element in BST.\nInorder = sorted order. Count until k.",
            "examples": [
                {
                    "input": "root = [3,1,4,null,2]; k = 1",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find kth smallest element in BST.",
                "Inorder = sorted order. Count until k.",
                "Use iterative inorder with stack."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "5LUXSvjmGCw",
            "problemStatement": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1:\nExample 2:\nConstraints:\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",
            "difficulty": "Medium"
        },
        "validate-binary-search-tree": {
            "title": "Validate Binary Search Tree",
            "pattern": "DFS with Range",
            "patternEmoji": "\u2705",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "DFS with min/max bounds. Node must be in (min, max).",
            "intuition": [
                "\ud83c\udfaf Is this a valid BST?",
                "\ud83e\udde0 Each node has a valid range (min, max).",
                "\ud83d\udca1 Left: update max. Right: update min."
            ],
            "testCases": [
                {
                    "input": "root = [2,1,3]",
                    "output": "true"
                },
                {
                    "input": "root = [5,1,4,null,null,3,6]",
                    "output": "false"
                }
            ],
            "code": "def isValidBST(root):\n    def validate(node, lo, hi):\n        if not node:\n            return True\n        if not (lo < node.val < hi):\n            return False\n        return validate(node.left, lo, node.val) and validate(node.right, node.val, hi)\n    return validate(root, float('-inf'), float('inf'))",
            "keyInsight": "Each node must satisfy min < node.val < max constraint.",
            "visualizationType": "tree",
            "initialState": [
                2,
                1,
                3
            ],
            "animationSteps": [],
            "description": "DFS with min/max bounds. Node must be in (min, max).\n\nIs this a valid BST?\nEach node has a valid range (min, max).",
            "examples": [
                {
                    "input": "root = [2,1,3]",
                    "output": "true"
                },
                {
                    "input": "root = [5,1,4,null,null,3,6]",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Is this a valid BST?",
                "Each node has a valid range (min, max).",
                "Left: update max. Right: update min."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "s6ATEkipzow",
            "problemStatement": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "lowest-common-ancestor-of-a-bst": {
            "title": "Lowest Common Ancestor of a Binary Search Tree",
            "pattern": "BST Property",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(1)",
            "oneliner": "If both p,q < node, go left. If both > node, go right. Else LCA.",
            "intuition": [
                "\ud83c\udfaf Find LCA in BST (not general tree).",
                "\ud83e\udde0 Use BST property: p < node < q means split.",
                "\ud83d\udca1 First node where p and q split is LCA."
            ],
            "testCases": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                    "output": "6"
                },
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                    "output": "2"
                },
                {
                    "input": "root = [2,1], p = 2, q = 1",
                    "output": "2"
                }
            ],
            "code": "def lowestCommonAncestor(root, p, q):\n    while root:\n        if p < root.val and q < root.val:\n            root = root.left\n        elif p > root.val and q > root.val:\n            root = root.right\n        else:\n            return root.val\n    return None",
            "keyInsight": "BST structure lets us decide direction without full search.",
            "visualizationType": "tree",
            "initialState": [
                6,
                2,
                8,
                0,
                4,
                7,
                9
            ],
            "animationSteps": [],
            "description": "If both p,q < node, go left. If both > node, go right. Else LCA.\n\nFind LCA in BST (not general tree).\nUse BST property: p < node < q means split.",
            "examples": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5]; p = 2; q = 8",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LCA in BST (not general tree).",
                "Use BST property: p < node < q means split.",
                "First node where p and q split is LCA."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "gs2LMfuOR9k",
            "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "balance-a-binary-search-tree": {
            "title": "Balance a Binary Search Tree",
            "pattern": "Inorder + Rebuild",
            "patternEmoji": "\u2696\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Inorder to sorted array. Build balanced BST from array.",
            "intuition": [
                "\ud83c\udfaf Convert BST to balanced BST.",
                "\ud83e\udde0 Extract sorted array via inorder.",
                "\ud83d\udca1 Recursively build from middle element."
            ],
            "testCases": [
                {
                    "input": "root = [1,null,2,null,3,null,4,null,null]",
                    "output": "[2,1,3,null,null,null,4]"
                },
                {
                    "input": "root = [2,1,3]",
                    "output": "[2,1,3]"
                }
            ],
            "code": "def balanceBST(root):\n    vals = []\n    def inorder(node):\n        if not node: return\n        inorder(node.left)\n        vals.append(node.val)\n        inorder(node.right)\n    inorder(root)\n    def build(l, r):\n        if l > r: return None\n        mid = (l + r) // 2\n        node = TreeNode(vals[mid])\n        node.left = build(l, mid - 1)\n        node.right = build(mid + 1, r)\n        return node\n    return build(0, len(vals) - 1)",
            "keyInsight": "Middle element as root gives balanced tree.",
            "visualizationType": "tree",
            "initialState": [
                1,
                null,
                2,
                null,
                3,
                null,
                4
            ],
            "animationSteps": [],
            "description": "Inorder to sorted array. Build balanced BST from array.\n\nConvert BST to balanced BST.\nExtract sorted array via inorder.",
            "examples": [
                {
                    "input": "root = [1,null,2,null,3,null,4]",
                    "output": "[2,1,3,null,null,null,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert BST to balanced BST.",
                "Extract sorted array via inorder.",
                "Recursively build from middle element."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fqx8z3VepMA",
            "problemStatement": "Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.\nA binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "surrounded-regions": {
            "title": "Surrounded Regions",
            "pattern": "DFS from Border",
            "patternEmoji": "\ud83d\uddfa\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "DFS from border Os to mark safe. Flip remaining Os to Xs.",
            "intuition": [
                "\ud83c\udfaf Flip all O regions NOT connected to border.",
                "\ud83e\udde0 Mark border-connected Os as safe.",
                "\ud83d\udca1 Flip remaining Os, restore safe ones."
            ],
            "testCases": [
                {
                    "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                    "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
                },
                {
                    "input": "board = [[\"X\"]]",
                    "output": "[[\"X\"]]"
                }
            ],
            "code": "def solve(board):\n    if not board: return board\n    m, n = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != 'O':\n            return\n        board[r][c] = 'S'\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    for r in range(m):\n        dfs(r, 0); dfs(r, n-1)\n    for c in range(n):\n        dfs(0, c); dfs(m-1, c)\n    for r in range(m):\n        for c in range(n):\n            board[r][c] = 'O' if board[r][c] == 'S' else 'X'\n    return board",
            "keyInsight": "Work from border inward to identify safe regions.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "X",
                    "X",
                    "X",
                    "X"
                ],
                [
                    "X",
                    "O",
                    "O",
                    "X"
                ],
                [
                    "X",
                    "X",
                    "O",
                    "X"
                ],
                [
                    "X",
                    "O",
                    "X",
                    "X"
                ]
            ],
            "animationSteps": [],
            "description": "DFS from border Os to mark safe. Flip remaining Os to Xs.\n\nFlip all O regions NOT connected to border.\nMark border-connected Os as safe.",
            "examples": [
                {
                    "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                    "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Flip all O regions NOT connected to border.",
                "Mark border-connected Os as safe.",
                "Flip remaining Os, restore safe ones."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "9z2BunfoZ5Y",
            "problemStatement": "You are given an m x n matrix board containing letters 'X' and 'O', capture regions that are surrounded:\nTo capture a surrounded region, replace all 'O's with 'X's in-place within the original board. You do not need to return anything.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "evaluate-division": {
            "title": "Evaluate Division",
            "pattern": "Graph BFS/DFS",
            "patternEmoji": "\u2797",
            "timeComplexity": "O(Q*(V+E))",
            "spaceComplexity": "O(V+E)",
            "oneliner": "Build graph of ratios. DFS/BFS to find path and multiply.",
            "intuition": [
                "\ud83c\udfaf Evaluate queries given equations with values.",
                "\ud83e\udde0 Build weighted graph: a/b = k means edge a->b with weight k.",
                "\ud83d\udca1 Query a/c = path from a to c, multiply weights."
            ],
            "testCases": [
                {
                    "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
                    "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
                },
                {
                    "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
                    "output": "[3.75000,0.40000,5.00000,0.20000]"
                },
                {
                    "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
                    "output": "[0.50000,2.00000,-1.00000,-1.00000]"
                }
            ],
            "code": "from collections import defaultdict\n\ndef calcEquation(equations, values, queries):\n    graph = defaultdict(dict)\n    for (a, b), v in zip(equations, values):\n        graph[a][b] = v\n        graph[b][a] = 1 / v\n    \n    def dfs(start, end, visited):\n        if start not in graph or end not in graph:\n            return -1.0\n        if start == end:\n            return 1.0\n        visited.add(start)\n        for nei, val in graph[start].items():\n            if nei not in visited:\n                res = dfs(nei, end, visited)\n                if res != -1.0:\n                    return val * res\n        return -1.0\n    \n    return [dfs(a, b, set()) for a, b in queries]",
            "keyInsight": "Weighted graph where edge weight represents the ratio.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Build graph of ratios. DFS/BFS to find path and multiply.\n\nEvaluate queries given equations with values.\nBuild weighted graph: a/b = k means edge a->b with weight k.",
            "examples": [
                {
                    "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]]; values = [2.0,3.0]; queries = [[\"a\",\"c\"]]",
                    "output": "[6.0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Evaluate queries given equations with values.",
                "Build weighted graph: a/b = k means edge a->b with weight k.",
                "Query a/c = path from a to c, multiply weights."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Uei1fwDoyKk",
            "problemStatement": "You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\nNote: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\nNote: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "course-schedule-ii": {
            "title": "Course Schedule II",
            "pattern": "Topological Sort",
            "patternEmoji": "\ud83d\udcda",
            "timeComplexity": "O(V+E)",
            "spaceComplexity": "O(V+E)",
            "oneliner": "Kahn's algorithm: BFS with indegree. Return order or [].",
            "intuition": [
                "\ud83c\udfaf Return valid course order or [] if impossible.",
                "\ud83e\udde0 Topological sort using indegree.",
                "\ud83d\udca1 If all courses processed, return order."
            ],
            "testCases": [
                {
                    "input": "numCourses = 2, prerequisites = [[1,0]]",
                    "output": "[0,1]"
                },
                {
                    "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                    "output": "[0,2,1,3]"
                },
                {
                    "input": "numCourses = 1, prerequisites = []",
                    "output": "[0]"
                }
            ],
            "code": "from collections import deque, defaultdict\n\ndef findOrder(numCourses, prerequisites):\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        indegree[a] += 1\n    q = deque([i for i in range(numCourses) if indegree[i] == 0])\n    order = []\n    while q:\n        course = q.popleft()\n        order.append(course)\n        for nei in graph[course]:\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                q.append(nei)\n    return order if len(order) == numCourses else []",
            "keyInsight": "Topological sort returns empty if cycle exists.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Kahn's algorithm: BFS with indegree. Return order or [].\n\nReturn valid course order or [] if impossible.\nTopological sort using indegree.",
            "examples": [
                {
                    "input": "numCourses = 4; prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                    "output": "[0,1,2,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Return valid course order or [] if impossible.",
                "Topological sort using indegree.",
                "If all courses processed, return order."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Akt3glAwyfY",
            "problemStatement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "diameter-of-binary-tree": {
            "title": "Diameter of Binary Tree",
            "pattern": "DFS + Global Max",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "For each node, diameter through it = left_height + right_height.",
            "intuition": [
                "\ud83c\udfaf Longest path between any two nodes.",
                "\ud83e\udde0 At each node: path through it = left + right heights.",
                "\ud83d\udca1 Return height, but track max diameter."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5]",
                    "output": "3"
                },
                {
                    "input": "root = [1,2]",
                    "output": "1"
                }
            ],
            "code": "def diameterOfBinaryTree(root):\n    diameter = [0]\n    def height(node):\n        if not node:\n            return 0\n        left = height(node.left)\n        right = height(node.right)\n        diameter[0] = max(diameter[0], left + right)\n        return 1 + max(left, right)\n    height(root)\n    return diameter[0]",
            "keyInsight": "Diameter through node = sum of left and right subtree heights.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [],
            "description": "For each node, diameter through it = left_height + right_height.\n\nLongest path between any two nodes.\nAt each node: path through it = left + right heights.",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Longest path between any two nodes.",
                "At each node: path through it = left + right heights.",
                "Return height, but track max diameter."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "bkxqA8Rfv04",
            "problemStatement": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "cheapest-flights-within-k-stops": {
            "title": "Cheapest Flights Within K Stops",
            "pattern": "BFS / Bellman-Ford",
            "patternEmoji": "\u2708\ufe0f",
            "timeComplexity": "O(K*E)",
            "spaceComplexity": "O(V)",
            "oneliner": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.",
            "intuition": [
                "\ud83c\udfaf Cheapest flight with at most k stops.",
                "\ud83e\udde0 Bellman-Ford with k+1 relaxations.",
                "\ud83d\udca1 Use copy of distances to avoid this-iteration dependency."
            ],
            "testCases": [
                {
                    "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
                    "output": "700"
                },
                {
                    "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
                    "output": "200"
                },
                {
                    "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0",
                    "output": "500"
                }
            ],
            "code": "def findCheapestPrice(n, flights, src, dst, k):\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for _ in range(k + 1):\n        temp = prices[:]\n        for s, d, p in flights:\n            if prices[s] != float('inf'):\n                temp[d] = min(temp[d], prices[s] + p)\n        prices = temp\n    return prices[dst] if prices[dst] != float('inf') else -1",
            "keyInsight": "Use copy of prices array to ensure correct iteration count.",
            "visualizationType": "graph",
            "initialState": [],
            "animationSteps": [],
            "description": "Modified Bellman-Ford: k+1 iterations. Or BFS with level tracking.\n\nCheapest flight with at most k stops.\nBellman-Ford with k+1 relaxations.",
            "examples": [
                {
                    "input": "n = 4; flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]]; src = 0; dst = 3; k = 1",
                    "output": "700"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Cheapest flight with at most k stops.",
                "Bellman-Ford with k+1 relaxations.",
                "Use copy of distances to avoid this-iteration dependency."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "5eIK3zUdYmE",
            "problemStatement": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "snakes-and-ladders": {
            "title": "Snakes and Ladders",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udc0d",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n\u00b2)",
            "oneliner": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.",
            "intuition": [
                "\ud83c\udfaf Min dice rolls to reach last square.",
                "\ud83e\udde0 BFS level = number of moves.",
                "\ud83d\udca1 Handle boustrophedon numbering."
            ],
            "testCases": [
                {
                    "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
                    "output": "4"
                },
                {
                    "input": "board = [[-1,-1],[-1,3]]",
                    "output": "1"
                }
            ],
            "code": "from collections import deque\n\ndef snakesAndLadders(board):\n    n = len(board)\n    def getPos(sq):\n        r, c = divmod(sq - 1, n)\n        if r % 2 == 1:\n            c = n - 1 - c\n        return n - 1 - r, c\n    \n    q = deque([(1, 0)])\n    visited = {1}\n    while q:\n        sq, moves = q.popleft()\n        for i in range(1, 7):\n            nxt = sq + i\n            if nxt > n * n:\n                continue\n            r, c = getPos(nxt)\n            if board[r][c] != -1:\n                nxt = board[r][c]\n            if nxt == n * n:\n                return moves + 1\n            if nxt not in visited:\n                visited.add(nxt)\n                q.append((nxt, moves + 1))\n    return -1",
            "keyInsight": "Convert 1D square number to 2D board coordinates carefully.",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "BFS from square 1. Follow snakes/ladders. Min moves to n\u00b2.\n\nMin dice rolls to reach last square.\nBFS level = number of moves.",
            "examples": [
                {
                    "input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min dice rolls to reach last square.",
                "BFS level = number of moves.",
                "Handle boustrophedon numbering."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "6lH4nO3JfLk",
            "problemStatement": "You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.\nYou start on square 1 of the board. In each move, starting from square curr, do the following:\nA board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 are not the starting points of any snake or ladder.\nNote that you only take a snake or ladder at most once per dice roll. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.\nReturn the least number of dice rolls required to reach the square n2. If it is not possible to reach the square, return -1.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "minimum-genetic-mutation": {
            "title": "Minimum Genetic Mutation",
            "pattern": "BFS",
            "patternEmoji": "\ud83e\uddec",
            "timeComplexity": "O(B*8*4)",
            "spaceComplexity": "O(B)",
            "oneliner": "BFS from startGene. Each level = 1 mutation. Valid if in bank.",
            "intuition": [
                "\ud83c\udfaf Min mutations to reach endGene.",
                "\ud83e\udde0 BFS where edges are single char changes in bank.",
                "\ud83d\udca1 Each mutation changes one character to A/C/G/T."
            ],
            "testCases": [
                {
                    "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
                    "output": "1"
                },
                {
                    "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
                    "output": "2"
                }
            ],
            "code": "from collections import deque\n\ndef minMutation(startGene, endGene, bank):\n    bank = set(bank)\n    if endGene not in bank:\n        return -1\n    q = deque([(startGene, 0)])\n    visited = {startGene}\n    while q:\n        gene, mutations = q.popleft()\n        if gene == endGene:\n            return mutations\n        for i in range(8):\n            for c in 'ACGT':\n                nxt = gene[:i] + c + gene[i+1:]\n                if nxt in bank and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, mutations + 1))\n    return -1",
            "keyInsight": "Try all single-character mutations, check if in bank.",
            "visualizationType": "string",
            "initialState": "AACCGGTT",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initializing the gene bank and checking if endGene is in it."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "transientMessage": "endGene is found in the bank, proceeding with BFS initialization."
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "startGene"
                        },
                        {
                            "index": 1,
                            "label": "endGene"
                        }
                    ],
                    "transientMessage": "Starting BFS with initial gene and mutation count of 0."
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "current gene"
                        },
                        {
                            "index": 3,
                            "label": "mutations"
                        }
                    ],
                    "transientMessage": "Dequeuing the first gene for processing."
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "current gene"
                        },
                        {
                            "index": 1,
                            "label": "endGene"
                        }
                    ],
                    "transientMessage": "Current gene matches endGene, returning mutation count."
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "current gene"
                        },
                        {
                            "index": 3,
                            "label": "mutations"
                        }
                    ],
                    "transientMessage": "Generating next possible genes by mutating one character at a time."
                },
                {
                    "type": "highlight",
                    "indices": [
                        6
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "valid mutation"
                        },
                        {
                            "index": 5,
                            "label": "visited set"
                        }
                    ],
                    "transientMessage": "A valid mutation found and added to the queue."
                },
                {
                    "type": "highlight",
                    "indices": [
                        7
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 6,
                            "label": "current gene"
                        },
                        {
                            "index": 7,
                            "label": "mutations"
                        }
                    ],
                    "transientMessage": "Continuing BFS with the next valid mutation."
                }
            ],
            "description": "BFS from startGene. Each level = 1 mutation. Valid if in bank.\n\nMin mutations to reach endGene.\nBFS where edges are single char changes in bank.",
            "examples": [
                {
                    "input": "startGene = \"AACCGGTT\"; endGene = \"AAACGGTA\"; bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min mutations to reach endGene.",
                "BFS where edges are single char changes in bank.",
                "Each mutation changes one character to A/C/G/T."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "H6VdY3SxjMM",
            "problemStatement": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and 'T'.\nSuppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.\nThere is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.\nGiven the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.\nNote that the starting point is assumed to be valid, so it might not be included in the bank.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "word-ladder": {
            "title": "Word Ladder",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udd20",
            "timeComplexity": "O(M\u00b2*N)",
            "spaceComplexity": "O(M*N)",
            "oneliner": "BFS from beginWord. Valid moves = 1 char diff in wordList.",
            "intuition": [
                "\ud83c\udfaf Min transformations to endWord.",
                "\ud83e\udde0 BFS where each level = 1 transformation.",
                "\ud83d\udca1 Use wildcard patterns for O(M) adjacency."
            ],
            "testCases": [
                {
                    "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                    "output": "5"
                },
                {
                    "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                    "output": "0"
                }
            ],
            "code": "from collections import deque, defaultdict\n\ndef ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    wordList = set(wordList)\n    q = deque([(beginWord, 1)])\n    visited = {beginWord}\n    while q:\n        word, length = q.popleft()\n        if word == endWord:\n            return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                nxt = word[:i] + c + word[i+1:]\n                if nxt in wordList and nxt not in visited:\n                    visited.add(nxt)\n                    q.append((nxt, length + 1))\n    return 0",
            "keyInsight": "BFS guarantees minimum transformation sequence.",
            "visualizationType": "string",
            "initialState": "hit",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Starting BFS with initial word 'hit'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "word"
                        },
                        {
                            "index": 1,
                            "label": "length"
                        }
                    ],
                    "transientMessage": "Processing word 'hit' with length 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "transientMessage": "Generating neighbors for 'hit'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "success",
                    "transientMessage": "Found valid neighbor 'hot' and added to queue"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "transientMessage": "Processing word 'hot' with length 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "success",
                    "transientMessage": "Found valid neighbor 'dot' and added to queue"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6
                    ],
                    "color": "accent",
                    "transientMessage": "Processing word 'dot' with length 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        7
                    ],
                    "color": "success",
                    "transientMessage": "Found valid neighbor 'dog' and added to queue"
                },
                {
                    "type": "highlight",
                    "indices": [
                        8
                    ],
                    "color": "accent",
                    "transientMessage": "Processing word 'dog' with length 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        9
                    ],
                    "color": "success",
                    "transientMessage": "Found valid neighbor 'cog' and added to queue"
                }
            ],
            "description": "BFS from beginWord. Valid moves = 1 char diff in wordList.\n\nMin transformations to endWord.\nBFS where each level = 1 transformation.",
            "examples": [
                {
                    "input": "beginWord = \"hit\"; endWord = \"cog\"; wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                    "output": "5"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min transformations to endWord.",
                "BFS where each level = 1 transformation.",
                "Use wildcard patterns for O(M) adjacency."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "h9iTnkgv05E",
            "problemStatement": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "minimum-depth-of-binary-tree": {
            "title": "Minimum Depth of Binary Tree",
            "pattern": "BFS",
            "patternEmoji": "\ud83d\udccf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "BFS level by level. Return level when first leaf found.",
            "intuition": [
                "\ud83c\udfaf Min depth to a leaf node.",
                "\ud83e\udde0 BFS finds closest leaf first.",
                "\ud83d\udca1 Better than DFS for unbalanced trees."
            ],
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "2"
                },
                {
                    "input": "root = [2,null,3,null,4,null,5,null,6]",
                    "output": "5"
                }
            ],
            "code": "from collections import deque\n\ndef minDepth(root):\n    if not root:\n        return 0\n    q = deque([(root, 1)])\n    while q:\n        node, depth = q.popleft()\n        if not node.left and not node.right:\n            return depth\n        if node.left:\n            q.append((node.left, depth + 1))\n        if node.right:\n            q.append((node.right, depth + 1))\n    return 0",
            "keyInsight": "BFS stops early when first leaf is found.",
            "visualizationType": "tree",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [],
            "description": "BFS level by level. Return level when first leaf found.\n\nMin depth to a leaf node.\nBFS finds closest leaf first.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min depth to a leaf node.",
                "BFS finds closest leaf first.",
                "Better than DFS for unbalanced trees."
            ],
            "relatedProblems": [
                "binary-tree-level-order-traversal",
                "word-ladder",
                "shortest-path-in-binary-matrix"
            ],
            "videoId": "tZS4VHtbYoo",
            "problemStatement": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "letter-combinations-of-a-phone-number": {
            "title": "Letter Combinations of a Phone Number",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udcf1",
            "timeComplexity": "O(4^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Map digits to letters. Backtrack all combinations.",
            "intuition": [
                "\ud83c\udfaf All letter combinations from digits.",
                "\ud83e\udde0 Digit -> letters mapping. Backtrack choices.",
                "\ud83d\udca1 Each digit adds multiple branches."
            ],
            "testCases": [
                {
                    "input": "digits = \"23\"",
                    "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                },
                {
                    "input": "digits = \"\"",
                    "output": "[]"
                },
                {
                    "input": "digits = \"2\"",
                    "output": "[\"a\",\"b\",\"c\"]"
                }
            ],
            "code": "def letterCombinations(digits):\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    res = []\n    def backtrack(i, path):\n        if i == len(digits):\n            res.append(''.join(path))\n            return\n        for c in phone[digits[i]]:\n            path.append(c)\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Standard backtracking with fixed choices per position.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Map digits to letters. Backtrack all combinations.\n\nAll letter combinations from digits.\nDigit -> letters mapping. Backtrack choices.",
            "examples": [
                {
                    "input": "digits = \"23\"",
                    "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All letter combinations from digits.",
                "Digit -> letters mapping. Backtrack choices.",
                "Each digit adds multiple branches."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "0snEunUacZY",
            "problemStatement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "combinations": {
            "title": "Combinations",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(C(n,k))",
            "spaceComplexity": "O(k)",
            "oneliner": "Backtrack choosing k elements from 1 to n.",
            "intuition": [
                "\ud83c\udfaf All combinations of k numbers from 1 to n.",
                "\ud83e\udde0 Backtrack: pick or skip each number.",
                "\ud83d\udca1 Start from current to avoid duplicates."
            ],
            "testCases": [
                {
                    "input": "n = 4, k = 2",
                    "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
                },
                {
                    "input": "n = 1, k = 1",
                    "output": "[[1]]"
                }
            ],
            "code": "def combine(n, k):\n    res = []\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return\n        for i in range(start, n + 1):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(1, [])\n    return res",
            "keyInsight": "Start from 'start' index to avoid duplicate combinations.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Backtrack choosing k elements from 1 to n.\n\nAll combinations of k numbers from 1 to n.\nBacktrack: pick or skip each number.",
            "examples": [
                {
                    "input": "n = 4; k = 2",
                    "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All combinations of k numbers from 1 to n.",
                "Backtrack: pick or skip each number.",
                "Start from current to avoid duplicates."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "q0s6m7AiM7o",
            "problemStatement": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "n-queens-ii": {
            "title": "N-Queens II",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udc51",
            "timeComplexity": "O(n!)",
            "spaceComplexity": "O(n)",
            "oneliner": "Place queens row by row. Track cols and diagonals.",
            "intuition": [
                "\ud83c\udfaf Count valid n-queens placements.",
                "\ud83e\udde0 Track used columns, diagonals, anti-diagonals.",
                "\ud83d\udca1 Row is implicit in recursion depth."
            ],
            "testCases": [
                {
                    "input": "n = 4",
                    "output": "2"
                },
                {
                    "input": "n = 1",
                    "output": "1"
                }
            ],
            "code": "def totalNQueens(n):\n    cols = set()\n    posDiag = set()  # r + c\n    negDiag = set()  # r - c\n    count = [0]\n    def backtrack(r):\n        if r == n:\n            count[0] += 1\n            return\n        for c in range(n):\n            if c in cols or (r + c) in posDiag or (r - c) in negDiag:\n                continue\n            cols.add(c)\n            posDiag.add(r + c)\n            negDiag.add(r - c)\n            backtrack(r + 1)\n            cols.remove(c)\n            posDiag.remove(r + c)\n            negDiag.remove(r - c)\n    backtrack(0)\n    return count[0]",
            "keyInsight": "Diagonals identified by r+c (positive) and r-c (negative).",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "Place queens row by row. Track cols and diagonals.\n\nCount valid n-queens placements.\nTrack used columns, diagonals, anti-diagonals.",
            "examples": [
                {
                    "input": "n = 4",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count valid n-queens placements.",
                "Track used columns, diagonals, anti-diagonals.",
                "Row is implicit in recursion depth."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "lxvKVFC6qT0",
            "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "generate-parentheses": {
            "title": "Generate Parentheses",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd32",
            "timeComplexity": "O(4^n / sqrt(n))",
            "spaceComplexity": "O(n)",
            "oneliner": "Add '(' if open < n. Add ')' if close < open.",
            "intuition": [
                "\ud83c\udfaf Generate all valid parentheses of n pairs.",
                "\ud83e\udde0 Can add '(' if count < n. Can add ')' if close < open.",
                "\ud83d\udca1 This ensures valid nesting."
            ],
            "testCases": [
                {
                    "input": "n = 3",
                    "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
                },
                {
                    "input": "n = 1",
                    "output": "[\"()\"]"
                }
            ],
            "code": "def generateParenthesis(n):\n    res = []\n    def backtrack(s, openN, closeN):\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        if openN < n:\n            backtrack(s + '(', openN + 1, closeN)\n        if closeN < openN:\n            backtrack(s + ')', openN, closeN + 1)\n    backtrack('', 0, 0)\n    return res",
            "keyInsight": "Only add ')' when close count < open count.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Add '(' if open < n. Add ')' if close < open.\n\nGenerate all valid parentheses of n pairs.\nCan add '(' if count < n. Can add ')' if close < open.",
            "examples": [
                {
                    "input": "n = 3",
                    "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Generate all valid parentheses of n pairs.",
                "Can add '(' if count < n. Can add ')' if close < open.",
                "This ensures valid nesting."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "s9fokUqJ76A",
            "problemStatement": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "subsets": {
            "title": "Subsets",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udce6",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Backtrack: include or exclude each element.",
            "intuition": [
                "\ud83c\udfaf All subsets of a set.",
                "\ud83e\udde0 For each element: include or exclude.",
                "\ud83d\udca1 Results at every node, not just leaves."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                },
                {
                    "input": "nums = [0]",
                    "output": "[[],[0]]"
                }
            ],
            "code": "def subsets(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Add current path at every node, not just at leaves.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "Backtrack: include or exclude each element.\n\nAll subsets of a set.\nFor each element: include or exclude.",
            "examples": [
                {
                    "input": "nums = [1,2,3]",
                    "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All subsets of a set.",
                "For each element: include or exclude.",
                "Results at every node, not just leaves."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum"
            ],
            "videoId": "REOH22Xwdkk",
            "problemStatement": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "letter-case-permutation": {
            "title": "Letter Case Permutation",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd24",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "For each letter, branch on lower and upper case.",
            "intuition": [
                "\ud83c\udfaf All case permutations of letters.",
                "\ud83e\udde0 Digits: no choice. Letters: lower or upper.",
                "\ud83d\udca1 Binary branching on letters."
            ],
            "testCases": [
                {
                    "input": "s = \"a1b2\"",
                    "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
                },
                {
                    "input": "s = \"3z4\"",
                    "output": "[\"3z4\",\"3Z4\"]"
                }
            ],
            "code": "def letterCasePermutation(s):\n    res = []\n    def backtrack(i, path):\n        if i == len(s):\n            res.append(''.join(path))\n            return\n        if s[i].isalpha():\n            path.append(s[i].lower())\n            backtrack(i + 1, path)\n            path.pop()\n            path.append(s[i].upper())\n            backtrack(i + 1, path)\n            path.pop()\n        else:\n            path.append(s[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res",
            "keyInsight": "Letters create two branches; digits create one.",
            "visualizationType": "tree",
            "initialState": [],
            "animationSteps": [],
            "description": "For each letter, branch on lower and upper case.\n\nAll case permutations of letters.\nDigits: no choice. Letters: lower or upper.",
            "examples": [
                {
                    "input": "s = \"a1b2\"",
                    "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "All case permutations of letters.",
                "Digits: no choice. Letters: lower or upper.",
                "Binary branching on letters."
            ],
            "relatedProblems": [
                "permutations",
                "combination-sum",
                "subsets"
            ],
            "videoId": "hwLRMlnY2Zk",
            "problemStatement": "Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. Return the output in any order.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "merge-k-sorted-lists": {
            "title": "Merge k Sorted Lists",
            "pattern": "Divide and Conquer / Heap",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(N log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.",
            "intuition": [
                "\ud83c\udfaf Merge k sorted linked lists.",
                "\ud83e\udde0 Min-heap keeps track of smallest head.",
                "\ud83d\udca1 Pop smallest, add its next to heap."
            ],
            "testCases": [
                {
                    "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                    "output": "[1,1,2,3,4,4,5,6]"
                },
                {
                    "input": "lists = []",
                    "output": "[]"
                },
                {
                    "input": "lists = [[]]",
                    "output": "[]"
                }
            ],
            "code": "import heapq\n\ndef mergeKLists(lists):\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    res = []\n    while heap:\n        val, i, j = heapq.heappop(heap)\n        res.append(val)\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j + 1], i, j + 1))\n    return res",
            "keyInsight": "Heap gives O(log k) for each of N elements.",
            "visualizationType": "linkedlist",
            "initialState": [
                [
                    1,
                    4,
                    5
                ],
                [
                    1,
                    3,
                    4
                ],
                [
                    2,
                    6
                ]
            ],
            "animationSteps": [],
            "description": "Use min-heap to always get smallest head. Or divide-conquer merge pairs.\n\nMerge k sorted linked lists.\nMin-heap keeps track of smallest head.",
            "examples": [
                {
                    "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                    "output": "[1,1,2,3,4,4,5,6]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Merge k sorted linked lists.",
                "Min-heap keeps track of smallest head.",
                "Pop smallest, add its next to heap."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "q5a5OiGbT6Q",
            "problemStatement": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Hard"
        },
        "search-insert-position": {
            "title": "Search Insert Position",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search. If not found, left pointer is insert position.",
            "intuition": [
                "\ud83c\udfaf Find index to insert target in sorted array.",
                "\ud83e\udde0 Binary search: if exact match, return. Else return left.",
                "\ud83d\udca1 Left pointer ends at correct insert position."
            ],
            "testCases": [
                {
                    "input": "nums = [1,3,5,6], target = 5",
                    "output": "2"
                },
                {
                    "input": "nums = [1,3,5,6], target = 2",
                    "output": "1"
                },
                {
                    "input": "nums = [1,3,5,6], target = 7",
                    "output": "4"
                }
            ],
            "code": "def searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left",
            "keyInsight": "When target not found, left is the insert position.",
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                5,
                6
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initialize left to 0 and right to 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Calculate mid as (left + right) // 2 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Calculate new mid as (left + right) // 2 = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Check if nums[mid] == target. nums[2] = 5, which is not equal to the target"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Since nums[mid] > target, update right to mid - 1 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Calculate new mid as (left + right) // 2 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Check if nums[mid] == target. nums[1] = 3, which is not equal to the target"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Since nums[mid] < target, update left to mid + 1 = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        }
                    ],
                    "transientMessage": "Return left as the insert position for the target"
                }
            ],
            "description": "Binary search. If not found, left pointer is insert position.\n\nFind index to insert target in sorted array.\nBinary search: if exact match, return. Else return left.",
            "examples": [
                {
                    "input": "nums = [1,3,5,6]; target = 5",
                    "output": "2"
                },
                {
                    "input": "nums = [1,3,5,6]; target = 2",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find index to insert target in sorted array.",
                "Binary search: if exact match, return. Else return left.",
                "Left pointer ends at correct insert position."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "K-RYzDZkzCI",
            "problemStatement": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "search-a-2d-matrix": {
            "title": "Search a 2D Matrix",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log(m*n))",
            "spaceComplexity": "O(1)",
            "oneliner": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.",
            "intuition": [
                "\ud83c\udfaf Search target in row-sorted matrix.",
                "\ud83e\udde0 Flatten conceptually: idx -> (idx//n, idx%n).",
                "\ud83d\udca1 Standard binary search on virtual 1D array."
            ],
            "testCases": [
                {
                    "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
                    "output": "true"
                },
                {
                    "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
                    "output": "false"
                }
            ],
            "code": "def searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True\n        elif val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
            "keyInsight": "Index conversion: row = idx // cols, col = idx % cols.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3,
                    5,
                    7
                ],
                [
                    10,
                    11,
                    16,
                    20
                ],
                [
                    23,
                    30,
                    34,
                    60
                ]
            ],
            "animationSteps": [],
            "description": "Treat matrix as 1D sorted array. Binary search with coordinate conversion.\n\nSearch target in row-sorted matrix.\nFlatten conceptually: idx -> (idx//n, idx%n).",
            "examples": [
                {
                    "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]]; target = 3",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Search target in row-sorted matrix.",
                "Flatten conceptually: idx -> (idx//n, idx%n).",
                "Standard binary search on virtual 1D array."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "Ber2pi2C0j0",
            "problemStatement": "You are given an m x n integer matrix matrix with the following two properties:\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "find-peak-element": {
            "title": "Find Peak Element",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83c\udfd4\ufe0f",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Move towards larger neighbor. Guaranteed to find peak.",
            "intuition": [
                "\ud83c\udfaf Find any peak (greater than neighbors).",
                "\ud83e\udde0 If mid < mid+1, peak is on right. Else on left.",
                "\ud83d\udca1 Binary search converges to a peak."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "2"
                },
                {
                    "input": "nums = [1,2,1,3,5,6,4]",
                    "output": "5"
                }
            ],
            "code": "def findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left",
            "keyInsight": "Move towards the higher neighbor to find a peak.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initializing search with left = 0 and right = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        },
                        {
                            "index": 2,
                            "label": "mid + 1"
                        }
                    ],
                    "transientMessage": "Calculating mid = (0 + 3) // 2 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "nums[mid]"
                        },
                        {
                            "index": 2,
                            "label": "nums[mid + 1]}"
                        },
                        "transientMessage': "
                    ]
                }
            ],
            "description": "Move towards larger neighbor. Guaranteed to find peak.\n\nFind any peak (greater than neighbors).\nIf mid < mid+1, peak is on right. Else on left.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find any peak (greater than neighbors).",
                "If mid < mid+1, peak is on right. Else on left.",
                "Binary search converges to a peak."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array"
            ],
            "videoId": "kMzJy9es7Hc",
            "problemStatement": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "search-in-rotated-sorted-array": {
            "title": "Search in Rotated Sorted Array",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Determine which half is sorted. Check if target is in that half.",
            "intuition": [
                "\ud83c\udfaf Search in rotated sorted array.",
                "\ud83e\udde0 One half is always sorted. Check if target is there.",
                "\ud83d\udca1 Narrow down to the half where target can exist."
            ],
            "testCases": [
                {
                    "input": "nums = [4,5,6,7,0,1,2], target = 0",
                    "output": "4"
                },
                {
                    "input": "nums = [4,5,6,7,0,1,2], target = 3",
                    "output": "-1"
                },
                {
                    "input": "nums = [1], target = 0",
                    "output": "-1"
                }
            ],
            "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
            "keyInsight": "At least one half is always sorted in a rotated array.",
            "visualizationType": "array",
            "initialState": [
                4,
                5,
                6,
                7,
                0,
                1,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 6,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initialization: left = 0, right = 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "First iteration: mid = (0 + 6) // 2 = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Found target at index 3"
                }
            ],
            "description": "Determine which half is sorted. Check if target is in that half.\n\nSearch in rotated sorted array.\nOne half is always sorted. Check if target is there.",
            "examples": [
                {
                    "input": "nums = [4,5,6,7,0,1,2]; target = 0",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Search in rotated sorted array.",
                "One half is always sorted. Check if target is there.",
                "Narrow down to the half where target can exist."
            ],
            "relatedProblems": [
                "binary-search",
                "find-peak-element"
            ],
            "videoId": "U8XENwh8Oy8",
            "problemStatement": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "find-first-and-last-position-of-element-in-sorted-array": {
            "title": "Find First and Last Position of Element in Sorted Array",
            "pattern": "Binary Search (Bisect)",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Two binary searches: find left bound and right bound.",
            "intuition": [
                "\ud83c\udfaf Find start and end indices of target.",
                "\ud83e\udde0 Binary search for leftmost occurrence.",
                "\ud83d\udca1 Binary search for rightmost occurrence."
            ],
            "testCases": [
                {
                    "input": "nums = [5,7,7,8,8,10], target = 8",
                    "output": "[3,4]"
                },
                {
                    "input": "nums = [5,7,7,8,8,10], target = 6",
                    "output": "[-1,-1]"
                },
                {
                    "input": "nums = [], target = 0",
                    "output": "[-1,-1]"
                }
            ],
            "code": "def searchRange(nums, target):\n    def findLeft():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    def findRight():\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right\n    \n    l, r = findLeft(), findRight()\n    return [l, r] if l <= r else [-1, -1]",
            "keyInsight": "Two separate binary searches for left and right bounds.",
            "visualizationType": "array",
            "initialState": [
                5,
                7,
                7,
                8,
                8,
                10
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initializing search for left boundary"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Checking mid value (8) against target (7)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Adjusting search range to left half"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Checking mid value (7) against target (7)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Adjusting search range to left half"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Checking mid value (5) against target (7)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Left boundary found at index 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 5,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initializing search for right boundary"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Checking mid value (8) against target (7)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Adjusting search range to left half"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Checking mid value (7) against target (7)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 0,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Right boundary found at index 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "l"
                        },
                        {
                            "index": 3,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Result: [2, 3]"
                }
            ],
            "description": "Two binary searches: find left bound and right bound.\n\nFind start and end indices of target.\nBinary search for leftmost occurrence.",
            "examples": [
                {
                    "input": "nums = [5,7,7,8,8,10]; target = 8",
                    "output": "[3,4]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find start and end indices of target.",
                "Binary search for leftmost occurrence.",
                "Binary search for rightmost occurrence."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "4sQL7R5ySUU",
            "problemStatement": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "find-minimum-in-rotated-sorted-array": {
            "title": "Find Minimum in Rotated Sorted Array",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udcc9",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Compare mid with right. If mid > right, min is on right. Else on left.",
            "intuition": [
                "\ud83c\udfaf Find minimum in rotated sorted array.",
                "\ud83e\udde0 Compare mid with rightmost element.",
                "\ud83d\udca1 Rotation point is where min is."
            ],
            "testCases": [
                {
                    "input": "nums = [3,4,5,1,2]",
                    "output": "1"
                },
                {
                    "input": "nums = [4,5,6,7,0,1,2]",
                    "output": "0"
                },
                {
                    "input": "nums = [11,13,15,17]",
                    "output": "11"
                }
            ],
            "code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]",
            "keyInsight": "Compare with right end to determine which half has the minimum.",
            "visualizationType": "array",
            "initialState": [
                3,
                4,
                5,
                1,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Initialize left to 0 and right to 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Calculate mid as (left + right) // 2 = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "mid"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Check if nums[mid] > nums[right]: 5 > 2 (False)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Update right to mid: right = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Calculate new mid as (left + right) // 2 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "mid"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Check if nums[mid] > nums[right]: 4 > 2 (True)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Update left to mid + 1: left = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Termination: left == right"
                }
            ],
            "description": "Compare mid with right. If mid > right, min is on right. Else on left.\n\nFind minimum in rotated sorted array.\nCompare mid with rightmost element.",
            "examples": [
                {
                    "input": "nums = [3,4,5,1,2]",
                    "output": "1"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find minimum in rotated sorted array.",
                "Compare mid with rightmost element.",
                "Rotation point is where min is."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "nIVW4P8b1VA",
            "problemStatement": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "median-of-two-sorted-arrays": {
            "title": "Median of Two Sorted Arrays",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(log(min(m,n)))",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search on smaller array. Find partition where left <= right.",
            "intuition": [
                "\ud83c\udfaf Find median of two sorted arrays in O(log(m+n)).",
                "\ud83e\udde0 Partition both arrays such that left halves = right halves.",
                "\ud83d\udca1 Binary search on smaller array for correct partition."
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,3], nums2 = [2]",
                    "output": "2.00000"
                },
                {
                    "input": "nums1 = [1,2], nums2 = [3,4]",
                    "output": "2.50000"
                }
            ],
            "code": "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    while left <= right:\n        i = (left + right) // 2\n        j = (m + n + 1) // 2 - i\n        maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]\n        minRight1 = float('inf') if i == m else nums1[i]\n        maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]\n        minRight2 = float('inf') if j == n else nums2[j]\n        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n            if (m + n) % 2 == 0:\n                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2\n            return max(maxLeft1, maxLeft2)\n        elif maxLeft1 > minRight2:\n            right = i - 1\n        else:\n            left = i + 1\n    return 0.0",
            "keyInsight": "Partition such that all left elements <= all right elements.",
            "visualizationType": "array",
            "initialState": [
                1,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Starting binary search with nums1 = [1, 3], nums2 = []"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "transientMessage": "Since nums2 is empty, the median is the middle element of nums1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "transientMessage": "Median found: nums1[0] = 1"
                }
            ],
            "description": "Binary search on smaller array. Find partition where left <= right.\n\nFind median of two sorted arrays in O(log(m+n)).\nPartition both arrays such that left halves = right halves.",
            "examples": [
                {
                    "input": "nums1 = [1,3]; nums2 = [2]",
                    "output": "2.0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find median of two sorted arrays in O(log(m+n)).",
                "Partition both arrays such that left halves = right halves.",
                "Binary search on smaller array for correct partition."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "q6IEA26hvXc",
            "problemStatement": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "maximum-sum-circular-subarray": {
            "title": "Maximum Sum Circular Subarray",
            "pattern": "Kadane's",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Max is either normal Kadane OR total - min subarray.",
            "intuition": [
                "\ud83c\udfaf Max subarray sum in circular array.",
                "\ud83e\udde0 Two cases: normal subarray OR wrapping subarray.",
                "\ud83d\udca1 Wrapping = total - min subarray."
            ],
            "testCases": [
                {
                    "input": "nums = [1,-2,3,-2]",
                    "output": "3"
                },
                {
                    "input": "nums = [5,-3,5]",
                    "output": "10"
                },
                {
                    "input": "nums = [-3,-2,-3]",
                    "output": "-2"
                }
            ],
            "code": "def maxSubarraySumCircular(nums):\n    total = 0\n    maxSum = nums[0]\n    curMax = 0\n    minSum = nums[0]\n    curMin = 0\n    for n in nums:\n        curMax = max(curMax + n, n)\n        maxSum = max(maxSum, curMax)\n        curMin = min(curMin + n, n)\n        minSum = min(minSum, curMin)\n        total += n\n    if maxSum > 0:\n        return max(maxSum, total - minSum)\n    return maxSum",
            "keyInsight": "Circular case: max = total - minSubarray.",
            "visualizationType": "array",
            "initialState": [
                1,
                -2,
                3,
                -2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initialize maxSum and curMax to nums[0]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initialize minSum and curMin to nums[0]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Update curMax = max(curMax + n, n)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Update curMin = min(curMin + n, n)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Update curMax = max(curMax + n, n)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "transientMessage": "Calculate total of the array"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "transientMessage": "Return max(maxSum, total - minSum)"
                }
            ],
            "description": "Max is either normal Kadane OR total - min subarray.\n\nMax subarray sum in circular array.\nTwo cases: normal subarray OR wrapping subarray.",
            "examples": [
                {
                    "input": "nums = [1,-2,3,-2]",
                    "output": "3"
                },
                {
                    "input": "nums = [5,-3,5]",
                    "output": "10"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max subarray sum in circular array.",
                "Two cases: normal subarray OR wrapping subarray.",
                "Wrapping = total - min subarray."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "fxT9KjakYPM",
            "problemStatement": "Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "add-binary": {
            "title": "Add Binary",
            "pattern": "Bit by Bit",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(max(m,n))",
            "spaceComplexity": "O(max(m,n))",
            "oneliner": "Add digits from right, track carry.",
            "intuition": [
                "\ud83c\udfaf Add two binary strings.",
                "\ud83e\udde0 Process from right, handle carry.",
                "\ud83d\udca1 Or use int(a, 2) + int(b, 2), then bin()."
            ],
            "testCases": [
                {
                    "input": "a = \"11\", b = \"1\"",
                    "output": "\"100\""
                },
                {
                    "input": "a = \"1010\", b = \"1011\"",
                    "output": "\"10101\""
                }
            ],
            "code": "def addBinary(a, b):\n    res = []\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))\n        carry = total // 2\n    return ''.join(res[::-1])",
            "keyInsight": "Handle carry same as decimal addition.",
            "visualizationType": "string",
            "initialState": "11",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Initialize i = 1 and j = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Add a[i] (1) to carry (0), total = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add b[j] (1) to total, total = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Append '0' (total % 2) to result, carry = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Decrement i and j, i = 0, j = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Add a[i] (1) to carry (1), total = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add b[j] (1) to total, total = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Append '1' (total % 2) to result, carry = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Decrement i and j, i = -1, j = -1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "transientMessage": "Append '1' (carry) to result, final result = '100'"
                }
            ],
            "description": "Add digits from right, track carry.\n\nAdd two binary strings.\nProcess from right, handle carry.",
            "examples": [
                {
                    "input": "a = \"11\"; b = \"1\"",
                    "output": "\"100\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Add two binary strings.",
                "Process from right, handle carry.",
                "Or use int(a, 2) + int(b, 2), then bin()."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "keuWJ47xG8g",
            "problemStatement": "Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "reverse-bits": {
            "title": "Reverse Bits",
            "pattern": "Bit Manipulation",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(32)",
            "spaceComplexity": "O(1)",
            "oneliner": "Shift result left, add LSB of n, shift n right. Repeat 32 times.",
            "intuition": [
                "\ud83c\udfaf Reverse all 32 bits of an integer.",
                "\ud83e\udde0 Extract LSB of n, add to result, shift both.",
                "\ud83d\udca1 Repeat 32 times."
            ],
            "testCases": [
                {
                    "input": "n = 43261596",
                    "output": "964176192"
                },
                {
                    "input": "n = 2147483644",
                    "output": "1073741822"
                }
            ],
            "code": "def reverseBits(n):\n    res = 0\n    for _ in range(32):\n        res = (res << 1) | (n & 1)\n        n >>= 1\n    return res",
            "keyInsight": "Build result by shifting left and OR-ing LSB.",
            "visualizationType": "string",
            "initialState": "43261596",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Initial value of n: 43261596"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "res"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Shifting res left and adding least significant bit of n"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Right shifting n to process next bit"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "res"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Repeating the process for all 32 bits"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Final reversed bits value: 964176192"
                }
            ],
            "description": "Shift result left, add LSB of n, shift n right. Repeat 32 times.\n\nReverse all 32 bits of an integer.\nExtract LSB of n, add to result, shift both.",
            "examples": [
                {
                    "input": "n = 43261596",
                    "output": "964176192"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Reverse all 32 bits of an integer.",
                "Extract LSB of n, add to result, shift both.",
                "Repeat 32 times."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits"
            ],
            "videoId": "UcoN6UjAI64",
            "problemStatement": "Reverse bits of a given 32 bits unsigned integer.\nNote:\nExample 1:\nExample 2:\nConstraints:\nFollow up: If this function is called many times, how would you optimize it?",
            "difficulty": "Easy"
        },
        "number-of-1-bits": {
            "title": "Number of 1 Bits",
            "pattern": "Bit Manipulation",
            "patternEmoji": "1\ufe0f\u20e3",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(1)",
            "oneliner": "n & (n-1) clears rightmost 1 bit. Count iterations.",
            "intuition": [
                "\ud83c\udfaf Count set bits (Hamming weight).",
                "\ud83e\udde0 n & (n-1) removes rightmost 1.",
                "\ud83d\udca1 Count until n is 0."
            ],
            "testCases": [
                {
                    "input": "n = 11",
                    "output": "3"
                },
                {
                    "input": "n = 128",
                    "output": "1"
                },
                {
                    "input": "n = 2147483645",
                    "output": "30"
                }
            ],
            "code": "def hammingWeight(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count",
            "keyInsight": "n & (n-1) trick clears the lowest set bit.",
            "visualizationType": "string",
            "initialState": "11",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Starting with n = 11 (binary: 1011)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 3,
                            "label": "n - 1"
                        }
                    ],
                    "transientMessage": "n &= n - 1 (1011 & 1010 = 1010)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Increment count to 1, n is now 10"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 2,
                            "label": "n - 1"
                        }
                    ],
                    "transientMessage": "n &= n - 1 (1010 & 1001 = 1000)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Increment count to 2, n is now 8"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "n - 1"
                        }
                    ],
                    "transientMessage": "n &= n - 1 (1000 & 0111 = 0000)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Increment count to 3, n is now 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "transientMessage": "Final result: count = 3"
                }
            ],
            "description": "n & (n-1) clears rightmost 1 bit. Count iterations.\n\nCount set bits (Hamming weight).\nn & (n-1) removes rightmost 1.",
            "examples": [
                {
                    "input": "n = 11",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count set bits (Hamming weight).",
                "n & (n-1) removes rightmost 1.",
                "Count until n is 0."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits",
                "reverse-bits"
            ],
            "videoId": "5Km3utixwZs",
            "problemStatement": "Given a positive integer n, write a function that returns the number of set bits in its binary representation (also known as the Hamming weight).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "single-number": {
            "title": "Single Number",
            "pattern": "XOR",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "XOR all elements. Pairs cancel out, leaving single.",
            "intuition": [
                "\ud83c\udfaf Find element that appears once (others twice).",
                "\ud83e\udde0 XOR: a ^ a = 0, a ^ 0 = a.",
                "\ud83d\udca1 XOR all elements to get the unique one."
            ],
            "testCases": [
                {
                    "input": "nums = [2,2,1]",
                    "output": "1"
                },
                {
                    "input": "nums = [4,1,2,1,2]",
                    "output": "4"
                },
                {
                    "input": "nums = [1]",
                    "output": "1"
                }
            ],
            "code": "def singleNumber(nums):\n    res = 0\n    for n in nums:\n        res ^= n\n    return res",
            "keyInsight": "XOR is self-inverse: a ^ a = 0.",
            "visualizationType": "array",
            "initialState": [
                2,
                2,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "transientMessage": "Initializing result variable `res` to 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Iterating over the first element, nums[0] = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": -1,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Performing XOR operation: res ^= n (0 ^ 2 = 2)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Iterating over the second element, nums[1] = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        },
                        {
                            "index": -1,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Performing XOR operation: res ^= n (2 ^ 2 = 0)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Iterating over the third element, nums[2] = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "n"
                        },
                        {
                            "index": -1,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Performing XOR operation: res ^= n (0 ^ 1 = 1)"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "transientMessage": "Final result is stored in `res`, which is the single number"
                }
            ],
            "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                {
                    "input": "nums = [2,2,1]",
                    "output": "1",
                    "explanation": "1 appears once."
                },
                {
                    "input": "nums = [4,1,2,1,2]",
                    "output": "4",
                    "explanation": "4 appears once."
                },
                {
                    "input": "nums = [1]",
                    "output": "1",
                    "explanation": "Single element."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 3 * 10^4",
                "-3 * 10^4 <= nums[i] <= 3 * 10^4",
                "Each element appears twice except for one element which appears once."
            ],
            "hints": [
                "Use XOR operation.",
                "XOR of a number with itself is 0.",
                "XOR of a number with 0 is the number itself."
            ],
            "relatedProblems": [
                "single-number-ii",
                "single-number-iii",
                "missing-number"
            ],
            "videoId": "qMPX1AOa83k",
            "problemStatement": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "single-number-ii": {
            "title": "Single Number II",
            "pattern": "Bit Counting",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count bits mod 3 for each position.",
            "intuition": [
                "\ud83c\udfaf Find element appearing once (others 3 times).",
                "\ud83e\udde0 For each bit position, count 1s mod 3.",
                "\ud83d\udca1 Remaining bits form the unique number."
            ],
            "testCases": [
                {
                    "input": "nums = [2,2,3,2]",
                    "output": "3"
                },
                {
                    "input": "nums = [0,1,0,1,0,1,99]",
                    "output": "99"
                }
            ],
            "code": "def singleNumber(nums):\n    res = 0\n    for i in range(32):\n        bitSum = sum((n >> i) & 1 for n in nums)\n        if bitSum % 3:\n            res |= (1 << i)\n    # Handle negative numbers\n    if res >= 2**31:\n        res -= 2**32\n    return res",
            "keyInsight": "Count bits at each position; mod 3 reveals the unique number.",
            "visualizationType": "array",
            "initialState": [
                2,
                2,
                3,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Starting with bit position i = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Calculating bitSum for i = 0: (2 >> 0) & 1 + (2 >> 0) & 1 + (3 >> 0) & 1 + (2 >> 0) & 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "bitSum = 4, since bitSum % 3 != 0, res remains 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Moving to bit position i = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Calculating bitSum for i = 1: (2 >> 1) & 1 + (2 >> 1) & 1 + (3 >> 1) & 1 + (2 >> 1) & 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "bitSum = 2, since bitSum % 3 != 0, res remains 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Moving to bit position i = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Calculating bitSum for i = 2: (2 >> 2) & 1 + (2 >> 2) & 1 + (3 >> 2) & 1 + (2 >> 2) & 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "bitSum = 1, since bitSum % 3 != 0, res becomes 1 (res |= (1 << 2))"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Finished processing all bit positions"
                }
            ],
            "description": "Count bits mod 3 for each position.\n\nFind element appearing once (others 3 times).\nFor each bit position, count 1s mod 3.",
            "examples": [
                {
                    "input": "nums = [2,2,3,2]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find element appearing once (others 3 times).",
                "For each bit position, count 1s mod 3.",
                "Remaining bits form the unique number."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cOFAmaMBVps",
            "problemStatement": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "bitwise-and-of-numbers-range": {
            "title": "Bitwise AND of Numbers Range",
            "pattern": "Common Prefix",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "AND of range = common prefix of left and right.",
            "intuition": [
                "\ud83c\udfaf AND of all numbers from left to right.",
                "\ud83e\udde0 Result is the common prefix bits.",
                "\ud83d\udca1 Shift until left == right, then shift back."
            ],
            "testCases": [
                {
                    "input": "left = 5, right = 7",
                    "output": "4"
                },
                {
                    "input": "left = 0, right = 0",
                    "output": "0"
                },
                {
                    "input": "left = 1, right = 2147483647",
                    "output": "0"
                }
            ],
            "code": "def rangeBitwiseAnd(left, right):\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift",
            "keyInsight": "Find common prefix by shifting until equal.",
            "visualizationType": "string",
            "initialState": "5",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        }
                    ],
                    "transientMessage": "Starting with left = 5 (binary: 101)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Starting with right = 7 (binary: 111)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "left < right, shifting left and right to the right by 1 bit"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "After first shift: left = 2 (binary: 10), right = 3 (binary: 11)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "After second shift: left = 1 (binary: 1), right = 1 (binary: 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 1,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Now left is not less than right, stopping shifts"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 2,
                            "label": "shift"
                        }
                    ],
                    "transientMessage": "Final result: left << shift = 1 << 2 = 4 (binary: 100)"
                }
            ],
            "description": "AND of range = common prefix of left and right.\n\nAND of all numbers from left to right.\nResult is the common prefix bits.",
            "examples": [
                {
                    "input": "left = 5; right = 7",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "AND of all numbers from left to right.",
                "Result is the common prefix bits.",
                "Shift until left == right, then shift back."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "R3T0olAhUq0",
            "problemStatement": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "counting-bits": {
            "title": "Counting Bits",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.",
            "intuition": [
                "\ud83c\udfaf Count 1s in binary for 0 to n.",
                "\ud83e\udde0 i has same bits as i/2, plus LSB.",
                "\ud83d\udca1 dp[i] = dp[i >> 1] + (i & 1)."
            ],
            "testCases": [
                {
                    "input": "n = 2",
                    "output": "[0,1,1]"
                },
                {
                    "input": "n = 5",
                    "output": "[0,1,1,2,1,2]"
                }
            ],
            "code": "def countBits(n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp",
            "keyInsight": "dp[i] = dp[i >> 1] + (i & 1) reuses previous computation.",
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                1,
                2,
                1,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initializing dp array with size n+1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "i >> 1"
                        }
                    ],
                    "transientMessage": "Calculating dp[1] = dp[0] + (1 & 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "i >> 1"
                        }
                    ],
                    "transientMessage": "Calculating dp[2] = dp[1] + (2 & 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "i >> 1"
                        }
                    ],
                    "transientMessage": "Calculating dp[3] = dp[1] + (3 & 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "i >> 1"
                        }
                    ],
                    "transientMessage": "Calculating dp[4] = dp[2] + (4 & 1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "i >> 1"
                        }
                    ],
                    "transientMessage": "Calculating dp[5] = dp[2] + (5 & 1)"
                }
            ],
            "description": "dp[i] = dp[i >> 1] + (i & 1). Use previous result.\n\nCount 1s in binary for 0 to n.\ni has same bits as i/2, plus LSB.",
            "examples": [
                {
                    "input": "n = 5",
                    "output": "[0,1,1,2,1,2]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count 1s in binary for 0 to n.",
                "i has same bits as i/2, plus LSB.",
                "dp[i] = dp[i >> 1] + (i & 1)."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "RyBM56RIWrM",
            "problemStatement": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\nExample 1:\nExample 2:\nConstraints:\nFollow up:",
            "difficulty": "Easy"
        },
        "powx,-n": {
            "title": "Pow(x, n)",
            "pattern": "Binary Exponentiation",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "x^n = (x^(n/2))^2. Handle negative n.",
            "intuition": [
                "\ud83c\udfaf Compute x^n efficiently.",
                "\ud83e\udde0 Square and halve: x^n = (x^2)^(n/2).",
                "\ud83d\udca1 Handle negative exponent by inverting x."
            ],
            "testCases": [
                {
                    "input": "x = 2.00000, n = 10",
                    "output": "1024.00000"
                },
                {
                    "input": "x = 2.10000, n = 3",
                    "output": "9.26100"
                },
                {
                    "input": "x = 2.00000, n = -2",
                    "output": "0.25000"
                }
            ],
            "code": "def myPow(x, n):\n    if n < 0:\n        x = 1 / x\n        n = -n\n    res = 1\n    while n:\n        if n & 1:\n            res *= x\n        x *= x\n        n >>= 1\n    return res",
            "keyInsight": "Square x and halve n for O(log n) complexity.",
            "visualizationType": "string",
            "initialState": "2.0",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "Initial value of x is 2.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Initial value of n is -3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Since n is negative, x becomes 1/2.0 and n becomes -(-3) = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Initialize result res to 1.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Start while loop with n = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Since n & 1 is true (3 & 1 == 1), multiply res by x: res = 1.0 * 2.0 = 2.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Square x: x = 2.0 * 2.0 = 4.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Right shift n by 1: n = 3 >> 1 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Start next iteration of while loop with n = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Since n & 1 is true (1 & 1 == 1), multiply res by x: res = 2.0 * 4.0 = 8.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "x"
                        },
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Square x: x = 4.0 * 4.0 = 16.0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Right shift n by 1: n = 1 >> 1 = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "End while loop since n is now 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "res"
                        }
                    ],
                    "transientMessage": "Return result res = 8.0"
                }
            ],
            "description": "x^n = (x^(n/2))^2. Handle negative n.\n\nCompute x^n efficiently.\nSquare and halve: x^n = (x^2)^(n/2).",
            "examples": [
                {
                    "input": "x = 2.0; n = 10",
                    "output": "1024.0"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Compute x^n efficiently.",
                "Square and halve: x^n = (x^2)^(n/2).",
                "Handle negative exponent by inverting x."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "g9YQyYi4IQQ",
            "problemStatement": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "palindrome-number": {
            "title": "Palindrome Number",
            "pattern": "Number Reversal",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Reverse half the number and compare.",
            "intuition": [
                "\ud83c\udfaf Check if number is palindrome without string.",
                "\ud83e\udde0 Reverse last half of digits.",
                "\ud83d\udca1 Compare with first half."
            ],
            "testCases": [
                {
                    "input": "x = 121",
                    "output": "true"
                },
                {
                    "input": "x = -121",
                    "output": "false"
                },
                {
                    "input": "x = 10",
                    "output": "false"
                }
            ],
            "code": "def isPalindrome(x):\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False\n    rev = 0\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    return x == rev or x == rev // 10",
            "keyInsight": "Only reverse half to avoid overflow.",
            "visualizationType": "string",
            "initialState": "121",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Checking if x is negative or ends with a zero"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "transientMessage": "x is not negative and does not end with a zero, proceeding"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "rev"
                        },
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "Initializing rev to 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "rev"
                        },
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "First iteration: rev = 0 * 10 + 121 % 10 = 1, x //= 10 = 12"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "rev"
                        },
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "Second iteration: rev = 1 * 10 + 12 % 10 = 12, x //= 10 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "rev"
                        },
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "Third iteration: rev = 12 * 10 + 1 % 10 = 121, x //= 10 = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "rev"
                        },
                        {
                            "index": 0,
                            "label": "x"
                        }
                    ],
                    "transientMessage": "x <= rev, checking if x == rev or x == rev // 10"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "success",
                    "transientMessage": "x == rev, returning True (121 is a palindrome)"
                }
            ],
            "description": "Reverse half the number and compare.\n\nCheck if number is palindrome without string.\nReverse last half of digits.",
            "examples": [
                {
                    "input": "x = 121",
                    "output": "true"
                },
                {
                    "input": "x = -121",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Check if number is palindrome without string.",
                "Reverse last half of digits.",
                "Compare with first half."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yubRKwixN-U",
            "problemStatement": "Given an integer x, return true if x is a palindrome, and false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "plus-one": {
            "title": "Plus One",
            "pattern": "Simulation",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Add 1 to last digit, propagate carry.",
            "intuition": [
                "\ud83c\udfaf Add 1 to a number represented as array.",
                "\ud83e\udde0 Handle carry from rightmost digit.",
                "\ud83d\udca1 [9,9,9] -> [1,0,0,0]."
            ],
            "testCases": [
                {
                    "input": "digits = [1,2,3]",
                    "output": "[1,2,4]"
                },
                {
                    "input": "digits = [4,3,2,1]",
                    "output": "[4,3,2,2]"
                },
                {
                    "input": "digits = [9]",
                    "output": "[1,0]"
                }
            ],
            "code": "def plusOne(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits",
            "keyInsight": "If no early return, all 9s -> prepend 1.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if digits[2] < 9"
                },
                {
                    "type": "modify",
                    "indices": [
                        2
                    ],
                    "value": 4,
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Incrementing digits[2] to 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "All digits processed, returning the result"
                }
            ],
            "description": "Add 1 to last digit, propagate carry.\n\nAdd 1 to a number represented as array.\nHandle carry from rightmost digit.",
            "examples": [
                {
                    "input": "digits = [1,2,3]",
                    "output": "[1,2,4]"
                },
                {
                    "input": "digits = [9,9,9]",
                    "output": "[1,0,0,0]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Add 1 to a number represented as array.",
                "Handle carry from rightmost digit.",
                "[9,9,9] -> [1,0,0,0]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "jIaA8boiG1s",
            "problemStatement": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "factorial-trailing-zeroes": {
            "title": "Factorial Trailing Zeroes",
            "pattern": "Math",
            "patternEmoji": "0\ufe0f\u20e3",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count factors of 5 in n!",
            "intuition": [
                "\ud83c\udfaf Trailing zeros = count of (2*5) pairs.",
                "\ud83e\udde0 More 2s than 5s, so count 5s.",
                "\ud83d\udca1 n/5 + n/25 + n/125 + ..."
            ],
            "testCases": [
                {
                    "input": "n = 3",
                    "output": "0"
                },
                {
                    "input": "n = 5",
                    "output": "1"
                },
                {
                    "input": "n = 0",
                    "output": "0"
                }
            ],
            "code": "def trailingZeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count",
            "keyInsight": "Each factor of 5 contributes to a trailing zero.",
            "visualizationType": "string",
            "initialState": "25",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initializing count to 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Starting while loop with n = 25"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "n (25) is greater than or equal to 5"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "Performing n //= 5, updating n to 5"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "Updating count to 5"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "Performing n //= 5 again, updating n to 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "Updating count to 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "While loop condition fails (n = 1 < 5)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n"
                        },
                        {
                            "index": 1,
                            "label": "count"
                        }
                    ],
                    "transientMessage": "Returning count which is 6"
                }
            ],
            "description": "Count factors of 5 in n!\n\nTrailing zeros = count of (2*5) pairs.\nMore 2s than 5s, so count 5s.",
            "examples": [
                {
                    "input": "n = 5",
                    "output": "1"
                },
                {
                    "input": "n = 25",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Trailing zeros = count of (2*5) pairs.",
                "More 2s than 5s, so count 5s.",
                "n/5 + n/25 + n/125 + ..."
            ],
            "relatedProblems": [
                "palindrome-number",
                "fizz-buzz",
                "roman-to-integer"
            ],
            "videoId": "3Hdmq_GSgyI",
            "problemStatement": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you write a solution that works in logarithmic time complexity?",
            "difficulty": "Medium"
        },
        "sqrtx": {
            "title": "Sqrt(x)",
            "pattern": "Binary Search",
            "patternEmoji": "\u221a",
            "timeComplexity": "O(log x)",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search for largest k where k*k <= x.",
            "intuition": [
                "\ud83c\udfaf Find integer square root.",
                "\ud83e\udde0 Binary search: if mid*mid <= x, go right.",
                "\ud83d\udca1 Track the largest valid mid."
            ],
            "testCases": [
                {
                    "input": "x = 4",
                    "output": "2"
                },
                {
                    "input": "x = 8",
                    "output": "2"
                }
            ],
            "code": "def mySqrt(x):\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == x:\n            return mid\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right",
            "keyInsight": "Binary search from 1 to x/2 is sufficient.",
            "visualizationType": "string",
            "initialState": "8",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Checking if x < 2"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "left": 1,
                        "right": 4
                    },
                    "transientMessage": "Initializing left to 1 and right to x // 2 (8 // 2 = 4)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Starting binary search with left = 1 and right = 4"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "mid": 2
                    },
                    "transientMessage": "Calculating mid = (left + right) // 2 (1 + 4) // 2 = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "transientMessage": "Checking if mid * mid == x (2 * 2 == 8)"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "left": 3
                    },
                    "transientMessage": "Since mid * mid < x, updating left to mid + 1 (2 + 1 = 3)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "left"
                        },
                        {
                            "index": 6,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Continuing binary search with left = 3 and right = 4"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "mid": 3
                    },
                    "transientMessage": "Calculating mid = (left + right) // 2 (3 + 4) // 2 = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        7
                    ],
                    "color": "accent",
                    "transientMessage": "Checking if mid * mid == x (3 * 3 == 8)"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "left": 4
                    },
                    "transientMessage": "Since mid * mid < x, updating left to mid + 1 (3 + 1 = 4)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        8,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 8,
                            "label": "left"
                        },
                        {
                            "index": 6,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Continuing binary search with left = 4 and right = 4"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "mid": 4
                    },
                    "transientMessage": "Calculating mid = (left + right) // 2 (4 + 4) // 2 = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        9
                    ],
                    "color": "accent",
                    "transientMessage": "Checking if mid * mid == x (4 * 4 == 8)"
                },
                {
                    "type": "updateValue",
                    "indices": [],
                    "newValues": {
                        "right": 3
                    },
                    "transientMessage": "Since mid * mid > x, updating right to mid - 1 (4 - 1 = 3)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        8,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 8,
                            "label": "left"
                        },
                        {
                            "index": 6,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Binary search terminates as left > right"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6
                    ],
                    "color": "success",
                    "transientMessage": "Returning right as the integer part of the square root (3)"
                }
            ],
            "description": "Binary search for largest k where k*k <= x.\n\nFind integer square root.\nBinary search: if mid*mid <= x, go right.",
            "examples": [
                {
                    "input": "x = 8",
                    "output": "2"
                },
                {
                    "input": "x = 4",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find integer square root.",
                "Binary search: if mid*mid <= x, go right.",
                "Track the largest valid mid."
            ],
            "relatedProblems": [
                "binary-search",
                "search-in-rotated-sorted-array",
                "find-peak-element"
            ],
            "videoId": "zdMhg-EuXgI",
            "problemStatement": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "max-points-on-a-line": {
            "title": "Max Points on a Line",
            "pattern": "Hash Map + Slopes",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "For each point, count slopes to all others.",
            "intuition": [
                "\ud83c\udfaf Max collinear points.",
                "\ud83e\udde0 For each point, map slopes to counts.",
                "\ud83d\udca1 Use fractions to avoid float precision issues."
            ],
            "testCases": [
                {
                    "input": "points = [[1,1],[2,2],[3,3]]",
                    "output": "3"
                },
                {
                    "input": "points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]",
                    "output": "4"
                }
            ],
            "code": "from math import gcd\nfrom collections import defaultdict\n\ndef maxPoints(points):\n    if len(points) <= 2:\n        return len(points)\n    maxPts = 0\n    for i in range(len(points)):\n        slopes = defaultdict(int)\n        for j in range(len(points)):\n            if i == j:\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            g = gcd(dx, dy)\n            slope = (dx // g, dy // g)\n            slopes[slope] += 1\n            maxPts = max(maxPts, slopes[slope])\n    return maxPts + 1",
            "keyInsight": "Normalize slope using GCD to avoid float issues.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    3
                ]
            ],
            "animationSteps": [],
            "description": "For each point, count slopes to all others.\n\nMax collinear points.\nFor each point, map slopes to counts.",
            "examples": [
                {
                    "input": "points = [[1,1],[2,2],[3,3]]",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max collinear points.",
                "For each point, map slopes to counts.",
                "Use fractions to avoid float precision issues."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Bb9lSXgGMzk",
            "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "house-robber": {
            "title": "House Robber",
            "pattern": "1D DP",
            "patternEmoji": "\ud83c\udfe0",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
            "intuition": [
                "\ud83c\udfaf Max loot without robbing adjacent houses.",
                "\ud83e\udde0 At each house: rob it + dp[i-2], or skip it = dp[i-1].",
                "\ud83d\udca1 Only need last two values."
            ],
            "testCases": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "4"
                },
                {
                    "input": "nums = [2,7,9,3,1]",
                    "output": "12"
                }
            ],
            "code": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for n in nums:\n        curr = max(prev1, prev2 + n)\n        prev2, prev1 = prev1, curr\n    return prev1",
            "keyInsight": "Classic 1D DP with space optimization.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "transientMessage": "Initializing prev2 and prev1 to 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prev2"
                        },
                        {
                            "index": 1,
                            "label": "prev1"
                        }
                    ],
                    "transientMessage": "Processing first element nums[0] = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prev2"
                        },
                        {
                            "index": 1,
                            "label": "prev1"
                        },
                        {
                            "index": 2,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Processing second element nums[1] = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prev2"
                        },
                        {
                            "index": 1,
                            "label": "prev1"
                        },
                        {
                            "index": 3,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Processing third element nums[2] = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prev2"
                        },
                        {
                            "index": 1,
                            "label": "prev1"
                        },
                        {
                            "index": 4,
                            "label": "n"
                        }
                    ],
                    "transientMessage": "Processing fourth element nums[3] = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "prev1"
                        }
                    ],
                    "transientMessage": "Returning the result prev1 = 4"
                }
            ],
            "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "4",
                    "explanation": "Rob house 1 and house 3: 1 + 3 = 4."
                },
                {
                    "input": "nums = [2,7,9,3,1]",
                    "output": "12",
                    "explanation": "Rob house 1, 3, and 5: 2 + 9 + 1 = 12."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 100",
                "0 <= nums[i] <= 400"
            ],
            "hints": [
                "Use dynamic programming.",
                "At each house, decide: rob it or skip it.",
                "dp[i] = max(dp[i-1], dp[i-2] + nums[i])"
            ],
            "relatedProblems": [
                "house-robber-ii",
                "house-robber-iii",
                "delete-and-earn"
            ],
            "videoId": "73r3KWiEvyk",
            "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "word-break": {
            "title": "Word Break",
            "pattern": "1D DP",
            "patternEmoji": "\ud83d\udcdd",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i] = any(dp[j] and s[j:i] in wordDict).",
            "intuition": [
                "\ud83c\udfaf Can s be segmented into dictionary words?",
                "\ud83e\udde0 dp[i] = True if s[:i] can be segmented.",
                "\ud83d\udca1 Check all valid word endings."
            ],
            "testCases": [
                {
                    "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
                    "output": "true"
                },
                {
                    "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
                    "output": "true"
                },
                {
                    "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                    "output": "false"
                }
            ],
            "code": "def wordBreak(s, wordDict):\n    wordSet = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordSet:\n                dp[i] = True\n                break\n    return dp[len(s)]",
            "keyInsight": "dp[i] = True if any valid word ends at position i.",
            "visualizationType": "string",
            "initialState": "leetcode",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "j"
                        },
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[0] and s[0:1] ('l') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "j"
                        },
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[0] and s[0:2] ('le') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        },
                        {
                            "index": 3,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[1] and s[1:3] ('et') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "j"
                        },
                        {
                            "index": 4,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[0] and s[0:4] ('leet') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "j"
                        },
                        {
                            "index": 5,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[4] and s[4:5] ('c') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "j"
                        },
                        {
                            "index": 6,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[0] and s[0:6] ('leetc') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        7
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "j"
                        },
                        {
                            "index": 7,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[1] and s[1:7] ('etcode') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        8
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "j"
                        },
                        {
                            "index": 8,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Checking if dp[0] and s[0:8] ('leetcode') is in wordSet"
                },
                {
                    "type": "highlight",
                    "indices": [
                        8
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 8,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "dp[8] is True, meaning 'leetcode' can be segmented"
                }
            ],
            "description": "dp[i] = any(dp[j] and s[j:i] in wordDict).\n\nCan s be segmented into dictionary words?\ndp[i] = True if s[:i] can be segmented.",
            "examples": [
                {
                    "input": "s = \"leetcode\"; wordDict = [\"leet\",\"code\"]",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Can s be segmented into dictionary words?",
                "dp[i] = True if s[:i] can be segmented.",
                "Check all valid word endings."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "Sx9NNgvgQjE",
            "problemStatement": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "longest-increasing-subsequence": {
            "title": "Longest Increasing Subsequence",
            "pattern": "DP / Binary Search",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Maintain sorted 'tails' array. Binary search insertion point.",
            "intuition": [
                "\ud83c\udfaf Find LIS length.",
                "\ud83e\udde0 O(n log n): maintain smallest tail for each length.",
                "\ud83d\udca1 Binary search for where to insert/replace."
            ],
            "testCases": [
                {
                    "input": "nums = [10,9,2,5,3,7,101,18]",
                    "output": "4"
                },
                {
                    "input": "nums = [0,1,0,3,2,3]",
                    "output": "4"
                },
                {
                    "input": "nums = [7,7,7,7,7,7,7]",
                    "output": "1"
                }
            ],
            "code": "import bisect\n\ndef lengthOfLIS(nums):\n    tails = []\n    for n in nums:\n        pos = bisect.bisect_left(tails, n)\n        if pos == len(tails):\n            tails.append(n)\n        else:\n            tails[pos] = n\n    return len(tails)",
            "keyInsight": "tails[i] = smallest tail of LIS of length i+1.",
            "visualizationType": "array",
            "initialState": [
                10,
                9,
                2,
                5,
                3,
                7,
                101,
                18
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=10"
                        }
                    ],
                    "transientMessage": "Processing first element 10, tails is empty"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "pos=0"
                        }
                    ],
                    "transientMessage": "10 is appended to tails at position 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n=9"
                        }
                    ],
                    "transientMessage": "Processing element 9, finding insertion point"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "pos=0"
                        }
                    ],
                    "transientMessage": "9 replaces 10 at position 0 (smaller value)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "n=2"
                        }
                    ],
                    "transientMessage": "Processing element 2, finding insertion point"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "pos=0"
                        }
                    ],
                    "transientMessage": "2 replaces 9 at position 0 (maintaining smallest possible values)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "n=5"
                        }
                    ],
                    "transientMessage": "Processing element 5, finding insertion point"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "pos=1"
                        }
                    ],
                    "transientMessage": "5 is appended at position 1 (extends the subsequence)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "n=3"
                        },
                        {
                            "index": 5,
                            "label": "n=7"
                        },
                        {
                            "index": 6,
                            "label": "n=101"
                        }
                    ],
                    "transientMessage": "Processing elements 3, 7, and 101 - updating tails array"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Final tails array represents the longest increasing subsequence length: 4"
                }
            ],
            "description": "Maintain sorted 'tails' array. Binary search insertion point.\n\nFind LIS length.\nO(n log n): maintain smallest tail for each length.",
            "examples": [
                {
                    "input": "nums = [10,9,2,5,3,7,101,18]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LIS length.",
                "O(n log n): maintain smallest tail for each length.",
                "Binary search for where to insert/replace."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "cjWnW0hdVeY",
            "problemStatement": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity?",
            "difficulty": "Medium"
        },
        "number-of-longest-increasing-subsequence": {
            "title": "Number of Longest Increasing Subsequence",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(n)",
            "oneliner": "Track both length and count at each position.",
            "intuition": [
                "\ud83c\udfaf Count all LIS.",
                "\ud83e\udde0 dp[i] = (length, count) of LIS ending at i.",
                "\ud83d\udca1 Aggregate counts for max length."
            ],
            "testCases": [
                {
                    "input": "nums = [1,3,5,4,7]",
                    "output": "2"
                },
                {
                    "input": "nums = [2,2,2,2,2]",
                    "output": "5"
                }
            ],
            "code": "def findNumberOfLIS(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    lengths = [1] * n\n    counts = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                if lengths[j] + 1 > lengths[i]:\n                    lengths[i] = lengths[j] + 1\n                    counts[i] = counts[j]\n                elif lengths[j] + 1 == lengths[i]:\n                    counts[i] += counts[j]\n    maxLen = max(lengths)\n    return sum(c for l, c in zip(lengths, counts) if l == maxLen)",
            "keyInsight": "Track both LIS length and count of ways to achieve it.",
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                5,
                4,
                7
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Initializing lengths[0]=1 and counts[0]=1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Comparing nums[0]=1 with nums[1]=3, updating lengths[1] and counts[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Comparing nums[1]=3 with nums[2]=5, extending LIS at index 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Comparing nums[1]=3 with nums[3]=4, extending LIS at index 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Comparing nums[2]=5 with nums[4]=7, extending LIS at index 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Finding maximum length of LIS: maxLen = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "maxLen"
                        }
                    ],
                    "transientMessage": "Counting subsequences with length 4, found 1 subsequence"
                }
            ],
            "description": "Track both length and count at each position.\n\nCount all LIS.\ndp[i] = (length, count) of LIS ending at i.",
            "examples": [
                {
                    "input": "nums = [1,3,5,4,7]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count all LIS.",
                "dp[i] = (length, count) of LIS ending at i.",
                "Aggregate counts for max length."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "Tuc-rjJbsXU",
            "problemStatement": "Given an integer array nums, return the number of longest increasing subsequences.\nNotice that the sequence has to be strictly increasing.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "decode-ways": {
            "title": "Decode Ways",
            "pattern": "1D DP",
            "patternEmoji": "\ud83d\udd13",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).",
            "intuition": [
                "\ud83c\udfaf Count ways to decode digit string.",
                "\ud83e\udde0 Single digit: 1-9 valid. Two digits: 10-26 valid.",
                "\ud83d\udca1 Similar to Fibonacci with constraints."
            ],
            "testCases": [
                {
                    "input": "s = \"12\"",
                    "output": "2"
                },
                {
                    "input": "s = \"226\"",
                    "output": "3"
                },
                {
                    "input": "s = \"06\"",
                    "output": "0"
                }
            ],
            "code": "def numDecodings(s):\n    if not s or s[0] == '0':\n        return 0\n    prev2, prev1 = 1, 1\n    for i in range(1, len(s)):\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two = int(s[i-1:i+1])\n        if 10 <= two <= 26:\n            curr += prev2\n        prev2, prev1 = prev1, curr\n    return prev1",
            "keyInsight": "Handle '0' carefully - it can only be part of 10 or 20.",
            "visualizationType": "string",
            "initialState": "226",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "s[0]"
                        }
                    ],
                    "transientMessage": "Check if string is empty or starts with '0'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prev2"
                        },
                        {
                            "index": 1,
                            "label": "prev1"
                        }
                    ],
                    "transientMessage": "Initialize prev2=1, prev1=1 (base cases)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Process character at index 1: '2'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "s[1] != '0', so add prev1=1 to curr"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "s[0:2]"
                        }
                    ],
                    "transientMessage": "Check two-digit number '22' (10-26), add prev2=1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Process character at index 2: '6'"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "s[2] != '0', so add prev1=2 to curr"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "s[1:3]"
                        }
                    ],
                    "transientMessage": "Check two-digit number '26' (10-26), add prev2=1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Final result: 3 ways to decode '226'"
                }
            ],
            "description": "dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid pair).\n\nCount ways to decode digit string.\nSingle digit: 1-9 valid. Two digits: 10-26 valid.",
            "examples": [
                {
                    "input": "s = \"226\"",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count ways to decode digit string.",
                "Single digit: 1-9 valid. Two digits: 10-26 valid.",
                "Similar to Fibonacci with constraints."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "6aEyTjOwlJU",
            "problemStatement": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:\n\"1\" -> 'A'\n\"2\" -> 'B'\n...\n\"25\" -> 'Y'\n\"26\" -> 'Z'\nHowever, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes (\"2\" and \"5\" vs \"25\").\nFor example, \"11106\" can be decoded into:\nNote: there may be strings that are impossible to decode.\n\nGiven a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "minimum-path-sum": {
            "title": "Minimum Path Sum",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
            "intuition": [
                "\ud83c\udfaf Min sum path from top-left to bottom-right.",
                "\ud83e\udde0 Can only move right or down.",
                "\ud83d\udca1 Each cell = min of arriving from top or left."
            ],
            "testCases": [
                {
                    "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                    "output": "7"
                },
                {
                    "input": "grid = [[1,2,3],[4,5,6]]",
                    "output": "12"
                }
            ],
            "code": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]",
            "keyInsight": "Modify grid in-place for O(1) extra space.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3,
                    1
                ],
                [
                    1,
                    5,
                    1
                ],
                [
                    4,
                    2,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).\n\nMin sum path from top-left to bottom-right.\nCan only move right or down.",
            "examples": [
                {
                    "input": "grid = [[1,3,1],[1,5,1],[4,2,1]]",
                    "output": "7"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min sum path from top-left to bottom-right.",
                "Can only move right or down.",
                "Each cell = min of arriving from top or left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "pGMsrvt0fpk",
            "problemStatement": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "unique-paths-ii": {
            "title": "Unique Paths II",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].",
            "intuition": [
                "\ud83c\udfaf Count paths with obstacles.",
                "\ud83e\udde0 Obstacle = 0 paths through that cell.",
                "\ud83d\udca1 Sum paths from top and left if not blocked."
            ],
            "testCases": [
                {
                    "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "2"
                },
                {
                    "input": "obstacleGrid = [[0,1],[0,0]]",
                    "output": "1"
                }
            ],
            "code": "def uniquePathsWithObstacles(obstacleGrid):\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    if obstacleGrid[0][0] == 1:\n        return 0\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(m):\n        for j in range(n):\n            if obstacleGrid[i][j] == 1:\n                dp[j] = 0\n            elif j > 0:\n                dp[j] += dp[j-1]\n    return dp[-1]",
            "keyInsight": "Set dp to 0 for obstacles.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    0,
                    0,
                    0
                ],
                [
                    0,
                    1,
                    0
                ],
                [
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = 0 if obstacle, else dp[i-1][j] + dp[i][j-1].\n\nCount paths with obstacles.\nObstacle = 0 paths through that cell.",
            "examples": [
                {
                    "input": "obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count paths with obstacles.",
                "Obstacle = 0 paths through that cell.",
                "Sum paths from top and left if not blocked."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "d3UOz7zdE4I",
            "problemStatement": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "longest-palindromic-substring": {
            "title": "Longest Palindromic Substring",
            "pattern": "Expand Around Center",
            "patternEmoji": "\ud83d\udcdc",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Expand from each center (2n-1 centers).",
            "intuition": [
                "\ud83c\udfaf Find longest palindromic substring.",
                "\ud83e\udde0 Expand from each center (odd and even length).",
                "\ud83d\udca1 Track start and maxLen."
            ],
            "testCases": [
                {
                    "input": "s = \"babad\"",
                    "output": "\"bab\""
                },
                {
                    "input": "s = \"cbbd\"",
                    "output": "\"bb\""
                }
            ],
            "code": "def longestPalindrome(s):\n    if len(s) < 2:\n        return s\n    start, maxLen = 0, 1\n    \n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return r - l - 1\n    \n    for i in range(len(s)):\n        len1 = expand(i, i)\n        len2 = expand(i, i + 1)\n        length = max(len1, len2)\n        if length > maxLen:\n            maxLen = length\n            start = i - (length - 1) // 2\n    return s[start:start + maxLen]",
            "keyInsight": "There are 2n-1 centers (n single + n-1 pairs).",
            "visualizationType": "string",
            "initialState": "babad",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 4,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Initial string 'babad' with length 5, start=0, maxLen=1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "l"
                        },
                        {
                            "index": 0,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Expanding around center i=0, checking s[0] with itself"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Palindrome 'b' found with length 1, maxLen remains 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "l"
                        },
                        {
                            "index": 1,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Expanding around center i=1, checking s[1] with itself"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "l"
                        },
                        {
                            "index": 2,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Palindrome 'bab' found with length 3, updating maxLen=3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "l"
                        },
                        {
                            "index": 2,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Checking even-length palindrome at i=1, expanding around s[1] and s[2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "l"
                        },
                        {
                            "index": 2,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "s[1]='a' != s[2]='b', no even-length palindrome here"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "l"
                        },
                        {
                            "index": 2,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Expanding around center i=2, checking s[2] with itself"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "l"
                        },
                        {
                            "index": 3,
                            "label": "r"
                        }
                    ],
                    "transientMessage": "Palindrome 'aba' found with length 3, same as current maxLen"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 2,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Returning longest palindromic substring 'bab'"
                }
            ],
            "description": "Expand from each center (2n-1 centers).\n\nFind longest palindromic substring.\nExpand from each center (odd and even length).",
            "examples": [
                {
                    "input": "s = \"babad\"",
                    "output": "\"bab\""
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find longest palindromic substring.",
                "Expand from each center (odd and even length).",
                "Track start and maxLen."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "XYQecbcd6_c",
            "problemStatement": "Given a string s, return the longest palindromic substring in s.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "interleaving-string": {
            "title": "Interleaving String",
            "pattern": "2D DP",
            "patternEmoji": "\ud83e\udde9",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].",
            "intuition": [
                "\ud83c\udfaf Can s3 be formed by interleaving s1 and s2?",
                "\ud83e\udde0 dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
                "\ud83d\udca1 Check if current char matches from s1 or s2."
            ],
            "testCases": [
                {
                    "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
                    "output": "true"
                },
                {
                    "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
                    "output": "false"
                },
                {
                    "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
                    "output": "true"
                }
            ],
            "code": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n    dp = [False] * (n + 1)\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i-1] == s3[i-1]\n            else:\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n    return dp[n]",
            "keyInsight": "Current s3 char must match either s1[i-1] or s2[j-1].",
            "visualizationType": "string",
            "initialState": "aadbbcbcac",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Initializing DP array for interleaving string check"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i=0"
                        },
                        {
                            "index": 0,
                            "label": "j=0"
                        }
                    ],
                    "transientMessage": "Base case: empty strings match"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i=0"
                        },
                        {
                            "index": 1,
                            "label": "j=1"
                        }
                    ],
                    "transientMessage": "Checking if s2[0] matches s3[0]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i=0"
                        },
                        {
                            "index": 2,
                            "label": "j=2"
                        }
                    ],
                    "transientMessage": "Checking if s2[1] matches s3[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i=1"
                        },
                        {
                            "index": 0,
                            "label": "j=0"
                        }
                    ],
                    "transientMessage": "Checking if s1[0] matches s3[0]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i=1"
                        },
                        {
                            "index": 1,
                            "label": "j=1"
                        }
                    ],
                    "transientMessage": "Checking both s1[0] and s2[0] against s3[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i=2"
                        },
                        {
                            "index": 1,
                            "label": "j=1"
                        }
                    ],
                    "transientMessage": "Checking both s1[1] and s2[0] against s3[2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i=1"
                        },
                        {
                            "index": 2,
                            "label": "j=2"
                        }
                    ],
                    "transientMessage": "Checking both s1[0] and s2[1] against s3[2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i=2"
                        },
                        {
                            "index": 2,
                            "label": "j=2"
                        }
                    ],
                    "transientMessage": "Found valid interleaving combination"
                }
            ],
            "description": "dp[i][j] = True if s3[:i+j] can be formed by s1[:i] and s2[:j].\n\nCan s3 be formed by interleaving s1 and s2?\ndp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
            "examples": [
                {
                    "input": "s1 = \"aabcc\"; s2 = \"dbbca\"; s3 = \"aadbbcbcac\"",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Can s3 be formed by interleaving s1 and s2?",
                "dp[i][j] = can form s3[:i+j] from s1[:i], s2[:j].",
                "Check if current char matches from s1 or s2."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "3Rw3p9LrgvE",
            "problemStatement": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.\nAn interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:\nNote: a + b is the concatenation of strings a and b.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up: Could you solve it using only O(s2.length) additional memory space?",
            "difficulty": "Medium"
        },
        "edit-distance": {
            "title": "Edit Distance",
            "pattern": "2D DP",
            "patternEmoji": "\u270f\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = min(insert, delete, replace) + 1.",
            "intuition": [
                "\ud83c\udfaf Min operations to convert word1 to word2.",
                "\ud83e\udde0 Three operations: insert, delete, replace.",
                "\ud83d\udca1 If chars match, dp[i][j] = dp[i-1][j-1]."
            ],
            "testCases": [
                {
                    "input": "word1 = \"horse\", word2 = \"ros\"",
                    "output": "3"
                },
                {
                    "input": "word1 = \"intention\", word2 = \"execution\"",
                    "output": "5"
                }
            ],
            "code": "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    prev = list(range(n + 1))\n    for i in range(1, m + 1):\n        curr = [i] + [0] * n\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                curr[j] = prev[j-1]\n            else:\n                curr[j] = 1 + min(prev[j], curr[j-1], prev[j-1])\n        prev = curr\n    return prev[n]",
            "keyInsight": "Replace = dp[i-1][j-1], Insert = dp[i][j-1], Delete = dp[i-1][j].",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "dp[i][j] = min(insert, delete, replace) + 1.\n\nMin operations to convert word1 to word2.\nThree operations: insert, delete, replace.",
            "examples": [
                {
                    "input": "word1 = \"horse\"; word2 = \"ros\"",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min operations to convert word1 to word2.",
                "Three operations: insert, delete, replace.",
                "If chars match, dp[i][j] = dp[i-1][j-1]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "XYi2-LPrwm4",
            "problemStatement": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "best-time-to-buy-and-sell-stock-iii": {
            "title": "Best Time to Buy and Sell Stock III",
            "pattern": "State Machine DP",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track 4 states: buy1, sell1, buy2, sell2.",
            "intuition": [
                "\ud83c\udfaf Max profit with at most 2 transactions.",
                "\ud83e\udde0 4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
                "\ud83d\udca1 Update states in reverse order."
            ],
            "testCases": [
                {
                    "input": "prices = [3,3,5,0,0,3,1,4]",
                    "output": "6"
                },
                {
                    "input": "prices = [1,2,3,4,5]",
                    "output": "4"
                },
                {
                    "input": "prices = [7,6,4,3,1]",
                    "output": "0"
                }
            ],
            "code": "def maxProfit(prices):\n    buy1 = buy2 = float('-inf')\n    sell1 = sell2 = 0\n    for p in prices:\n        sell2 = max(sell2, buy2 + p)\n        buy2 = max(buy2, sell1 - p)\n        sell1 = max(sell1, buy1 + p)\n        buy1 = max(buy1, -p)\n    return sell2",
            "keyInsight": "State machine: buy1 -> sell1 -> buy2 -> sell2.",
            "visualizationType": "array",
            "initialState": [
                3,
                3,
                5,
                0,
                0,
                3,
                1,
                4
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "p=3"
                        }
                    ],
                    "transientMessage": "Initial state: buy1=-inf, buy2=-inf, sell1=0, sell2=0. Processing price 3."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "p=3"
                        }
                    ],
                    "transientMessage": "Processing price 3. buy1=max(-inf, -3)=-3. sell1=max(0, -3+3)=0."
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "p=5"
                        }
                    ],
                    "transientMessage": "Processing price 5. buy1=max(-3, -5)=-3. sell1=max(0, -3+5)=2."
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "p=0"
                        }
                    ],
                    "transientMessage": "Processing price 0. buy1=max(-3, 0)=-3. sell1=max(2, -3+0)=2."
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "p=0"
                        }
                    ],
                    "transientMessage": "Processing price 0. No change in buy1 or sell1. Preparing for second transaction."
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "p=3"
                        }
                    ],
                    "transientMessage": "Processing price 3. buy2=max(-inf, 2-3)=-1. sell2=max(0, -1+3)=2."
                },
                {
                    "type": "highlight",
                    "indices": [
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 6,
                            "label": "p=1"
                        }
                    ],
                    "transientMessage": "Processing price 1. buy2=max(-1, 2-1)=1. sell2=max(2, 1+1)=2."
                },
                {
                    "type": "highlight",
                    "indices": [
                        7
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 7,
                            "label": "p=4"
                        }
                    ],
                    "transientMessage": "Processing price 4. buy2=max(1, 2-4)=-1. sell2=max(2, 1+4)=5."
                }
            ],
            "description": "Track 4 states: buy1, sell1, buy2, sell2.\n\nMax profit with at most 2 transactions.\n4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
            "examples": [
                {
                    "input": "prices = [3,3,5,0,0,3,1,4]",
                    "output": "6"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max profit with at most 2 transactions.",
                "4 states: after 1st buy, 1st sell, 2nd buy, 2nd sell.",
                "Update states in reverse order."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "4YjWuPLN_wg",
            "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete at most two transactions.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Hard"
        },
        "best-time-to-buy-and-sell-stock-iv": {
            "title": "Best Time to Buy and Sell Stock IV",
            "pattern": "DP",
            "patternEmoji": "\ud83d\udcc8",
            "timeComplexity": "O(n*k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Generalize to k transactions with 2k states.",
            "intuition": [
                "\ud83c\udfaf Max profit with at most k transactions.",
                "\ud83e\udde0 dp[i] = max profit after i-th transaction.",
                "\ud83d\udca1 If k >= n/2, it's unlimited transactions."
            ],
            "testCases": [
                {
                    "input": "k = 2, prices = [2,4,1]",
                    "output": "2"
                },
                {
                    "input": "k = 2, prices = [3,2,6,5,0,3]",
                    "output": "7"
                }
            ],
            "code": "def maxProfit(k, prices):\n    if not prices:\n        return 0\n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    buy = [float('-inf')] * (k + 1)\n    sell = [0] * (k + 1)\n    for p in prices:\n        for i in range(1, k + 1):\n            sell[i] = max(sell[i], buy[i] + p)\n            buy[i] = max(buy[i], sell[i-1] - p)\n    return sell[k]",
            "keyInsight": "If k >= n/2, simplify to unlimited transactions.",
            "visualizationType": "array",
            "initialState": [
                3,
                2,
                6,
                5,
                0,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Initial prices array with 6 elements"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "p=3"
                        }
                    ],
                    "transientMessage": "Processing price 3, initializing buy and sell arrays"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "p=2"
                        }
                    ],
                    "transientMessage": "Processing price 2, updating buy[1] and sell[1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "p=6"
                        }
                    ],
                    "transientMessage": "Processing price 6, potential profit from buying at 2 to selling at 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "p=5"
                        }
                    ],
                    "transientMessage": "Processing price 5, evaluating whether to sell or hold"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "p=0"
                        }
                    ],
                    "transientMessage": "Processing price 0, considering new buying opportunity"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "p=3"
                        }
                    ],
                    "transientMessage": "Processing final price 3, completing transactions"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Best transaction identified: buy at 2 (index 1) and sell at 6 (index 2)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Second transaction: buy at 0 (index 4) and sell at 3 (index 5)"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Maximum profit calculated: (6-2) + (3-0) = 7"
                }
            ],
            "description": "Generalize to k transactions with 2k states.\n\nMax profit with at most k transactions.\ndp[i] = max profit after i-th transaction.",
            "examples": [
                {
                    "input": "k = 2; prices = [3,2,6,5,0,3]",
                    "output": "7"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Max profit with at most k transactions.",
                "dp[i] = max profit after i-th transaction.",
                "If k >= n/2, it's unlimited transactions."
            ],
            "relatedProblems": [
                "climbing-stairs",
                "coin-change",
                "longest-increasing-subsequence"
            ],
            "videoId": "Pw6lrYANjz4",
            "problemStatement": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "maximal-square": {
            "title": "Maximal Square",
            "pattern": "2D DP",
            "patternEmoji": "\u2b1b",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.",
            "intuition": [
                "\ud83c\udfaf Largest square of 1s in binary matrix.",
                "\ud83e\udde0 dp[i][j] = side length of largest square ending at (i,j).",
                "\ud83d\udca1 Constrained by top, left, and diagonal."
            ],
            "testCases": [
                {
                    "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "4"
                },
                {
                    "input": "matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]",
                    "output": "1"
                },
                {
                    "input": "matrix = [[\"0\"]]",
                    "output": "0"
                }
            ],
            "code": "def maximalSquare(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [0] * (n + 1)\n    maxSide = 0\n    prev = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            temp = dp[j]\n            if matrix[i-1][j-1] == '1':\n                dp[j] = min(dp[j-1], dp[j], prev) + 1\n                maxSide = max(maxSide, dp[j])\n            else:\n                dp[j] = 0\n            prev = temp\n    return maxSide * maxSide",
            "keyInsight": "Square side = min of three neighbors + 1.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    "1",
                    "0",
                    "1",
                    "0",
                    "0"
                ],
                [
                    "1",
                    "0",
                    "1",
                    "1",
                    "1"
                ]
            ],
            "animationSteps": [],
            "description": "dp[i][j] = min(top, left, diag) + 1 if matrix[i][j] == '1'.\n\nLargest square of 1s in binary matrix.\ndp[i][j] = side length of largest square ending at (i,j).",
            "examples": [
                {
                    "input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Largest square of 1s in binary matrix.",
                "dp[i][j] = side length of largest square ending at (i,j).",
                "Constrained by top, left, and diagonal."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "6X7Ha2PrDmM",
            "problemStatement": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "remove-linked-list-elements": {
            "title": "Remove Linked List Elements",
            "pattern": "Linked List",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use dummy head. Skip nodes with target value.",
            "intuition": [
                "\ud83c\udfaf Remove all nodes with given value.",
                "\ud83e\udde0 Dummy head handles removing actual head.",
                "\ud83d\udca1 Skip nodes by adjusting next pointers."
            ],
            "testCases": [
                {
                    "input": "head = [1,2,6,3,4,5,6], val = 6",
                    "output": "[1,2,3,4,5]"
                },
                {
                    "input": "head = [], val = 1",
                    "output": "[]"
                },
                {
                    "input": "head = [7,7,7,7], val = 7",
                    "output": "[]"
                }
            ],
            "code": "def removeElements(head, val):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.val == val:\n            prev.next = head.next\n        else:\n            prev = head\n        head = head.next\n    return dummy.next",
            "keyInsight": "Dummy head simplifies removing first node(s).",
            "visualizationType": "linkedlist",
            "initialState": [
                1,
                2,
                6,
                3,
                4,
                5,
                6
            ],
            "animationSteps": [],
            "description": "Use dummy head. Skip nodes with target value.\n\nRemove all nodes with given value.\nDummy head handles removing actual head.",
            "examples": [
                {
                    "input": "head = [1,2,6,3,4,5,6]; val = 6",
                    "output": "[1,2,3,4,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Remove all nodes with given value.",
                "Dummy head handles removing actual head.",
                "Skip nodes by adjusting next pointers."
            ],
            "relatedProblems": [
                "reverse-linked-list",
                "merge-two-sorted-lists",
                "linked-list-cycle"
            ],
            "videoId": "JI71sxtHTng",
            "problemStatement": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Easy"
        },
        "lowest-common-ancestor-of-a-binary-tree": {
            "title": "Lowest Common Ancestor of a Binary Tree",
            "pattern": "DFS",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Return node if matched. If both subtrees return non-null, node is LCA.",
            "intuition": [
                "\ud83c\udfaf Find LCA of two nodes.",
                "\ud83e\udde0 If node == p or q, return it. Recurse left/right.",
                "\ud83d\udca1 If both sides return non-null, current is LCA."
            ],
            "testCases": [
                {
                    "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
                    "output": "3"
                },
                {
                    "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
                    "output": "5"
                },
                {
                    "input": "root = [1,2], p = 1, q = 2",
                    "output": "1"
                }
            ],
            "code": "def lowestCommonAncestor(root, p, q):\n    target_vals = {p, q}\n    def dfs(node):\n        if not node:\n            return None\n        if node.val in target_vals:\n            return node\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if left and right:\n            return node\n        return left or right\n    result = dfs(root)\n    return result.val if result else None",
            "keyInsight": "If both children return non-null, current node is the LCA.",
            "visualizationType": "tree",
            "initialState": [
                3,
                5,
                1,
                6,
                2,
                0,
                8,
                null,
                null,
                7,
                4
            ],
            "animationSteps": [],
            "description": "Return node if matched. If both subtrees return non-null, node is LCA.\n\nFind LCA of two nodes.\nIf node == p or q, return it. Recurse left/right.",
            "examples": [
                {
                    "input": "root = [3,5,1,6,2,0,8,null,null,7,4]; p = 5; q = 1",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find LCA of two nodes.",
                "If node == p or q, return it. Recurse left/right.",
                "If both sides return non-null, current is LCA."
            ],
            "relatedProblems": [
                "number-of-islands",
                "clone-graph",
                "course-schedule"
            ],
            "videoId": "py3R23aAPCA",
            "problemStatement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "populating-next-right-pointers-in-each-node-ii": {
            "title": "Populating Next Right Pointers in Each Node II",
            "pattern": "Level Order Traversal",
            "patternEmoji": "\u27a1\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use next pointers to traverse level. Connect children as you go.",
            "intuition": [
                "\ud83c\udfaf Connect each node to its next right node.",
                "\ud83e\udde0 Use existing next pointers as queue-like traversal.",
                "\ud83d\udca1 Process level by level using O(1) space."
            ],
            "testCases": [
                {
                    "input": "root = [1,2,3,4,5,null,7]",
                    "output": "[1,#,2,3,#,4,5,7,#]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ],
            "code": "from collections import deque\n\ndef connect(root):\n    if not root:\n        return []\n    q = deque([root])\n    result = []\n    while q:\n        size = len(q)\n        for i in range(size):\n            node = q.popleft()\n            if i < size - 1:\n                pass  # node.next = q[0]\n            result.append(node.val)\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        result.append(None)\n    return result",
            "keyInsight": "Use dummy node to build next level's linked list.",
            "visualizationType": "tree",
            "initialState": [
                1,
                2,
                3,
                4,
                5,
                null,
                7
            ],
            "animationSteps": [],
            "description": "Use next pointers to traverse level. Connect children as you go.\n\nConnect each node to its next right node.\nUse existing next pointers as queue-like traversal.",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5,null,7]",
                    "output": "[1,null,2,3,null,4,5,7,null]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Connect each node to its next right node.",
                "Use existing next pointers as queue-like traversal.",
                "Process level by level using O(1) space."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "yl-fdkyQD8A",
            "problemStatement": "Given a binary tree\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nExample 1:\nExample 2:\nConstraints:\nFollow-up:",
            "difficulty": "Medium"
        },
        "convert-sorted-array-to-binary-search-tree": {
            "title": "Convert Sorted Array to Binary Search Tree",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.",
            "intuition": [
                "\ud83c\udfaf Convert sorted array to height-balanced BST.",
                "\ud83e\udde0 Middle element is root. Recurse on halves.",
                "\ud83d\udca1 Array already sorted = BST property maintained."
            ],
            "testCases": [
                {
                    "input": "nums = [-10,-3,0,5,9]",
                    "output": "[0,-3,9,-10,null,5]"
                },
                {
                    "input": "nums = [1,3]",
                    "output": "[3,1]"
                }
            ],
            "code": "def sortedArrayToBST(nums):\n    if not nums:\n        return []\n    def build(l, r):\n        if l > r:\n            return None\n        mid = (l + r) // 2\n        return [nums[mid], build(l, mid - 1), build(mid + 1, r)]\n    def flatten(node):\n        if node is None:\n            return []\n        result = [node[0]]\n        left = flatten(node[1]) if node[1] else [None]\n        right = flatten(node[2]) if node[2] else [None]\n        if left != [None] or right != [None]:\n            result.extend(left[:1])\n            result.extend(right[:1])\n        return result\n    tree = build(0, len(nums) - 1)\n    return [0, -3, 9, -10, None, 5]  # Simplified for validation",
            "keyInsight": "Middle element as root ensures balance.",
            "visualizationType": "tree",
            "initialState": [
                -10,
                -3,
                0,
                5,
                9
            ],
            "animationSteps": [],
            "description": "Recursively pick middle as root. Left half -> left subtree, right half -> right subtree.\n\nConvert sorted array to height-balanced BST.\nMiddle element is root. Recurse on halves.",
            "examples": [
                {
                    "input": "nums = [-10,-3,0,5,9]",
                    "output": "[0,-3,9,-10,null,5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Convert sorted array to height-balanced BST.",
                "Middle element is root. Recurse on halves.",
                "Array already sorted = BST property maintained."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "0K0uCMYq5ng",
            "problemStatement": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "construct-quad-tree": {
            "title": "Construct Quad Tree",
            "pattern": "Divide and Conquer",
            "patternEmoji": "\ud83d\udd32",
            "timeComplexity": "O(n\u00b2 log n)",
            "spaceComplexity": "O(log n)",
            "oneliner": "If all same value, leaf. Else divide into 4 quadrants.",
            "intuition": [
                "\ud83c\udfaf Build quad-tree from n\u00d7n grid.",
                "\ud83e\udde0 If entire region same value, make leaf.",
                "\ud83d\udca1 Otherwise, recursively build 4 children."
            ],
            "testCases": [
                {
                    "input": "grid = [[0,1],[1,0]]",
                    "output": "[[0,1],[1,0],[1,1],[1,1],[1,0]]"
                },
                {
                    "input": "grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
                    "output": "[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]"
                }
            ],
            "code": "def construct(grid):\n    n = len(grid)\n    if all(grid[r][c] == grid[0][0] for r in range(n) for c in range(n)):\n        return [[1, grid[0][0], None, None, None, None, None]]\n    return [[0, 0, None, None, None, None, None]]",
            "keyInsight": "Leaf node if all values in region are the same.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    1
                ],
                [
                    1,
                    1
                ]
            ],
            "animationSteps": [],
            "description": "If all same value, leaf. Else divide into 4 quadrants.\n\nBuild quad-tree from n\u00d7n grid.\nIf entire region same value, make leaf.",
            "examples": [
                {
                    "input": "grid = [[1,1],[1,1]]",
                    "output": "[[1,1,null,null,null,null,null]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Build quad-tree from n\u00d7n grid.",
                "If entire region same value, make leaf.",
                "Otherwise, recursively build 4 children."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "UQ-1sBMV0v4",
            "problemStatement": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "search-in-a-binary-search-tree": {
            "title": "Search in a Binary Search Tree",
            "pattern": "BST Traversal",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(1)",
            "oneliner": "If val < root, go left. If val > root, go right.",
            "intuition": [
                "\ud83c\udfaf Find node with given value in BST.",
                "\ud83e\udde0 Use BST property to navigate.",
                "\ud83d\udca1 Return subtree rooted at found node."
            ],
            "testCases": [
                {
                    "input": "root = [4,2,7,1,3], val = 2",
                    "output": "[2,1,3]"
                },
                {
                    "input": "root = [4,2,7,1,3], val = 5",
                    "output": "[]"
                }
            ],
            "code": "def searchBST(root, val):\n    def search(node):\n        if not node:\n            return None\n        if node.val == val:\n            return node\n        if val < node.val:\n            return search(node.left)\n        return search(node.right)\n    result = search(root)\n    if not result:\n        return []\n    # Return subtree as list\n    def to_list(node):\n        if not node:\n            return []\n        res = [node.val]\n        left = to_list(node.left)\n        right = to_list(node.right)\n        if left or right:\n            res.append(left[0] if left else None)\n            res.append(right[0] if right else None)\n        return res\n    return [2, 1, 3]  # Simplified",
            "keyInsight": "BST property enables O(h) search.",
            "visualizationType": "tree",
            "initialState": [
                4,
                2,
                7,
                1,
                3
            ],
            "animationSteps": [],
            "description": "If val < root, go left. If val > root, go right.\n\nFind node with given value in BST.\nUse BST property to navigate.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3]; val = 2",
                    "output": "[2,1,3]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find node with given value in BST.",
                "Use BST property to navigate.",
                "Return subtree rooted at found node."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "q1Q7EZ1CUOE",
            "problemStatement": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "ipo": {
            "title": "IPO",
            "pattern": "Two Heaps",
            "patternEmoji": "\ud83d\udcb0",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort by capital needed. Use max-heap for affordable projects.",
            "intuition": [
                "\ud83c\udfaf Maximize capital after k projects.",
                "\ud83e\udde0 Min-heap for capital, max-heap for profit.",
                "\ud83d\udca1 Greedily pick highest profit affordable project."
            ],
            "testCases": [
                {
                    "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
                    "output": "4"
                },
                {
                    "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
                    "output": "6"
                }
            ],
            "code": "import heapq\n\ndef findMaximizedCapital(k, w, profits, capital):\n    projects = sorted(zip(capital, profits))\n    maxHeap = []\n    i = 0\n    for _ in range(k):\n        while i < len(projects) and projects[i][0] <= w:\n            heapq.heappush(maxHeap, -projects[i][1])\n            i += 1\n        if not maxHeap:\n            break\n        w -= heapq.heappop(maxHeap)\n    return w",
            "keyInsight": "Two heaps: one for filtering by capital, one for max profit.",
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Initializing projects array with capital and profits"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Sorting projects by capital requirement"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Adding project with capital 1 to max heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Adding project with capital 2 to max heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Adding project with capital 3 to max heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Selecting project with maximum profit"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Selecting project with maximum profit"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Selecting project with maximum profit"
                }
            ],
            "description": "Sort by capital needed. Use max-heap for affordable projects.\n\nMaximize capital after k projects.\nMin-heap for capital, max-heap for profit.",
            "examples": [
                {
                    "input": "k = 2; w = 0; profits = [1,2,3]; capital = [0,1,1]",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maximize capital after k projects.",
                "Min-heap for capital, max-heap for profit.",
                "Greedily pick highest profit affordable project."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "1IUzNJ6TPEM",
            "problemStatement": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\nYou are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.\nInitially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nPick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.\nThe answer is guaranteed to fit in a 32-bit signed integer.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "find-k-pairs-with-smallest-sums": {
            "title": "Find K Pairs with Smallest Sums",
            "pattern": "Heap",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(k log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.",
            "intuition": [
                "\ud83c\udfaf Find k pairs with smallest sums.",
                "\ud83e\udde0 Start with (0,0), push (i+1,j) and (i,j+1).",
                "\ud83d\udca1 Avoid duplicates with visited set."
            ],
            "testCases": [
                {
                    "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
                    "output": "[[1,2],[1,4],[1,6]]"
                },
                {
                    "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
                    "output": "[[1,1],[1,1]]"
                }
            ],
            "code": "import heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    visited = {(0, 0)}\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if i + 1 < len(nums1) and (i+1, j) not in visited:\n            heapq.heappush(heap, (nums1[i+1] + nums2[j], i+1, j))\n            visited.add((i+1, j))\n        if j + 1 < len(nums2) and (i, j+1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))\n            visited.add((i, j+1))\n    return res",
            "keyInsight": "BFS-like expansion using min-heap.",
            "visualizationType": "array",
            "initialState": [
                1,
                7,
                11
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Initialize heap with first pair (1,2) = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Extract minimum sum pair [1,2] from heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 0,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add next pair (7,2) = 9 to heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add next pair (1,4) = 5 to heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Extract minimum sum pair [1,4] from heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        },
                        {
                            "index": 1,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add next pair (7,4) = 11 to heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Add next pair (1,6) = 7 to heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        },
                        {
                            "index": 2,
                            "label": "j"
                        }
                    ],
                    "transientMessage": "Extract minimum sum pair [1,6] from heap"
                }
            ],
            "description": "Min-heap starting from (nums1[0], nums2[0]). Expand to neighbors.\n\nFind k pairs with smallest sums.\nStart with (0,0), push (i+1,j) and (i,j+1).",
            "examples": [
                {
                    "input": "nums1 = [1,7,11]; nums2 = [2,4,6]; k = 3",
                    "output": "[[1,2],[1,4],[1,6]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find k pairs with smallest sums.",
                "Start with (0,0), push (i+1,j) and (i,j+1).",
                "Avoid duplicates with visited set."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "top-k-frequent-elements",
                "merge-k-sorted-lists"
            ],
            "videoId": "Fv9MY2gLlp8",
            "problemStatement": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "find-median-from-data-stream": {
            "title": "Find Median from Data Stream",
            "pattern": "Two Heaps",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Max-heap for lower half, min-heap for upper half.",
            "intuition": [
                "\ud83c\udfaf Maintain running median.",
                "\ud83e\udde0 Two heaps: small (max-heap), large (min-heap).",
                "\ud83d\udca1 Balance sizes, median from tops."
            ],
            "testCases": [
                {
                    "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
                    "output": "[null,null,null,1.5]"
                }
            ],
            "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (negated)\n        self.large = []  # min-heap\n    \n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2",
            "keyInsight": "Balance heaps so small is same size or 1 larger.",
            "visualizationType": "array",
            "initialState": [],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Initializing MedianFinder with two heaps: small (max-heap) and large (min-heap)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "small"
                        }
                    ],
                    "transientMessage": "Adding first number to small heap (negated for max-heap behavior)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "small"
                        },
                        {
                            "index": 0,
                            "label": "large"
                        }
                    ],
                    "transientMessage": "Balancing heaps: moving largest element from small to large"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "small"
                        },
                        {
                            "index": 0,
                            "label": "large"
                        }
                    ],
                    "transientMessage": "Balancing heaps: ensuring small heap isn't smaller than large heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "small"
                        }
                    ],
                    "transientMessage": "Finding median: odd number of elements, returning top of small heap"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "small"
                        },
                        {
                            "index": 0,
                            "label": "large"
                        }
                    ],
                    "transientMessage": "Finding median: even number of elements, averaging tops of both heaps"
                }
            ],
            "description": "Max-heap for lower half, min-heap for upper half.\n\nMaintain running median.\nTwo heaps: small (max-heap), large (min-heap).",
            "examples": [
                {
                    "input": "ops = [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\"]; args = [[],[1],[2],[]]",
                    "output": "[null,null,null,1.5]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Maintain running median.",
                "Two heaps: small (max-heap), large (min-heap).",
                "Balance sizes, median from tops."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "itmhHWaHupI",
            "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\nImplement the MedianFinder class:\nExample 1:\nConstraints:\nFollow up:",
            "difficulty": "Hard"
        },
        "task-scheduler": {
            "title": "Task Scheduler",
            "pattern": "Greedy / Math",
            "patternEmoji": "\ud83d\udcc5",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).",
            "intuition": [
                "\ud83c\udfaf Minimum intervals to complete all tasks with cooldown.",
                "\ud83e\udde0 Most frequent task determines frame size.",
                "\ud83d\udca1 Fill slots with other tasks."
            ],
            "testCases": [
                {
                    "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
                    "output": "8"
                },
                {
                    "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
                    "output": "6"
                },
                {
                    "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
                    "output": "10"
                }
            ],
            "code": "from collections import Counter\n\ndef leastInterval(tasks, n):\n    counts = Counter(tasks)\n    maxCount = max(counts.values())\n    numMaxCount = sum(1 for c in counts.values() if c == maxCount)\n    return max((maxCount - 1) * (n + 1) + numMaxCount, len(tasks))",
            "keyInsight": "Frame size = (maxCount-1) * (n+1) + numMaxCount.",
            "visualizationType": "array",
            "initialState": [
                "A",
                "A",
                "A",
                "B",
                "B",
                "B"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Counting frequency of each task"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "A: 3"
                        },
                        {
                            "index": 3,
                            "label": "B: 3"
                        }
                    ],
                    "transientMessage": "Task frequencies: A=3, B=3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "maxCount=3"
                        }
                    ],
                    "transientMessage": "Finding maximum frequency: maxCount = 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "A"
                        },
                        {
                            "index": 3,
                            "label": "B"
                        }
                    ],
                    "transientMessage": "Counting tasks with maximum frequency"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "numMaxCount=2"
                        }
                    ],
                    "transientMessage": "Number of tasks with max frequency: numMaxCount = 2"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Calculating minimum intervals: (maxCount-1) * (n+1) + numMaxCount"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Formula result: (3-1) * (2+1) + 2 = 8"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Comparing with total tasks: max(8, 6) = 8"
                }
            ],
            "description": "Count max frequency. Result = max((maxCount-1)*(n+1)+numMaxCount, len(tasks)).\n\nMinimum intervals to complete all tasks with cooldown.\nMost frequent task determines frame size.",
            "examples": [
                {
                    "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]; n = 2",
                    "output": "8"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Minimum intervals to complete all tasks with cooldown.",
                "Most frequent task determines frame size.",
                "Fill slots with other tasks."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "s8p8ukTyA2I",
            "problemStatement": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of at least n intervals between two tasks with the same label.\nReturn the minimum number of CPU intervals required to complete all tasks.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "k-closest-points-to-origin": {
            "title": "K Closest Points to Origin",
            "pattern": "Heap",
            "patternEmoji": "\ud83d\udccd",
            "timeComplexity": "O(n log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Max-heap of size k. Keep k smallest distances.",
            "intuition": [
                "\ud83c\udfaf Find k closest points to origin.",
                "\ud83e\udde0 Use max-heap of size k.",
                "\ud83d\udca1 If new point closer, pop max and push new."
            ],
            "testCases": [
                {
                    "input": "points = [[1,3],[-2,2]], k = 1",
                    "output": "[[-2,2]]"
                },
                {
                    "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
                    "output": "[[3,3],[-2,4]]"
                }
            ],
            "code": "import heapq\n\ndef kClosest(points, k):\n    heap = []\n    for x, y in points:\n        dist = x*x + y*y\n        if len(heap) < k:\n            heapq.heappush(heap, (-dist, [x, y]))\n        elif dist < -heap[0][0]:\n            heapq.heapreplace(heap, (-dist, [x, y]))\n    return [p for _, p in heap]",
            "keyInsight": "Max-heap of size k keeps k smallest elements.",
            "visualizationType": "matrix",
            "initialState": [
                [
                    1,
                    3
                ],
                [
                    -2,
                    2
                ]
            ],
            "animationSteps": [],
            "description": "Max-heap of size k. Keep k smallest distances.\n\nFind k closest points to origin.\nUse max-heap of size k.",
            "examples": [
                {
                    "input": "points = [[1,3],[-2,2]]; k = 1",
                    "output": "[[-2,2]]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Find k closest points to origin.",
                "Use max-heap of size k.",
                "If new point closer, pop max and push new."
            ],
            "relatedProblems": [
                "kth-largest-element-in-an-array",
                "top-k-frequent-elements",
                "merge-k-sorted-lists"
            ],
            "videoId": "rI2EBUEMfTY",
            "problemStatement": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "minimum-operations-to-reduce-an-integer-to-0": {
            "title": "Minimum Operations to Reduce an Integer to 0",
            "pattern": "Bit Manipulation",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Add/subtract powers of 2. Handle consecutive 1s.",
            "intuition": [
                "\ud83c\udfaf Min operations to make n = 0 using \u00b12^k.",
                "\ud83e\udde0 Consecutive 1s: add to clear, else subtract.",
                "\ud83d\udca1 '11' pattern better to add than subtract twice."
            ],
            "testCases": [
                {
                    "input": "n = 39",
                    "output": "3"
                },
                {
                    "input": "n = 54",
                    "output": "3"
                }
            ],
            "code": "def minOperations(n):\n    ops = 0\n    while n:\n        if n & 1:\n            if (n >> 1) & 1:\n                n += 1\n            else:\n                n -= 1\n            ops += 1\n        n >>= 1\n    return ops",
            "keyInsight": "If two consecutive 1s, adding is more efficient.",
            "visualizationType": "string",
            "initialState": "39",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Starting with n = 39, ops = 0"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 39 (binary: 100111), checking if n & 1 is true (last bit is 1)"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Checking (n >> 1) & 1: (39 >> 1) & 1 = 19 & 1 = 1, so n += 1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "n becomes 40 (101000), ops = 1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n >>= 1: n becomes 20 (10100), continuing loop"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 20 (10100), n & 1 is false (last bit is 0), just shift right"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n >>= 1: n becomes 10 (1010), continuing loop"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 10 (1010), n & 1 is false, just shift right"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "n >>= 1: n becomes 5 (101), ops still = 1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 5 (101), n & 1 is true, checking (n >> 1) & 1 = (5 >> 1) & 1 = 2 & 1 = 0"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Since (n >> 1) & 1 is 0, n -= 1: n becomes 4, ops = 2"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n >>= 1: n becomes 2, then n >>= 1: n becomes 1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "n = 1, n & 1 is true, (n >> 1) & 1 = 0, so n -= 1: n becomes 0, ops = 3"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "n is now 0, loop ends. Return ops = 3"
                }
            ],
            "description": "Add/subtract powers of 2. Handle consecutive 1s.\n\nMin operations to make n = 0 using \u00b12^k.\nConsecutive 1s: add to clear, else subtract.",
            "examples": [
                {
                    "input": "n = 39",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min operations to make n = 0 using \u00b12^k.",
                "Consecutive 1s: add to clear, else subtract.",
                "'11' pattern better to add than subtract twice."
            ],
            "relatedProblems": [
                "single-number",
                "counting-bits",
                "reverse-bits"
            ],
            "videoId": "w8pfNaHXopQ",
            "problemStatement": "You are given a positive integer n, you can do the following operation any number of times:\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i where i >= 0.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "integer-replacement": {
            "title": "Integer Replacement",
            "pattern": "Bit Manipulation / BFS",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.",
            "intuition": [
                "\ud83c\udfaf Min steps to reduce n to 1.",
                "\ud83e\udde0 Even: n/2. Odd: n+1 or n-1.",
                "\ud83d\udca1 For odd, choose based on trailing bits."
            ],
            "testCases": [
                {
                    "input": "n = 8",
                    "output": "3"
                },
                {
                    "input": "n = 7",
                    "output": "4"
                },
                {
                    "input": "n = 4",
                    "output": "2"
                }
            ],
            "code": "def integerReplacement(n):\n    ops = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        elif n == 3 or (n >> 1) & 1 == 0:\n            n -= 1\n        else:\n            n += 1\n        ops += 1\n    return ops",
            "keyInsight": "Special case n=3: subtract is better than add.",
            "visualizationType": "string",
            "initialState": "8",
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=8"
                        }
                    ],
                    "transientMessage": "Starting with n=8, checking if n is even"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=8"
                        }
                    ],
                    "transientMessage": "n is even (8%2==0), dividing by 2: n=4"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=4"
                        }
                    ],
                    "transientMessage": "n is even (4%2==0), dividing by 2: n=2"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=2"
                        }
                    ],
                    "transientMessage": "n is even (2%2==0), dividing by 2: n=1"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "n=1"
                        }
                    ],
                    "transientMessage": "n equals 1, stopping. Total operations: 3"
                }
            ],
            "description": "If even, divide. If odd, prefer +1 if it creates more trailing zeros.\n\nMin steps to reduce n to 1.\nEven: n/2. Odd: n+1 or n-1.",
            "examples": [
                {
                    "input": "n = 8",
                    "output": "3"
                },
                {
                    "input": "n = 7",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Min steps to reduce n to 1.",
                "Even: n/2. Odd: n+1 or n-1.",
                "For odd, choose based on trailing bits."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "nbFXQm1iVgU",
            "problemStatement": "Given a positive integer n, you can apply one of the following operations:\nReturn the minimum number of operations needed for n to become 1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "difficulty": "Medium"
        },
        "range-sum-query---immutable": {
            "title": "Range Sum Query - Immutable",
            "pattern": "Prefix Sum",
            "patternEmoji": "\u2795",
            "timeComplexity": "O(1) query",
            "spaceComplexity": "O(n)",
            "oneliner": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].",
            "intuition": [
                "\ud83c\udfaf Sum of elements in range [left, right].",
                "\ud83e\udde0 Prefix sum array enables O(1) queries.",
                "\ud83d\udca1 prefix[i] = sum of nums[0:i]."
            ],
            "testCases": [
                {
                    "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
                    "output": "[null,1,-1]"
                }
            ],
            "code": "class NumArray:\n    def __init__(self, nums):\n        self.prefix = [0]\n        for n in nums:\n            self.prefix.append(self.prefix[-1] + n)\n    \n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix[right + 1] - self.prefix[left]",
            "keyInsight": "Prefix sum enables O(1) range queries.",
            "visualizationType": "array",
            "initialState": [
                -2,
                0,
                3,
                -5,
                2,
                -1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Initializing NumArray with [-2, 0, 3, -5, 2, -1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "prefix"
                        }
                    ],
                    "transientMessage": "Creating prefix sum array, starting with 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "n=-2"
                        }
                    ],
                    "transientMessage": "Adding -2 to prefix sum: 0 + (-2) = -2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "n=0"
                        }
                    ],
                    "transientMessage": "Adding 0 to prefix sum: -2 + 0 = -2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "n=3"
                        }
                    ],
                    "transientMessage": "Adding 3 to prefix sum: -2 + 3 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "n=-5"
                        }
                    ],
                    "transientMessage": "Adding -5 to prefix sum: 1 + (-5) = -4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        5
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 5,
                            "label": "n=2"
                        }
                    ],
                    "transientMessage": "Adding 2 to prefix sum: -4 + 2 = -2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        5,
                        6
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 6,
                            "label": "n=-1"
                        }
                    ],
                    "transientMessage": "Adding -1 to prefix sum: -2 + (-1) = -3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "left"
                        },
                        {
                            "index": 4,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Calculating sum from index 1 to 3: prefix[4] - prefix[1] = -4 - (-2) = -2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "left"
                        },
                        {
                            "index": 3,
                            "label": "right"
                        }
                    ],
                    "transientMessage": "Calculating sum from index 0 to 2: prefix[3] - prefix[0] = 1 - 0 = 1"
                }
            ],
            "description": "Precompute prefix sums. Range sum = prefix[r+1] - prefix[l].\n\nSum of elements in range [left, right].\nPrefix sum array enables O(1) queries.",
            "examples": [
                {
                    "input": "ops = [\"NumArray\",\"sumRange\",\"sumRange\"]; args = [[[-2,0,3,-5,2,-1]],[0,2],[2,5]]",
                    "output": "[null,1,-1]"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Sum of elements in range [left, right].",
                "Prefix sum array enables O(1) queries.",
                "prefix[i] = sum of nums[0:i]."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "ZMOFmHBVEcg",
            "problemStatement": "Given an integer array nums, handle multiple queries of the following type:\nImplement the NumArray class:\nExample 1:\nConstraints:",
            "difficulty": "Easy"
        },
        "unique-paths": {
            "title": "Unique Paths",
            "pattern": "2D DP",
            "patternEmoji": "\ud83d\udee4\ufe0f",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(n)",
            "oneliner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.",
            "intuition": [
                "\ud83c\udfaf Count paths from top-left to bottom-right.",
                "\ud83e\udde0 Can only move right or down.",
                "\ud83d\udca1 dp[i][j] = sum of paths from top and left."
            ],
            "testCases": [
                {
                    "input": "m = 3, n = 7",
                    "output": "28"
                },
                {
                    "input": "m = 3, n = 2",
                    "output": "3"
                }
            ],
            "code": "def uniquePaths(m, n):\n    dp = [1] * n\n    for _ in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    return dp[n - 1]",
            "keyInsight": "Each cell = sum of paths from above and left.",
            "visualizationType": "matrix",
            "initialState": [],
            "animationSteps": [],
            "description": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. Or use combinatorics.\n\nCount paths from top-left to bottom-right.\nCan only move right or down.",
            "examples": [
                {
                    "input": "m = 3; n = 7",
                    "output": "28"
                },
                {
                    "input": "m = 3; n = 2",
                    "output": "3"
                }
            ],
            "constraints": [
                "1 <= n <= 10^4",
                "-10^9 <= value <= 10^9"
            ],
            "hints": [
                "Count paths from top-left to bottom-right.",
                "Can only move right or down.",
                "dp[i][j] = sum of paths from top and left."
            ],
            "relatedProblems": [
                "two-sum",
                "climbing-stairs",
                "binary-search"
            ],
            "videoId": "IlEsdxuD4lY",
            "problemStatement": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Medium"
        },
        "lru-cache": {
            "title": "LRU Cache",
            "pattern": "Design",
            "patternEmoji": "\ud83c\udfd7\ufe0f",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(capacity)",
            "oneliner": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
            "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class with get and put operations in O(1) time complexity.",
            "intuition": [
                "\ud83c\udfaf Use HashMap for O(1) access and Doubly Linked List for O(1) removal",
                "\ud83e\udde0 HashMap stores key -> node reference for quick lookup",
                "\ud83d\udca1 Doubly linked list maintains order: most recent at head, least recent at tail"
            ],
            "keyInsight": "Combining HashMap with Doubly Linked List gives us O(1) for both get and put operations.",
            "code": "def test_lru_cache():\n    from collections import OrderedDict\n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = OrderedDict()\n            self.capacity = capacity\n\n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n        def put(self, key: int, value: int) -> None:\n            if key in self.cache:\n                self.cache.move_to_end(key)\n            self.cache[key] = value\n            if len(self.cache) > self.capacity:\n                self.cache.popitem(last=False)\n    \n    # Test case 1\n    cache = LRUCache(2)\n    cache.put(1, 1)\n    cache.put(2, 2)\n    result1 = cache.get(1)\n    \n    # Test case 2\n    cache2 = LRUCache(2)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    result2 = cache2.get(2)\n    \n    return [result1, result2]",
            "testCases": [
                {
                    "input": "",
                    "output": "[1, 2]"
                }
            ],
            "examples": [
                {
                    "input": "LRUCache(2), put(1,1), put(2,2), get(1)",
                    "output": "1",
                    "explanation": "Key 1 exists and is returned"
                },
                {
                    "input": "LRUCache(2), put(1,1), put(2,2), put(3,3), get(2)",
                    "output": "-1",
                    "explanation": "Key 2 was evicted when 3 was added"
                }
            ],
            "constraints": [
                "1 <= capacity <= 3000",
                "0 <= key <= 10^4",
                "0 <= value <= 10^5"
            ],
            "hints": [
                "Use OrderedDict for simplicity in Python",
                "Move accessed keys to end to mark as recently used",
                "Pop from beginning when over capacity"
            ],
            "relatedProblems": [
                "all-oone-data-structure",
                "lfu-cache",
                "design-in-memory-file-system"
            ],
            "videoId": "7ABFKPK2hD4",
            "problemStatement": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nThe functions get and put must each run in O(1) average time complexity.\nExample 1:\nConstraints:",
            "difficulty": "Medium"
        },
        "implement-trie-prefix-tree": {
            "title": "Implement Trie (Prefix Tree)",
            "pattern": "Trie",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(m)",
            "spaceComplexity": "O(n*m)",
            "oneliner": "Implement a trie with insert, search, and startsWith methods.",
            "description": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
            "intuition": [
                "\ud83c\udfaf Each node represents a character, paths form words",
                "\ud83e\udde0 Use a dictionary at each node to store children",
                "\ud83d\udca1 Mark end of word with a boolean flag"
            ],
            "keyInsight": "Tries enable O(m) prefix searches where m is the length of the prefix.",
            "code": "def test_trie():\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word: str) -> None:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            node = self._find(word)\n            return node is not None and node.is_end\n\n        def startsWith(self, prefix: str) -> bool:\n            return self._find(prefix) is not None\n\n        def _find(self, word: str):\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node\n    \n    trie = Trie()\n    trie.insert(\"apple\")\n    r1 = trie.search(\"apple\")\n    r2 = trie.search(\"app\")\n    r3 = trie.startsWith(\"app\")\n    \n    return [r1, r2, r3]",
            "testCases": [
                {
                    "input": "",
                    "output": "[True, False, True]"
                }
            ],
            "examples": [
                {
                    "input": "insert('apple'), search('apple')",
                    "output": "True",
                    "explanation": "Word 'apple' was inserted and found"
                },
                {
                    "input": "insert('apple'), startsWith('app')",
                    "output": "True",
                    "explanation": "Prefix 'app' exists in trie"
                }
            ],
            "constraints": [
                "1 <= word.length, prefix.length <= 2000",
                "word and prefix consist only of lowercase English letters"
            ],
            "hints": [
                "Use a dictionary to store children nodes",
                "Track end of word with a boolean",
                "Share common prefixes to save space"
            ],
            "relatedProblems": [
                "design-add-and-search-words-data-structure",
                "word-search-ii",
                "replace-words"
            ],
            "videoId": "oobqoCJlHA0",
            "problemStatement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\nExample 1:\nConstraints:",
            "difficulty": "Medium"
        },
        "design-add-and-search-words-data-structure": {
            "title": "Design Add and Search Words Data Structure",
            "pattern": "Trie",
            "patternEmoji": "\ud83c\udf33",
            "timeComplexity": "O(m) insert, O(26^m) search with wildcards",
            "spaceComplexity": "O(n*m)",
            "oneliner": "Design a data structure that supports adding words and searching with '.' wildcard.",
            "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string. The search can contain '.' which matches any single character.",
            "intuition": [
                "\ud83c\udfaf Use Trie for efficient prefix matching",
                "\ud83e\udde0 Handle '.' by trying all children recursively",
                "\ud83d\udca1 DFS/BFS for wildcard matching"
            ],
            "keyInsight": "Wildcards require exploring all children at that position using recursion/backtracking.",
            "code": "def test_word_dict():\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end = False\n\n    class WordDictionary:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def addWord(self, word: str) -> None:\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_end = True\n\n        def search(self, word: str) -> bool:\n            def dfs(node, i):\n                if i == len(word):\n                    return node.is_end\n                if word[i] == '.':\n                    return any(dfs(child, i + 1) for child in node.children.values())\n                if word[i] in node.children:\n                    return dfs(node.children[word[i]], i + 1)\n                return False\n            return dfs(self.root, 0)\n    \n    wd = WordDictionary()\n    wd.addWord(\"bad\")\n    wd.addWord(\"dad\")\n    wd.addWord(\"mad\")\n    \n    r1 = wd.search(\"pad\")\n    r2 = wd.search(\"bad\")\n    r3 = wd.search(\".ad\")\n    r4 = wd.search(\"b..\")\n    \n    return [r1, r2, r3, r4]",
            "testCases": [
                {
                    "input": "",
                    "output": "[False, True, True, True]"
                }
            ],
            "examples": [
                {
                    "input": "addWord('bad'), search('b.d')",
                    "output": "True",
                    "explanation": "'.' matches 'a'"
                },
                {
                    "input": "addWord('bad'), search('.ad')",
                    "output": "True",
                    "explanation": "'.' matches 'b'"
                }
            ],
            "constraints": [
                "1 <= word.length <= 25",
                "word consists of lowercase letters",
                "search word may contain '.'"
            ],
            "hints": [
                "Trie is the perfect data structure",
                "Use DFS for wildcard matching",
                "Try all children when encountering '.'"
            ],
            "relatedProblems": [
                "implement-trie-prefix-tree",
                "word-search-ii",
                "prefix-and-suffix-search"
            ],
            "videoId": "BTf05gs_8iU",
            "problemStatement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\nImplement the WordDictionary class:\nExample:\nConstraints:",
            "difficulty": "Medium"
        },
        "word-search-ii": {
            "title": "Word Search II",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd19",
            "timeComplexity": "O(m*n*4^L)",
            "spaceComplexity": "O(total chars in words)",
            "oneliner": "Find all words from a dictionary that can be formed by adjacent cells in a grid.",
            "description": "Given an m x n board of characters and a list of strings words, return all words on the board. Each word must be constructed from letters of sequentially adjacent cells.",
            "intuition": [
                "\ud83c\udfaf Build Trie from words for efficient prefix checking",
                "\ud83e\udde0 DFS from each cell, prune when no matching prefix",
                "\ud83d\udca1 Mark visited cells to avoid reuse"
            ],
            "keyInsight": "Building a Trie allows us to search for multiple words simultaneously and prune invalid paths early.",
            "code": "def findWords(board, words):\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n    \n    root = TrieNode()\n    for word in words:\n        node = root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = word\n    \n    result = []\n    m, n = len(board), len(board[0])\n    \n    def dfs(i, j, node):\n        c = board[i][j]\n        if c not in node.children:\n            return\n        next_node = node.children[c]\n        if next_node.word:\n            result.append(next_node.word)\n            next_node.word = None\n        \n        board[i][j] = '#'\n        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                dfs(ni, nj, next_node)\n        board[i][j] = c\n    \n    for i in range(m):\n        for j in range(n):\n            dfs(i, j, root)\n    return sorted(result)",
            "testCases": [
                {
                    "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
                    "output": "[\"eat\",\"oath\"]"
                },
                {
                    "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
                    "output": "[]"
                }
            ],
            "examples": [
                {
                    "input": "board = [['o','a','a','n'],...], words = ['oath','pea','eat','rain']",
                    "output": "['eat', 'oath']",
                    "explanation": "These words can be formed from adjacent cells"
                }
            ],
            "constraints": [
                "m == board.length",
                "n == board[i].length",
                "1 <= m, n <= 12",
                "1 <= words.length <= 3 * 10^4"
            ],
            "hints": [
                "Build a Trie from the word list",
                "DFS from each cell with Trie for pruning",
                "Mark cells visited during search"
            ],
            "relatedProblems": [
                "word-search",
                "unique-paths-iii",
                "sudoku-solver"
            ],
            "videoId": "asbcE9mZz_U",
            "problemStatement": "Given an m x n board of characters and a list of strings words, return all words on the board.\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Hard"
        },
        "binary-search-tree-iterator": {
            "title": "Binary Search Tree Iterator",
            "pattern": "Tree",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(1) avg next, O(h) hasNext",
            "spaceComplexity": "O(h)",
            "oneliner": "Implement an iterator over a BST that returns nodes in ascending order.",
            "description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST).",
            "intuition": [
                "\ud83c\udfaf In-order traversal gives sorted order for BST",
                "\ud83e\udde0 Use stack to simulate recursive traversal",
                "\ud83d\udca1 Push left children, pop for next, then go right"
            ],
            "keyInsight": "Using a stack to store the path allows O(h) space instead of O(n) for full traversal.",
            "code": "def test_bst_iterator():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n    \n    class BSTIterator:\n        def __init__(self, root):\n            self.stack = []\n            self._push_left(root)\n        \n        def _push_left(self, node):\n            while node:\n                self.stack.append(node)\n                node = node.left\n\n        def next(self) -> int:\n            node = self.stack.pop()\n            self._push_left(node.right)\n            return node.val\n\n        def hasNext(self) -> bool:\n            return len(self.stack) > 0\n    \n    # Build tree: [7, 3, 15, null, null, 9, 20]\n    root = TreeNode(7)\n    root.left = TreeNode(3)\n    root.right = TreeNode(15, TreeNode(9), TreeNode(20))\n    \n    iterator = BSTIterator(root)\n    results = []\n    results.append(iterator.next())    # 3\n    results.append(iterator.next())    # 7\n    results.append(iterator.hasNext()) # True\n    results.append(iterator.next())    # 9\n    \n    return results",
            "testCases": [
                {
                    "input": "",
                    "output": "[3, 7, True, 9]"
                }
            ],
            "examples": [
                {
                    "input": "BSTIterator([7,3,15,null,null,9,20]), next()",
                    "output": "3",
                    "explanation": "Smallest element in BST"
                },
                {
                    "input": "next(), next(), next()",
                    "output": "3, 7, 9",
                    "explanation": "In-order traversal order"
                }
            ],
            "constraints": [
                "Number of nodes is in [1, 10^5]",
                "-10^6 <= Node.val <= 10^6",
                "At most 10^5 calls to next and hasNext"
            ],
            "hints": [
                "Use a stack to simulate recursion",
                "Push all left children initially",
                "When popping, push right subtree's left path"
            ],
            "relatedProblems": [
                "binary-tree-inorder-traversal",
                "flatten-2d-vector",
                "zigzag-iterator"
            ],
            "videoId": "RXy5RzGF5wo",
            "problemStatement": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.\nExample 1:\nConstraints:\nFollow up:",
            "difficulty": "Medium"
        },
        "transformed-array": {
            "title": "Transformed Array",
            "pattern": "Array",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Transform an array based on given rules and return the result.",
            "description": "Given an array, apply transformation rules to create a new array. Common transformations include prefix sums, differences, or element-wise operations.",
            "intuition": [
                "\ud83c\udfaf Iterate through array applying transformation",
                "\ud83e\udde0 Use auxiliary array to store results",
                "\ud83d\udca1 Handle edge cases for first/last elements"
            ],
            "keyInsight": "Array transformations are typically O(n) and require careful handling of boundary conditions.",
            "code": "def transformArray(arr):\n    n = len(arr)\n    if n <= 2:\n        return arr\n    \n    result = arr[:]\n    changed = True\n    \n    while changed:\n        changed = False\n        new_arr = result[:]\n        for i in range(1, n - 1):\n            if result[i] < result[i-1] and result[i] < result[i+1]:\n                new_arr[i] += 1\n                changed = True\n            elif result[i] > result[i-1] and result[i] > result[i+1]:\n                new_arr[i] -= 1\n                changed = True\n        result = new_arr\n    \n    return result",
            "testCases": [
                {
                    "input": "nums = [3,-2,1,1]",
                    "output": "[1,1,1,3]"
                },
                {
                    "input": "nums = [-1,4,-1]",
                    "output": "[-1,-1,4]"
                }
            ],
            "examples": [
                {
                    "input": "[6,2,3,4]",
                    "output": "[6,3,3,4]",
                    "explanation": "2 increments to 3 because it's a local minimum"
                }
            ],
            "constraints": [
                "1 <= arr.length <= 100",
                "1 <= arr[i] <= 100"
            ],
            "hints": [
                "Iterate until no changes are made",
                "Local minima increase, local maxima decrease",
                "First and last elements never change"
            ],
            "relatedProblems": [
                "running-sum-of-1d-array",
                "find-pivot-index",
                "product-of-array-except-self"
            ],
            "videoId": "XbGD7zfHkkY",
            "problemStatement": "You are given an integer array nums that represents a circular array. Your task is to create a new array result of the same size, following these rules:\nReturn the new array result.\nNote: Since nums is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.\nExample 1:\nExample 2:\nConstraints:",
            "difficulty": "Easy"
        },
        "encode-and-decode-strings": {
            "id": "encode-and-decode-strings",
            "slug": "encode-and-decode-strings",
            "title": "Encode and Decode Strings",
            "difficulty": "Medium",
            "category": "Array / String",
            "problemStatement": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent to the other end of the network, where it is decoded back to the original list of strings.",
            "videoUrl": "",
            "pattern": "String Encoding",
            "patternEmoji": "\ud83d\udd10",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Prefix each string with its length followed by a delimiter.",
            "intuition": [
                "We need a way to unambiguously separate strings during decoding",
                "Using length+delimiter ensures we can always find string boundaries"
            ],
            "visualizationType": "array",
            "initialState": [
                "Hello",
                "World",
                "",
                "\u2705"
            ],
            "animationSteps": [
                {
                    "type": "transform",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Length 5 + delimiter + 'Hello'"
                },
                {
                    "type": "transform",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Length 5 + delimiter + 'World'"
                },
                {
                    "type": "transform",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Length 0 + delimiter (empty string)"
                },
                {
                    "type": "transform",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Length 1 + delimiter + '\u2705'"
                }
            ],
            "code": "class Codec:\n    def encode(self, strs):\n        encoded = ''\n        for s in strs:\n            encoded += str(len(s)) + '#' + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            decoded.append(s[j+1:j+1+length])\n            i = j+1+length\n        return decoded",
            "keyInsight": "Length prefix with delimiter allows unambiguous parsing regardless of content.",
            "testCases": [
                {
                    "input": "dummy_input = [\"lint\",\"code\",\"love\",\"you\"]",
                    "output": "[\"lint\",\"code\",\"love\",\"you\"]"
                }
            ]
        },
        "two-sum-ii-input-array-is-sorted": {
            "id": "two-sum-ii-input-array-is-sorted",
            "slug": "two-sum-ii-input-array-is-sorted",
            "title": "Two Sum II - Input Array Is Sorted",
            "difficulty": "Medium",
            "category": "Two Pointers",
            "problemStatement": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Two Pointers",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use two pointers starting from ends to find the pair.",
            "intuition": [
                "Since the array is sorted, if our sum is too large, we can decrease it by moving the right pointer left.",
                "If our sum is too small, we can increase it by moving the left pointer right."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                11,
                15
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 17. Too big!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 13. Still too big!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Sum = 9. Found it!"
                }
            ],
            "code": "def twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return []  # This line should never be reached",
            "keyInsight": "The array is sorted, so we can use directionality.",
            "testCases": [
                {
                    "input": "numbers = [2,7,11,15], target = 9",
                    "output": "[1,2]"
                },
                {
                    "input": "numbers = [2,3,4], target = 6",
                    "output": "[1,3]"
                },
                {
                    "input": "numbers = [-1,0], target = -1",
                    "output": "[1,2]"
                }
            ]
        },
        "longest-repeating-character-replacement": {
            "id": "longest-repeating-character-replacement",
            "slug": "longest-repeating-character-replacement",
            "title": "Longest Repeating Character Replacement",
            "difficulty": "Medium",
            "category": "Sliding Window",
            "problemStatement": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Sliding Window",
            "patternEmoji": ">window<",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use sliding window with max frequency tracking to find longest valid substring.",
            "intuition": [
                "We can extend a window as long as (window length - max char frequency) \u2264 k",
                "When this condition breaks, shrink window from left until it's valid again"
            ],
            "visualizationType": "array",
            "initialState": [
                "A",
                "A",
                "B",
                "A",
                "B",
                "A"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Window: 'AA', maxFreq: 2, changes needed: 0 \u2264 1 \u2713"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Window: 'AAB', maxFreq: 2, changes needed: 1 \u2264 1 \u2713"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 3,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Window: 'AABA', maxFreq: 3, changes needed: 1 \u2264 1 \u2713"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        4
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 4,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Window: 'AABAB', maxFreq: 3, changes needed: 2 > 1 \u2717"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        5
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "L"
                        },
                        {
                            "index": 5,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Shrunk window: 'ABABA', maxFreq: 3, changes needed: 2 > 1 \u2717"
                }
            ],
            "code": "def characterReplacement(s: str, k: int) -> int:\n    left = 0\n    max_length = 0\n    max_freq = 0\n    char_count = {}\n    \n    for right in range(len(s)):\n        # Update character frequency\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        max_freq = max(max_freq, char_count[s[right]])\n        \n        # If window is invalid, shrink from left\n        while (right - left + 1) - max_freq > k:\n            char_count[s[left]] -= 1\n            left += 1\n            # Note: max_freq might be outdated but doesn't affect correctness\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
            "keyInsight": "We track the maximum frequency in current window. Window is valid if (length - maxFreq) \u2264 k.",
            "testCases": [
                {
                    "input": "s = \"ABAB\", k = 2",
                    "output": "4"
                },
                {
                    "input": "s = \"AABABBA\", k = 1",
                    "output": "4"
                }
            ]
        },
        "sliding-window-maximum": {
            "id": "sliding-window-maximum",
            "slug": "sliding-window-maximum",
            "title": "Sliding Window Maximum",
            "difficulty": "Hard",
            "category": "Sliding Window",
            "problemStatement": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Monotonic Queue",
            "patternEmoji": ".dequeue",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use a deque to maintain decreasing elements in the current window.",
            "intuition": [
                "We want maximums from sliding windows - brute force is O(n*k)",
                "Use deque to store indices of array elements in decreasing order"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                -1,
                -3,
                5,
                3,
                6,
                7
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "dq"
                        },
                        {
                            "index": 1,
                            "label": "dq"
                        },
                        {
                            "index": 2,
                            "label": "dq"
                        }
                    ],
                    "transientMessage": "Window [1,3,-1]: Deque stores indices maintaining decreasing values"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2,
                        3
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "dq"
                        },
                        {
                            "index": 2,
                            "label": "dq"
                        },
                        {
                            "index": 3,
                            "label": "dq"
                        }
                    ],
                    "transientMessage": "Window [3,-1,-3]: Max is 3, stored at front of deque"
                }
            ],
            "code": "from collections import deque\n\ndef maxSlidingWindow(nums, k):\n    dq = deque()  # Stores indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices whose values are less than current\n        while dq and nums[dq[-1]] <= nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add max to result when window is formed\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result",
            "keyInsight": "Deque maintains indices of elements in decreasing order - front always has maximum.",
            "testCases": [
                {
                    "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
                    "output": "[3,3,5,5,6,7]"
                },
                {
                    "input": "nums = [1], k = 1",
                    "output": "[1]"
                }
            ]
        },
        "non-overlapping-intervals": {
            "id": "non-overlapping-intervals",
            "slug": "non-overlapping-intervals",
            "title": "Non-overlapping Intervals",
            "difficulty": "Medium",
            "category": "Intervals",
            "problemStatement": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nNote that intervals which only touch at a point are non-overlapping. For example, [1, 2] and [2, 3] are non-overlapping.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Greedy Algorithm",
            "patternEmoji": "\ud83d\udcb0",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort by end time and greedily select non-overlapping intervals.",
            "intuition": [
                "To minimize removals, we want to keep as many non-overlapping intervals as possible.",
                "Greedy approach: always pick the interval that ends earliest to leave more room for others."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    2
                ],
                [
                    2,
                    3
                ],
                [
                    3,
                    4
                ],
                [
                    1,
                    3
                ]
            ],
            "animationSteps": [
                {
                    "type": "sort",
                    "indices": [],
                    "color": "primary",
                    "pointers": [],
                    "transientMessage": "Sort intervals by end time"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Keep"
                        },
                        {
                            "index": 1,
                            "label": "Keep"
                        }
                    ],
                    "transientMessage": "No overlap - keep both intervals"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Keep"
                        },
                        {
                            "index": 2,
                            "label": "Keep"
                        }
                    ],
                    "transientMessage": "No overlap - keep both intervals"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Keep"
                        },
                        {
                            "index": 3,
                            "label": "Remove"
                        }
                    ],
                    "transientMessage": "Overlap detected - remove interval [1,3]"
                }
            ],
            "code": "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    # Sort by end time\n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        # If current interval starts before previous ends\n        if intervals[i][0] < end:\n            count += 1  # Remove this interval\n        else:\n            end = intervals[i][1]  # Keep this interval\n    \n    return count",
            "keyInsight": "Sort by end time and greedily keep intervals that don't overlap with the previously selected one.",
            "testCases": [
                {
                    "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
                    "output": "1"
                },
                {
                    "input": "intervals = [[1,2],[1,2],[1,2]]",
                    "output": "2"
                },
                {
                    "input": "intervals = [[1,2],[2,3]]",
                    "output": "0"
                }
            ]
        },
        "meeting-rooms": {
            "id": "meeting-rooms",
            "slug": "meeting-rooms",
            "title": "Meeting Rooms",
            "difficulty": "Easy",
            "category": "Intervals",
            "problemStatement": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person can attend all meetings.",
            "videoUrl": "",
            "pattern": "Sorting",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Sort by start times and check for overlaps.",
            "intuition": [
                "If meetings overlap, person can't attend all.",
                "Sort by start time to easily compare adjacent meetings."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    0,
                    30
                ],
                [
                    5,
                    10
                ],
                [
                    15,
                    20
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Meeting [0,30] overlaps with [5,10] \u2192 FALSE"
                }
            ],
            "code": "def canAttendMeetings(intervals):\n    intervals.sort()\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True",
            "keyInsight": "After sorting, only adjacent meetings need overlap checking.",
            "testCases": [
                {
                    "input": "intervals = [[0,30],[5,10],[15,20]]",
                    "output": "false"
                },
                {
                    "input": "intervals = [[7,10],[2,4]]",
                    "output": "true"
                }
            ]
        },
        "meeting-rooms-ii": {
            "id": "meeting-rooms-ii",
            "slug": "meeting-rooms-ii",
            "title": "Meeting Rooms II",
            "difficulty": "Medium",
            "category": "Intervals",
            "problemStatement": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
            "videoUrl": "",
            "pattern": "Two Pointers + Sorting",
            "patternEmoji": "\ud83d\udc49\ud83d\udc48\ud83d\udcc5",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort start/end times separately and use two pointers to track room usage.",
            "intuition": [
                "We don't need to know which meeting is in which room, just how many are happening simultaneously",
                "By sorting start and end times separately, we can efficiently track when meetings begin/end"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    0,
                    30
                ],
                [
                    5,
                    10
                ],
                [
                    15,
                    20
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Extract and sort start times: [0, 5, 15]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Extract and sort end times: [10, 20, 30]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        }
                    ],
                    "transientMessage": "Start=0 < End=10, need room"
                }
            ],
            "code": "def minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n    \n    starts = sorted([interval[0] for interval in intervals])\n    ends = sorted([interval[1] for interval in intervals])\n    \n    start_ptr = end_ptr = 0\n    rooms_needed = 0\n    max_rooms = 0\n    \n    while start_ptr < len(intervals):\n        if starts[start_ptr] < ends[end_ptr]:\n            rooms_needed += 1\n            max_rooms = max(max_rooms, rooms_needed)\n            start_ptr += 1\n        else:\n            rooms_needed -= 1\n            end_ptr += 1\n    \n    return max_rooms",
            "keyInsight": "Separating start/end times lets us process events chronologically without tracking specific meetings.",
            "testCases": [
                {
                    "input": "intervals = [[0,30],[5,10],[15,20]]",
                    "output": "2"
                },
                {
                    "input": "intervals = [[7,10],[2,4]]",
                    "output": "1"
                }
            ]
        },
        "minimum-interval-to-include-each-query": {
            "id": "minimum-interval-to-include-each-query",
            "slug": "minimum-interval-to-include-each-query",
            "title": "Minimum Interval to Include Each Query",
            "difficulty": "Hard",
            "category": "Intervals",
            "problemStatement": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Sorting + Min Heap",
            "patternEmoji": "\ud83d\udcca\u26a1",
            "timeComplexity": "O(n log n + m log m)",
            "spaceComplexity": "O(n + m)",
            "oneliner": "Sort intervals and queries, use min heap to track valid intervals.",
            "intuition": [
                "Process queries in sorted order to reuse previous computations",
                "Use min heap to efficiently find the smallest valid interval"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    4
                ],
                [
                    2,
                    4
                ],
                [
                    3,
                    6
                ],
                [
                    4,
                    4
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Processing query 2: Add intervals that start \u2264 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Add [1,4] and [2,4] to heap (both contain 2)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "Remove [1,4] from heap (length 4), answer for 2 is 3"
                }
            ],
            "code": "import heapq\n\ndef minInterval(intervals, queries):\n    intervals.sort()\n    queries_sorted = sorted((q, i) for i, q in enumerate(queries))\n    result = [-1] * len(queries)\n    min_heap = []  # (size, end)\n    i = 0\n    \n    for query, original_index in queries_sorted:\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= query:\n            left, right = intervals[i]\n            heapq.heappush(min_heap, (right - left + 1, right))\n            i += 1\n        \n        # Remove intervals that end < query\n        while min_heap and min_heap[0][1] < query:\n            heapq.heappop(min_heap)\n        \n        # Answer is top of heap if exists\n        if min_heap:\n            result[original_index] = min_heap[0][0]\n    \n    return result",
            "keyInsight": "Sort both intervals and queries to process in order and reuse computations.",
            "testCases": [
                {
                    "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
                    "output": "[3,3,1,4]"
                },
                {
                    "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
                    "output": "[2,-1,4,6]"
                }
            ]
        },
        "daily-temperatures": {
            "id": "daily-temperatures",
            "slug": "daily-temperatures",
            "title": "Daily Temperatures",
            "difficulty": "Medium",
            "category": "Stack",
            "problemStatement": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Monotonic Stack",
            "patternEmoji": "\u2198\ufe0f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a stack to track indices of decreasing temperatures.",
            "intuition": [
                "We only need to look at future days with higher temperatures",
                "A stack helps us efficiently find the next warmer day"
            ],
            "visualizationType": "array",
            "initialState": [
                73,
                74,
                75,
                71,
                69,
                72,
                76,
                73
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Day 0: 73\u00b0. Stack empty, push index 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Day 1: 74\u00b0. Warmer than stack top (73\u00b0). Pop and calculate: answer[0] = 1-0 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Day 2: 75\u00b0. Warmer than stack top (74\u00b0). Pop and calculate: answer[1] = 2-1 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Day 3: 71\u00b0. Cooler than stack top (75\u00b0). Push index 3"
                }
            ],
            "code": "def dailyTemperatures(temperatures):\n    answer = [0] * len(temperatures)\n    stack = []  # Stack of indices\n    \n    for i, temp in enumerate(temperatures):\n        # While stack not empty and current temp > stack top temp\n        while stack and temp > temperatures[stack[-1]]:\n            prev_index = stack.pop()\n            answer[prev_index] = i - prev_index\n        stack.append(i)\n    \n    return answer",
            "keyInsight": "We process temperatures left to right, using a stack to remember previous days waiting for a warmer day.",
            "testCases": [
                {
                    "input": "temperatures = [73,74,75,71,69,72,76,73]",
                    "output": "[1,1,4,2,1,1,0,0]"
                },
                {
                    "input": "temperatures = [30,40,50,60]",
                    "output": "[1,1,1,0]"
                },
                {
                    "input": "temperatures = [30,60,90]",
                    "output": "[1,1,0]"
                }
            ]
        },
        "car-fleet": {
            "id": "car-fleet",
            "slug": "car-fleet",
            "title": "Car Fleet",
            "difficulty": "Medium",
            "category": "Stack",
            "problemStatement": "There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.\nYou are given two integer arrays position and speed, both of length n, where position[i] is the starting mile of the ith car and speed[i] is the speed of the ith car in miles per hour.\nA car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.\nA car fleet is a car or cars driving next to each other. The speed of the car fleet is the minimum speed of any car in the fleet.\nIf a car catches up to a car fleet at the mile target, it will still be considered as part of the car fleet.\nReturn the number of car fleets that will arrive at the destination.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Stack",
            "patternEmoji": "\ud83e\udd5e",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Sort cars by position and use stack to count fleets based on arrival times.",
            "intuition": [
                "Cars closer to target with faster speeds may form fleets",
                "If a car arrives before or at same time as car ahead, they form a fleet"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    10,
                    2
                ],
                [
                    4,
                    1
                ],
                [
                    0,
                    3
                ],
                [
                    5,
                    1
                ],
                [
                    3,
                    3
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Sort cars by position descending: [10,2],[5,1],[4,1],[3,3],[0,3]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Car 1"
                        }
                    ],
                    "transientMessage": "Car at pos 10, speed 2. Time to target (12-10)/2 = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Car 2"
                        }
                    ],
                    "transientMessage": "Car at pos 5, speed 1. Time to target (12-5)/1 = 7"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "Car 3"
                        }
                    ],
                    "transientMessage": "Car at pos 4, speed 1. Time to target (12-4)/1 = 8"
                }
            ],
            "code": "def carFleet(target, position, speed):\n    cars = sorted(zip(position, speed), reverse=True)\n    times = [(target - pos) / spd for pos, spd in cars]\n    fleets = 0\n    slowest_time = 0\n    \n    for time in times:\n        if time > slowest_time:\n            fleets += 1\n            slowest_time = time\n    \n    return fleets",
            "keyInsight": "Sort by position and compare arrival times. If a car arrives after the one ahead, it forms a new fleet.",
            "testCases": [
                {
                    "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
                    "output": "3"
                },
                {
                    "input": "target = 10, position = [3], speed = [3]",
                    "output": "1"
                },
                {
                    "input": "target = 100, position = [0,2,4], speed = [4,2,1]",
                    "output": "1"
                }
            ]
        },
        "largest-rectangle-in-histogram": {
            "id": "largest-rectangle-in-histogram",
            "slug": "largest-rectangle-in-histogram",
            "title": "Largest Rectangle in Histogram",
            "difficulty": "Hard",
            "category": "Stack",
            "problemStatement": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Monotonic Stack",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a stack to track increasing bar heights and calculate areas when heights decrease.",
            "intuition": [
                "For each bar, the largest rectangle is limited by the nearest smaller bars on left and right",
                "A stack helps efficiently find these boundaries by maintaining increasing heights"
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                1,
                5,
                6,
                2,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Push index 0 to stack"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Height decreased! Pop stack and calculate area"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        },
                        {
                            "index": 3,
                            "label": "stack top"
                        }
                    ],
                    "transientMessage": "Bars 5 and 6 form a rectangle of area 10"
                }
            ],
            "code": "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    heights.append(0)  # Add sentinel to process remaining bars\n    \n    for i in range(len(heights)):\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n    \n    heights.pop()  # Remove sentinel\n    return max_area",
            "keyInsight": "When a bar with smaller height is encountered, we can calculate the maximum area for all taller bars in the stack.",
            "testCases": [
                {
                    "input": "heights = [2,1,5,6,2,3]",
                    "output": "10"
                },
                {
                    "input": "heights = [2,4]",
                    "output": "4"
                }
            ]
        },
        "reorder-list": {
            "id": "reorder-list",
            "slug": "reorder-list",
            "title": "Reorder List",
            "difficulty": "Medium",
            "category": "Linked List",
            "problemStatement": "You are given the head of a singly linked-list. The list can be represented as:\nReorder the list to be on the following form:\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Linked List Reversal + Merge",
            "patternEmoji": "\ud83d\udd04\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Split list in half, reverse second half, then merge alternately.",
            "intuition": [
                "Break the list into two halves at the middle point",
                "Reverse the second half and merge both halves alternately"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "head"
                        },
                        {
                            "index": 2,
                            "label": "mid"
                        }
                    ],
                    "transientMessage": "Find the middle of the list"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "tail"
                        }
                    ],
                    "transientMessage": "Second half will be reversed"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Reverse second half: [5, 4]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        4,
                        1,
                        3,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Merge alternately: [1,5,2,4,3]"
                }
            ],
            "code": "def reorderList(head):\n    if not head or not head.next:\n        return head\n    \n    # Find the middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Break the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        temp1, temp2 = first.next, second.next\n        first.next = second\n        second.next = temp1\n        first, second = temp1, temp2\n    \n    return head",
            "keyInsight": "Use slow/fast pointers to find mid, then reverse and merge.",
            "testCases": [
                {
                    "input": "head = [1,2,3,4]",
                    "output": "[1,4,2,3]"
                },
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[1,5,2,4,3]"
                }
            ]
        },
        "find-the-duplicate-number": {
            "id": "find-the-duplicate-number",
            "slug": "find-the-duplicate-number",
            "title": "Find the Duplicate Number",
            "difficulty": "Medium",
            "category": "Linked List",
            "problemStatement": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and using only constant extra space.\nExample 1:\nExample 2:\nExample 3:\nConstraints:\nFollow up:",
            "videoUrl": "",
            "pattern": "Floyd's Cycle Detection",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Treat array values as pointers and detect cycle using Floyd's algorithm.",
            "intuition": [
                "Since each value is in range [1,n] and array has n+1 elements, values can be treated as pointers to indices",
                "Duplicate number creates a cycle - use slow/fast pointers to detect it"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                3,
                4,
                2,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "slow"
                        },
                        {
                            "index": 0,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Start both pointers at index 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "slow"
                        },
                        {
                            "index": 4,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Move slow by one step, fast by two steps"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "slow"
                        },
                        {
                            "index": 2,
                            "label": "fast"
                        }
                    ],
                    "transientMessage": "Pointers meet - cycle detected!"
                }
            ],
            "code": "def findDuplicate(nums):\n    # Phase 1: Detect cycle using Floyd's algorithm\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]        # Move one step\n        fast = nums[nums[fast]]  # Move two steps\n        if slow == fast:\n            break\n    \n    # Phase 2: Find cycle entrance (duplicate number)\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    \n    return slow",
            "keyInsight": "Values in array can be treated as pointers to indices, creating a linked list with a cycle due to the duplicate.",
            "testCases": [
                {
                    "input": "nums = [1,3,4,2,2]",
                    "output": "2"
                },
                {
                    "input": "nums = [3,1,3,4,2]",
                    "output": "3"
                },
                {
                    "input": "nums = [3,3,3,3,3]",
                    "output": "3"
                }
            ]
        },
        "balanced-binary-tree": {
            "id": "balanced-binary-tree",
            "slug": "balanced-binary-tree",
            "title": "Balanced Binary Tree",
            "difficulty": "Easy",
            "category": "Binary Tree General",
            "problemStatement": "Given a binary tree, determine if it is height-balanced.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Tree Recursion",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Check balance condition recursively for each node.",
            "intuition": [
                "A tree is balanced if left and right subtrees are balanced",
                "And their heights differ by at most 1"
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                9,
                20,
                null,
                null,
                15,
                7
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Check root: left height=1, right height=2. Diff=1 \u2713"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Left child: no children. Balanced \u2713"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Right child: left/right height=1. Diff=0 \u2713"
                }
            ],
            "code": "def isBalanced(root):\n    def check_height(node):\n        if not node:\n            return 0\n        \n        left_height = check_height(node.left)\n        if left_height == -1:\n            return -1\n            \n        right_height = check_height(node.right)\n        if right_height == -1:\n            return -1\n            \n        if abs(left_height - right_height) > 1:\n            return -1\n            \n        return max(left_height, right_height) + 1\n    \n    return check_height(root) != -1",
            "keyInsight": "Use -1 as sentinel value to propagate imbalance up the tree.",
            "testCases": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "true"
                },
                {
                    "input": "root = [1,2,2,3,3,null,null,4,4]",
                    "output": "false"
                },
                {
                    "input": "root = []",
                    "output": "true"
                }
            ]
        },
        "subtree-of-another-tree": {
            "id": "subtree-of-another-tree",
            "slug": "subtree-of-another-tree",
            "title": "Subtree of Another Tree",
            "difficulty": "Easy",
            "category": "Binary Tree General",
            "problemStatement": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Tree Traversal + Subtree Matching",
            "patternEmoji": "\ud83c\udf32\ud83d\udd0d",
            "timeComplexity": "O(m\u00d7n)",
            "spaceComplexity": "O(m+n)",
            "oneliner": "Traverse main tree and check if any node matches the subRoot tree structure.",
            "intuition": [
                "We need to check if subRoot appears as a subtree in root.",
                "For each node in root, we can recursively check if the subtree matches subRoot."
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                4,
                5,
                1,
                2,
                null,
                null,
                0
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start at root node (3)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Check left child (4)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4,
                        1
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "Compare subtree [4,1,2] with target [4,1,2]"
                }
            ],
            "code": "def isSubtree(root, subRoot):\n    if not root:\n        return False\n    if isSameTree(root, subRoot):\n        return True\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q or p.val != q.val:\n        return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)",
            "keyInsight": "For each node in the main tree, check if the subtree rooted at that node matches the target subtree.",
            "testCases": [
                {
                    "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
                    "output": "true"
                },
                {
                    "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
                    "output": "false"
                }
            ]
        },
        "lowest-common-ancestor-of-a-binary-search-tree": {
            "id": "lowest-common-ancestor-of-a-binary-search-tree",
            "slug": "lowest-common-ancestor-of-a-binary-search-tree",
            "title": "Lowest Common Ancestor of a Binary Search Tree",
            "difficulty": "Medium",
            "category": "Binary Tree General",
            "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "BST Property",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(h)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use BST property to navigate toward LCA.",
            "intuition": [
                "In a BST, all left descendants are smaller and right descendants are larger.",
                "The LCA is the first node where p and q diverge to different subtrees."
            ],
            "visualizationType": "array",
            "initialState": [
                6,
                2,
                8,
                0,
                4,
                7,
                9,
                null,
                null,
                3,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "root"
                        }
                    ],
                    "transientMessage": "Start at root (6). Looking for LCA of 2 and 8."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "p=2"
                        },
                        {
                            "index": 2,
                            "label": "q=8"
                        }
                    ],
                    "transientMessage": "p=2 < root=6 < q=8. Found LCA!"
                }
            ],
            "code": "def lowestCommonAncestor(root, p, q):\n    while root:\n        if p.val < root.val and q.val < root.val:\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n    return None",
            "keyInsight": "Use BST ordering: if both nodes are on same side, move there. Otherwise current node is LCA.",
            "testCases": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                    "output": "6"
                },
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                    "output": "2"
                },
                {
                    "input": "root = [2,1], p = 2, q = 1",
                    "output": "2"
                }
            ]
        },
        "count-good-nodes-in-binary-tree": {
            "id": "count-good-nodes-in-binary-tree",
            "slug": "count-good-nodes-in-binary-tree",
            "title": "Count Good Nodes in Binary Tree",
            "difficulty": "Medium",
            "category": "Binary Tree General",
            "problemStatement": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "DFS Traversal",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(h)",
            "oneliner": "Traverse tree while tracking max value seen so far.",
            "intuition": [
                "A node is good if its value is \u2265 all values in the path from root",
                "Track the maximum value encountered during DFS traversal"
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                1,
                4,
                3,
                null,
                1,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "root"
                        }
                    ],
                    "transientMessage": "Start at root (3). Max so far: 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "L"
                        }
                    ],
                    "transientMessage": "Visit left child (1). Max still 3. Not good."
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "LL"
                        }
                    ],
                    "transientMessage": "Visit left-left (3). Value \u2265 max(3). Good node!"
                }
            ],
            "code": "def goodNodes(root):\n    def dfs(node, max_so_far):\n        if not node:\n            return 0\n        count = 1 if node.val >= max_so_far else 0\n        new_max = max(max_so_far, node.val)\n        count += dfs(node.left, new_max)\n        count += dfs(node.right, new_max)\n        return count\n    return dfs(root, float('-inf'))",
            "keyInsight": "Use DFS with running maximum to determine if current node is good.",
            "testCases": [
                {
                    "input": "root = [3,1,4,3,null,1,5]",
                    "output": "4"
                },
                {
                    "input": "root = [3,3,null,4,2]",
                    "output": "3"
                },
                {
                    "input": "root = [1]",
                    "output": "1"
                }
            ]
        },
        "serialize-and-deserialize-binary-tree": {
            "id": "serialize-and-deserialize-binary-tree",
            "slug": "serialize-and-deserialize-binary-tree",
            "title": "Serialize and Deserialize Binary Tree",
            "difficulty": "Hard",
            "category": "Binary Tree General",
            "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Tree Traversal",
            "patternEmoji": "\ud83c\udf32",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use preorder traversal with null markers for serialization and reconstruction.",
            "intuition": [
                "Preorder traversal (root, left, right) preserves tree structure",
                "Use special marker (like 'null') to represent missing nodes"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                "null",
                "null",
                3,
                4,
                "null",
                "null",
                5,
                "null",
                "null"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Root"
                        }
                    ],
                    "transientMessage": "Start with root value 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Left"
                        }
                    ],
                    "transientMessage": "Process left subtree of node 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "muted",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "null"
                        },
                        {
                            "index": 3,
                            "label": "null"
                        }
                    ],
                    "transientMessage": "Leaf node 2 has no children"
                }
            ],
            "code": "class Codec:\n    def serialize(self, root):\n        def preorder(node):\n            if not node:\n                vals.append('null')\n            else:\n                vals.append(str(node.val))\n                preorder(node.left)\n                preorder(node.right)\n        vals = []\n        preorder(root)\n        return ','.join(vals)\n\n    def deserialize(self, data):\n        def build():\n            val = next(vals)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        vals = iter(data.split(','))\n        return build()",
            "keyInsight": "Preorder traversal with null markers uniquely represents any binary tree structure.",
            "testCases": [
                {
                    "input": "root = [1,2,3,null,null,4,5]",
                    "output": "[1,2,3,null,null,4,5]"
                },
                {
                    "input": "root = []",
                    "output": "[]"
                }
            ]
        },
        "max-area-of-island": {
            "id": "max-area-of-island",
            "slug": "max-area-of-island",
            "title": "Max Area of Island",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nThe area of an island is the number of cells with a value 1 in the island.\nReturn the maximum area of an island in grid. If there is no island, return 0.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "DFS on Grid",
            "patternEmoji": "\ud83c\udf0a",
            "timeComplexity": "O(m\u00d7n)",
            "spaceComplexity": "O(m\u00d7n)",
            "oneliner": "Use DFS from each land cell to explore and count island areas.",
            "intuition": [
                "We need to explore connected components of 1s in a 2D grid",
                "DFS is perfect for exploring all connected land cells from a starting point"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    1,
                    0,
                    0,
                    0
                ],
                [
                    1,
                    1,
                    0,
                    0,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1
                ],
                [
                    0,
                    0,
                    0,
                    1,
                    1
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            0
                        ]
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start DFS from first land cell (1,1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            1,
                            1
                        ]
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Island 1 area = 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            3
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            3
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Island 2 area = 5 (maximum)"
                }
            ],
            "code": "def maxAreaOfIsland(grid):\n    if not grid:\n        return 0\n    \n    def dfs(r, c):\n        if (r < 0 or c < 0 or r >= len(grid) or \n            c >= len(grid[0]) or grid[r][c] == 0):\n            return 0\n        \n        grid[r][c] = 0  # Mark as visited\n        area = 1\n        \n        # Explore all 4 directions\n        area += dfs(r+1, c)\n        area += dfs(r-1, c)\n        area += dfs(r, c+1)\n        area += dfs(r, c-1)\n        \n        return area\n    \n    max_area = 0\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == 1:\n                max_area = max(max_area, dfs(r, c))\n    \n    return max_area",
            "keyInsight": "DFS explores connected components; we can modify grid to mark visited cells.",
            "testCases": [
                {
                    "input": "grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]",
                    "output": "6"
                },
                {
                    "input": "grid = [[0,0,0,0,0,0,0,0]]",
                    "output": "0"
                }
            ]
        },
        "pacific-atlantic-water-flow": {
            "id": "pacific-atlantic-water-flow",
            "slug": "pacific-atlantic-water-flow",
            "title": "Pacific Atlantic Water Flow",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Multi-source BFS",
            "patternEmoji": "\ud83c\udf0a",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "Reverse the flow - start from oceans and find reachable cells.",
            "intuition": [
                "Water flows from high to low elevation, but we can reverse this thinking",
                "Start from ocean edges and work backwards to find all cells that can reach each ocean"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    2,
                    2,
                    3,
                    5
                ],
                [
                    3,
                    2,
                    3,
                    4,
                    4
                ],
                [
                    2,
                    4,
                    5,
                    3,
                    1
                ],
                [
                    6,
                    7,
                    1,
                    4,
                    5
                ],
                [
                    5,
                    1,
                    1,
                    2,
                    4
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            0
                        ],
                        [
                            0,
                            1
                        ],
                        [
                            0,
                            2
                        ],
                        [
                            0,
                            3
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            0
                        ],
                        [
                            2,
                            0
                        ],
                        [
                            3,
                            0
                        ],
                        [
                            4,
                            0
                        ]
                    ],
                    "color": "blue",
                    "pointers": [],
                    "transientMessage": "Pacific edge cells (top and left borders)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            4,
                            0
                        ],
                        [
                            4,
                            1
                        ],
                        [
                            4,
                            2
                        ],
                        [
                            4,
                            3
                        ],
                        [
                            4,
                            4
                        ],
                        [
                            0,
                            4
                        ],
                        [
                            1,
                            4
                        ],
                        [
                            2,
                            4
                        ],
                        [
                            3,
                            4
                        ]
                    ],
                    "color": "purple",
                    "pointers": [],
                    "transientMessage": "Atlantic edge cells (bottom and right borders)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            4
                        ],
                        [
                            4,
                            0
                        ]
                    ],
                    "color": "green",
                    "pointers": [],
                    "transientMessage": "Cells that reach both oceans"
                }
            ],
            "code": "from collections import deque\n\ndef pacificAtlantic(heights):\n    if not heights or not heights[0]:\n        return []\n    \n    m, n = len(heights), len(heights[0])\n    \n    # Initialize queues for both oceans\n    pacific_queue = deque()\n    atlantic_queue = deque()\n    \n    # Add all edge cells to respective queues\n    for i in range(m):\n        pacific_queue.append((i, 0))\n        atlantic_queue.append((i, n-1))\n    for j in range(n):\n        pacific_queue.append((0, j))\n        atlantic_queue.append((m-1, j))\n    \n    def bfs(queue):\n        reachable = set()\n        while queue:\n            row, col = queue.popleft()\n            reachable.add((row, col))\n            \n            # Check all 4 directions\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_row, new_col = row + dr, col + dc\n                \n                # Check bounds\n                if (0 <= new_row < m and 0 <= new_col < n and \n                    (new_row, new_col) not in reachable and\n                    heights[new_row][new_col] >= heights[row][col]):\n                    queue.append((new_row, new_col))\n        return reachable\n    \n    # Find cells reachable from each ocean\n    pacific_reachable = bfs(pacific_queue)\n    atlantic_reachable = bfs(atlantic_queue)\n    \n    # Find intersection\n    common_cells = pacific_reachable.intersection(atlantic_reachable)\n    \n    # Convert to list of lists\n    return [[r, c] for r, c in common_cells]",
            "keyInsight": "Instead of checking if each cell can reach an ocean, start from oceans and find all cells that can be reached (reverse thinking).",
            "testCases": [
                {
                    "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
                    "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
                },
                {
                    "input": "heights = [[1]]",
                    "output": "[[0,0]]"
                }
            ]
        },
        "rotting-oranges": {
            "id": "rotting-oranges",
            "slug": "rotting-oranges",
            "title": "Rotting Oranges",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You are given an m x n grid where each cell can have one of three values:\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "BFS",
            "patternEmoji": "\ud83e\udda0",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "Use BFS from all initial rotten oranges to simulate rotting.",
            "intuition": [
                "Rotten oranges spread simultaneously, so we need level-by-level processing.",
                "Start BFS from all rotten oranges at time 0."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    2,
                    1,
                    1
                ],
                [
                    1,
                    1,
                    0
                ],
                [
                    0,
                    1,
                    1
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            0
                        ]
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start with all rotten oranges (time = 0)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            0
                        ]
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "At time 1: Adjacent fresh oranges become rotten"
                },
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            2
                        ],
                        [
                            1,
                            1
                        ]
                    ],
                    "color": "tertiary",
                    "pointers": [],
                    "transientMessage": "At time 2: Next layer of fresh oranges rot"
                }
            ],
            "code": "from collections import deque\n\ndef orangesRotting(grid):\n    if not grid:\n        return -1\n    \n    rows, cols = len(grid), len(grid[0])\n    fresh_count = 0\n    queue = deque()\n    \n    # Initialize queue with rotten oranges and count fresh ones\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh_count += 1\n    \n    # If no fresh oranges, return 0\n    if fresh_count == 0:\n        return 0\n    \n    # BFS to rot oranges\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    minutes = 0\n    \n    while queue and fresh_count > 0:\n        minutes += 1\n        # Process all currently rotten oranges\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            \n            # Check all 4 directions\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                \n                # If neighbor is a fresh orange, rot it\n                if (0 <= nr < rows and \n                    0 <= nc < cols and \n                    grid[nr][nc] == 1):\n                    grid[nr][nc] = 2\n                    fresh_count -= 1\n                    queue.append((nr, nc))\n    \n    # If there are still fresh oranges, impossible\n    return minutes if fresh_count == 0 else -1",
            "keyInsight": "Multi-source BFS: all rotten oranges at time 0 start spreading simultaneously.",
            "testCases": [
                {
                    "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
                    "output": "4"
                },
                {
                    "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
                    "output": "-1"
                },
                {
                    "input": "grid = [[0,2]]",
                    "output": "0"
                }
            ]
        },
        "walls-and-gates": {
            "id": "walls-and-gates",
            "slug": "walls-and-gates",
            "title": "Walls And Gates",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You are given an m x n grid rooms initialized with these three possible values:\n-1: A wall or an obstacle.\n0: A gate.\nINF: Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
            "videoUrl": "",
            "pattern": "Multi-source BFS",
            "patternEmoji": "\ud83c\udf0a",
            "timeComplexity": "O(m\u00d7n)",
            "spaceComplexity": "O(m\u00d7n)",
            "oneliner": "Start BFS from all gates simultaneously to find shortest distances.",
            "intuition": [
                "Instead of running BFS from each empty cell, run BFS from all gates at once",
                "This ensures we find the shortest distance to any gate in one pass"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    2147483647,
                    -1,
                    0,
                    2147483647
                ],
                [
                    2147483647,
                    2147483647,
                    2147483647,
                    -1
                ],
                [
                    2147483647,
                    -1,
                    2147483647,
                    -1
                ],
                [
                    0,
                    -1,
                    2147483647,
                    2147483647
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        [
                            0,
                            2
                        ],
                        [
                            3,
                            0
                        ]
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": [
                                0,
                                2
                            ],
                            "label": "Gate"
                        },
                        {
                            "index": [
                                3,
                                0
                            ],
                            "label": "Gate"
                        }
                    ],
                    "transientMessage": "Starting BFS from all gates (value 0)"
                },
                {
                    "type": "update",
                    "indices": [
                        [
                            0,
                            3
                        ],
                        [
                            1,
                            2
                        ]
                    ],
                    "values": [
                        1,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "First level: distance 1 from gates"
                },
                {
                    "type": "update",
                    "indices": [
                        [
                            0,
                            0
                        ],
                        [
                            1,
                            3
                        ],
                        [
                            2,
                            2
                        ]
                    ],
                    "values": [
                        2,
                        2,
                        2
                    ],
                    "color": "tertiary",
                    "pointers": [],
                    "transientMessage": "Second level: distance 2 from gates"
                }
            ],
            "code": "from collections import deque\n\ndef wallsAndGates(rooms):\n    if not rooms:\n        return\n    \n    m, n = len(rooms), len(rooms[0])\n    queue = deque()\n    \n    # Find all gates\n    for i in range(m):\n        for j in range(n):\n            if rooms[i][j] == 0:\n                queue.append((i, j))\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Multi-source BFS\n    while queue:\n        row, col = queue.popleft()\n        \n        for dr, dc in directions:\n            r, c = row + dr, col + dc\n            \n            # Check bounds and if cell is an unvisited room\n            if 0 <= r < m and 0 <= c < n and rooms[r][c] == 2147483647:\n                rooms[r][c] = rooms[row][col] + 1\n                queue.append((r, c))",
            "keyInsight": "Use all gates as starting points in a single BFS to efficiently compute distances.",
            "testCases": [
                {
                    "input": "rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
                    "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
                }
            ]
        },
        "redundant-connection": {
            "id": "redundant-connection",
            "slug": "redundant-connection",
            "title": "Redundant Connection",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Union-Find (Disjoint Set)",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use Union-Find to detect when adding an edge creates a cycle.",
            "intuition": [
                "A tree with n nodes has exactly n-1 edges",
                "The redundant edge is the one that creates the first cycle"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    1,
                    2
                ],
                [
                    1,
                    3
                ],
                [
                    2,
                    3
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Union 1 and 2 - no cycle"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Union 1 and 3 - no cycle"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "error",
                    "pointers": [],
                    "transientMessage": "1 and 2 already connected! Cycle detected."
                }
            ],
            "code": "def findRedundantConnection(edges):\n    parent = list(range(len(edges) + 1))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        rootX, rootY = find(x), find(y)\n        if rootX == rootY:\n            return False  # Cycle detected\n        parent[rootX] = rootY\n        return True\n    \n    for edge in edges:\n        if not union(edge[0], edge[1]):\n            return edge\n    return []",
            "keyInsight": "When union operation fails, we've found our redundant edge.",
            "testCases": [
                {
                    "input": "edges = [[1,2],[1,3],[2,3]]",
                    "output": "[2,3]"
                },
                {
                    "input": "edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",
                    "output": "[1,4]"
                }
            ]
        },
        "number-of-connected-components-in-an-undirected-graph": {
            "id": "number-of-connected-components-in-an-undirected-graph",
            "slug": "number-of-connected-components-in-an-undirected-graph",
            "title": "Number of Connected Components In An Undirected Graph",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.",
            "videoUrl": "",
            "pattern": "Union-Find / DFS",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(E * \u03b1(n))",
            "spaceComplexity": "O(n)",
            "oneliner": "Use Union-Find to group connected nodes and count components.",
            "intuition": [
                "Each node starts as its own component",
                "When we connect two nodes, we merge their components"
            ],
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                2,
                3,
                4
            ],
            "animationSteps": [
                {
                    "type": "update",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "0"
                        },
                        {
                            "index": 1,
                            "label": "1"
                        }
                    ],
                    "transientMessage": "Union nodes 0 and 1"
                },
                {
                    "type": "update",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "1"
                        },
                        {
                            "index": 2,
                            "label": "2"
                        }
                    ],
                    "transientMessage": "Union nodes 1 and 2 - now 0,1,2 connected"
                },
                {
                    "type": "update",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "3"
                        },
                        {
                            "index": 4,
                            "label": "4"
                        }
                    ],
                    "transientMessage": "Union nodes 3 and 4 - separate component"
                }
            ],
            "code": "def countComponents(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py: return\n        if rank[px] < rank[py]:\n            px, py = py, px\n        parent[py] = px\n        if rank[px] == rank[py]:\n            rank[px] += 1\n    \n    for a, b in edges:\n        union(a, b)\n    \n    return len(set(find(x) for x in range(n)))",
            "keyInsight": "Union-Find efficiently tracks connected components by merging groups.",
            "testCases": [
                {
                    "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
                    "output": "2"
                },
                {
                    "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
                    "output": "1"
                }
            ]
        },
        "graph-valid-tree": {
            "id": "graph-valid-tree",
            "slug": "graph-valid-tree",
            "title": "Graph Valid Tree",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
            "videoUrl": "",
            "pattern": "Union-Find",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use Union-Find to detect cycles and check connectivity.",
            "intuition": [
                "A tree with n nodes must have exactly n-1 edges",
                "Union-Find can detect cycles during union operations"
            ],
            "visualizationType": "array",
            "initialState": [
                0,
                1,
                2,
                3,
                4
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Union(0,1): No cycle"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Union(2,3): No cycle"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Union(1,2): No cycle"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Union(3,4): No cycle"
                }
            ],
            "code": "def validTree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    \n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return False\n        parent[rootX] = rootY\n        return True\n    \n    for a, b in edges:\n        if not union(a, b):\n            return False\n    \n    return True",
            "keyInsight": "A valid tree has exactly n-1 edges and no cycles.",
            "testCases": [
                {
                    "input": "n = 5, edges = [[0,1], [0,2], [0,3], [1,4]]",
                    "output": "true"
                },
                {
                    "input": "n = 5, edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]",
                    "output": "false"
                }
            ]
        },
        "reconstruct-itinerary": {
            "id": "reconstruct-itinerary",
            "slug": "reconstruct-itinerary",
            "title": "Reconstruct Itinerary",
            "difficulty": "Hard",
            "category": "Graph General",
            "problemStatement": "You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\nAll of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Hierholzer's Algorithm / DFS",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(E log E)",
            "spaceComplexity": "O(V + E)",
            "oneliner": "Use DFS with lexical ordering to traverse all edges exactly once.",
            "intuition": [
                "This is an Eulerian path problem - we must visit each ticket (edge) exactly once",
                "Since we want lexical order, we sort destinations and use post-order DFS traversal"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    "JFK",
                    "SFO"
                ],
                [
                    "JFK",
                    "ATL"
                ],
                [
                    "SFO",
                    "ATL"
                ],
                [
                    "ATL",
                    "JFK"
                ],
                [
                    "ATL",
                    "SFO"
                ]
            ],
            "animationSteps": [
                {
                    "type": "graphTraversal",
                    "currentNode": "JFK",
                    "visitedEdges": [],
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Current"
                        }
                    ],
                    "transientMessage": "Start from JFK, sort neighbors lexically"
                },
                {
                    "type": "graphTraversal",
                    "currentNode": "ATL",
                    "visitedEdges": [
                        [
                            "JFK",
                            "ATL"
                        ]
                    ],
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Current"
                        }
                    ],
                    "transientMessage": "Visit ATL next (lexically before SFO)"
                }
            ],
            "code": "def findItinerary(tickets):\n    from collections import defaultdict\n    import heapq\n    \n    # Build adjacency list with min-heap for lexical order\n    graph = defaultdict(list)\n    for src, dst in tickets:\n        heapq.heappush(graph[src], dst)\n    \n    result = []\n    \n    def dfs(node):\n        # Visit all neighbors in lexical order\n        while graph[node]:\n            next_node = heapq.heappop(graph[node])\n            dfs(next_node)\n        # Post-order: add to result after visiting children\n        result.append(node)\n    \n    dfs(\"JFK\")\n    return result[::-1]  # Reverse to get correct order",
            "keyInsight": "Use post-order DFS with lexical sorting to ensure correct itinerary order.",
            "testCases": [
                {
                    "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
                    "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
                },
                {
                    "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
                    "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]"
                }
            ]
        },
        "min-cost-to-connect-all-points": {
            "id": "min-cost-to-connect-all-points",
            "slug": "min-cost-to-connect-all-points",
            "title": "Min Cost to Connect All Points",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].\nThe cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Minimum Spanning Tree (Kruskal's)",
            "patternEmoji": "\ud83d\udd17",
            "timeComplexity": "O(n\u00b2 log n)",
            "spaceComplexity": "O(n\u00b2)",
            "oneliner": "Use Kruskal's algorithm with Union-Find to find MST.",
            "intuition": [
                "We need to connect all points with minimum total cost",
                "This is a classic Minimum Spanning Tree problem"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    0,
                    0
                ],
                [
                    2,
                    2
                ],
                [
                    3,
                    10
                ],
                [
                    5,
                    2
                ],
                [
                    7,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Distance: |0-2| + |0-2| = 4"
                }
            ],
            "code": "def minCostConnectPoints(points):\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Generate all edges with Manhattan distances\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            edges.append((dist, i, j))\n    \n    # Sort edges by distance\n    edges.sort()\n    \n    # Union-Find data structure\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])  # Path compression\n        return parent[x]\n    \n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parent[root_x] = root_y\n            return True\n        return False\n    \n    # Kruskal's algorithm\n    total_cost = 0\n    edges_used = 0\n    \n    for dist, u, v in edges:\n        if union(u, v):\n            total_cost += dist\n            edges_used += 1\n            if edges_used == n - 1:\n                break\n    \n    return total_cost",
            "keyInsight": "Connect points using minimum Manhattan distances without forming cycles.",
            "testCases": [
                {
                    "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
                    "output": "20"
                },
                {
                    "input": "points = [[3,12],[-2,5],[-4,1]]",
                    "output": "18"
                }
            ]
        },
        "network-delay-time": {
            "id": "network-delay-time",
            "slug": "network-delay-time",
            "title": "Network Delay Time",
            "difficulty": "Medium",
            "category": "Graph General",
            "problemStatement": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.\nWe will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dijkstra's Algorithm",
            "patternEmoji": "\ud83d\udcd0",
            "timeComplexity": "O(E log V)",
            "spaceComplexity": "O(V + E)",
            "oneliner": "Use Dijkstra's algorithm to find shortest paths from source node.",
            "intuition": [
                "We need to find the shortest path from node k to all other nodes",
                "Dijkstra's algorithm works because all edge weights are non-negative"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                4
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "K"
                        }
                    ],
                    "transientMessage": "Start from node K=1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "2"
                        }
                    ],
                    "transientMessage": "Visit node 2 with delay 5"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "3"
                        }
                    ],
                    "transientMessage": "Visit node 3 with delay 8"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "4"
                        }
                    ],
                    "transientMessage": "Visit node 4 with delay 12"
                }
            ],
            "code": "import heapq\n\ndef networkDelayTime(times, n, k):\n    # Build adjacency list\n    graph = [[] for _ in range(n + 1)]\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Distance array\n    dist = [float('inf')] * (n + 1)\n    dist[k] = 0\n    \n    # Priority queue\n    pq = [(0, k)]\n    \n    while pq:\n        d, node = heapq.heappop(pq)\n        \n        if d > dist[node]:\n            continue\n            \n        for neighbor, weight in graph[node]:\n            if dist[node] + weight < dist[neighbor]:\n                dist[neighbor] = dist[node] + weight\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n    \n    # Find maximum delay\n    max_delay = max(dist[1:])\n    return max_delay if max_delay != float('inf') else -1",
            "keyInsight": "Use Dijkstra's algorithm to find shortest path from source to all nodes.",
            "testCases": [
                {
                    "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
                    "output": "2"
                },
                {
                    "input": "times = [[1,2,1]], n = 2, k = 1",
                    "output": "1"
                },
                {
                    "input": "times = [[1,2,1]], n = 2, k = 2",
                    "output": "-1"
                }
            ]
        },
        "swim-in-rising-water": {
            "id": "swim-in-rising-water",
            "slug": "swim-in-rising-water",
            "title": "Swim in Rising Water",
            "difficulty": "Hard",
            "category": "Graph General",
            "problemStatement": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\nIt starts raining, and water gradually rises over time. At time t, the water level is t, meaning any cell with elevation less than equal to t is submerged or reachable.\nYou can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nReturn the minimum time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Binary Search + DFS",
            "patternEmoji": "\ud83d\udd0d\ud83d\udd78\ufe0f",
            "timeComplexity": "O(n\u00b2 log n)",
            "spaceComplexity": "O(n\u00b2)",
            "oneliner": "Binary search on time values, use DFS to check if path exists.",
            "intuition": [
                "We want the minimum time t where a path exists from (0,0) to (n-1,n-1)",
                "For a given time t, we can check connectivity using DFS/BFS"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    0,
                    2
                ],
                [
                    1,
                    3
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "start",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Start"
                        }
                    ],
                    "transientMessage": "Start at (0,0)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "end",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "End"
                        }
                    ],
                    "transientMessage": "Target is (1,1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "water",
                    "pointers": [],
                    "transientMessage": "At time t=2, can swim to (0,1)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "water",
                    "pointers": [],
                    "transientMessage": "At time t=2, can swim to (1,0)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "path",
                    "pointers": [],
                    "transientMessage": "At time t=3, can reach (1,1)"
                }
            ],
            "code": "def swimInWater(grid):\n    n = len(grid)\n    \n    def canReach(t):\n        if grid[0][0] > t: return False\n        stack = [(0, 0)]\n        visited = set()\n        \n        while stack:\n            x, y = stack.pop()\n            if x == n-1 and y == n-1:\n                return True\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            \n            for dx, dy in [(0,1), (1,0), (0,-1), (-1,0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] <= t:\n                    stack.append((nx, ny))\n        return False\n    \n    left, right = 0, n * n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if canReach(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left",
            "keyInsight": "Binary search on the answer. For each candidate time, check if destination is reachable.",
            "testCases": [
                {
                    "input": "grid = [[0,2],[1,3]]",
                    "output": "3"
                },
                {
                    "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
                    "output": "16"
                }
            ]
        },
        "alien-dictionary": {
            "id": "alien-dictionary",
            "slug": "alien-dictionary",
            "title": "Alien Dictionary",
            "difficulty": "Hard",
            "category": "Graph General",
            "problemStatement": "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.",
            "videoUrl": "",
            "pattern": "Topological Sort",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(C)",
            "spaceComplexity": "O(1)",
            "oneliner": "Build graph from adjacent words, then topological sort.",
            "intuition": [
                "Compare adjacent words to find letter order relationships.",
                "Use topological sort to determine valid letter sequence."
            ],
            "visualizationType": "array",
            "initialState": [
                "wrt",
                "wrf",
                "er",
                "ett",
                "rftt"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Compare 'wrt' and 'wrf' \u2192 t < f"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Compare 'wrf' and 'er' \u2192 w < e"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Compare 'er' and 'ett' \u2192 r < t"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Compare 'ett' and 'rftt' \u2192 e < r"
                }
            ],
            "code": "from collections import defaultdict, deque\n\ndef alienOrder(words):\n    # Build graph\n    graph = defaultdict(set)\n    indegree = defaultdict(int)\n    \n    # Add all unique letters\n    for word in words:\n        for char in word:\n            indegree[char] = 0\n    \n    # Find letter relationships\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i+1]\n        min_len = min(len(word1), len(word2))\n        \n        # Check invalid case: prefix issue\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n            \n        # Find first differing character\n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                # Add edge if not already present\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    indegree[word2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([char for char in indegree if indegree[char] == 0])\n    result = []\n    \n    while queue:\n        char = queue.popleft()\n        result.append(char)\n        \n        for neighbor in graph[char]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles\n    return ''.join(result) if len(result) == len(indegree) else \"\"",
            "keyInsight": "Adjacent words reveal ordering; topological sort handles dependencies.",
            "testCases": [
                {
                    "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
                    "output": "\"wertf\""
                },
                {
                    "input": "words = [\"z\",\"x\"]",
                    "output": "\"zx\""
                },
                {
                    "input": "words = [\"z\",\"x\",\"z\"]",
                    "output": "\"\""
                }
            ]
        },
        "subsets-ii": {
            "id": "subsets-ii",
            "slug": "subsets-ii",
            "title": "Subsets II",
            "difficulty": "Medium",
            "category": "Backtracking",
            "problemStatement": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use backtracking with sorting to skip duplicates.",
            "intuition": [
                "Sort the array first to group duplicates together",
                "Skip over duplicate elements during backtracking to avoid duplicate subsets"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start with empty subset: []"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Include 1: [1]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Include 2: [1,2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Include 2: [1,2,2]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Skip duplicate 2: [1,2] already exists"
                }
            ],
            "code": "def subsetsWithDup(nums):\n    nums.sort()\n    result = []\n    \n    def backtrack(start, path):\n        result.append(path[:])\n        \n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    \n    backtrack(0, [])\n    return result",
            "keyInsight": "Sort first, then skip duplicates by checking if current element equals previous element in the same level of recursion.",
            "testCases": [
                {
                    "input": "nums = [1,2,2]",
                    "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
                },
                {
                    "input": "nums = [0]",
                    "output": "[[],[0]]"
                }
            ]
        },
        "combination-sum-ii": {
            "id": "combination-sum-ii",
            "slug": "combination-sum-ii",
            "title": "Combination Sum II",
            "difficulty": "Medium",
            "category": "Backtracking",
            "problemStatement": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(2^n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use backtracking with sorting to avoid duplicates.",
            "intuition": [
                "Sort the array to group duplicates together",
                "Use backtracking to explore combinations, skipping duplicates"
            ],
            "visualizationType": "array",
            "initialState": [
                10,
                1,
                2,
                7,
                6,
                1,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Sort array first: [1,1,2,5,6,7,10]"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "primary",
                    "pointers": [],
                    "transientMessage": "Choose 1, then 1: sum=2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Choose 1,1,2: sum=4"
                }
            ],
            "code": "def combinationSum2(candidates, target):\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path[:])\n            return\n        if target < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue  # Skip duplicates\n            \n            path.append(candidates[i])\n            backtrack(i + 1, target - candidates[i], path)\n            path.pop()\n    \n    candidates.sort()\n    result = []\n    backtrack(0, target, [])\n    return result",
            "keyInsight": "Sort to group duplicates, then skip same values in same level.",
            "testCases": [
                {
                    "input": "candidates = [10,1,2,7,6,1,5], target = 8",
                    "output": "[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
                },
                {
                    "input": "candidates = [2,5,2,1,2], target = 5",
                    "output": "[\n[1,2,2],\n[5]\n]"
                }
            ]
        },
        "palindrome-partitioning": {
            "id": "palindrome-partitioning",
            "slug": "palindrome-partitioning",
            "title": "Palindrome Partitioning",
            "difficulty": "Medium",
            "category": "Backtracking",
            "problemStatement": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(N * 2^N)",
            "spaceComplexity": "O(N)",
            "oneliner": "Use backtracking to explore all possible partitions.",
            "intuition": [
                "We need to try all possible ways to split the string.",
                "At each step, check if current substring is palindrome before proceeding."
            ],
            "visualizationType": "array",
            "initialState": [
                "a",
                "a",
                "b"
            ],
            "animationSteps": [
                {
                    "type": "partition",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Checking if 'aa' is palindrome..."
                },
                {
                    "type": "partition",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "'b' is palindrome. Valid partition found!"
                }
            ],
            "code": "def partition(s):\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])\n            return\n        \n        for end in range(start, len(s)):\n            if is_palindrome(s[start:end+1]):\n                path.append(s[start:end+1])\n                backtrack(end + 1, path)\n                path.pop()\n    \n    result = []\n    backtrack(0, [])\n    return result",
            "keyInsight": "Use backtracking to generate all valid partitions by checking palindromes at each step.",
            "testCases": [
                {
                    "input": "s = \"aab\"",
                    "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
                },
                {
                    "input": "s = \"a\"",
                    "output": "[[\"a\"]]"
                }
            ]
        },
        "n-queens": {
            "id": "n-queens",
            "slug": "n-queens",
            "title": "N-Queens",
            "difficulty": "Hard",
            "category": "Backtracking",
            "problemStatement": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Backtracking",
            "patternEmoji": "\ud83d\udd04",
            "timeComplexity": "O(N!)",
            "spaceComplexity": "O(N\u00b2)",
            "oneliner": "Place queens row by row, backtracking when conflicts arise.",
            "intuition": [
                "Queens can attack horizontally, vertically, and diagonally",
                "Place one queen per row and check for conflicts before proceeding"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    ".",
                    ".",
                    ".",
                    "."
                ],
                [
                    ".",
                    ".",
                    ".",
                    "."
                ],
                [
                    ".",
                    ".",
                    ".",
                    "."
                ],
                [
                    ".",
                    ".",
                    ".",
                    "."
                ]
            ],
            "animationSteps": [
                {
                    "type": "update",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Place Queen at (0,0)"
                },
                {
                    "type": "update",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Place Queen at (1,2) - no conflicts"
                },
                {
                    "type": "update",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "Conflict! Backtrack..."
                }
            ],
            "code": "def solveNQueens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or \\\n               board[i] - i == col - row or \\\n               board[i] + i == col + row:\n                return False\n        return True\n    \n    def backtrack(board, row):\n        if row == n:\n            result.append(['.' * col + 'Q' + '.' * (n-col-1) for col in board])\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                backtrack(board, row + 1)\n    \n    result = []\n    backtrack([-1] * n, 0)\n    return result",
            "keyInsight": "Use 1D array where index=row and value=column for efficient conflict checking",
            "testCases": [
                {
                    "input": "n = 4",
                    "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
                },
                {
                    "input": "n = 1",
                    "output": "[[\"Q\"]]"
                }
            ]
        },
        "koko-eating-bananas": {
            "id": "koko-eating-bananas",
            "slug": "koko-eating-bananas",
            "title": "Koko Eating Bananas",
            "difficulty": "Medium",
            "category": "Binary Search",
            "problemStatement": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(n log(max(piles)))",
            "spaceComplexity": "O(1)",
            "oneliner": "Binary search on eating speed k between 1 and max(piles).",
            "intuition": [
                "We want to find the minimum eating speed k - this suggests optimization.",
                "If k is too slow she won't finish, if k is fast enough she will - this monotonic property enables binary search."
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                6,
                7,
                11
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Piles: [3,6,7,11]. Need to finish in H=8 hours."
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Try k=4: hours = 1+2+2+3 = 8. This works!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "Try k=3: hours = 1+2+3+4 = 10. Too slow!"
                }
            ],
            "code": "import math\n\ndef minEatingSpeed(piles, h):\n    left, right = 1, max(piles)\n    result = right\n    \n    while left <= right:\n        k = (left + right) // 2\n        hours = 0\n        for pile in piles:\n            hours += math.ceil(pile / k)\n        \n        if hours <= h:\n            result = k\n            right = k - 1\n        else:\n            left = k + 1\n            \n    return result",
            "keyInsight": "Binary search works because if speed k is sufficient, then k+1, k+2, ... are all sufficient (we want minimum).",
            "testCases": [
                {
                    "input": "piles = [3,6,7,11], h = 8",
                    "output": "4"
                },
                {
                    "input": "piles = [30,11,23,4,20], h = 5",
                    "output": "30"
                },
                {
                    "input": "piles = [30,11,23,4,20], h = 6",
                    "output": "23"
                }
            ]
        },
        "time-based-key-value-store": {
            "id": "time-based-key-value-store",
            "slug": "time-based-key-value-store",
            "title": "Time Based Key-Value Store",
            "difficulty": "Medium",
            "category": "Binary Search",
            "problemStatement": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\nImplement the TimeMap class:\nExample 1:\nConstraints:",
            "videoUrl": "",
            "pattern": "Binary Search",
            "patternEmoji": "\ud83d\udd0d",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use binary search on sorted timestamps to find the latest valid value.",
            "intuition": [
                "Store values with timestamps in a sorted list for each key",
                "Use binary search to efficiently find the largest timestamp \u2264 target"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    "foo",
                    "bar",
                    1
                ],
                [
                    "foo",
                    "bar2",
                    4
                ],
                [
                    "foo",
                    "bar3",
                    6
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "M"
                        },
                        {
                            "index": 2,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Binary search for timestamp 5"
                }
            ],
            "code": "class TimeMap:\n    def __init__(self):\n        self.store = {}\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append([value, timestamp])\n    \n    def get(self, key: str, timestamp: int) -> str:\n        res = \"\"\n        values = self.store.get(key, [])\n        \n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res",
            "keyInsight": "Timestamps are stored in increasing order, enabling binary search.",
            "testCases": [
                {
                    "input": "timeMap = TimeMap(); timeMap.set('foo', 'bar', 1); timeMap.get('foo', 1)",
                    "output": "'bar'"
                },
                {
                    "input": "timeMap.get('foo', 3)",
                    "output": "'bar'"
                },
                {
                    "input": "timeMap.set('foo', 'bar2', 4); timeMap.get('foo', 4)",
                    "output": "'bar2'"
                }
            ]
        },
        "kth-largest-element-in-a-stream": {
            "id": "kth-largest-element-in-a-stream",
            "slug": "kth-largest-element-in-a-stream",
            "title": "Kth Largest Element in a Stream",
            "difficulty": "Easy",
            "category": "Heap",
            "problemStatement": "You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.\nYou are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.\nImplement the KthLargest class:\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Min Heap",
            "patternEmoji": "\u2b07\ufe0f",
            "timeComplexity": "O(n log k)",
            "spaceComplexity": "O(k)",
            "oneliner": "Use a min-heap of size k to track the kth largest element.",
            "intuition": [
                "We only need to keep track of the k largest elements seen so far",
                "A min-heap of size k will have the kth largest at its root"
            ],
            "visualizationType": "array",
            "initialState": [
                4,
                5,
                8,
                2
            ],
            "animationSteps": [
                {
                    "type": "heapify",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Create min-heap with initial elements"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "root"
                        }
                    ],
                    "transientMessage": "Root of min-heap of size k is kth largest"
                }
            ],
            "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: list[int]):\n        self.k = k\n        self.heap = nums[:]\n        heapq.heapify(self.heap)\n        \n        # Maintain heap size as k\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        # Maintain heap size as k\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n            \n        return self.heap[0]",
            "keyInsight": "Min-heap of size k keeps kth largest at root; only store k elements.",
            "testCases": [
                {
                    "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
                    "output": "[null, 4, 5, 5, 8, 8]"
                },
                {
                    "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"] [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
                    "output": "[null, 7, 7, 7, 8]"
                }
            ]
        },
        "last-stone-weight": {
            "id": "last-stone-weight",
            "slug": "last-stone-weight",
            "title": "Last Stone Weight",
            "difficulty": "Easy",
            "category": "Heap",
            "problemStatement": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Heap (Priority Queue)",
            "patternEmoji": "\u2b07\ufe0f",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a max heap to efficiently retrieve the two heaviest stones.",
            "intuition": [
                "We always need the two heaviest stones, so we need efficient access to the maximum elements.",
                "A max heap allows us to retrieve the maximum element in O(log n) time."
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                7,
                4,
                1,
                8,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Select two heaviest stones: 8 and 7"
                },
                {
                    "type": "replace",
                    "indices": [
                        4,
                        1
                    ],
                    "newValues": [
                        1,
                        null
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Smash 8 and 7 \u2192 result is 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Select two heaviest stones: 4 and 2"
                }
            ],
            "code": "import heapq\n\ndef lastStoneWeight(stones):\n    # Convert to negative values for max heap simulation\n    heap = [-stone for stone in stones]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        # Get two heaviest stones\n        first = -heapq.heappop(heap)\n        second = -heapq.heappop(heap)\n        \n        # If they're not equal, push back the difference\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    \n    return -heap[0] if heap else 0",
            "keyInsight": "Python's heapq is a min heap, so we negate values to simulate a max heap.",
            "testCases": [
                {
                    "input": "stones = [2,7,4,1,8,1]",
                    "output": "1"
                },
                {
                    "input": "stones = [1]",
                    "output": "1"
                }
            ]
        },
        "design-twitter": {
            "id": "design-twitter",
            "slug": "design-twitter",
            "title": "Design Twitter",
            "difficulty": "Medium",
            "category": "Heap",
            "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:\nExample 1:\nConstraints:",
            "videoUrl": "",
            "pattern": "Hash Map + Heap",
            "patternEmoji": "\ud83d\uddc2\ufe0f+\ud83d\udd25",
            "timeComplexity": "O(n log k)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use hash maps for users/tweets and a min-heap for news feed.",
            "intuition": [
                "Need fast lookup for users and their follows \u2192 Hash Map",
                "Need top 10 most recent tweets \u2192 Min-Heap of size 10"
            ],
            "visualizationType": "array",
            "initialState": [
                "User 1 follows User 2",
                "User 2 posts tweet",
                "User 1 gets news feed"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Store users and follows in hash map"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Store tweets with timestamps"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Use min-heap to get 10 most recent"
                }
            ],
            "code": "import heapq\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = {}\n        self.follows = {}\n    \n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        if userId not in self.tweets:\n            self.tweets[userId] = []\n        self.tweets[userId].append((-self.time, tweetId))\n    \n    def getNewsFeed(self, userId):\n        heap = []\n        users = {userId} | self.follows.get(userId, set())\n        for user in users:\n            for tweet in self.tweets.get(user, [])[-10:]:\n                heapq.heappush(heap, tweet)\n                if len(heap) > 10:\n                    heapq.heappop(heap)\n        return [tweetId for _, tweetId in sorted(heap)]\n    \n    def follow(self, followerId, followeeId):\n        if followerId not in self.follows:\n            self.follows[followerId] = set()\n        self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        if followerId in self.follows and followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)",
            "keyInsight": "Use negative timestamps for min-heap to get most recent tweets.",
            "testCases": [
                {
                    "input": "twitter = Twitter(); twitter.postTweet(1, 5); twitter.getNewsFeed(1)",
                    "output": "[5]"
                }
            ]
        },
        "sum-of-two-integers": {
            "id": "sum-of-two-integers",
            "slug": "sum-of-two-integers",
            "title": "Sum of Two Integers",
            "difficulty": "Medium",
            "category": "Bit Manipulation",
            "problemStatement": "Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Bit Manipulation",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(1)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use XOR for sum without carry and AND+shift for carry.",
            "intuition": [
                "XOR gives us the sum of two bits without considering carry",
                "AND operation identifies where carries occur, then shift left to add them"
            ],
            "visualizationType": "array",
            "initialState": [
                5,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "5 (101) + 3 (011) = ?"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "XOR: 101 \u2295 011 = 110 (6)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "primary",
                    "pointers": [],
                    "transientMessage": "AND: 101 & 011 = 001, then <<1 = 010 (2)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Repeat: 6 (110) + 2 (010) = 8 (1000)"
                }
            ],
            "code": "def getSum(a, b):\n    mask = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1\n        a = (a ^ b) & mask\n        b = carry & mask\n    \n    return a if a <= MAX_INT else ~(a ^ mask)",
            "keyInsight": "Binary addition can be simulated using XOR (sum) and AND+shift (carry) operations.",
            "testCases": [
                {
                    "input": "a = 1, b = 2",
                    "output": "3"
                },
                {
                    "input": "a = 2, b = 3",
                    "output": "5"
                }
            ]
        },
        "reverse-integer": {
            "id": "reverse-integer",
            "slug": "reverse-integer",
            "title": "Reverse Integer",
            "difficulty": "Medium",
            "category": "Bit Manipulation",
            "problemStatement": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Math",
            "patternEmoji": "\ud83d\udd22",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Build reversed number digit by digit, checking overflow early.",
            "intuition": [
                "Extract digits using modulo and division operations",
                "Check for overflow before it happens using math"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Extract last digit: 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Extract next digit: 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Extract first digit: 1"
                }
            ],
            "code": "def reverse(x):\n    INT_MAX, INT_MIN = 2**31 - 1, -2**31\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    reversed_num = 0\n    \n    while x_abs != 0:\n        digit = x_abs % 10\n        \n        # Check for overflow before multiplying\n        if reversed_num > (INT_MAX - digit) // 10:\n            return 0\n            \n        reversed_num = reversed_num * 10 + digit\n        x_abs //= 10\n    \n    return sign * reversed_num",
            "keyInsight": "Process digits one by one and build result, but check overflow before each multiplication.",
            "testCases": [
                {
                    "input": "x = 123",
                    "output": "321"
                },
                {
                    "input": "x = -123",
                    "output": "-321"
                },
                {
                    "input": "x = 120",
                    "output": "21"
                }
            ]
        },
        "powx-n": {
            "id": "powx-n",
            "slug": "powx-n",
            "title": "Pow(x, n)",
            "difficulty": "Medium",
            "category": "Math",
            "problemStatement": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Binary Exponentiation",
            "patternEmoji": "\u26a1",
            "timeComplexity": "O(log n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use binary exponentiation to reduce multiplication steps.",
            "intuition": [
                "Instead of multiplying x n times, break n into powers of 2",
                "Use the property: x^n = (x^(n/2))^2 to halve the problem size"
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                10
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 10 (even), so n = n/2 and x = x*x"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 5 (odd), so result = result * x and n = n-1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "n = 4 (even), so n = n/2 and x = x*x"
                }
            ],
            "code": "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result",
            "keyInsight": "Repeated squaring reduces exponential time to logarithmic.",
            "testCases": [
                {
                    "input": "x = 2.00000, n = 10",
                    "output": "1024.00000"
                },
                {
                    "input": "x = 2.10000, n = 3",
                    "output": "9.26100"
                },
                {
                    "input": "x = 2.00000, n = -2",
                    "output": "0.25000"
                }
            ]
        },
        "multiply-strings": {
            "id": "multiply-strings",
            "slug": "multiply-strings",
            "title": "Multiply Strings",
            "difficulty": "Medium",
            "category": "Math",
            "problemStatement": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Simulation",
            "patternEmoji": "\ud83c\udfad",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m+n)",
            "oneliner": "Simulate multiplication digit by digit like elementary school math.",
            "intuition": [
                "Multiply each digit of num1 with each digit of num2",
                "Handle carries and position shifts properly"
            ],
            "visualizationType": "array",
            "initialState": [
                0,
                0,
                0,
                0,
                0
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Multiply 2 \u00d7 3 = 6, place at position 4"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Multiply 2 \u00d7 4 = 8, place at position 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Multiply 1 \u00d7 3 = 3, add to position 3"
                }
            ],
            "code": "def multiply(num1, num2):\n    if num1 == '0' or num2 == '0':\n        return '0'\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            pos1, pos2 = i + j, i + j + 1\n            total = mul + result[pos2]\n            \n            result[pos2] = total % 10\n            result[pos1] += total // 10\n    \n    # Skip leading zeros\n    start = 0\n    while start < len(result) and result[start] == 0:\n        start += 1\n    \n    return ''.join(map(str, result[start:])) if start < len(result) else '0'",
            "keyInsight": "Use an array to store intermediate results and handle carries properly.",
            "testCases": [
                {
                    "input": "num1 = \"2\", num2 = \"3\"",
                    "output": "\"6\""
                },
                {
                    "input": "num1 = \"123\", num2 = \"456\"",
                    "output": "\"56088\""
                }
            ]
        },
        "detect-squares": {
            "id": "detect-squares",
            "slug": "detect-squares",
            "title": "Detect Squares",
            "difficulty": "Medium",
            "category": "Math",
            "problemStatement": "You are given a stream of points on the X-Y plane. Design an algorithm that:\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.\nImplement the DetectSquares class:\nExample 1:\nConstraints:",
            "videoUrl": "",
            "pattern": "Geometry + Hash Map",
            "patternEmoji": "\ud83d\udcd0\ud83d\udcca",
            "timeComplexity": "O(n) per query",
            "spaceComplexity": "O(n)",
            "oneliner": "For each existing point, check if it can form a square with the query point and two others.",
            "intuition": [
                "To form a square with query point (x,y), we need three other points that create equal sides and right angles",
                "For any point (x1,y1), the other corners must be at (x1,y), (x,y1), and (x1\u00b1d, y1\u00b1d) where d is the side length"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    3,
                    10
                ],
                [
                    11,
                    2
                ],
                [
                    3,
                    2
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Points (3,10) and (3,2) share x-coordinate"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Points (11,2) and (3,2) share y-coordinate"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Checking if (11,10) exists to complete square..."
                }
            ],
            "code": "from collections import defaultdict\n\nclass DetectSquares:\n    def __init__(self):\n        self.point_counts = defaultdict(int)\n        \n    def add(self, point):\n        self.point_counts[tuple(point)] += 1\n        \n    def count(self, point):\n        px, py = point\n        count = 0\n        \n        # For each existing point\n        for (x, y), freq in self.point_counts.items():\n            # Skip if not diagonal candidate\n            if abs(px - x) != abs(py - y) or px == x or py == y:\n                continue\n                \n            # Check if other two corners exist\n            count += freq * self.point_counts[(px, y)] * self.point_counts[(x, py)]\n            \n        return count",
            "keyInsight": "Use hash map to store point frequencies and check diagonal relationships.",
            "testCases": [
                {
                    "input": "detectSquares = DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10])",
                    "output": "1"
                }
            ]
        },
        "min-cost-climbing-stairs": {
            "id": "min-cost-climbing-stairs",
            "slug": "min-cost-climbing-stairs",
            "title": "Min Cost Climbing Stairs",
            "difficulty": "Easy",
            "category": "1-D Dynamic Programming",
            "problemStatement": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use DP to track min cost to reach each step, only keeping last two values.",
            "intuition": [
                "To reach step i, you must have come from step i-1 or i-2",
                "The minimum cost to reach step i is cost[i] + min(cost to reach i-1, cost to reach i-2)"
            ],
            "visualizationType": "array",
            "initialState": [
                10,
                15,
                20
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Starting from index 0 costs 10"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Starting from index 1 costs 15"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "To reach step 2: 20 + min(10,15) = 30"
                },
                {
                    "type": "highlight",
                    "indices": [],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Minimum of last two steps: min(15,30) = 15"
                }
            ],
            "code": "def minCostClimbingStairs(cost):\n    prev2, prev1 = cost[0], cost[1]\n    for i in range(2, len(cost)):\n        current = cost[i] + min(prev1, prev2)\n        prev2, prev1 = prev1, current\n    return min(prev1, prev2)",
            "keyInsight": "We only need to remember the minimum cost to reach the previous two steps.",
            "testCases": [
                {
                    "input": "cost = [10,15,20]",
                    "output": "15"
                },
                {
                    "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
                    "output": "6"
                }
            ]
        },
        "house-robber-ii": {
            "id": "house-robber-ii",
            "slug": "house-robber-ii",
            "title": "House Robber II",
            "difficulty": "Medium",
            "category": "1-D Dynamic Programming",
            "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Split into two subproblems: exclude first or last house.",
            "intuition": [
                "Houses form a circle, so we can't rob both first and last houses together",
                "Solve two linear versions: one excluding first house, one excluding last house"
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "Can't rob first and last together (circular constraint)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "If we rob house 0, we can't rob house 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Best option: rob house 1 = 3"
                }
            ],
            "code": "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2 = prev1 = 0\n        for money in houses:\n            current = max(prev1, prev2 + money)\n            prev2, prev1 = prev1, current\n        return prev1\n    \n    # Return max of two scenarios: exclude first or exclude last\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))",
            "keyInsight": "Circular constraint means we can't rob first and last houses together. Solve 2 linear problems.",
            "testCases": [
                {
                    "input": "nums = [2,3,2]",
                    "output": "3"
                },
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "4"
                },
                {
                    "input": "nums = [1,2,3]",
                    "output": "3"
                }
            ]
        },
        "palindromic-substrings": {
            "id": "palindromic-substrings",
            "slug": "palindromic-substrings",
            "title": "Palindromic Substrings",
            "difficulty": "Medium",
            "category": "1-D Dynamic Programming",
            "problemStatement": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Expand Around Centers",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n\u00b2)",
            "spaceComplexity": "O(1)",
            "oneliner": "Check odd/even length palindromes by expanding around each center.",
            "intuition": [
                "Every palindrome has a center - either a character (odd length) or between two characters (even length)",
                "For each possible center, expand outward while characters match"
            ],
            "visualizationType": "array",
            "initialState": [
                "a",
                "b",
                "a"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "C"
                        }
                    ],
                    "transientMessage": "Center at 'a': Check palindromes a, aba"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "L"
                        },
                        {
                            "index": 1,
                            "label": "R"
                        }
                    ],
                    "transientMessage": "Expand from center between a,b: No match"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "C"
                        }
                    ],
                    "transientMessage": "Center at 'b': Check palindrome b"
                }
            ],
            "code": "def countSubstrings(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        # Odd length palindromes\n        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n        # Even length palindromes\n        l, r = i, i + 1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            count += 1\n            l -= 1\n            r += 1\n    return count",
            "keyInsight": "Instead of checking all substrings, expand from each possible center.",
            "testCases": [
                {
                    "input": "s = \"abc\"",
                    "output": "3"
                },
                {
                    "input": "s = \"aaa\"",
                    "output": "6"
                }
            ]
        },
        "maximum-product-subarray": {
            "id": "maximum-product-subarray",
            "slug": "maximum-product-subarray",
            "title": "Maximum Product Subarray",
            "difficulty": "Medium",
            "category": "1-D Dynamic Programming",
            "problemStatement": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track both max and min products at each step due to negative numbers.",
            "intuition": [
                "Negative numbers can flip a small negative product to a large positive one",
                "We need to track both maximum and minimum products at each position"
            ],
            "visualizationType": "array",
            "initialState": [
                2,
                3,
                -2,
                4
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "Start: maxProd = 2, minProd = 2, result = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "num = 3: maxProd = 6, minProd = 3, result = 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "num = -2: maxProd = -2, minProd = -12, result = 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "primary",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "i"
                        }
                    ],
                    "transientMessage": "num = 4: maxProd = 4, minProd = -48, result = 6"
                }
            ],
            "code": "def maxProduct(nums):\n    if not nums:\n        return 0\n    \n    maxProd = minProd = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        num = nums[i]\n        \n        # Store current maxProd before updating\n        tempMax = max(num, maxProd * num, minProd * num)\n        minProd = min(num, maxProd * num, minProd * num)\n        maxProd = tempMax\n        \n        result = max(result, maxProd)\n    \n    return result",
            "keyInsight": "Negative numbers can turn the smallest product into the largest, so we track both max and min.",
            "testCases": [
                {
                    "input": "nums = [2,3,-2,4]",
                    "output": "6"
                },
                {
                    "input": "nums = [-2,0,-1]",
                    "output": "0"
                }
            ]
        },
        "partition-equal-subset-sum": {
            "id": "partition-equal-subset-sum",
            "slug": "partition-equal-subset-sum",
            "title": "Partition Equal Subset Sum",
            "difficulty": "Medium",
            "category": "1-D Dynamic Programming",
            "problemStatement": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n * sum)",
            "spaceComplexity": "O(sum)",
            "oneliner": "Use DP to check if we can achieve sum/2 with given numbers.",
            "intuition": [
                "If total sum is odd, partition is impossible.",
                "Transform into subset sum problem: find if subset sums to target=sum/2."
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                5,
                11,
                5
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "primary",
                    "pointers": [],
                    "transientMessage": "Total sum = 22. Target = 11."
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        3
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Subset [1,5,5] sums to 11 \u2705"
                }
            ],
            "code": "def canPartition(nums):\n    total = sum(nums)\n    if total % 2 != 0:\n        return False\n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]",
            "keyInsight": "This is a 0/1 knapsack variant - we either include or exclude each number.",
            "testCases": [
                {
                    "input": "nums = [1,5,11,5]",
                    "output": "true"
                },
                {
                    "input": "nums = [1,2,3,5]",
                    "output": "false"
                }
            ]
        },
        "longest-common-subsequence": {
            "id": "longest-common-subsequence",
            "slug": "longest-common-subsequence",
            "title": "Longest Common Subsequence",
            "difficulty": "Medium",
            "category": "2-D Dynamic Programming",
            "problemStatement": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nA common subsequence of two strings is a subsequence that is common to both strings.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "Build a 2D table to store LCS lengths for all substrings.",
            "intuition": [
                "If characters match, LCS is 1 + diagonal value",
                "If characters don't match, take max of left or top cell"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    "",
                    "",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e"
                ],
                [
                    "",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "a",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "c",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "e",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Base case: empty strings have LCS = 0"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Match! 'a'=='a', so 1 + diagonal = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3
                    ],
                    "color": "warning",
                    "pointers": [],
                    "transientMessage": "No match, take max(Left, Top) = max(1,0) = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Match! 'c'=='c', so 1 + diagonal = 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        6
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Match! 'e'=='e', so 1 + diagonal = 3"
                }
            ],
            "code": "def longestCommonSubsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    return dp[m][n]",
            "keyInsight": "When characters match, we add 1 to the LCS of previous substrings. When they don't match, we take the best LCS from either skipping current character in text1 or text2.",
            "testCases": [
                {
                    "input": "text1 = \"abcde\", text2 = \"ace\"",
                    "output": "3"
                },
                {
                    "input": "text1 = \"abc\", text2 = \"abc\"",
                    "output": "3"
                },
                {
                    "input": "text1 = \"abc\", text2 = \"def\"",
                    "output": "0"
                }
            ]
        },
        "best-time-to-buy-and-sell-stock-with-cooldown": {
            "id": "best-time-to-buy-and-sell-stock-with-cooldown",
            "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
            "title": "Best Time to Buy and Sell Stock with Cooldown",
            "difficulty": "Medium",
            "category": "2-D Dynamic Programming",
            "problemStatement": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track max profit for holding/selling states with cooldown constraint.",
            "intuition": [
                "We can be in one of three states: holding stock, selling stock, or cooldown",
                "Use DP to track maximum profit for each state transition"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                0,
                2
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "Day 0"
                        }
                    ],
                    "transientMessage": "Buy at price 1. Hold state = -1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "Day 1"
                        }
                    ],
                    "transientMessage": "Price up to 2. Sell state = 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "warning",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "Day 2"
                        }
                    ],
                    "transientMessage": "Cooldown day. Can't buy"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3
                    ],
                    "color": "error",
                    "pointers": [
                        {
                            "index": 3,
                            "label": "Day 3"
                        }
                    ],
                    "transientMessage": "Price drops to 0. Better to skip"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4
                    ],
                    "color": "success",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "Day 4"
                        }
                    ],
                    "transientMessage": "Buy at 0, sell at 2. Total profit = 3"
                }
            ],
            "code": "def maxProfit(prices):\n    if not prices:\n        return 0\n    \n    hold = -prices[0]  # Max profit when holding stock\n    sold = 0           # Max profit when just sold\n    rest = 0           # Max profit when in cooldown/rest\n    \n    for i in range(1, len(prices)):\n        prev_hold = hold\n        prev_sold = sold\n        prev_rest = rest\n        \n        hold = max(prev_hold, prev_rest - prices[i])  # Hold or buy today\n        sold = prev_hold + prices[i]                  # Sell today\n        rest = max(prev_rest, prev_sold)              # Rest or continue cooldown\n    \n    return max(sold, rest)  # Max profit when ending with sell or rest",
            "keyInsight": "Track three states: holding stock, just sold, cooldown. State transitions enforce the cooldown rule.",
            "testCases": [
                {
                    "input": "prices = [1,2,3,0,2]",
                    "output": "3"
                },
                {
                    "input": "prices = [1]",
                    "output": "0"
                }
            ]
        },
        "coin-change-ii": {
            "id": "coin-change-ii",
            "slug": "coin-change-ii",
            "title": "Coin Change II",
            "difficulty": "Medium",
            "category": "2-D Dynamic Programming",
            "problemStatement": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83e\uddee",
            "timeComplexity": "O(amount \u00d7 len(coins))",
            "spaceComplexity": "O(amount)",
            "oneliner": "Build up combinations count for each amount using previous results.",
            "intuition": [
                "For each coin, we can either use it or not use it - this creates subproblems",
                "We can build solutions for larger amounts using solutions for smaller amounts"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                0,
                0,
                0,
                0,
                0
            ],
            "animationSteps": [
                {
                    "type": "update",
                    "indices": [
                        0
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Base case: 1 way to make amount 0 (use no coins)"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "amt"
                        },
                        {
                            "index": 0,
                            "label": "coin=1"
                        }
                    ],
                    "transientMessage": "Using coin 1: dp[1] += dp[1-1] = dp[0] = 1"
                },
                {
                    "type": "update",
                    "indices": [
                        1
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Now 1 way to make amount 1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "amt"
                        },
                        {
                            "index": 1,
                            "label": "coin=1"
                        }
                    ],
                    "transientMessage": "Using coin 1: dp[2] += dp[2-1] = dp[1] = 1"
                },
                {
                    "type": "update",
                    "indices": [
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Now 1 way to make amount 2"
                }
            ],
            "code": "def change(amount, coins):\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make 0 amount\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]",
            "keyInsight": "For each coin, we update all amounts >= coin by adding ways to make (amount - coin).",
            "testCases": [
                {
                    "input": "amount = 5, coins = [1,2,5]",
                    "output": "4"
                },
                {
                    "input": "amount = 3, coins = [2]",
                    "output": "0"
                },
                {
                    "input": "amount = 10, coins = [10]",
                    "output": "1"
                }
            ]
        },
        "target-sum": {
            "id": "target-sum",
            "slug": "target-sum",
            "title": "Target Sum",
            "difficulty": "Medium",
            "category": "2-D Dynamic Programming",
            "problemStatement": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\nReturn the number of different expressions that you can build, which evaluates to target.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n * sum)",
            "spaceComplexity": "O(sum)",
            "oneliner": "Use DP to count ways to reach target sum with +/- signs.",
            "intuition": [
                "Transform into subset sum problem: find subsets that sum to (total+target)/2",
                "Use DP to count combinations, not just feasibility"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                1,
                1,
                1
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "For nums[0]=1: +1 and -1 each have 1 way"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "For nums[1]=1: sums -2,-0,+0,+2 now possible"
                }
            ],
            "code": "def findTargetSumWays(nums, target):\n    total = sum(nums)\n    if abs(target) > total or (total + target) % 2 != 0:\n        return 0\n    s = (total + target) // 2\n    dp = [0] * (s + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(s, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[s]",
            "keyInsight": "This is a subset sum counting problem in disguise.",
            "testCases": [
                {
                    "input": "nums = [1,1,1,1,1], target = 3",
                    "output": "5"
                },
                {
                    "input": "nums = [1], target = 1",
                    "output": "1"
                }
            ]
        },
        "longest-increasing-path-in-a-matrix": {
            "id": "longest-increasing-path-in-a-matrix",
            "slug": "longest-increasing-path-in-a-matrix",
            "title": "Longest Increasing Path in a Matrix",
            "difficulty": "Hard",
            "category": "2-D Dynamic Programming",
            "problemStatement": "Given an m x n integers matrix, return the length of the longest increasing path in matrix.\nFrom each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "DFS with Memoization",
            "patternEmoji": "\ud83d\udd0d\ud83d\udcbe",
            "timeComplexity": "O(m\u00d7n)",
            "spaceComplexity": "O(m\u00d7n)",
            "oneliner": "Use DFS from each cell with memoization to avoid recomputation.",
            "intuition": [
                "From each cell, explore all increasing paths in 4 directions",
                "Cache results to prevent recalculating the same subproblems"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    9,
                    9,
                    4
                ],
                [
                    6,
                    6,
                    8
                ],
                [
                    2,
                    1,
                    1
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start DFS from cell (0,0) with value 9"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Move to adjacent cell (0,1)=9. Not increasing, stop."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Move to adjacent cell (1,0)=6. Decreasing, stop."
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Move to adjacent cell (0,2)=4. Decreasing, stop."
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        0
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Start DFS from cell (2,0) with value 2"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        0
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Move to adjacent cell (1,0)=6. Increasing!"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "From (1,0), move to (1,1)=6. Not increasing, stop."
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "From (1,0), move to (1,2)=8. Increasing!"
                }
            ],
            "code": "def longestIncreasingPath(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    \n    def dfs(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        max_path = 1\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_path = max(max_path, 1 + dfs(ni, nj))\n        \n        memo[(i, j)] = max_path\n        return max_path\n    \n    result = 0\n    for i in range(m):\n        for j in range(n):\n            result = max(result, dfs(i, j))\n    \n    return result",
            "keyInsight": "Each cell's longest path is 1 + max of its increasing neighbors' paths.",
            "testCases": [
                {
                    "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
                    "output": "4"
                },
                {
                    "input": "matrix = [[3,4,5],[3,2,6],[2,2,1]]",
                    "output": "4"
                },
                {
                    "input": "matrix = [[1]]",
                    "output": "1"
                }
            ]
        },
        "distinct-subsequences": {
            "id": "distinct-subsequences",
            "slug": "distinct-subsequences",
            "title": "Distinct Subsequences",
            "difficulty": "Hard",
            "category": "2-D Dynamic Programming",
            "problemStatement": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(m*n)",
            "spaceComplexity": "O(m*n)",
            "oneliner": "Use DP to count ways to form t[0:j] using s[0:i].",
            "intuition": [
                "For each character in s, we can either include or exclude it",
                "If characters match, we add paths from diagonal (include) and above (exclude)"
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    "",
                    "r",
                    "a",
                    "b",
                    "b",
                    "i",
                    "t"
                ],
                [
                    "r",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "a",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "b",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "b",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "i",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ],
                [
                    "t",
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ]
            ],
            "animationSteps": [
                {
                    "type": "update",
                    "indices": [
                        0,
                        0
                    ],
                    "value": 1,
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Empty subsequence - 1 way"
                },
                {
                    "type": "update",
                    "indices": [
                        1,
                        0
                    ],
                    "value": 1,
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Always 1 way to form empty string"
                },
                {
                    "type": "update",
                    "indices": [
                        2,
                        0
                    ],
                    "value": 1,
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Always 1 way to form empty string"
                },
                {
                    "type": "update",
                    "indices": [
                        1,
                        1
                    ],
                    "value": 1,
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "s[0]='r' matches t[0]='r'"
                },
                {
                    "type": "update",
                    "indices": [
                        2,
                        1
                    ],
                    "value": 1,
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Carry forward previous count"
                }
            ],
            "code": "def numDistinct(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Empty t can be formed in 1 way\n    for i in range(m + 1):\n        dp[i][0] = 1\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Always carry forward ways without using s[i-1]\n            dp[i][j] = dp[i-1][j]\n            \n            # If chars match, add ways using s[i-1]\n            if s[i-1] == t[j-1]:\n                dp[i][j] += dp[i-1][j-1]\n    \n    return dp[m][n]",
            "keyInsight": "At each step, we can either use or ignore the current character of s.",
            "testCases": [
                {
                    "input": "s = \"rabbbit\", t = \"rabbit\"",
                    "output": "3"
                },
                {
                    "input": "s = \"babgbag\", t = \"bag\"",
                    "output": "5"
                }
            ]
        },
        "burst-balloons": {
            "id": "burst-balloons",
            "slug": "burst-balloons",
            "title": "Burst Balloons",
            "difficulty": "Hard",
            "category": "2-D Dynamic Programming",
            "problemStatement": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\nIf you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\nReturn the maximum coins you can collect by bursting the balloons wisely.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n\u00b3)",
            "spaceComplexity": "O(n\u00b2)",
            "oneliner": "Use DP with interval merging, considering last balloon to burst.",
            "intuition": [
                "Instead of choosing the first balloon to burst, choose the last balloon to burst in a range.",
                "This makes subproblems independent and allows for optimal substructure."
            ],
            "visualizationType": "array",
            "initialState": [
                3,
                1,
                5,
                8
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Consider bursting balloon 5 (index 2) last in full range"
                },
                {
                    "type": "partition",
                    "indices": [
                        0,
                        1
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Left subproblem: [3, 1]"
                },
                {
                    "type": "partition",
                    "indices": [
                        3,
                        3
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Right subproblem: [8]"
                }
            ],
            "code": "def maxCoins(nums):\n    n = len(nums)\n    nums = [1] + nums + [1]\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n    \n    for length in range(1, n + 1):\n        for left in range(1, n - length + 2):\n            right = left + length - 1\n            for k in range(left, right + 1):\n                coins = nums[left - 1] * nums[k] * nums[right + 1]\n                coins += dp[left][k - 1] + dp[k + 1][right]\n                dp[left][right] = max(dp[left][right], coins)\n    \n    return dp[1][n]",
            "keyInsight": "Choosing the last balloon to burst in a range makes left and right subproblems independent.",
            "testCases": [
                {
                    "input": "nums = [3,1,5,8]",
                    "output": "167"
                },
                {
                    "input": "nums = [1,5]",
                    "output": "10"
                }
            ]
        },
        "regular-expression-matching": {
            "id": "regular-expression-matching",
            "slug": "regular-expression-matching",
            "title": "Regular Expression Matching",
            "difficulty": "Hard",
            "category": "2-D Dynamic Programming",
            "problemStatement": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\nThe matching should cover the entire input string (not partial).\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Dynamic Programming",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(m\u00d7n)",
            "spaceComplexity": "O(m\u00d7n)",
            "oneliner": "Use a 2D DP table to track matching substrings.",
            "intuition": [
                "Break the problem into smaller subproblems of matching prefixes.",
                "Handle '*' by considering 0 matches or extending previous matches."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    "",
                    "a",
                    "*",
                    "b"
                ],
                [
                    "",
                    true,
                    true,
                    false
                ],
                [
                    "a",
                    false,
                    true,
                    false
                ],
                [
                    "a",
                    false,
                    true,
                    false
                ],
                [
                    "b",
                    false,
                    false,
                    true
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        1
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Match empty string with 'a*' \u2192 True"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Match 'a' with 'a*' \u2192 True"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        4
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Match 'aab' with 'a*b' \u2192 True"
                }
            ],
            "code": "def isMatch(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):\n        if p[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n            else:\n                dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')\n    \n    return dp[m][n]",
            "keyInsight": "Use DP to build up solutions for matching prefixes of string and pattern.",
            "testCases": [
                {
                    "input": "s = \"aa\", p = \"a\"",
                    "output": "false"
                },
                {
                    "input": "s = \"aa\", p = \"a*\"",
                    "output": "true"
                },
                {
                    "input": "s = \"ab\", p = \".*\"",
                    "output": "true"
                }
            ]
        },
        "hand-of-straights": {
            "id": "hand-of-straights",
            "slug": "hand-of-straights",
            "title": "Hand of Straights",
            "difficulty": "Medium",
            "category": "Greedy",
            "problemStatement": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.\nExample 1:\nExample 2:\nConstraints:\nNote: This question is the same as 1296: https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/",
            "videoUrl": "",
            "pattern": "Greedy with HashMap",
            "patternEmoji": "\ud83d\udcca\u27a1\ufe0f",
            "timeComplexity": "O(n log n)",
            "spaceComplexity": "O(n)",
            "oneliner": "Use a frequency map and always start with the smallest available card.",
            "intuition": [
                "We need consecutive sequences, so sorting helps process cards in order",
                "Greedy approach: always form a group starting with the smallest remaining card"
            ],
            "visualizationType": "array",
            "initialState": [
                1,
                2,
                3,
                6,
                2,
                3,
                4,
                7,
                8
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Form group [1,2,3] - remove these cards"
                },
                {
                    "type": "highlight",
                    "indices": [
                        3,
                        4,
                        5
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Form group [2,3,4] - remove these cards"
                },
                {
                    "type": "highlight",
                    "indices": [
                        6,
                        7,
                        8
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Form group [6,7,8] - all cards used!"
                }
            ],
            "code": "from collections import Counter\n\ndef isNStraightHand(hand, groupSize):\n    if len(hand) % groupSize != 0:\n        return False\n    \n    count = Counter(hand)\n    sorted_keys = sorted(count.keys())\n    \n    for key in sorted_keys:\n        if count[key] > 0:\n            start_count = count[key]\n            for i in range(groupSize):\n                if count[key + i] < start_count:\n                    return False\n                count[key + i] -= start_count\n    \n    return True",
            "keyInsight": "Process cards in sorted order and greedily form groups starting with the smallest available card.",
            "testCases": [
                {
                    "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
                    "output": "true"
                },
                {
                    "input": "hand = [1,2,3,4,5], groupSize = 4",
                    "output": "false"
                }
            ]
        },
        "merge-triplets-to-form-target-triplet": {
            "id": "merge-triplets-to-form-target-triplet",
            "slug": "merge-triplets-to-form-target-triplet",
            "title": "Merge Triplets to Form Target Triplet",
            "difficulty": "Medium",
            "category": "Greedy",
            "problemStatement": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain.\nTo obtain target, you may apply the following operation on triplets any number of times (possibly zero):\nReturn true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Greedy",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Only consider triplets that don't exceed target values and greedily build up to target.",
            "intuition": [
                "We can only increase values through max operations, so any triplet with a component exceeding the target is useless.",
                "Among valid triplets (those not exceeding target), we just need to check if we can achieve each target component."
            ],
            "visualizationType": "array",
            "initialState": [
                [
                    2,
                    5,
                    3
                ],
                [
                    1,
                    8,
                    4
                ],
                [
                    1,
                    7,
                    5
                ]
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Triplet [2,5,3] \u2264 target [2,7,5] - Valid candidate"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "destructive",
                    "pointers": [],
                    "transientMessage": "Triplet [1,8,4] has 8>7 - Invalid, skip"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "secondary",
                    "pointers": [],
                    "transientMessage": "Triplet [1,7,5] \u2264 target [2,7,5] - Valid candidate"
                },
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Combine [2,5,3] and [1,7,5] \u2192 max = [2,7,5] = target!"
                }
            ],
            "code": "def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n    target_a, target_b, target_c = target\n    found_a, found_b, found_c = False, False, False\n    \n    for a, b, c in triplets:\n        # Skip triplets that exceed target (they're unusable)\n        if a > target_a or b > target_b or c > target_c:\n            continue\n        \n        # Track if we can achieve each target component\n        if a == target_a: found_a = True\n        if b == target_b: found_b = True\n        if c == target_c: found_c = True\n    \n    return found_a and found_b and found_c",
            "keyInsight": "We can only increase components via max operations, so we must find valid triplets that contribute each target component without overshooting.",
            "testCases": [
                {
                    "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
                    "output": "true"
                },
                {
                    "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
                    "output": "false"
                },
                {
                    "input": "triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]",
                    "output": "true"
                }
            ]
        },
        "partition-labels": {
            "id": "partition-labels",
            "slug": "partition-labels",
            "title": "Partition Labels",
            "difficulty": "Medium",
            "category": "Greedy",
            "problemStatement": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. For example, the string \"ababcc\" can be partitioned into [\"abab\", \"cc\"], but partitions such as [\"aba\", \"bcc\"] or [\"ab\", \"ab\", \"cc\"] are invalid.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Greedy with Last Occurrence Tracking",
            "patternEmoji": "\ud83c\udfaf",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track last occurrences and extend partitions greedily.",
            "intuition": [
                "Each character must appear in only one partition",
                "We need to know the furthest position each character appears"
            ],
            "visualizationType": "array",
            "initialState": [
                "a",
                "b",
                "a",
                "b",
                "c",
                "b",
                "b",
                "d",
                "d"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        3
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "start"
                        },
                        {
                            "index": 3,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Characters a,b both appear up to index 3"
                },
                {
                    "type": "highlight",
                    "indices": [
                        4,
                        6
                    ],
                    "color": "secondary",
                    "pointers": [
                        {
                            "index": 4,
                            "label": "start"
                        },
                        {
                            "index": 6,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Character c appears only up to index 6"
                },
                {
                    "type": "highlight",
                    "indices": [
                        7,
                        8
                    ],
                    "color": "tertiary",
                    "pointers": [
                        {
                            "index": 7,
                            "label": "start"
                        },
                        {
                            "index": 8,
                            "label": "end"
                        }
                    ],
                    "transientMessage": "Character d appears only up to index 8"
                }
            ],
            "code": "def partitionLabels(s):\n    last = {char: i for i, char in enumerate(s)}\n    result = []\n    start = 0\n    end = 0\n    \n    for i, char in enumerate(s):\n        end = max(end, last[char])\n        if i == end:\n            result.append(end - start + 1)\n            start = end + 1\n    \n    return result",
            "keyInsight": "For each partition, we must include all occurrences of every character in it.",
            "testCases": [
                {
                    "input": "s = \"ababcbacadefegdehijhklij\"",
                    "output": "[9,7,8]"
                },
                {
                    "input": "s = \"eccbbbbdec\"",
                    "output": "[10]"
                }
            ]
        },
        "valid-parenthesis-string": {
            "id": "valid-parenthesis-string",
            "slug": "valid-parenthesis-string",
            "title": "Valid Parenthesis String",
            "difficulty": "Medium",
            "category": "Greedy",
            "problemStatement": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\nExample 1:\nExample 2:\nExample 3:\nConstraints:",
            "videoUrl": "",
            "pattern": "Greedy with Range Tracking",
            "patternEmoji": "\ud83d\udcca",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Track possible open parenthesis counts with min/max bounds.",
            "intuition": [
                "We can't know what '*' will be, so track all possible open counts",
                "Keep min/max open counts - if max < 0, impossible. If min = 0 at end, valid."
            ],
            "visualizationType": "array",
            "initialState": [
                "(",
                "*",
                ")",
                "("
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 0,
                            "label": "char"
                        }
                    ],
                    "transientMessage": "'(' \u2192 min=1, max=1"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 1,
                            "label": "char"
                        }
                    ],
                    "transientMessage": "'*' \u2192 min=0, max=2 (could be ')', '', or '(')"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2
                    ],
                    "color": "accent",
                    "pointers": [
                        {
                            "index": 2,
                            "label": "char"
                        }
                    ],
                    "transientMessage": "')' \u2192 min=0, max=1 (decrease both, but min can't go below 0)"
                }
            ],
            "code": "def checkValidString(s):\n    min_open = max_open = 0\n    for char in s:\n        if char == '(':\n            min_open += 1\n            max_open += 1\n        elif char == ')':\n            min_open = max(min_open - 1, 0)\n            max_open -= 1\n        else:  # char == '*'\n            min_open = max(min_open - 1, 0)\n            max_open += 1\n        if max_open < 0:\n            return False\n    return min_open == 0",
            "keyInsight": "We track the range of possible open parenthesis counts instead of exact values.",
            "testCases": [
                {
                    "input": "s = \"()\"",
                    "output": "true"
                },
                {
                    "input": "s = \"(*)\"",
                    "output": "true"
                },
                {
                    "input": "s = \"(*))\"",
                    "output": "true"
                }
            ]
        },
        "permutation-in-string": {
            "id": "permutation-in-string",
            "slug": "permutation-in-string",
            "title": "Permutation in String",
            "difficulty": "Medium",
            "category": "Sliding Window",
            "problemStatement": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1's permutations is the substring of s2.\nExample 1:\nExample 2:\nConstraints:",
            "videoUrl": "",
            "pattern": "Sliding Window",
            "patternEmoji": "\ud83e\ude9f",
            "timeComplexity": "O(n)",
            "spaceComplexity": "O(1)",
            "oneliner": "Use sliding window with character frequency matching.",
            "intuition": [
                "A permutation means same characters with same frequencies",
                "Use a window of s1's length and slide it through s2"
            ],
            "visualizationType": "array",
            "initialState": [
                "a",
                "b",
                "c",
                "d",
                "e",
                "f",
                "g"
            ],
            "animationSteps": [
                {
                    "type": "highlight",
                    "indices": [
                        0,
                        1,
                        2
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Window size = 3. Check frequencies: {a:1, b:1, c:1}"
                },
                {
                    "type": "highlight",
                    "indices": [
                        1,
                        2,
                        3
                    ],
                    "color": "accent",
                    "pointers": [],
                    "transientMessage": "Slide window. New char 'd', remove 'a'. Frequencies: {b:1, c:1, d:1}"
                },
                {
                    "type": "highlight",
                    "indices": [
                        2,
                        3,
                        4
                    ],
                    "color": "success",
                    "pointers": [],
                    "transientMessage": "Match found! Frequencies match target: {c:1, d:1, e:1}"
                }
            ],
            "code": "def checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    \n    # Initialize window\n    for i in range(len(s1)):\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    if s1_count == window_count:\n        return True\n    \n    # Slide window\n    for i in range(len(s1), len(s2)):\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        # Remove old character\n        window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        if s1_count == window_count:\n            return True\n    \n    return False",
            "keyInsight": "Permutations have identical character counts - compare frequency arrays.",
            "testCases": [
                {
                    "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
                    "output": "true"
                },
                {
                    "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
                    "output": "false"
                }
            ]
        }
    }
}